[
  {
    "row_number": 2,
    "bug_id": " H-03",
    "bug_label": " S1-1",
    "difficulty": 1,
    "bug_description": " \"Price feed can be manipulated\"",
    "line": "PriceAware[60,111,144]",
    "url": " https://code4rena.com/reports/2021-04-marginswap#h-03-price-feed-can-be-manipulated",
    "title": "",
    "main_content": [
      "Anyone can trigger an update to the price feed by callingPriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true).\nIf the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts.\nThis simulation uses the reserves of the Uniswap pairs which can be changed drastically using flash loans to yield almost arbitrary output amounts, and thus prices. Wrong prices break the core functionality of the contracts such as borrowing on margin, liquidations, etc.",
      "Recommend against using the Uniswap spot price as the real price. Uniswap itself warns against this and instead recommends implementing aTWAP price oracleusing theprice*CumulativeLastvariables."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 3,
    "bug_id": " H-04",
    "bug_label": " S6-2",
    "difficulty": 1,
    "bug_description": " \"Inconsistent usage of applyInterest\"",
    "line": "BaseLending[31], HourlyBondSubscriptionLending[68,97], Lending[163,185]",
    "url": " https://code4rena.com/reports/2021-04-marginswap#h-04-inconsistent-usage-of-applyinterest",
    "title": "",
    "main_content": [
      "It is unclear if the functionapplyInterestis supposed to return a new balance with the interest applied or only the accrued interest? There are various usages of it, some calls add the return value to the old amount:",
      "This makes the code misbehave and return the wrong values for the balance and accrued interest.",
      "Recommend making it consistent in all cases when calling this function."
    ],
    "code_blocks": [
      "return\nbond\n.\namount\n+\napplyInterest\n(\nbond\n.\namount\n,\ncumulativeYield\n,\nyieldQuotientFP\n);\nand\nsome\nnot:\nbalanceWithInterest\n=\napplyInterest\n(\nbalance\n,\nyA\n.\naccumulatorFP\n,\nyieldQuotientFP\n);"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 4,
    "bug_id": " H-05",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Wrong liquidation logic\"",
    "line": "CrossMarginAccounts[194], IsolatedMarginAccounts[80]",
    "url": " https://code4rena.com/reports/2021-04-marginswap#h-05-wrong-liquidation-logic",
    "title": "",
    "main_content": [
      "ThebelowMaintenanceThresholdfunction decides if a trader can be liquidated:",
      "The inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated. The inverse equality was probably intendedreturn 100 * holdings <= liquidationThresholdPercent * loan;. Users that shouldn‚Äôt be liquidated can be liquidated, and users that should be liquidated cannot get liquidated."
    ],
    "code_blocks": [
      "function\nbelowMaintenanceThreshold\n(\nCrossMarginAccount\nstorage\naccount\n)\ninternal\nreturns\n(\nbool\n)\n{\nuint256\nloan\n=\nloanInPeg\n(\naccount\n,\ntrue\n);\nuint256\nholdings\n=\nholdingsInPeg\n(\naccount\n,\ntrue\n);\n// The following should hold:\n// holdings / loan >= 1.1\n// =>\nreturn\n100\n*\nholdings\n>=\nliquidationThresholdPercent\n*\nloan\n;\n}"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 5,
    "bug_id": " H-07",
    "bug_label": " S3-1",
    "difficulty": 1,
    "bug_description": " \"account.holdsToken is never set\"",
    "line": "CrossMarginAccounts[58]",
    "url": " https://code4rena.com/reports/2021-04-marginswap#h-07-accountholdstoken-is-never-set",
    "title": "",
    "main_content": [
      "TheaddHoldingfunction does not update theaccount.holdsTokenmap.",
      "This leads to a critical vulnerability where deposits of the same token keep being pushed to theaccount.holdingTokensarray but the sum is correctly updated inaccount.holdings[token]. However, because of the duplicate token in theholdingTokensarray the same token is counted several times in thegetHoldingAmountsfunction:",
      "TheMarginRouter.crossCloseAccountfunction uses these wrong amounts to withdraw all tokens:",
      "An attacker can just deposit the same token X times which increases their balance by X times the actual value.\nThis inflated balance can then be withdrawn to steal all tokens.",
      "Recommend correctly setting theaccount.holdsTokenmap inaddHolding."
    ],
    "code_blocks": [
      "function\naddHolding\n(\nCrossMarginAccount\nstorage\naccount\n,\naddress\ntoken\n,\nuint256\ndepositAmount\n)\ninternal\n{\nif\n(!\nhasHoldingToken\n(\naccount\n,\ntoken\n)) {\n// SHOULD SET account.holdsToken here\naccount\n.\nholdingTokens\n.\npush\n(\ntoken\n);\n}\naccount\n.\nholdings\n[\ntoken\n] +=\ndepositAmount\n;\n}",
      "function\ngetHoldingAmounts\n(\naddress\ntrader\n)\nexternal\nview\noverride\nreturns\n(\naddress\n[]\nmemory\nholdingTokens\n,\nuint256\n[]\nmemory\nholdingAmounts\n)\n{\nCrossMarginAccount\nstorage\naccount\n=\nmarginAccounts\n[\ntrader\n];\nholdingTokens\n=\naccount\n.\nholdingTokens\n;\nholdingAmounts\n=\nnew\nuint256\n[](\naccount\n.\nholdingTokens\n.\nlength\n);\nfor\n(\nuint256\nidx\n=\n0\n;\nholdingTokens\n.\nlength\n>\nidx\n;\nidx\n++) {\naddress\ntokenAddress\n=\nholdingTokens\n[\nidx\n];\n// RETURNS SUM OF THE BALANCE FOR EACH TOKEN ENTRY\nholdingAmounts\n[\nidx\n] =\naccount\n.\nholdings\n[\ntokenAddress\n];\n}\n}",
      "function\ncrossCloseAccount\n()\nexternal\n{\n(\naddress\n[]\nmemory\nholdingTokens\n,\nuint256\n[]\nmemory\nholdingAmounts\n) =\nIMarginTrading\n(\nmarginTrading\n()).\ngetHoldingAmounts\n(\nmsg\n.\nsender\n);\n// requires all debts paid off\nIMarginTrading\n(\nmarginTrading\n()).\nregisterLiquidation\n(\nmsg\n.\nsender\n);\nfor\n(\nuint256\ni\n;\nholdingTokens\n.\nlength\n>\ni\n;\ni\n++) {\nFund\n(\nfund\n()).\nwithdraw\n(\nholdingTokens\n[\ni\n],\nmsg\n.\nsender\n,\nholdingAmounts\n[\ni\n]\n);\n}\n}"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 6,
    "bug_id": " H-07",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Wrong calcAsymmetricShare calculation\"",
    "line": "Utils[266]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-07-wrong-calcasymmetricshare-calculation",
    "title": "",
    "main_content": [
      "The inline-comment defines the number of asymmetric shares as(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3but theUtils.calcAsymmetricSharefunction computes(uA * 2U^2 - 2uU + u^2) / U^3which is not equivalent as can be seen from theA^2term in the first term which does not occur in the second one.",
      "The associativity onP * part1is wrong, andpart2is not multiplied byP.",
      "The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up.",
      "Recommend clarifying if the comment or the code is correct and fix them if not.",
      "strictly-scarce (vader) confirmed:",
      "strictly-scarce (vader) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "Valid",
      "Whilst the math is incorrect, in the current implementation it is not yet implemented, so disagree with Severity (funds not lost), recommend: 2"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 7,
    "bug_id": " H-08",
    "bug_label": " S6-4",
    "difficulty": 3,
    "bug_description": " \"Wrong liquidity units calculation\"",
    "line": "Utils[229]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-08-wrong-liquidity-units-calculation",
    "title": "",
    "main_content": [
      "The spec defines the number of LP units to be minted asunits = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustmentsbut theUtils.calcLiquidityUnitsfunction computes((P * part1) + part2) / part3 * slipAdjustments.",
      "The associativity onP * part1is wrong, andpart2is not multiplied byP.",
      "The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.",
      "Recommend fixing the equation.",
      "strictly-scarce (vader) confirmed:"
    ],
    "code_blocks": null,
    "quotes": ["Valid, but funds not at risk."],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 8,
    "bug_id": " H-10",
    "bug_label": " S5-3",
    "difficulty": 1,
    "bug_description": " \"Anyone can list anchors / curate tokens\"",
    "line": "Pools[54,59], Router[245,254]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-10-anyone-can-list-anchors--curate-tokens",
    "title": "",
    "main_content": [
      "TheRouter.listAnchorfunction can be called by anyone and tokens can be added. The only check is thatrequire(iPOOLS(POOLS).isAnchor(token));but this can easily be set by callingPools.addLiquidity(VADER, token, _)once even without actually sending any tokens to the contract. This makes it an essentially useless check.",
      "This only works initially as long as theanchorLimithas not been reached yet.\nHowever, thereplaceAnchorcan be used in the same way and flash loans can be used to get around the liquidity restrictions and push another anchor token out of the price range as these checks use the current reserves.",
      "Anchored pools are automatically curated pools and determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.",
      "After a pool has been anchored through flash loans, liquidity can be withdrawn which could make the anchor price easy to manipulate in the next block and launch other attacks.",
      "Recommend revisiting the_isAnchor[token] = true;statement inaddLiquidity, it seems strange without any further checks.\nConsider makinglistAnchor/replaceAnchorDAO-only functions and make them flash-loan secure.\nOne should probably use time-weighted prices for these pools for the bounds check.",
      "strictly-scarce (vader) disputed:"
    ],
    "code_blocks": null,
    "quotes": [
      "The protocol is intended to be launched with 5 anchors so it can only be attacked by usingreplaceAnchor(), in which case slip-based fees apply for attacks and thwart the attack path."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 9,
    "bug_id": " H-11",
    "bug_label": " S2-1",
    "difficulty": 2,
    "bug_description": " \"Swap token can be traded as fake base token\"",
    "line": "Pools[101,103,111]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-11-swap-token-can-be-traded-as-fake-base-token",
    "title": "",
    "main_content": [
      "ThePools.swapfunction does not check ifbaseis one of the base tokens. One can transfertokens to the pool and setbase=tokenand callswap(token, token, member, toBase=false)",
      "The_actualInput = getAddedAmount(base, token);will return thetokenamount added but use the ratio compared to thebasereservecalcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmountwhich yields a wrong swap result.",
      "It breaks the accounting for the pool astokens are transferred in, but thebasebalance is increased (andtokenbalance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.",
      "Another example scenario is that the token pool amount can be stolen.\nSendtokenIn=baseAmountof tokens to the pool and callswap(base=token, token, member, toBase=false). Depending on the price oftokenrelative tobasethis could be cheaper than trading with the base tokens.",
      "Recommend checking thatbaseis eitherUSDVorVADER.",
      "strictly-scarce (vader) confirmed:"
    ],
    "code_blocks": null,
    "quotes": ["Valid, funds can be lost"],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 10,
    "bug_id": " H-12",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"getAddedAmount can return wrong results\"",
    "line": "Pools[192]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-12-getaddedamount-can-return-wrong-results",
    "title": "",
    "main_content": [
      "ThegetAddedAmountfunction only works correctly when called with(VADER/USDV, pool)or(pool, pool).\nHowever, when called with (token, pool)wheretokenis neitherVADER/USDV/pool, it returns the wrong results:",
      "It gets thetokenbalance",
      "And subtracts it from the storedmapToken_tokenAmount[_pool]amount which can be that of a completely different token",
      "Anyone can break individual pairs by callingsync(token1, token2)where thetoken1balance is less thanmapToken_tokenAmount[token2]. This will add the difference tomapToken_tokenAmount[token2]and break the accounting and result in a wrong swap logic.",
      "Furthermore, this can also be used to swap tokens without having to pay anthing withswap(token1, token2, member, toBase=false).",
      "Recommend adding a require statement in theelsebranch that checks that_token == _pool.",
      "strictly-scarce (vader) confirmed:",
      "strictly-scarce (vader) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "Valid, funds can be lost",
      "Would bundle this issue with:https://github.com/code-423n4/2021-04-vader-findings/issues/205"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 11,
    "bug_id": " H-13",
    "bug_label": " S2-1",
    "difficulty": 1,
    "bug_description": " \"4 Synths can be minted with fake base token\"",
    "line": "Pools[103,143,145]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-13-4-synths-can-be-minted-with-fake-base-token",
    "title": "",
    "main_content": [
      "ThePools.mintSynthfunction does not check ifbaseis one of the base tokens. One can transfertokens to the pool and setbase=tokenand callmintSynth(token, token, member).",
      "The_actualInput = getAddedAmount(base, token);will return thetokenamount added but use the ratio compared to thebasereservecalcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmountwhich yields a wrong swap result.",
      "It breaks the accounting for the pool astokens are transferred in, but thebasebalance is increased.",
      "The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially iftokenis a high-precision token or worth less than base.",
      "Recommend checking thatbaseis eitherUSDVorVADERinmintSynth.",
      "strictly-scarce (vader) confirmed:",
      "strictly-scarce (vader) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "Valid, funds can be lost.",
      "would bundle this issue with:https://github.com/code-423n4/2021-04-vader-findings/issues/205"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 12,
    "bug_id": " H-14",
    "bug_label": " S5-3",
    "difficulty": 1,
    "bug_description": " \"Missing access restriction on lockUnits/unlockUnits\"",
    "line": "Pools[179]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-14-missing-access-restriction-on-lockunitsunlockunits",
    "title": "",
    "main_content": [
      "ThePool.lockUnitsallows anyone to steal pool tokens from amemberand assign them tomsg.sender. Anyone can steal pool tokens from any other user.",
      "Recommend adding access control and require thatmsg.senderis the router or another authorized party.",
      "strictly-scarce (vader) confirmed:"
    ],
    "code_blocks": null,
    "quotes": [
      "Valid, although this is part of the partially-complete lending code."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 13,
    "bug_id": " H-15",
    "bug_label": " S6-3",
    "difficulty": 4,
    "bug_description": " \"Wrong slippage protection on Token -> Token trades\"",
    "line": "Router[133,156]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-15-wrong-slippage-protection-on-token---token-trades",
    "title": "",
    "main_content": [
      "TheRouter.swapWithSynthsWithLimitallows trading token to token and specifying slippage protection. A token to token trade consists of two trades:",
      "token to base",
      "base to token",
      "The slippage protection of the second trade (base to token) is computed wrong:",
      "It compares thetokeninput amount (of the first trade) to thebasereserve of the second pair.",
      "Slippage protection fails and either the trade is cancelled when it shouldn‚Äôt be or it is accepted even though the user suffered more losses than expected.",
      "Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.",
      "strictly-scarce (vader) confirmed:",
      "Mervyn853 commented:"
    ],
    "code_blocks": [
      "require\n(\niUTILS\n(\nUTILS\n()).\ncalcSwapSlip\n(\ninputAmount\n,\n// should use outToken here from prev trade\niPOOLS\n(\nPOOLS\n).\ngetBaseAmount\n(\noutputToken\n)\n) <=\nslipLimit\n);"
    ],
    "quotes": [
      "Valid, although disagree with severity, the wrongly compute slip amount would just fail the trade or allow the second trade to go thru with no protection.",
      "Our decision matrix for severity:0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.Recommended: 1"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 14,
    "bug_id": " H-21",
    "bug_label": " S5-3",
    "difficulty": 1,
    "bug_description": " \"Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List.\"",
    "line": "Vether[93]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-21-anyone-can-avoid-all-vether-transfer-fees-by-adding-their-address-to-the-vether-excludedaddresses-list",
    "title": "",
    "main_content": [
      "Vether.solimplements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses(mapAddress_Excluded). However, theaddExcluded()function inVether.solhas no restrictions on who can call it.\nSo any user can calladdExcludedwith their own address as the argument, and bypass all transfer fees.",
      "Alice calls:",
      "(1)Vether.addExcluded(aliceAddress), which adds Alice‚Äôs address tomapAddress_Excluded.\n(2) Alice can now freely transfer Vether with no fees.",
      "Recommend adding restrictions to who can calladdExcluded, perhaps by restricting it to a caller set byDAO.sol",
      "strictly-scarce (vader) commented:",
      "dmvt (judge) commented:",
      "moneylegobatman (C4 Editor) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "Vether contract is outside of contest",
      "https://github.com/code-423n4/2021-04-vader-findings/issues/3#issuecomment-849043144The warden should be paid out on this issue, in my opinion, because the code was included in the repo to be reviewed. The work to review the contract was done despite the fact that the team has addressed the issue and has already deployedvether.sol. I do not think that any issues related toVether.solshould be included in the final report generated by @code423n4.It was unclear to me (and obviously most of the wardens) thatVether.solwas considered out of scope.",
      "Leaving report and discussion in for transparency, since finding was awarded."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 15,
    "bug_id": " H-23",
    "bug_label": " S5-3",
    "difficulty": 1,
    "bug_description": " \"Anyone can curate pools and steal rewards\"",
    "line": "Router[224,234]",
    "url": " https://code4rena.com/reports/2021-04-vader#h-23-anyone-can-curate-pools-and-steal-rewards",
    "title": "",
    "main_content": [
      "TheRouter.curatePoolandreplacePooldon‚Äôt have any access restriction.\nAn attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools.",
      "Curated pools determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.\nThey can then go ahead and game the reward system by repeatedly swapping in their custom pool with useless tokens, withdraw liquidity, and in the end, pay back the base flashloan.",
      "Recommend preventing the replacing of curations through flash loans. Also, consider making pool curations DAO-exclusive actions.",
      "strictly-scarce (vader) disputed:",
      "dmvt (judge) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "Slip-based pools cannot be attacked with flash loans.",
      "Further comment from @cmichelio:I can curate my custom token usingcuratePoolwithout using a flashloan or using replacePool by temporarily providing liquidity to the pool without trading in it and getting slip-fee‚Äôd. I‚Äôm not trading in the pool, and don‚Äôt think providing/removing liquidity comes with a fee. I think this is still an issue."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 16,
    "bug_id": " H-03",
    "bug_label": " S6-4",
    "difficulty": 2,
    "bug_description": " \"getRandomTokenIdFromFund yields wrong probabilities for ERC1155\"",
    "line": "NFTXVaultUpgradeable[413]",
    "url": " https://code4rena.com/reports/2021-05-nftx#h-03-getrandomtokenidfromfund-yields-wrong-probabilities-for-erc1155",
    "title": "",
    "main_content": [
      "NFTXVaultUpgradeable.getRandomTokenIdFromFunddoes not work with ERC1155 as it does not take the depositedquantity1155into account.",
      "AssumetokenId0has a count of 100, andtokenId1has a count of 1.\nThengetRandomIdwould have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.",
      "This might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.",
      "Recommend taking the quantities of each token into account (quantity1155) which probably requires a design change as it is currently hard to do without iterating over all tokens.",
      "0xKiwi (NFTX) acknowledged",
      "cemozer (Judge) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "Marking this as high risk as an attacker can weed out high-value NFTs from a vault putting other users funds at risk"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 17,
    "bug_id": " H-02",
    "bug_label": " S3-1",
    "difficulty": 2,
    "bug_description": " \"NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens\"",
    "line": "Visor[481]",
    "url": " https://code4rena.com/reports/2021-05-visorfinance#h-02-nft-transfer-approvals-are-not-removed-and-cannot-be-revoked-thus-leading-to-loss-of-nft-tokens",
    "title": "",
    "main_content": [
      "Submitted by 0xRajeev, also found by shw",
      "NFT transfer approvals that are set to true inapproveTransferERC721()are never set to false and there is no way to remove such an nft approval.",
      "Impact 1: The approval is not removed (set to false) after a transfer intransferERC721(). So if the NFT is ever moved back into the owner‚Äôs vault again, then the previous/compromised delegate can again transfer it to any address of choice without requiring a new approval.",
      "Impact 2: If a delegate becomes compromised/untrustworthy after granting approval but before transfer then the owner will lose its NFT because there is no mechanism to revoke the approval that was granted earlier.",
      "PoC-1:",
      "Alice grants Eve approval to transfer a particular NFT out of its vault usingapproveTransferERC721()",
      "Eve, who has transfer rights to that NFT from Alice‚Äôs vault,  transfers that NFT to Bob usingtransferERC721()",
      "Alice decides to buy back that NFT (e.g. because it is now considered rare and more valuable) from Bob and transfers it back to its vault",
      "Eve, who continues to have transfer rights to that NFT from Alice‚Äôs vault, can steal that NFT and transfer to anyone",
      "PoC-2:",
      "Alice grants Eve approval to transfer a particular NFT out of its vault usingapproveTransferERC721()",
      "Alice learns that Eve‚Äôs keys are compromises or that Eve is malicious and wants to revoke the approval but there is no mechanism to do so",
      "Eve (or whoever stole her credentials) has transfer rights to that NFT from Alice‚Äôs vault and can steal that NFT and transfer to anyone",
      "Recommend adding a boolean parameter toapproveTransferERC721()and set thenftApprovalsto that parameter which can be true for giving approval and false for removing/revoking approval\nIfmsg.sender != _getOwner(), callapproveTransferERC721()with the boolean false to remove approval before making a transfer intransferERC721()on L515."
    ],
    "code_blocks": null,
    "quotes": [
      "duplicatehttps://github.com/code-423n4/2021-05-visorfinance-findings/issues/35",
      "35 is about token being stuck in the vault. This issue is about not being able to revoke approval. Marking this as separate.",
      "patchlink"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 18,
    "bug_id": " H-03",
    "bug_label": " S3-1",
    "difficulty": 3,
    "bug_description": " \"Approval for NFT transfers is not removed after transfer\"",
    "line": "Visor[495]",
    "url": " https://code4rena.com/reports/2021-05-visorfinance#h-03-approval-for-nft-transfers-is-not-removed-after-transfer",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by gpersoon, and pauliax",
      "TheVisor.transferERC721does not reset the approval for the NFT.",
      "An approved delegatee can move the NFT out of the contract once.\nIt could be moved to a market and bought by someone else who then deposits it again to the same vault.\nThe first delegatee can steal the NFT and move it out of the contract a second time.",
      "Recommend resetting the approval on transfer.",
      "xyz-ctrl (Visor) confirmed:",
      "ztcrypto (Visor) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "We will be mitigating this issue for our next release and before these experimental features are introduced in platform.\nPR pending",
      "duplicate of above ones and fixed"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 19,
    "bug_id": " H-03",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"YieldMath.sol / Log2: >= or > ?\"",
    "line": "YieldMath[41]",
    "url": " https://code4rena.com/reports/2021-05-yield#h-03-yieldmathsol--log2--or--",
    "title": "",
    "main_content": [
      "The V1 version ofYieldMath.solcontains ‚Äù>=‚Äù (larger or equal), while the V2 version ofYieldMath.solcontains ‚Äù>‚Äù (larger) in the log_2 function.\nThis change doesn‚Äôt seem logical and might lead to miss calculations.\nThe difference is present in several adjacent lines.",
      "and",
      "Recommend checking which version is the correct version and fix the incorrect version."
    ],
    "code_blocks": [
      "function\nlog_2\n(\nuint128\nx\n)\n...\nb\n=\nb\n*\nb\n>> 127;\nif\n(\nb\n>=\n0x100000000000000000000000000000000\n) {\nb\n>>=\n1\n;\nl\n|=\n0x1000000000000000000000000000000\n;}",
      "function\nlog_2\n(\nuint128\nx\n)\n...\nb\n=\nb\n*\nb\n>> 127;\nif\n(\nb\n>\n0x100000000000000000000000000000000\n) {\nb\n>>=\n1\n;\nl\n|=\n0x1000000000000000000000000000000\n;}",
      "Join\njoin\n=\nnew\nJoin\n{\nsalt\n:\nkeccak256\n(\nabi\n.\nencodePacked\n(\nasset\n))}();",
      "modifier\nauth\n(\nbytes4\nfs\n) {\nrequire\n(\nmsg\n.\nsig\n==\nfs\n,\n\"Wrong selector\"\n);\nrequire\n(\n_hasRole\n(\nmsg\n.\nsig\n,\nmsg\n.\nsender\n),\n\"Access denied\"\n);\n_\n;\n}",
      "function\nsetFee\n(\nuint256\n)\npublic\nauth\n(this.setFee.selector) {\n.....\n}",
      "function\n_update\n(\nuint128\nbaseBalance\n,\nuint128\nfyBalance\n,\nuint112\n_baseCached\n,\nuint112\n_fyTokenCached\n)\nprivate\n{\n....\ncumulativeBalancesRatio\n+=\n(\nscaledFYTokenCached\n/\n_baseCached\n) *\ntimeElapsed\n;\n....\n}",
      "a\n= (\nb\n/\nd\n)*\nc\n0\n= (\n5\n/\n10\n)*\n2\na\n= (\nb\n*\nc\n)/\n2\n1\n= (\n5\n*\n2\n)/\n10",
      "// Ladle._close calling it with art or ink as type(int128).min will crash\nuint128\namt\n=\n_debtInBase\n(\nvault\n.\nseriesId\n,\nseries\n,\nuint128\n(-\nart\n));\nilkJoin\n.\nexit\n(\nto\n,\nuint128\n(-\nink\n))\n// explanation\nint128\nart\n=\ntype\n(\nint128\n).\nmin\n;\n// -2^127\nuint128\namt\n=\nuint128\n(-\nart\n);\n// this fails as -art=--2^127=2^127 cannot be represented in int128",
      "require ```(ilks[seriesId][ilkId] == true, \"Ilk not added to series\")```",
      "solidity\nprice = term1.wmul(term2); // this is the art price in terms of ink now, instead of ink price\nink = uint256(art).wmulup(price); // can just multiply by art price"
    ],
    "quotes": [
      "That‚Äôs entirely my fault, and this is a scary one. We might be having a slightly different or impredictable curve in Pool.sol, and we might notice only after a long while with the Pools being slowly drained. We might never even have found this was the issue.I would suggest increasing the severity of this issue to High."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 20,
    "bug_id": " H-03",
    "bug_label": " S5-3",
    "difficulty": 4,
    "bug_description": " \"anyone can call function sponsor\"",
    "line": "RCMarket[817]",
    "url": " https://code4rena.com/reports/2021-06-realitycards#h-03-anyone-can-call-function-sponsor",
    "title": "",
    "main_content": [
      "Submitted bypaulius.eth, also found by0xRajeev,cmichel, andshw",
      "This functionsponsorshould only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary_sponsorAddressaddress and transfer tokens from them if the allowance is > 0:",
      "Recommend checking that the sender is a factory contract.",
      "Splidge (Reality Cards) confirmed:",
      "mcplums (Reality Cards) commented:"
    ],
    "code_blocks": [
      "/// @notice ability to add liqudity to the pot without being able to win.\n/// @dev called by Factory during market creation\n/// @param _sponsorAddress the msgSender of createMarket in the Factory\nfunction\nsponsor\n(\naddress\n_sponsorAddress\n,\nuint256\n_amount\n)\nexternal\noverride\n{\n_sponsor\n(\n_sponsorAddress\n,\n_amount\n);\n}"
    ],
    "quotes": [
      "This is a good one!",
      "Yeah this is massive one!! Thanks @pauliax :)",
      "fixedhere"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 21,
    "bug_id": " H-04",
    "bug_label": " S5-1",
    "difficulty": 1,
    "bug_description": " \"Anyone can affect deposits of any user and turn the owner of the token\"",
    "line": "RCTreasury[703]",
    "url": " https://code4rena.com/reports/2021-06-realitycards#h-04-anyone-can-affect-deposits-of-any-user-and-turn-the-owner-of-the-token",
    "title": "",
    "main_content": [
      "Submitted by [adlamo](https://twitter.com/a_delamo)_",
      "OnRCTreasury, we have the methodcollectRentUser. This method is public, so anyone can call it using whatever user and whatever timestamp.\nSo, calling this method usinguser = XXXXXand_timeToCollectTo = type(uint256).max), would makeisForeclosed[user] = true.",
      "Seeissue pagefor referenced code",
      "Now, we can do the same for all the users bidding for a specific token.\nFinally, I can become the owner of the token by just callingnewRentaland using a small price.newRentalwill iterate over all the previous bid and will remove them because there are foreclosed.",
      "Recommend thatcollectRentUsershould be private and create a new public method withonlyOrderbookmodifier.",
      "Splidge (Reality Cards) confirmed:",
      "mcplums (Reality Cards) commented:"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 22,
    "bug_id": " H-01",
    "bug_label": " S6-3",
    "difficulty": 1,
    "bug_description": " \"User could lose underlying tokens when redeeming from the IdleYieldSource\"",
    "line": "IdleYieldSource[128,131]",
    "url": " https://code4rena.com/reports/2021-06-pooltogether#h-01-user-could-lose-underlying-tokens-when-redeeming-from-the-idleyieldsource",
    "title": "",
    "main_content": [
      "Submitted by shw",
      "TheredeemTokenfunction inIdleYieldSourceusesredeemedShareinstead ofredeemAmountas the input parameter when callingredeemIdleTokenof the Idle yield source. As a result, users could get fewer underlying tokens than they should.",
      "When burning users‚Äô shares, it is correct to useredeemedShare(line 130). However, when redeeming underlying tokens from Idle Finance,redeemAmountshould be used instead ofredeemedShare(line 131). Usually, thetokenPriceWithFee()is greater thanONE_IDLE_TOKEN, and thusredeemedShareis less thanredeemAmount, causing users to get fewer underlying tokens than expected.",
      "Recommend changingredeemedSharetoredeemAmountat lineL131.",
      "PierrickGT (PoolTogether) confirmed and patched:"
    ],
    "code_blocks": null,
    "quotes": ["PR:https://github.com/pooltogether/idle-yield-source/pull/4"],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 23,
    "bug_id": " H-03",
    "bug_label": " S6-3",
    "difficulty": 1,
    "bug_description": " \"BadgerYieldSource balanceOfToken share calculation seems wrong\"",
    "line": "BadgerYieldSource[32,36]",
    "url": " https://code4rena.com/reports/2021-06-pooltogether#h-03-badgeryieldsource-balanceoftoken-share-calculation-seems-wrong",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "When suppling to theBadgerYieldSource, someamountofbadgeris deposited tobadgerSettand one receivesbadgerSettshare tokens in return which are stored in thebalancesmapping of the user. So far this is correct.",
      "ThebalanceOfTokenfunction should then return the redeemable balance inbadgerfor the user‚ÄôsbadgerSettbalance.\nIt computes it as the pro-rata share of the user balance (compared to the total-supply ofbadgerSett) on thebadgerin the vault:",
      "However,badger.balanceOf(address(badgerSett))is only a small amount of badger that is deployed in the vault (‚ÄúSett‚Äù) due to most of the capital being deployed to thestrategies. Therefore, it under-reports the actual balance:",
      "Any contract or user calling thebalanceOffunction will receive a value that is far lower than the actual balance.\nUsing this value as a basis for computations will lead to further errors in the integrations.",
      "Recommend usingbadgerSett.balance()instead ofbadger.balanceOf(address(badgerSett))to also account for ‚Äúthe balance in the Sett, the Controller, and the Strategy‚Äù.",
      "asselstine (PoolTogether) confirmed"
    ],
    "code_blocks": [
      "balances\n[\naddr\n].\nmul\n(\nbadger\n.\nbalanceOf\n(\naddress\n(\nbadgerSett\n))\n).\ndiv\n(\nbadgerSett\n.\ntotalSupply\n()\n)"
    ],
    "quotes": [
      "Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply.Badger Docs"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 24,
    "bug_id": " H-04",
    "bug_label": " S3-2",
    "difficulty": 1,
    "bug_description": " \"withdraw timelock can be circumvented\"",
    "line": "PrizePool[371,398]",
    "url": " https://code4rena.com/reports/2021-06-pooltogether#h-04-withdraw-timelock-can-be-circumvented",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "One can withdraw the entirePrizePooldeposit by circumventing the timelock.\nAssume the user has no credits for ease of computation:",
      "user callswithdrawWithTimelockFrom(user, amount=userBalance)with their entire balance. This ‚Äúmints‚Äù an equivalentamountoftimelockand resets_unlockTimestamps[user] = timestamp = blockTime + lockDuration.",
      "user callswithdrawWithTimelockFrom(user, amount=0)again but this time withdrawing0amount. This will return alockDurationof0and thusunlockTimestamp = blockTime. The inner_mintTimelocknow resets_unlockTimestamps[user] = unlockTimestamp",
      "Asif (timestamp <= _currentTime())is true, the full users amount is now transferred out to the user in the_sweepTimelockBalancescall.",
      "Users don‚Äôt need to wait for their deposit to contribute their fair share to the prize pool.\nThey can join before the awards and leave right after without a penalty which leads to significant issues for the protocol.\nIt‚Äôs the superior strategy but it leads to no investments in the strategy to earn the actual interest.",
      "Recommend that the unlock timestamp should be increased by duration each time, instead of being reset to the duration.",
      "asselstine (PoolTogether) confirmed:"
    ],
    "code_blocks": null,
    "quotes": [
      "Mitigation:If a user‚Äôs timelock balance is non-zero, the prize strategy rejects the ticket burn."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 25,
    "bug_id": " H-01",
    "bug_label": " S1-3",
    "difficulty": 2,
    "bug_description": " \"Wrong trading pricing calculations\"",
    "line": "Pricing[69],Trader[67]",
    "url": " https://code4rena.com/reports/2021-06-tracer#h-01-wrong-trading-pricing-calculations",
    "title": "",
    "main_content": [
      "Submitted by 0xsanson, also found by shw",
      "In thePricingcontract, an agent can manipulate the trading prices by spamming a high amount of trades.",
      "Indeed an agent can create a high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn‚Äôt even need large funds); next he/she pairs the orders with another account and callsTrader.executeTrade; now every order calls aPricing.recordTradeusing the arbitrary price set by the agent.",
      "Since the trades are all made in the same hour, by the wayhourlyTracerPrices[currentHour]is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate thefundingRatesand thefairPrice, allowing a malicious agent the ability to manipulate the market.",
      "Recommend passing thefillAmountparameter torecordTrade(...), and calculatehourlyTracerPrices[currentHour].tradessummingfillAmountinstead of 1 every trade.",
      "raymogg (Tracer) confirmed:"
    ],
    "code_blocks": null,
    "quotes": [
      "Issue is valid, and there appear to be a few other issues that reference similar problems.The Trader contract will have a whitelist allowing only select relayers to push orders on chain. As long as off chain order books have sufficient liquidity, this issue is then mitigated as users can‚Äôt just arbitrarily match orders and send them in, they must be matched on a book with liquidity. To alter the price you would then need to eat through significant liquidity (increasing the cost of this attack)."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 26,
    "bug_id": " H-02",
    "bug_label": " S6-3",
    "difficulty": 1,
    "bug_description": " \"Use of incorrect index leads to incorrect updation of funding rates\"",
    "line": "Pricing[141,155,159]",
    "url": " https://code4rena.com/reports/2021-06-tracer#h-02-use-of-incorrect-index-leads-to-incorrect-updation-of-funding-rates",
    "title": "",
    "main_content": [
      "Submitted by 0xRajeev",
      "TheupdateFundingRate()function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of[currentFundingIndex]which has been updated since the previous call to this function while it should really be using[currentFundingIndex-1]to reference the previous funding rate.",
      "The impact of this, is that the cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and the protocol takes a reputation hit.",
      "Recommend using[currentFundingIndex-1]for non-zero values ofcurrentFundingIndexto get the value updated in the previous call on lines L155 and L159 ofPricing.sol.",
      "raymogg (Tracer) confirmed:"
    ],
    "code_blocks": null,
    "quotes": ["Confirmed as an index issue with funding rate üëç"],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 27,
    "bug_id": " H-04",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Logic error in fee subtraction\"",
    "line": "TracerPerpetualSwaps[272], LibBalances[172]",
    "url": " https://code4rena.com/reports/2021-06-tracer#h-04-logic-error-in-fee-subtraction",
    "title": "",
    "main_content": [
      "Submitted by 0xsanson",
      "InLibBalances.applyTrade(), we need to collect a fee from the trade. However, the current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (seeTracerPerpetualSwaps.solL272).\nThis issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.",
      "Recommend changing+feeto-feein thehighlighted line.",
      "raymogg (Tracer) confirmed:"
    ],
    "code_blocks": null,
    "quotes": ["Valid issue üëç"],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 28,
    "bug_id": " H-06",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Wrong price scale for GasOracle\"",
    "line": "ChainlinkOracleAdapter[33]",
    "url": " https://code4rena.com/reports/2021-06-tracer#h-06-wrong-price-scale-for-gasoracle",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheGasOracleuses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.",
      "However, the scaling depends on the underlying decimals of the two oracles and could be anything.\nBut the code assumes it‚Äôs in 18 decimals.",
      "There is atoWadfunction that seems to involve scaling but it is never used.",
      "The impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported.",
      "Recommend checkingchainlink.decimals()to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, thelatestAnswerfunction always returns the answer in 18 decimals."
    ],
    "code_blocks": null,
    "quotes": [
      "‚ÄúReturned value is USD/Gas * 10^18 for compatibility with rest of calculations‚Äù",
      "Disagree with severity as while the statement that the underlying decimals of the oracles could be anything, we will be using production Chainlink feeds for which the decimals are known at the time of deploy.This is still however an issue as you don‚Äôt want someone using different oracles (eg non Chainlink) that have different underlying decimals and not realising that this contract will not support that.",
      "Marking this a high-risk issue as it poses a big threat to users deploying their own markets"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 29,
    "bug_id": " H-02",
    "bug_label": " S6-4",
    "difficulty": 2,
    "bug_description": " \"Buoy3Pool.safetyCheck is not precise and has some assumptions\"",
    "line": "Buoy3Pool[87]",
    "url": " https://code4rena.com/reports/2021-06-gro#h-02-buoy3poolsafetycheck-is-not-precise-and-has-some-assumptions",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by shw",
      "ThesafetyCheckfunction has several issues that impact how precise the checks are:",
      "Only checks if thea/banda/cratios are withinBASIS_POINTS.\nBy transitivity,b/cis only within2 * BASIS_POINTSifa/banda/care in range.\nFor a more precise check whether both USDC and USDT are within range,b/cmust be checked as well.",
      "Ifa/bis within range, this does not imply thatb/ais within range.",
      "‚Äúinverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions‚Äù",
      "Example:lastRatio = 1.0ratio: a = 1.0, b = 0.8=>a/b = 1.25,b/a = 0.8Ifa/bwas used with a 20% range, it‚Äôd be out of range, butb/ais in range.",
      "The NatSpec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both_ratioandlastRatioare only from Curve. Only_updateRatioschecks the oracle.",
      "To address this issue, it is recommended to check ifb/cis withinBASIS_POINTS.",
      "kristian-gro (Gro) confirmed but disagreed with severity:",
      "kristian-gro (Gro) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "Makes strong assumption about the range of possible values - small differences between a and b will result in small differences between a/b and b/a - Extreme cases are handled by emergency. Agree on b/c check",
      "medium severity - will only cause stop of deposits/withdrawals against curve, work around to put in emergency mode",
      "Acknowledged, but the differences between variables are in basis points, we‚Äôve simulated flash loan manipulations of curve and come to the conclusion that this approximation has a sufficiently small error margin to not cause issues.\nThe B/C check (usdc/usdt) has been added in release version.",
      "A possibility of stopping deposits or withdrawals deserves high risk."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 30,
    "bug_id": " H-03",
    "bug_label": " S5-3",
    "difficulty": 3,
    "bug_description": " \"Incorrect use of operator leads to arbitrary minting of GVT tokens\"",
    "line": "Controller[357,405]",
    "url": " https://code4rena.com/reports/2021-06-gro#h-03-incorrect-use-of-operator-leads-to-arbitrary-minting-of-gvt-tokens",
    "title": "",
    "main_content": [
      "Submitted by 0xRajeev, also found by pauliax and gpersoon",
      "ThedistributeStrategyGainLoss()function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced onmsg.senderby checking thatvaultIndexes[msg.sender]is a valid index range 1-4. However, the operator used in therequire()is||instead of&&, which allows an arbitrarymsg.sender, i.e. attacker, to bypass the check.",
      "Scenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value invaultIndexes[msg.sender], which will fail the> 0check, but pass the<= N_COINS + 1check (N_COINS = 3) because0 <= 4which will allow control to go past this check.",
      "Furthermore, on L362,index=0will underflow the -1 decrement (due to lack ofSafeMath.suband use of < 0.8.0 solc) and the index will be set to(uint256_MAX - 1). This will allow execution to proceed to the ‚Äúelse‚Äù part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.",
      "The attack control flow:",
      "->Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0)",
      "->index = 0passes check for theindex <= N_COINS + 1part of predicate on L357 inController.sol",
      "->index = uint256_MAXafter L362",
      "->gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN);on L371 inController.sol",
      "->ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);on L376 inController.sol",
      "->(gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);on L254 inPnL.sol",
      "->performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);on L186 ofPnL.sol",
      "->gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);on L256 inPnL.sol",
      "Recommend changing||to&&inrequire()on L357 ofController.solto prevent arbitrary addresses from going past this check. Or, consider exercising explicit access control for the authorized vault adaptors.",
      "kristian-gro (Gro) confirmed"
    ],
    "code_blocks": null,
    "quotes": ["Confirmed and Fix has been implemented in release version."],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 31,
    "bug_id": " H-01",
    "bug_label": " S6-1",
    "difficulty": 1,
    "bug_description": " \"Reward computation is wrong\"",
    "line": "LendingPair[187]",
    "url": " https://code4rena.com/reports/2021-07-wildcredit#h-01-reward-computation-is-wrong",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheLendingPair.accrueAccountfunction distributes rewardsbeforeupdating the cumulative supply / borrow indexes as well as the index + balance for the user (by minting supply tokens / debt).\nThis means the percentage of the user‚Äôs balance to the total is not correct as the total can be updated several times in between.",
      "Example: Two users deposit the same amounts in the same block. Thus, after some time they should receive the same tokens.",
      "User A and B deposit 1000 tokens (in the same block) and are minted 1000 tokens in return. Total supply =2000",
      "Assume after 50,000 blocks,AcallsaccrueAccount(A)which first calls_distributeReward. A is paid out 1000/2000 = 50% of the 50,000 blocks reward since deposit. Afterwards,accrue+_accrueAccountInterest(A)is called andAis minted 200 more tokens due to supplier lending rate. The supplytotalSupply is now 2200.",
      "After another 50,000 blocks,AcallsaccrueAccount(A)again. which first calls_distributeReward. A is paid out 1200/2200 =54.5454% of the 50,000 blocks reward since deposit.",
      "From here, you can already see thatAreceives more than 50% of the 100,000 block rewards although they deposited at the same time asBand didn‚Äôt deposit or withdraw any funds.Bwill receive~1000/2200 = 45%(ignoring any new LP supply tokens minted forA‚Äôs second claim.)",
      "The impact is that wrong rewards will be minted users which do not represent their real fair share. Usually, users will get fewer rewards than they should receive, as their individual interest was not updated yet, but the totals (total debt and total supply) could have been updated by other accounts in between.",
      "There are two issues that both contribute to it:",
      "total LP supply and total debt must be updated by thetotal new interestwhenaccrueis called, not only increased by anindividual user‚Äôs interest. See my other issue ‚ÄúReward computation is wrong‚Äù that goes into more depth",
      "Lending/borrow accrual must happen before reward distribution",
      "talegift (Wild Credit) acknowledged but disagreed with severity:",
      "ghoul-sol (Judge) commented:"
    ],
    "code_blocks": [
      "function\naccrueAccount\n(\naddress\n_account\n)\npublic\n{\n// distributes before updating accrual state\n_distributeReward\n(\n_account\n);\naccrue\n();\n_accrueAccountInterest\n(\n_account\n);\nif\n(\n_account\n!=\nfeeRecipient\n()) {\n_accrueAccountInterest\n(\nfeeRecipient\n());\n}\n}"
    ],
    "quotes": [
      "Assets not at direct risk, but the function of the protocol or its availability could be impacted, orleak valuewith a hypothetical attack path with stated assumptions, butexternal requirements.Update to severity - 2",
      "Disagree with sponsor about severity, this is significant accounting error."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 32,
    "bug_id": " H-02",
    "bug_label": " S3-1",
    "difficulty": 1,
    "bug_description": " \"LendingPair.liquidateAccount does not accrue and update cumulativeInterestRate\"",
    "line": "LendingPair[246]",
    "url": " https://code4rena.com/reports/2021-07-wildcredit#h-02-lendingpairliquidateaccount-does-not-accrue-and-update-cumulativeinterestrate",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheLendingPair.liquidateAccountfunction does not accrue and update thecumulativeInterestRatefirst, it only calls_accrueAccountInterestwhich does not update and instead uses the oldcumulativeInterestRate.",
      "The liquidatee (borrower)‚Äòs state will not be up-to-date.\nI could skip some interest payments by liquidating myself instead of repaying if I‚Äôm under-water.\nAs the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.",
      "Recommend callingaccrueAccountinstead of_accrueAccountInterest",
      "talegift (Wild Credit) confirmed but disagreed with severity:",
      "ghoul-sol (Judge) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "Assets not at direct risk, but the function of the protocol or its availability could be impacted, orleak valuewith a hypothetical attack path with stated assumptions, butexternal requirements.Update to severity - 2",
      "No funds are lost however a user can steal ‚Äúunpaid interest‚Äù from the protocol. Keeping high risk."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 35,
    "bug_id": " H-05",
    "bug_label": " S1-1",
    "difficulty": 2,
    "bug_description": " \"Synth realise is vulnerable to flash loan attacks\"",
    "line": "Synth[187]",
    "url": " https://code4rena.com/reports/2021-07-spartan#h-05-synth-realise-is-vulnerable-to-flash-loan-attacks",
    "title": "",
    "main_content": [
      "Submitted by jonah1005, also found by adelamo_",
      "Synthrealisefunction calculatesbaseValueLPandbaseValueSynthbase on AMM spot price which is vulnerable to flash loan attack.Synth‚Äôs lp is subject torealisewhenever the AMM ratio is different than Synth‚Äôs debt ratio.",
      "The attack does not necessarily require a flash loan. A big whale of the lp token holders could keep callingrealiseby shifting token ratio of AMM pool back and forth.",
      "The vulnerability is located atSynth.solL187-L199. Where the formulahereis dangerous.",
      "Here‚Äôs a script for conducting flashloan attack:",
      "Output:",
      "Calculating Lp token‚Äôs value base on AMM protocol is known to be dangerous.\nThere are a few steps that might solve the issue:",
      "calculate token‚Äôs price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle.",
      "calculate lp token value based on anti-flashloan formula.  Alpha finance‚Äôs formula is a good reference:https://blog.alphafinance.io/fair-lp-token-pricing",
      "verifyfirst (Spartan) confirmed and disagreed with severity:"
    ],
    "code_blocks": [
      "flashloan_amount = init_amount\nuser = w3.eth.accounts[\n0\n]\nmarked_token.functions.transfer(user, flashloan_amount).transact()\nmarked_token.functions.transfer(token_pool.address, flashloan_amount).transact({\n'from'\n: user})\ntoken_pool.functions.addForMember(user).transact({\n'from'\n: user})\nreceived_lp = token_pool.functions.balanceOf(user).call()\nsynth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\ntoken_synth.functions.realise(token_pool.address).transact()\ntoken_pool.functions.transfer(token_pool.address, received_lp).transact({\n'from'\n: user})\ntoken_pool.functions.removeForMember(user).transact({\n'from'\n: user})\ntoken_synth.functions.realise(token_pool.address).transact()\nsynth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\nprint\n(\n'synth_lp_balance_after_realise'\n, synth_balance_after_realise)\nprint\n(\n'synth_lp_balance_before_realise'\n, synth_balance_before_realise)",
      "synth_balance_after_realise 1317859964829313908162\nsynth_balance_before_realise 2063953488372093023256"
    ],
    "quotes": [
      "A proposal has been suggested to limit the use of realise() for a DAO proposal. This will allow only liquidity providers to choose the outcome of a function that directly affects them."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 36,
    "bug_id": " H-06",
    "bug_label": " S1-1",
    "difficulty": 1,
    "bug_description": " \"SynthVault rewards can be gamed\"",
    "line": "BondVault[60], Dao[250], synthVault[91,95]",
    "url": " https://code4rena.com/reports/2021-07-spartan#h-06-synthvault-rewards-can-be-gamed",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheSynthVault._depositfunction addsweightfor the user that depends on the spot value of the deposit synth amount inBASE.",
      "This spot price can be manipulated and the cost of manipulation is relative to the pool‚Äôs liquidity.\nHowever, the reward (seecalcReward) is measured in BASE tokens unrelated to the pool.\nTherefore, if the pool‚Äôs liquidity is low and the reward reserve is high, the attack can be profitable:",
      "Manipulate the pool spot price of theiSYNTH(_synth).LayerONE()pool by dripping a lot ofBASEinto it repeatedly (sending lots of smaller trades is less costly due to thepath-independence of the continuous liquidity model). This increases theBASEpertokenprice.",
      "CallSynthVault.depositForMemberand deposit asmallamount of synth token. TheiUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)will return an inflated weight due to the price.",
      "Optionally drip moreBASEinto the pool and repeat the deposits",
      "Drip backtokento the pool to rebalance it",
      "The user‚Äôsweightis now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool‚Äôs liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.",
      "Recommend tracking a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.",
      "verifyfirst (Spartan) acknowledged:"
    ],
    "code_blocks": null,
    "quotes": [
      "There is already a discussion in place to change spot rate to swap rate calculation for weights."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 37,
    "bug_id": " H-07",
    "bug_label": " S1-2",
    "difficulty": 2,
    "bug_description": " \"Missing slippage checks\"",
    "line": "Pool[284,296]",
    "url": " https://code4rena.com/reports/2021-07-spartan#h-07-missing-slippage-checks",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by tensors",
      "There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated.\nThis means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.",
      "Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn‚Äôt obtained.",
      "verifyfirst (Spartan) acknowledge:",
      "SamusEldburg (Spartan) confirmed and disagreed with severity:",
      "ghoul-sol (Judge) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "We acknowledge the issue for the protocol‚Äôs AMM, but if this becomes a large issue in the future, the router is easily upgradeable to include a minimum rate parameter.",
      "Have changed this to confirmed; even though we already were aware of it; we have discussed and are happy to add in a UI-handed arg for minAmount now rather than reactively in the future. Disagree with severity though; this wasn‚Äôt a problem with V1 at all.",
      "I‚Äôll keep high risk as sandwich attacks are very common and risk of getting a bad swap is real."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 38,
    "bug_id": " H-09",
    "bug_label": " S2-2",
    "difficulty": 1,
    "bug_description": " \"arbitrary synth mint/burn from pool\"",
    "line": "Pool[229],Synth[165]",
    "url": " https://code4rena.com/reports/2021-07-spartan#h-09-arbitrary-synth-mintburn-from-pool",
    "title": "",
    "main_content": [
      "Submitted by jonah1005",
      "Poolcan mint arbitrarySynthprovided as long as it‚Äôs a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.",
      "Pool‚Äôs mintSynth logic,Synth‚Äôs mintSynth logic, andSynth‚Äôs authorization logic.",
      "The price of the synthetics to be mint is calculated inPoolbased on the AMM price of the current Pool",
      "Here‚Äôs a web3.py script of minting arbitrarySynthin a pool.\nFor simplicity, two pools are set with the assumption that link is 10x expensive than dai.",
      "The log of the above script",
      "Recommend Checking the provided synth‚Äôs underlying token inmintSynth",
      "verifyfirst (Spartan) confirmed:"
    ],
    "code_blocks": [
      "sparta_amount =\n100\n*\n10\n**\n18\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(link_pool.address, sparta_amount).transact({\n'from'\n: user})\nlink_pool.functions.mintSynth(link_synth.address, user).transact({\n'from'\n: user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\nprint\n(\n'get link synth amount from link pool:'\n, after_link_synth - initail_link_synth)\nsparta_amount =\n100\n*\n10\n**\n18\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(dai_pool.address, sparta_amount).transact({\n'from'\n: user})\ndai_pool.functions.mintSynth(link_synth.address, user).transact({\n'from'\n: user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\nprint\n(\n'get link synth amount from dai pool:'\n, after_link_synth - initail_link_synth)",
      "get\nlink\nsynth\namount\nfrom\nlink\npool:\n97078046905036524413\nget\nlink\nsynth\namount\nfrom\ndai\npool:\n970780469050365244136",
      "require\n(\niSYNTH\n(\nsynthOut\n).\nLayerONE\n() ==\nTOKEN\n,\n\"invalid synth\"\n);"
    ],
    "quotes": [
      "We agree and appreciate this finding being valid high risk issue."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 39,
    "bug_id": " H-13",
    "bug_label": " S1-1",
    "difficulty": 1,
    "bug_description": " \"Flash loan manipulation on getPoolShareWeight of Utils\"",
    "line": "Dao[201,570], DaoVault[44], Utils[46,70]",
    "url": " https://code4rena.com/reports/2021-07-spartan#h-13-flash-loan-manipulation-on-getpoolshareweight-of-utils",
    "title": "",
    "main_content": [
      "Submitted by shw",
      "ThegetPoolShareWeightfunction returns a user‚Äôs pool share weight by calculating how many SPARTAN the user‚Äôs LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.",
      "According to the implementation ofgetPoolShareWeight,a user‚Äôs pool share weight is calculated byuints * baseAmount / totalSupply, whereuintsis the number of user‚Äôs LP tokens,totalSupplyis the total supply of LP tokens, andbaseAmountis the number of SPARTAN in the pool. Thus, a user‚Äôs pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:",
      "Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool.",
      "The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool‚ÄôsbaseAmount. He could split his trade into small amounts to reduce slip-based fees.",
      "The attacker now wants to increase his weight in theDaoVault. He adds his LP tokens to the pool by calling thedepositfunction ofDao.",
      "Daothen callsdepositLPofDaoVault, causing the attacker‚Äôs weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker‚Äôs weight is artificially increased.",
      "With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when callingharvestof theDaocontract.",
      "The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.",
      "Referenced code:Utils.sol#L46-L50,Utils.sol#L70-L77,DaoVault.sol#L44-L56,Dao.sol#L201, andDao.sol#L570.",
      "A possible mitigation is to record the current timestamp when a user‚Äôs weight in theDaoVaultorBondVaultis recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.",
      "SamusElderg (Spartan) confirmed and disagreed with severity:",
      "ghoul-sol (judge) commented:"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 40,
    "bug_id": " H-02",
    "bug_label": " S2-3",
    "difficulty": 1,
    "bug_description": " \"2 variables not indexed by marketIndex\"",
    "line": "Staker[622]",
    "url": " https://code4rena.com/reports/2021-08-floatcapital#h-02-2-variables-not-indexed-by-marketindex",
    "title": "",
    "main_content": [
      "Submitted by gpersoon",
      "In the token contract:batched_stakerNextTokenShiftIndexis indexed bymarketIndex, so it can have separate (or the same) values for each differentmarketIndex.",
      "stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingandstakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mappingare not indexed bymarketIndex.\nSo the values ofstakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingandstakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mappingcan be overwritten by a different market, ifbatched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex[market2]",
      "This will lead to weird results in_calculateAccumulatedFloat, allocating too much or too little float.",
      "Staker.solL622",
      "Recommend adding an index withmarketIndexto the variables:",
      "stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping",
      "stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping",
      "Also consider shortening the variable names, this way mistakes can be spotted easier.",
      "Confirmed by Jason of Float Capital: Yes, you are totally right, it should use themarketIndexsince they are specific per market!",
      "JasoonS (Float) confirmed:"
    ],
    "code_blocks": [
      "function\npushUpdatedMarketPricesToUpdateFloatIssuanceCalculations\n(\n...\nstakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping\n[\nbatched_stakerNextTokenShiftIndex\n[\nmarketIndex\n]  ] =\nstakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted\n;\nstakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping\n[\nbatched_stakerNextTokenShiftIndex\n[\nmarketIndex\n]  ] =\nlatestRewardIndex\n[\nmarketIndex\n] +\n1\n;\nbatched_stakerNextTokenShiftIndex\n[\nmarketIndex\n] +=\n1\n;\n...\n)"
    ],
    "quotes": ["Embarrassed by this one!Thank you for the report.Fixed!!"],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 41,
    "bug_id": " H-04",
    "bug_label": " S2-1",
    "difficulty": 1,
    "bug_description": " \"Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed\"",
    "line": " CompoundToNotionalV2[58,73]",
    "url": " https://code4rena.com/reports/2021-08-notional#h-04-access-restrictions-on-compoundtonotionalv2notionalcallback-can-be-bypassed",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheCompoundToNotionalV2.notionalCallbackis supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providingsender = this, assenderis a parameter of the function that can be chosen by the attacker.",
      "An attacker can call the function passing in an arbitraryaccountwhose tokens are then transferred to the contract.\nTheaccountfirst has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker front-runs the actual transaction.",
      "It‚Äôs at least a griefing attack:\nI can pass in a maliciouscTokenBorrowthat returns any token of my choice (through the.underlying()call) but whoserepayBorrowBehalfis a no-op.",
      "This will lead to any of the victim‚Äôs approved tokens becoming stuck in the contract, essentially burning them:",
      "Note that the assumption at the end of the function ‚Äù// When this exits a free collateral check will be triggered‚Äù is not correct anymore but I couldn‚Äôt find a way to make use of it to lead to an invalid account state.",
      "Recommend fixing the authorization check.",
      "jeffywu (Notional) confirmed"
    ],
    "code_blocks": [
      "function\nnotionalCallback\n(\naddress\nsender\n,\naddress\naccount\n,\nbytes\ncalldata\ncallbackData\n)\nexternal\nreturns\n(\nuint256\n) {\n// @audit sender can be passed in by the attacker\nrequire\n(\nsender\n==\naddress\n(\nthis\n),\n\"Unauthorized callback\"\n);",
      "// @audit using a malicious contract, this can be any token\naddress\nunderlyingToken\n=\nCTokenInterface\n(\ncTokenBorrow\n).\nunderlying\n();\nbool\nsuccess\n=\nIERC20\n(\nunderlyingToken\n).\ntransferFrom\n(\naccount\n,\naddress\n(\nthis\n),\ncTokenRepayAmount\n);\nrequire\n(\nsuccess\n,\n\"Transfer of repayment failed\"\n);\n// Use the amount transferred to repay the borrow\n// @audit using a malicious contract, this can be a no-op\nuint\ncode\n=\nCErc20Interface\n(\ncTokenBorrow\n).\nrepayBorrowBehalf\n(\naccount\n,\ncTokenRepayAmount\n);"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 42,
    "bug_id": " H-05",
    "bug_label": " S2-1",
    "difficulty": 2,
    "bug_description": " \"Access restrictions on NotionalV1ToNotionalV2.notionalCallback can be bypassed\"",
    "line": " NotionalV1ToNotionalV2[144]",
    "url": " https://code4rena.com/reports/2021-08-notional#h-05-access-restrictions-on-notionalv1tonotionalv2notionalcallback-can-be-bypassed",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by pauliax",
      "TheNotionalV1ToNotionalV2.notionalCallbackis supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providingsender = thisassenderis a parameter of the function that can be chosen by the attacker.",
      "An attacker can call the function passing in an arbitraryaccountwhose tokens can then be stolen.\nTheaccountfirst has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.",
      "The attacker can steal the tokens by performing an attack similar to the following:",
      "first transaction is used to withdraw the victim‚Äôs funds to the contract. This can be done by choosingaccount=victim,v1RepayAmount=0,v1CollateralId=WBTC,v2CollateralId=DAI. TheNotionalV1Erc1155.batchOperationWithdraw(not part of this contest) will withdraw the victim‚Äôs funds to this contract. Note that the attacker has to deposit the samev2CollateralBalance = uint256(collateralBalance)for the victim into the V2 version, but they can choose different cheaper collateral (for example, withdraw WBTC, deposit same amount of DAI).",
      "second transaction is now used to deposit the victim funds in the contract into the user‚Äôs account. They useaccount=attacker,v1DebtCurrencyId=WBTC,v1RepayAmount=amountto deposit it into Notional V1. (They need to have a smallcollateralBalance, etc. to pass all checks).",
      "Recommend fixing the authorization check."
    ],
    "code_blocks": [
      "function\nnotionalCallback\n(\naddress\nsender\n,\naddress\naccount\n,\nbytes\ncalldata\ncallbackData\n)\nexternal\nreturns\n(\nuint256\n) {\nrequire\n(\nsender\n==\naddress\n(\nthis\n),\n\"Unauthorized callback\"\n);"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 43,
    "bug_id": " H-10",
    "bug_label": " S1-1",
    "difficulty": 1,
    "bug_description": " \"Liquidity token value can be manipulated\"",
    "line": "AssetHandler[107,114,120,151]",
    "url": " https://code4rena.com/reports/2021-08-notional#h-10-liquidity-token-value-can-be-manipulated",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "The liquidity token value (AssetHandler.getLiquidityTokenValue) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash.\nThe amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, seeAssetHandler.getCashClaims/AssetHandler.getHaircutCashClaims:",
      "This means the value depends on thecurrent market reserveswhich can be manipulated.\nYou‚Äôre essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.",
      "See the ‚ÄúHow do I tell if I‚Äôm using spot price?‚Äù sectionhere.",
      "The value of an LP token is computed asassetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) ), where(assetCashClaim, fCashClaim)depends on the current market reserves which can be manipulated by an attacker via flashloans.\nTherefore, an attacker trading large amounts in the market can either increase or decrease the value of an LP token.",
      "If the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens.\nIf the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.",
      "The exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage.\nIn constant-product AMMs like Uniswap it‚Äôs profitable and several projects have already been exploited by this, likewarp.finance.\nHowever, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles:",
      "Recommend not using the current market reserves to determine the value of LP tokens. Also, think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.",
      "T-Woodward (Notional) confirmed and disagreed with severity:",
      "ghoul-sol (judge) commented:"
    ],
    "code_blocks": [
      "// @audit token.notional are the LP tokens to redeem\nassetCash\n=\nmarket\n.\ntotalAssetCash\n.\nmul\n(\ntoken\n.\nnotional\n).\ndiv\n(\nmarket\n.\ntotalLiquidity\n);\nfCash\n=\nmarket\n.\ntotalfCash\n.\nmul\n(\ntoken\n.\nnotional\n).\ndiv\n(\nmarket\n.\ntotalLiquidity\n);"
    ],
    "quotes": [
      "However, by doing this you‚Äôre actually incorporating the spot price because you‚Äôre still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about thisfootgunin this writeup by @cmichelio.",
      "‚ÄúOracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated.‚Äù - Market.sol L424",
      "It is true that a flash loan could be used to manipulate the value of a liquidity token‚Äôs cash and fCash claims. This issue can potentially cause accounts to be liquidated which shouldn‚Äôt be, but not for the reasons stated in this issue. I‚Äôll explain what actually can go wrong, and why the fix is simple and non-invasive.First, to restate the issue: The manipulator could borrow or lend a large amount to a liquidity pool, which would change the amount of cash and fCash sitting in that pool and the corresponding cash and fCash claims of a liquidity token associated with that pool. This could change the liquidity token‚Äôs net value within the space of a transaction despite the fact that the oracleRate used to value fCash is lagged and manipulation resistant.But it is not true that this manipulation could decrease the value of a liquidity token - in fact it could only increase a liquidity token‚Äôs value. By borrowing or lending a large amount using a flash loan, the interest rate that the attacker would receive would deviate from the oracleRate in favor of the liquidity provider. If the attacker executed a large lend order, the interest rate on the loan would be significantly below the oracleRate. This would mean that the liquidity providers had borrowed at a below-market rate and that the net value of that trade would be positive for them. Conversely if the attacker executed a large borrow order, the interest rate on the loan would be significantly above the oracleRate. Again, this would mean that the net value of that trade would be positive for the liquidity providers because they would effectively be lending at an above-market rate. In either case, the value of the liquidity token would increase, not decrease.However, even though the value of a liquidity token could only increase during such an attack, the collateral value of the liquidity token could decrease once the haircuts were applied in the free collateral calculation. The reason for this is that fCash claims are effectively double-haircut (once by the liquidity token haircut and once by the fCash haircut), whereas cash claims are only haircut once (by the liquidity token haircut). This means that even though the attack would increase the value of the liquidity token without haircuts, once you consider the haircuts applied in the free collateral calculation, the collateral value of the liquidity token can be decreased and accounts could become undercollateralized and eligible for liquidation.Remediation:The immediate remediation for this issue is to restrict providing liquidity to the nToken account exclusively. In the longer term, we will plan to add TWAPs to determine the collateral value of liquidity token cash and fCash claims. This immediate remediation will be fine for now though, and will not degrade the system for two reasons:The team does not anticipate users providing liquidity directly outside of the nToken (we don‚Äôt even offer a way to do it within the UI for example). Only nToken holders receive NOTE incentives, not direct liquidity providers.The nToken accounts are safe from this attack because the maximum amount that an attacker could temporarily decrease the collateral value of liquidity tokens could never be enough to cause the nToken accounts to become undercollateralized, and therefore they would never be at risk of liquidation due to this attack. The TLDR here is that this attack can‚Äôt actually decrease the collateral value of liquidity tokens all that much, and so for an account to be vulnerable they would have to be running quite close to minimum collateralization. This will never happen for the nToken because it doesn‚Äôt borrow, it just provides liquidity and always maintains very healthy collateralization levels.",
      "Again, I gave it some thought and I think that this is high risk. Keeping as is."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 44,
    "bug_id": " H-03",
    "bug_label": " S3-1",
    "difficulty": 1,
    "bug_description": " \"setYieldSource leads to temporary wrong results\"",
    "line": "SwappableYieldSource[148,167,186,208,225,254,268]",
    "url": " https://code4rena.com/reports/2021-07-pooltogether#h-03-setyieldsource-leads-to-temporary-wrong-results",
    "title": "",
    "main_content": [
      "Submitted by gpersoon",
      "The use ofsetYieldSourceleaves the contract in a temporary inconsistent state because it changes the underlying yield source,\nbut doesn‚Äôt (yet) transfer the underlying balances, while the shares stay the same.",
      "The functionbalanceOfTokenwill show the wrong results, because it is based on_sharesToToken, which usesyieldSource.balanceOfToken(address(this)), that isn‚Äôt updated yet.",
      "More importantlysupplyTokenTowill give the wrong amount of shares back:\nFirst it supplies tokens to theyieldsource.\nThen is calls_mintShares, which calls_tokenToShares, which calculates the shares, usingyieldSource.balanceOfToken(address(this))ThisyieldSource.balanceOfToken(address(this))only contains the just supplied tokens, but doesn‚Äôt include the tokens from the previousYieldSource.\nSo the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (oncetransferFundshas been done).",
      "It is possible to make use of this problem in the following way:",
      "monitor the blockchain until you seesetYieldSourcehas been done",
      "immediately call the functionsupplyTokenTo(which can be called because there is no access control on this function)",
      "Reocommend removing the functionsetYieldSource(e.g. only leaveswapYieldSource)\nOr temporally disable actions likesupplyTokenTo,redeemTokenand balanceOfToken, aftersetYieldSourceand untiltransferFundshas been done.",
      "PierrickGT (PoolTogether) confirmed and resolved:"
    ],
    "code_blocks": [
      "// https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol\nfunction\nsetYieldSource\n(\nIYieldSource\n_newYieldSource\n)\nexternal\n`\nonlyOwnerOrAssetManager\n`\nreturns\n(\nbool\n) {\n_setYieldSource\n(\n_newYieldSource\n);\nfunction\n_setYieldSource\n(\nIYieldSource\n_newYieldSource\n)\ninternal\n{\n..\nyieldSource\n=\n_newYieldSource\n;\nfunction\nsupplyTokenTo\n(\nuint256\namount\n,\naddress\nto\n)\nexternal\noverride\nnonReentrant\n{\n..\nyieldSource\n.\nsupplyTokenTo\n(\namount\n,\naddress\n(\nthis\n));\n_mintShares\n(\namount\n,\nto\n);\n}\nfunction\n_mintShares\n(\nuint256\nmintAmount\n,\naddress\nto\n)\ninternal\n{\nuint256\nshares\n=\n`_tokenToShares`\n(\nmintAmount\n);\nrequire\n(\nshares\n>\n0\n,\n\"SwappableYieldSource/shares-gt-zero\"\n);\n_mint\n(\nto\n,\nshares\n);\n}\nfunction\n_tokenToShares\n(\nuint256\ntokens\n)\ninternal\nreturns\n(\nuint256\n) {\nuint256\nshares\n;\nuint256\n_totalSupply\n=\ntotalSupply\n();\n..\nuint256\nexchangeMantissa\n=\nFixedPoint\n.\ncalculateMantissa\n(\n_totalSupply\n,\nyieldSource\n.\nbalanceOfToken\n(\naddress\n(\nthis\n)));\n// based on incomplete yieldSource.balanceOfToken(address(this))\nshares\n=\nFixedPoint\n.\nmultiplyUintByMantissa\n(\ntokens\n,\nexchangeMantissa\n);\nfunction\nbalanceOfToken\n(\naddress\naddr\n)\nexternal\noverride\nreturns\n(\nuint256\n) {\nreturn\n_sharesToToken\n(\nbalanceOf\n(\naddr\n));\n}\nfunction\n_sharesToToken\n(\nuint256\nshares\n)\ninternal\nreturns\n(\nuint256\n) {\nuint256\ntokens\n;\nuint256\n_totalSupply\n=\ntotalSupply\n();\n..\nuint256\nexchangeMantissa\n=\nFixedPoint\n.\ncalculateMantissa\n(\nyieldSource\n.\nbalanceOfToken\n(\naddress\n(\nthis\n)),\n_totalSupply\n);\n// based on incomplete yieldSource.balanceOfToken(address(this))\ntokens\n=\nFixedPoint\n.\nmultiplyUintByMantissa\n(\nshares\n,\nexchangeMantissa\n);"
    ],
    "quotes": [
      "PR:https://github.com/pooltogether/swappable-yield-source/pull/4We‚Äôve mitigated this issue by removing thetransferFundsandsetYieldSourceexternal functions and makingswapYieldSourcecallable only by the owner that will be a multi sig wallet for governance pools."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 45,
    "bug_id": " H-01",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"CompositeMultiOracle returns wrong decimals for prices?\"",
    "line": "CompositeMultiOracle[115,125]",
    "url": " https://code4rena.com/reports/2021-08-yield#h-01-compositemultioracle-returns-wrong-decimals-for-prices",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheCompositeMultiOracle.peek/getfunctions seem to return wrong prices.\nIt‚Äôs unclear what decimalssource.decimalsrefers to in this case. Does it refer tosource.sourcetoken decimals?",
      "It chains the price arguments through_peekfunction calls and a single price is computed as:",
      "Assume all oracles use 18 decimals (oracle.decimals()returns 18) andsource.decimalsrefers to thetoken decimalsofsource.source.",
      "Then going fromUSDC -> DAI -> USDT(path = [DAI]) starts with a price of1e18inpeek:",
      "_peek(USDC, DAI, 1e18): Gets the price of1e6 USDC(as USDC has 6 decimals) in DAI with 18 decimals precision (because all oracle precision is set to 18):priceOut = priceIn * 1e18 / 1e6 = 1e18 * 1e18 / 1e6 = 1e30",
      "_peek(DAI, USDT, 1e30): Gets the price of1e18 DAI(DAI has 18 decimals) with 18 decimals precision:priceOut = priceIn * 1e18 / 1e18 = priceIn = 1e30",
      "It then uses1e30as the price to go fromUSDCtoUSDT:value = price * amount / 1e18 = 1e30 * (1.0 USDC) / 1e18 = 1e30 * 1e6 / 1e18 = 1e18 = 1e12 * 1e6 = 1_000_000_000_000.0 USDT. Inflating the actualUSDTamount.",
      "The issue is thatpeekassumes that the final price is in 18 decimals in thevalue = price * amount / 1e18division by1e18.\nBut_peek(and_get) don‚Äôt enforce this.",
      "Recommend that_peekshould scale the prices to1e18by doing:",
      "It does not need to divide by thesource.sourcetoken precision(source.decimals), but by the oracle precision (IOracle(source.source).decimals()).",
      "alcueca (Yield) acknowledged:",
      "alcueca (Yield) patched:",
      "alcueca (Yield) further patched:"
    ],
    "code_blocks": [
      "(\npriceOut\n,\nupdateTimeOut\n) =\nIOracle\n(\nsource\n.\nsource\n).\npeek\n(\nbase\n,\nquote\n,\n10\n**\nsource\n.\ndecimals\n);\n// Get price for one unit\n// @audit shouldn't this divide by 10 ** IOracle(source.source).decimals() instead?\npriceOut\n=\npriceIn\n*\npriceOut\n/ (\n10\n**\nsource\n.\ndecimals\n);",
      "(\npriceOut\n,\nupdateTimeOut\n) =\nIOracle\n(\nsource\n.\nsource\n).\nget\n(\nbase\n,\nquote\n,\n10\n**\nsource\n.\ndecimals\n);\n// priceOut will have same decimals as priceIn if we divide by oracle decimals\npriceOut\n=\npriceIn\n*\npriceOut\n/ (\n10\n**\nIOracle\n(\nsource\n.\nsource\n).\ndecimals\n());"
    ],
    "quotes": [
      "It‚Äôs confusing to deal with all these decimals, I should at least comment the code better, and try to make it easier to understand.It‚Äôs unclear what decimals source.decimals refers to in this case. Does it refer to source.source token decimals?CompositeMultiOracle takes IOracle contracts as sources, sosource.decimalsrefers to the token decimals of the oracle, not of the data source one level below.It does not need to divide by the source.source token precision (source.decimals), but by the oracle precision (IOracle(source.source).decimals()).The source.source token precision would beIChainlinkAggregatorV3(source.source()).decimals(), the source oracle precision issource.decimals(). CompositeMultiOracle cannot make an assumption on any fields present onsource.source, and must  work only with the underlyingsourceIOracles.I‚Äôm still not disputing this finding. I need to dig further to make sure the decimals are right when different IOracle sources have different decimals, and I‚Äôve hardcoded a few1e18in there. Those are code smells.",
      "Sent me into a wild goose chase to support IOracle of multiple decimals as sources to CompositeMultiOracle, only to realize that we create all IOracles and we always create them with 18 decimals, converting from the underlying data source if needed.Ended up making CompositeMultiOracle require that underlying oracles have 18 decimals.Done.",
      "Furtherrefactored all oracles so that decimals are handled properly, and work on taking an amount of base as input, and returning an amount of quote as output. Our oracles don‚Äôt have decimals themselves anymore as a state variable, since the return values are in the decimals of quote. This means that CompositeMultiOracle is agnostic with regards to decimals, and doesn‚Äôt even need to know about them."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 46,
    "bug_id": " H-02",
    "bug_label": " S3-1",
    "difficulty": 1,
    "bug_description": " \"ERC20Rewards returns wrong rewards if no tokens initially exist\"",
    "line": "ERC20Rewards[102]",
    "url": " https://code4rena.com/reports/2021-08-yield#h-02-erc20rewards-returns-wrong-rewards-if-no-tokens-initially-exist",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheERC20Rewards._updateRewardsPerTokenfunction exits without updatingrewardsPerToken_.lastUpdatediftotalSupplyis zero, i.e., if there are no tokens initially.",
      "This leads to an error if there is an active rewards period but no tokens have been minted yet.",
      "Example:rewardsPeriod.start: 1 month ago,rewardsPeriod.end: in 1 month,totalSupply == 0.",
      "The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case).",
      "_mintis called, calls_updateRewardsPerTokenwhich short-circuits.rewardsPerToken.lastUpdatedis still set torewardsPeriod.startfrom the constructor. Then_updateUserRewardsis called and does not currently yield any rewards. (because both balance and the index diff are zero). User has now minted the tokens,totalSupplyincreases and user balance is set.",
      "User performs aclaim:_updateRewardsPerTokenis called andtimeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month. Contract ‚Äúissues‚Äù rewards for the past month. The first mintee receives all of it.",
      "The first mintee receives all pending rewards when they should not receive any past rewards.\nThis can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet.\nNote thatsetRewardsalso allows setting a date in the past which would also be fatal in this case.",
      "Recommend that therewardsPerToken_.lastUpdatedfield must always be updated in_updateRewardsPerTokento the current time (orend) even if_totalSupply == 0. Don‚Äôt return early.",
      "alcueca (Yield) confirmed:",
      "alcueca (Yield) patched:"
    ],
    "code_blocks": [
      "function\nrewardPerToken\n()\npublic\nview\nreturns\n(\nuint256\n) {\nif\n(\ntotalSupply\n() ==\n0\n) {\nreturn\nrewardPerTokenStored\n;\n}"
    ],
    "quotes": [
      "You are right, that‚Äôs a great finding. For the record, I think that this is whatthis line in Unipool.soldoes:",
      "I‚Äôll apply the mitigation step suggested, with a conditional to not do therewardsPerToken_.accumulatedmath that would revert.Now I know the feeling of the devs that fork a known project and leave a pesky conditional out, thanks again :D",
      "Fix"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 47,
    "bug_id": " H-03",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"ERC20Rewards breaks when setting a different token\"",
    "line": "ERC20Rewards[74]",
    "url": " https://code4rena.com/reports/2021-08-yield#h-03-erc20rewards-breaks-when-setting-a-different-token",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "ThesetRewardsfunction allows setting a different token.\nHolders of a previous reward period cannot all be paid out and will receivetheir old reward amountin the new token.",
      "This leads to issues when the new token is more (less) valuable, or uses different decimals.",
      "Example:Assume the first reward period paid out inDAIwhich has 18 decimals. Someone would have received1.0 DAI = 1e18 DAIif they calledclaimnow. Instead, they wait until the new period starts withUSDC(using only 6 decimals) and canclaimtheir1e18reward amount in USDC which would equal1e12 USDC, one trillion USD.",
      "Changing the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.",
      "Recommend disallowing changing the reward token, or clearing user‚Äôs pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.",
      "alcueca (Yield) confirmed:",
      "alcueca (Yield) patched:"
    ],
    "code_blocks": null,
    "quotes": [
      "Maybe I should have used stronger language:// If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new tokenThe issue is known, but you are right in pointing it out. There are few situations in which changing the rewards token would make sense (such as replacing a faulty rewards token by a fixed one). I think it would be best to just disallow changing the token.",
      "Fix"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 48,
    "bug_id": " H-05",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Exchange rates from Compound are assumed with 18 decimals\"",
    "line": "CTokenMultiOracle[110]",
    "url": " https://code4rena.com/reports/2021-08-yield#h-05-exchange-rates-from-compound-are-assumed-with-18-decimals",
    "title": "",
    "main_content": [
      "Submitted by shw",
      "TheCTokenMultiOraclecontract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to theCompound documentation, the exchange rate returned from theexchangeRateCurrentfunction is scaled by1 * 10^(18 - 8 + Underlying Token Decimals)(and so doesexchangeRateStored). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens. SeeCTokenMultiOracle.sol#L110.",
      "Recommend following the documentation and getting the decimals of the underlying tokens to set the correct decimal of aSource.",
      "alcueca (Yield) confirmed:",
      "alcueca (Yield) patched:"
    ],
    "code_blocks": null,
    "quotes": [
      "Thanks a lot for coming up with this. I had looked into how Compound defined the decimals and couldn‚Äôt find it."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 49,
    "bug_id": " H-05",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"hybrid pool uses wrong non_optimal_mint_fee\"",
    "line": "HybridPool[425]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident#h-05-hybrid-pool-uses-wrong-non_optimal_mint_fee",
    "title": "",
    "main_content": [
      "Submitted by broccoli",
      "When an lp provider deposits an imbalance amount of token, a swap fee is applied.HybridPooluses the same_nonOptimalMintFeeasconstantProductPool; however, since two pools use different AMM curve, the ideal balance is not the same.  ref:StableSwap3Pool.vyL322-L337",
      "Stable swap Pools are designed for 1B+ TVL. Any issue related to pricing/fee is serious. I consider this is a high-risk issue"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "StableSwap3Pool.vy#L322-L337HybridPool.sol#L425-L441"
    ],
    "recommended_mitigation": [
      "Calculate the swapping fee based on the stable swap curve. refer toStableSwap3Pool.vy#L322-L337.",
      "maxsam4 (Sushi) confirmed"
    ]
  },
  {
    "row_number": 50,
    "bug_id": " H-08",
    "bug_label": " S6-4",
    "difficulty": 3,
    "bug_description": " \"HybridPoolÈà•Ê™ö reserve is converted to Èà•Ê∏ÅmountÈà•?twice\"",
    "line": "HybridPool[253,259]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident#h-08-hybridpools-reserve-is-converted-to-amount-twice",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by 0xsanson and WatchPug",
      "TheHybridPool‚Äôs reserves are stored as Bento ‚Äúamounts‚Äù (not Bento shares) in_updateReservesbecause_balance()converts the current share balance to amount balances.\nHowever, when retrieving thereserve0/1storage fields in_getReserves, they are converted to amounts a second time.",
      "TheHybridPoolreturns wrong reserves which affects all minting/burning and swap functions.\nThey all return wrong results making the pool eventually economically exploitable or leading to users receiving less tokens than they should."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "Imagine the current Bento amount / share price being1.5.\nThe pool‚Äôs Bentosharebalance being1000._updateReserveswill store a reserve of1.5 * 1000 = 1500.\nWhen anyone trades using theswapfunction,_getReserves()is called and multiplies it by1.5again, leading to using a reserve of 2250 instead of 1500.\nA higher reserve for the output token leads to receiving more tokens as the swap output.\nThus the pool lost tokens and the LPs suffer this loss."
    ],
    "recommended_mitigation": [
      "Make sure that the reserves are in the correct amounts.",
      "maxsam4 (Sushi) confirmed"
    ]
  },
  {
    "row_number": 51,
    "bug_id": " H-11",
    "bug_label": " S6-3",
    "difficulty": 1,
    "bug_description": " \"ConstantProductPool.burnSingle swap amount computations should use balance\"",
    "line": "ConstantProductPool[156,175], HybridPool[143,159]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident#h-11-constantproductpoolburnsingle-swap-amount-computations-should-use-balance",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheConstantProductPool.burnSinglefunction is basically aburnfollowed by aswapand must therefore act the same way as calling these two functions sequentially.",
      "The token amounts to redeem (amount0,amount1) are computed on thebalance(not the reserve).\nHowever, the swap amount is then computed on thereservesand not the balance.\nTheburnfunction would have updated thereserveto the balances and thereforebalanceshould be used here:",
      "For a burn, usually thereserveshould equal thebalance, however if any new tokens are sent to the contract andbalance > reserve, this function will return slightly less swap amounts."
    ],
    "code_blocks": [
      "amount1\n+=\n_getAmountOut\n(\namount0\n,\n_reserve0\n-\namount0\n,\n_reserve1\n-\namount1\n);"
    ],
    "quotes": ["‚ö†Ô∏è The same issue occurs in theHybridPool.burnSingle."],
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Call_getAmountOutwith the balances instead of the reserves:_getAmountOut(amount0, balance0 - amount0, balance1 - amount1)",
      "maxsam4 (Sushi) confirmed:",
      "Please bump this to High sev. This bug can actually lead to loss of funds from the pool. The author found the right issue but failed to analyze the full impact. Regardless, I think they deserve ‚ÄúHigh‚Äù for pointing this out.",
      "alcueca (judge) commented:",
      "This is what we come to C4 for"
    ]
  },
  {
    "row_number": 52,
    "bug_id": " H-14",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Incorrect usage of _pow in _computeSingleOutGivenPoolIn of IndexPool\"",
    "line": "IndexPool[268,279]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident#h-14-incorrect-usage-of-_pow-in-_computesingleoutgivenpoolin-of-indexpool",
    "title": "",
    "main_content": [
      "Submitted by broccoli",
      "The_computeSingleOutGivenPoolInfunction ofIndexPooluses the_powfunction to calculatetokenOutRatiowith the exponent inWAD(i.e., in 18 decimals of precision). However, the_powfunction assumes that the given exponentnis not inWAD. (for example,_pow(5, BASE)returns5 ** (10 ** 18)instead of5 ** 1). The misuse of the_powfunction could causes an integer overflow in the_computeSingleOutGivenPoolInfunction and thus prevent any function from calling it."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": ["Referenced code:IndexPool.sol#L279"],
    "recommended_mitigation": [
      "Change the_powfunction to the_computefunction, which supports exponents inWAD.",
      "maxsam4 (Sushi) confirmed"
    ]
  },
  {
    "row_number": 53,
    "bug_id": " H-15",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Incorrect multiplication in _computeSingleOutGivenPoolIn of IndexPool\"",
    "line": "IndexPool[268,282]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident#h-15-incorrect-multiplication-in-_computesingleoutgivenpoolin-of-indexpool",
    "title": "",
    "main_content": [
      "Submitted by broccoli",
      "The_computeSingleOutGivenPoolInfunction ofIndexPooluses the raw multiplication (i.e.,*) to calculate thezazvariable. However, since both(BASE - normalizedWeight)and_swapFeeare inWAD, the_mulfunction should be used instead to calculate the correct value ofzaz. Otherwise,zazwould be10 ** 18times larger than the expected value and causes an integer underflow when calculatingamountOut. The incorrect usage of multiplication prevents anyone from calling the function successfully."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": ["Referenced code:IndexPool.sol#L282"],
    "recommended_mitigation": [
      "Change(BASE - normalizedWeight) * _swapFeeto_mul((BASE - normalizedWeight), _swapFee).",
      "maxsam4 (Sushi) confirmed"
    ]
  },
  {
    "row_number": 54,
    "bug_id": " H-01",
    "bug_label": " S6-3",
    "difficulty": 1,
    "bug_description": " \"Controller.setCap sets wrong vault balance\"",
    "line": "Controller[242]",
    "url": " https://code4rena.com/reports/2021-09-yaxis#h-01-controllersetcap-sets-wrong-vault-balance",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheController.setCapfunction sets a cap for a strategy and withdraws any excess amounts (_diff).\nThe vault balance is decreased by the entire strategy balance instead of by this_diff:",
      "The_vaultDetails[_vault].balancevariable does not correctly track the actual vault balances anymore, it will usuallyunderestimatethe vault balance.\nThis variable is used inController.balanceOf(), which in turn is used inVault.balance(), which in turn is used to determine how many shares to mint / amount to receive when redeeming shares.\nIf the value is less, users will lose money as they can redeem fewer tokens.\nAlso, an attacker candepositand will receive more shares than they should receive. They can then wait until the balance is correctly updated again and withdraw their shares for a higher amount than they deposited. This leads to the vault losing tokens."
    ],
    "code_blocks": [
      "// @audit why not sub _diff?\n_vaultDetails\n[\n_vault\n].\nbalance\n=\n_vaultDetails\n[\n_vault\n].\nbalance\n.\nsub\n(\n_balance\n);"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Sub the_diffinstead of thebalance:_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);",
      "Haz077 (yAxis) confirmed and patched:",
      "Already fixed in code-423n4/2021-09-yaxis#1",
      "GalloDaSballo (judge) commented:",
      "Finding is valid, has been mitigated by sponsor as of 14 days ago"
    ]
  },
  {
    "row_number": 55,
    "bug_id": " H-07",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Vault.balance() mixes normalized and standard amounts\"",
    "line": "Vault[303,315,323]",
    "url": " https://code4rena.com/reports/2021-09-yaxis#h-07-vaultbalance-mixes-normalized-and-standard-amounts",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheVault.balancefunction uses thebalanceOfThisfunction which scales (‚Äúnormalizes‚Äù) all balances to 18 decimals.",
      "Note thatbalance()‚Äôs second termIController(manager.controllers(address(this))).balanceOf()is not normalized.\nThe code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).",
      "The result is that thebalance()will be under-reported.\nThis leads to receiving wrong shares whendepositing tokens, and a wrong amount when redeemingtokens."
    ],
    "code_blocks": [
      "for\n(\nuint8\ni\n;\ni\n<\n_tokens\n.\nlength\n;\ni\n++) {\naddress\n_token\n=\n_tokens\n[\ni\n];\n// everything is padded to 18 decimals\n_balance\n=\n_balance\n.\nadd\n(\n_normalizeDecimals\n(\n_token\n,\nIERC20\n(\n_token\n).\nbalanceOf\n(\naddress\n(\nthis\n))));\n}"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "The second termIController(manager.controllers(address(this))).balanceOf()must also be normalized before adding it.IController(manager.controllers(address(this))).balanceOf()uses_vaultDetails[msg.sender].balancewhich directly uses the raw token amounts which are not normalized.",
      "GainsGoblin (yAxis) acknowledged",
      "GalloDaSballo (judge) commented:",
      "balanceandbalanceOfThismixes the usage of decimals by alternatingly using_normalizeDecimalsThis can break accounting as well as create opportunities for abuse\nA consistent usage of_normalizeDecimalswould mitigate",
      "BobbyYaxis (yAxis) noted:",
      "Mitigated in PR 114:https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b"
    ]
  },
  {
    "row_number": 56,
    "bug_id": " H-08",
    "bug_label": " S6-4",
    "difficulty": 3,
    "bug_description": " \"Vault.withdraw mixes normalized and standard amounts\"",
    "line": "Vault[249,231,303,315,323]",
    "url": " https://code4rena.com/reports/2021-09-yaxis#h-08-vaultwithdraw-mixes-normalized-and-standard-amounts",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by hickuphh3 and jonah1005",
      "TheVault.balancefunction uses thebalanceOfThisfunction which scales (‚Äúnormalizes‚Äù) all balances to 18 decimals.",
      "Note thatbalance()‚Äôs second termIController(manager.controllers(address(this))).balanceOf()is not normalized, but it must be.",
      "This leads to many issues through the contracts that usebalancebut don‚Äôt treat these values as normalized values.\nFor example, inVault.withdraw, the computed_amountvalue is normalized (in 18 decimals).\nBut theuint256 _balance = IERC20(_output).balanceOf(address(this));value is not normalized but compared to the normalized_amountand even subtracted:",
      "Imagine inwithdraw, theoutputis USDC with 6 decimals, then the normalized_toWithdrawwith 18 decimals (due to using_amount) will be a huge number and attempt to withdraw an inflated amount.\nAn attacker can steal tokens this way by withdrawing a tiny amount of shares and receive an inflated USDC or USDT amount (or any_outputtoken with less than 18 decimals)."
    ],
    "code_blocks": [
      "for\n(\nuint8\ni\n;\ni\n<\n_tokens\n.\nlength\n;\ni\n++) {\naddress\n_token\n=\n_tokens\n[\ni\n];\n// everything is padded to 18 decimals\n_balance\n=\n_balance\n.\nadd\n(\n_normalizeDecimals\n(\n_token\n,\nIERC20\n(\n_token\n).\nbalanceOf\n(\naddress\n(\nthis\n))));\n}",
      "// @audit compares unnormalzied output to normalized output\nif\n(\n_balance\n<\n_amount\n) {\nIController\n_controller\n=\nIController\n(\nmanager\n.\ncontrollers\n(\naddress\n(\nthis\n)));\n// @audit cannot directly subtract unnormalized\nuint256\n_toWithdraw\n=\n_amount\n.\nsub\n(\n_balance\n);\nif\n(\n_controller\n.\nstrategies\n() >\n0\n) {\n_controller\n.\nwithdraw\n(\n_output\n,\n_toWithdraw\n);\n}\nuint256\n_after\n=\nIERC20\n(\n_output\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\n_diff\n=\n_after\n.\nsub\n(\n_balance\n);\nif\n(\n_diff\n<\n_toWithdraw\n) {\n_amount\n=\n_balance\n.\nadd\n(\n_diff\n);\n}\n}"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Whenever using anything involvingvault.balanceOfThis()orvault.balance()one needs to be sure that any derived token amount needs to be denormalized again before using them.",
      "GalloDaSballo (judge) commented:",
      "An inconsistent usage of_normalizeDecimalswill cause accounting issues and potentially paths for an exploit",
      "BobbyYaxis (yAxis) noted:",
      "Mitigated in PR 114:https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b"
    ]
  },
  {
    "row_number": 57,
    "bug_id": " H-01",
    "bug_label": " S6-4",
    "difficulty": 2,
    "bug_description": " \"veCVXStrategy.manualRebalance has wrong logic\"",
    "line": "veCVXStrategy[444,468,471,477]",
    "url": " https://code4rena.com/reports/2021-09-bvecvx#h-01-vecvxstrategymanualrebalance-has-wrong-logic",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by tabish",
      "TheveCVXStrategy.manualRebalancefunction computes two ratioscurrentLockRatioandnewLockRatioand compares them.",
      "However, these ratios compute different things and are not comparable:",
      "currentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance)is apercentage valuewith 18 decimals (i.e.1e18 = 100%). Its max value can at most be1e18.",
      "newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS)is aCVX token amount. It‚Äôs unbounded and just depends on thetotalCVXBalanceamount.",
      "The comparison that follows does not make sense:",
      "The rebalancing is broken and does not correctly rebalance. It usually leads to locking nearly everything iftotalCVXBalanceis high."
    ],
    "code_blocks": [
      "if\n(\nnewLockRatio\n<=\ncurrentLockRatio\n) {\n// ...\n}"
    ],
    "quotes": null,
    "proof_of_concept": ["sol#L444L453"],
    "recommended_mitigation": [
      "Judging from the cvxToLock = newLockRatio.sub(currentLockRatio) it seems the desired computation is that the ‚Äúratios‚Äù should actually be in CVX amounts and not in percentages. Therefore, currentLockRatio should just be balanceInLock. (The variables should be renamed as they aren‚Äôt really ratios but absolute CVX balance amounts.)"
    ]
  },
  {
    "row_number": 58,
    "bug_id": " H-01",
    "bug_label": " S6-3",
    "difficulty": 2,
    "bug_description": " \"Use of tokenBÈà•Ê™ö price instead of tokenA in determining account health will lead to protocol mis-accounting and insolvency\"",
    "line": "LendingPair[119,266,289,340,398,532,544,674]",
    "url": " https://code4rena.com/reports/2021-09-wildcredit#h-01-use-of-tokenbs-price-instead-of-tokena-in-determining-account-health-will-lead-to-protocol-mis-accounting-and-insolvency",
    "title": "",
    "main_content": [
      "Submitted by 0xRajeev, also found by WatchPug.",
      "In_supplyCreditUni(), the last argument of_convertTokenValues()onL674 being _priceBinstead of_priceAin the calculation ofsupplyBis a typo (should be_priceA) and therefore miscalculatessupplyB,creditB,creditUniand thereforetotalAccountSupplyin functionaccountHealth()which affects the health of account/protocol determination that is used across all borrows/withdrawals/transfers/liquidations in the protocol. This miscalculation significantly affects all calculations in protocol and could therefore cause protocol insolvency.",
      "Manual Analysis"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L674https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L340https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L398-L401https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L532https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L544https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L119https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L266https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L289"
    ],
    "recommended_mitigation": [
      "Change the last argument of\\_convertTokenValues()from\\_priceBto\\_priceAon L674.",
      "talegift (Wild Credit) confirmed"
    ]
  },
  {
    "row_number": 59,
    "bug_id": " H-01",
    "bug_label": " S6-4",
    "difficulty": 2,
    "bug_description": " \"The formula of number of prizes for a degree is wrong\"",
    "line": "DrawCalculator[423]",
    "url": " https://code4rena.com/reports/2021-10-pooltogether#h-01-the-formula-of-number-of-prizes-for-a-degree-is-wrong",
    "title": "",
    "main_content": [
      "Submitted by WatchPug, also found by cmichel.",
      "The formula of the number of prizes for a degree per the document:https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizesis:",
      "Should be changed to:",
      "or",
      "Per the document:",
      "Due to the miscalculation ofnumber of prizes for a degree, it will be smaller than expected, as a result,prize for a degreewill be larger than expected. Making the protocol giving out more prizes than designed.",
      "Because2^x = 1 << x",
      "Therefore, whenn > 0:",
      "QED.",
      "By definition,degree nis constructed by 3 chunks:",
      "The first N numbers, must equal the matching numbers. Number of possible values:1;",
      "The N-th number, must not equal the N-th matching number. Number of possible values:2^bitRange - 1",
      "From N (not include) until the end. Number of possible values:2 ^ (bitRange * (n-1))",
      "Therefore, totalnumberOfPrizesForDegreewill be:",
      "QED.",
      "https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431",
      "L423-431 should change to:",
      "BTW, the comment on L416 is wrong:",
      "seems like it‚Äôs copied from\\_calculatePrizeTierFraction()",
      "plus, it‚Äôs not base 1e18 but base 1e9",
      "PierrickGT (PoolTogether) confirmed and patched:",
      "Alex the Entreprenerd (judge) commented:"
    ],
    "code_blocks": [
      "Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) - (2^bit range)^(degree-2) - ...",
      "Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1)",
      "Number of prizes for a degree = 2^(bit range * degree) - 2^(bit range * (degree-1))",
      "2 ^ {bitRange \\times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\nf(bitRange, n) = 2 ^ {bitRange \\times n} - ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\nf(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\nBecause:\n2 ^ {bitRange \\times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\n2 ^ {bitRange \\times (n-1)} - f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\nTherefore:\nf(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - ( 2 ^ {bitRange \\times (n-1)} - f(bitRange, n-1) )\nf(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - 2 ^ {bitRange \\times (n-1)} + f(bitRange, n-1)\nf(bitRange, n) = 2 ^ {bitRange \\times n} - 2 ^ {bitRange \\times (n-1)}",
      "f(bitRange, n) = ( 1 << bitRange * n ) - ( 1 << bitRange * (n - 1) )",
      "f(bitRange, n) = (2 ^ {bitRange} - 1) \\times 2 ^ {bitRange \\times (n - 1)}\nf(bitRange, n) = 2 ^ {bitRange} \\times 2 ^ {bitRange \\times (n - 1)} - 2 ^ {bitRange \\times (n - 1)}\nf(bitRange, n) = 2 ^ {bitRange + bitRange \\times (n - 1)} - 2 ^ {bitRange \\times (n - 1)}\nf(bitRange, n) = 2 ^ {bitRange + bitRange \\times n - bitRange} - 2 ^ {bitRange \\times (n - 1)}\nf(bitRange, n) = 2 ^ {bitRange \\times n} - 2 ^ {bitRange \\times (n - 1)}",
      "/**\n*\n@notice\nCalculates the number of prizes for a given prizeDistributionIndex\n*\n@param\n_bitRangeSize\nBit range size for Draw\n*\n@param\n_prizeTierIndex\nIndex of the prize tier array to calculate\n*\n@return\nreturns the fraction of the total prize (base 1e18)\n*/\nfunction\n_numberOfPrizesForIndex\n(\nuint8\n_bitRangeSize\n,\nuint256\n_prizeTierIndex\n)\ninternal\npure\nreturns\n(\nuint256\n)\n{\nuint256\nbitRangeDecimal\n=\n2\n**\nuint256\n(\n_bitRangeSize\n);\nuint256\nnumberOfPrizesForIndex\n=\nbitRangeDecimal\n**\n_prizeTierIndex\n;\nwhile\n(\n_prizeTierIndex\n>\n0\n) {\nnumberOfPrizesForIndex\n-=\nbitRangeDecimal\n**(\n_prizeTierIndex\n-\n1\n);\n_prizeTierIndex\n--;\n}\nreturn\nnumberOfPrizesForIndex\n;\n}",
      "if\n(\n_prizeTierIndex\n>\n0\n) {\nreturn\n(\n1\n<<\n_bitRangeSize\n*\n_prizeTierIndex\n) - (\n1\n<<\n_bitRangeSize\n* (\n_prizeTierIndex\n-\n1\n) );\n}\nelse\n{\nreturn\n1\n;\n}"
    ],
    "quotes": [
      "prize for a degree = total prize * degree percentage / number of prizes for a degree",
      "We will usef(bitRange, degree)to representnumberOfPrizesForDegree(bitRangeSize, degree).",
      "PR:https://github.com/pooltogether/v4-core/pull/242",
      "The warden found the usage of an incorrect formula that would cause the protocol to give out larger prizes than expected, the sponsor has mitigated in a following PR"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 60,
    "bug_id": " H-03",
    "bug_label": " S3-1",
    "difficulty": 5,
    "bug_description": " \"ConcentratedLiquidityPoolManagerÈà•Ê™ö incentives can be stolen\"",
    "line": "ConcentratedLiquidityPoolManager[49]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident-2#h-03-concentratedliquiditypoolmanagers-incentives-can-be-stolen",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by broccoli, hickuphh3, pauliax, and WatchPug",
      "TheConcentratedLiquidityPoolManagerkeeps all tokens for all incentives in the same contract. ThereclaimIncentivefunction does not reduce theincentive.rewardsUnclaimedfield and thus one can reclaim tokens several times.\nThis allows anyone to steal all tokens from all incentives by creating an incentive themself, and once it‚Äôs expired, repeatedly claim the unclaimed rewards until the token balance is empty.",
      "An attacker can steal all tokens in thePoolManager."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "Attacker creates an incentive for a non-existent pool using a random address forpool(This is done such that no other user can claim rewards as we need a non-zerorewardsUnclaimedbalance for expiry). They choose theincentive.tokento be the token they want to steal from other incentives. (for example,WETH,USDC, orSUSHI) They choose thestartTime, endTime, expirysuch that the checks pass, i.e., starting and ending in a few seconds from now, expiring in 5 weeks. Then they choose a non-zerorewardsUnclaimedand transfer theincentive.tokento thePoolManager.Attacker waits for 5 weeks until the incentive is expiredAttacker can now callreclaimIncentive(pool, incentiveId, amount=incentive.rewardsUnclaimed, attacker, false)to withdrawincentive.rewardsUnclaimedofincentive.tokenfrom the pool manager.As theincentive.rewardsUnclaimedvariable has not been decreased, they can keep callingreclaimIncentiveuntil the pool is drained."
    ],
    "recommended_mitigation": [
      "InreclaimIncentive, reduceincentive.rewardsUnclaimedby the withdrawnamount.",
      "sarangparikh22 (Sushi) confirmed"
    ]
  },
  {
    "row_number": 61,
    "bug_id": " H-08",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"Wrong inequality when adding/removing liquidity in current price range\"",
    "line": "ConcentratedLiquidityPool[141,176,231,242]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident-2#h-08-wrong-inequality-when-addingremoving-liquidity-in-current-price-range",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheConcentratedLiquidityPool.mint/burnfunctions add/removeliquiditywhen(priceLower < currentPrice && currentPrice < priceUpper).\nShouldn‚Äôt it also be changed ifpriceLower == currentPrice?",
      "Pools that mint/burn liquidity at a time where thecurrentPriceis right at the lower price range do not work correctly and will lead to wrong swap amounts."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Change the inequalities toif (priceLower <= currentPrice && currentPrice < priceUpper).",
      "sarangparikh22 (Sushi) disputed:",
      "You shouldn‚Äôt be able to reach this, can you produce a POC?",
      "alcueca (judge) commented:",
      "@sarangparikh22 (Sushi), could you please elaborate on why this is not reachable?",
      "sarangparikh22 (Sushi) confirmed:",
      "I confused this with another similar issue, my apologies, took a look at this, and this a valid issue, we should probably even bump the severity to Sev 3, not sure if I am allowed to do so haha, I created a PoC in which users can actually loose funds, when they add liquidity in that specific range. @alcueca (judge)",
      "alcueca (judge) commented:",
      "Sponsors are allowed to bump up severity, and I‚Äôve done it myself in my past as a sponsor as well."
    ]
  },
  {
    "row_number": 62,
    "bug_id": " H-10",
    "bug_label": " S6-3",
    "difficulty": 1,
    "bug_description": " \"ConcentratedLiquidityPool.burn() Wrong implementation\"",
    "line": "ConcentratedLiquidityPool[231,263]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident-2#h-10-concentratedliquiditypoolburn-wrong-implementation",
    "title": "",
    "main_content": [
      "Submitted by WatchPug",
      "The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool.",
      "However, the current implementation only updated reserves with the fees subtracted.",
      "Makes thereserve0andreserve1smaller than the currentbalance0andbalance1.",
      "As a result, many essential features of the contract will malfunction, includesswap()andmint()."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "ConcentratedLiquidityPool.sol#L263L267Change:",
      "unchecked\n{\nreserve0\n-=\nuint128\n(\namount0fees\n);\nreserve1\n-=\nuint128\n(\namount1fees\n);\n}",
      "to:",
      "unchecked\n{\nreserve0\n-=\nuint128\n(\namount0\n);\nreserve1\n-=\nuint128\n(\namount1\n);\n}",
      "sarangparikh22 (Sushi) confirmed"
    ]
  },
  {
    "row_number": 63,
    "bug_id": " H-11",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"ConcentratedLiquidityPool: incorrect feeGrowthGlobal accounting when crossing ticks\"",
    "line": "ConcentratedLiquidityPool[305,511], Ticks[23,32]",
    "url": " https://code4rena.com/reports/2021-09-sushitrident-2#h-11-concentratedliquiditypool-incorrect-feegrowthglobal-accounting-when-crossing-ticks",
    "title": "",
    "main_content": [
      "Submitted by hickuphh3",
      "Swap fees are taken from the output. Hence, if swapping token0 for token1 (zeroForOneis true), then fees are taken in token1. We see this to be the case in the initialization offeeGrowthGlobalin the swap cache",
      "feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0;",
      "and in_updateFees().",
      "However, looking atTicks.cross(), the logic is the reverse, which causes wrong fee accounting.",
      "Switch the0and1inTicks.cross().",
      "sarangparikh22 (Sushi) confirmed"
    ],
    "code_blocks": [
      "if\n(\nzeroForOne\n) {\n...\nticks\n[\nnextTickToCross\n].\nfeeGrowthOutside0\n=\nfeeGrowthGlobal\n-\nticks\n[\nnextTickToCross\n].\nfeeGrowthOutside0\n;\n}\nelse\n{\n...\nticks\n[\nnextTickToCross\n].\nfeeGrowthOutside1\n=\nfeeGrowthGlobal\n-\nticks\n[\nnextTickToCross\n].\nfeeGrowthOutside1\n;\n}",
      "if\n(\nzeroForOne\n) {\n...\n// `feeGrowthGlobal` = feeGrowthGlobal1\nticks\n[\nnextTickToCross\n].\nfeeGrowthOutside1\n=\nfeeGrowthGlobal\n-\nticks\n[\nnextTickToCross\n].\nfeeGrowthOutside1\n;\n}\nelse\n{\n...\n// feeGrowthGlobal = feeGrowthGlobal0\nticks\n[\nnextTickToCross\n].\nfeeGrowthOutside0\n=\nfeeGrowthGlobal\n-\nticks\n[\nnextTickToCross\n].\nfeeGrowthOutside0\n;\n}"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 64,
    "bug_id": " H-12",
    "bug_label": " S6-1",
    "difficulty": 1,
    "bug_description": " \"ConcentratedLiquidityPool: secondsPerLiquidity should be modified whenever pool liquidity changes\"",
    "line": "ConcentratedLiquidityPool[495,552],",
    "url": " https://code4rena.com/reports/2021-09-sushitrident-2#h-12-concentratedliquiditypool-secondsperliquidity-should-be-modified-whenever-pool-liquidity-changes",
    "title": "",
    "main_content": [
      "Submitted by hickuphh3",
      "secondsPerLiquidityis updated as such:secondsPerLiquidity += uint160((diff << 128) / liquidity);wherediff = timestamp - uint256(lastObservation). Hence, whenever liquidity changes,secondsPerLiquidityshould be updated prior to the change.",
      "In particular, this affects themint()andburn()functions, in the case where liquidity changes whenlowerTick <= currentTick < upperTick.",
      "In fact, the latestsecondsPerLiquidityvalue should be calculated and used inTicks.insert(). For comparison, notice how UniswapV3 fetches the latest value by callingobservations.observeSingle()in its_updatePosition()function.",
      "ThesecondsPerLiquidityincrement logic should be applied prior to liquidity addition inmint()and removal inburn().",
      "sarangparikh22 (Sushi) disputed:",
      "alcueca (judge) commented:",
      "sarangparikh22 (Sushi) confirmed:"
    ],
    "code_blocks": [
      "// insert logic before these lines in mint()\nunchecked\n{\nif\n(\npriceLower\n<\ncurrentPrice\n&&\ncurrentPrice\n<\npriceUpper\n)\nliquidity\n+=\nuint128\n(\n_liquidity\n);\n}\nnearestTick\n=\nTicks\n.\ninsert\n(\nticks\n,\nfeeGrowthGlobal0\n,\nfeeGrowthGlobal1\n,\nsecondsPerLiquidity\n,\n// should calculate and use latest secondsPerLiquidity value\n...\n);\n// insert logic before before these lines in burn()\nunchecked\n{\nif\n(\npriceLower\n<\ncurrentPrice\n&&\ncurrentPrice\n<\npriceUpper\n)\nliquidity\n-=\namount\n;\n}"
    ],
    "quotes": [
      "The secondsPerLiquidity is same, changing the order of that will not affect anything, since it is not getting calculated at the mint or burn function.",
      "@sarangparikh22 (Sushi), could you please elaborate on why this isn‚Äôt an issue?",
      "@alcueca (judge) my apologies, this is an issue. I could confirm this."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": null
  },
  {
    "row_number": 65,
    "bug_id": " H-02",
    "bug_label": " S3-1",
    "difficulty": 1,
    "bug_description": " \"Basket.sol#auctionBurn() A failed auction will freeze part of the funds\"",
    "line": "Basket[102]",
    "url": " https://code4rena.com/reports/2021-09-defiprotocol#h-02-basketsolauctionburn-a-failed-auction-will-freeze-part-of-the-funds",
    "title": "",
    "main_content": [
      "Submitted by WatchPug",
      "https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L102-L108",
      "Given theauctionBurn()function will_burn()the auction bond without updating theibRatio. Once the bond of a failed auction is burned, the proportional underlying tokens won‚Äôt be able to be withdrawn, in other words, being frozen in the contract."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "With the configuration of:",
      "basket.ibRatio = 1e18\nfactory.bondPercentDiv = 400\nbasket.totalSupply = 400\nbasket.tokens = [BTC, ETH]\nbasket.weights = [1, 1]",
      "Create an auction;Bond with 1 BASKET TOKEN;Wait for 24 hrs and callauctionBurn();",
      "basket.ibRatioremains to be 1e18; basket.totalSupply = 399.",
      "Burn 1 BASKET TOKEN will only get back 1 BTC and 1 ETH, which means, there are 1 BTC and 1 ETH frozen in the contract."
    ],
    "recommended_mitigation": [
      "Change to:",
      "function\nauctionBurn\n(\nuint256\namount\n)\nonlyAuction\nexternal\noverride\n{\nhandleFees\n();\nuint256\nstartSupply\n=\ntotalSupply\n();\n_burn\n(\nmsg\n.\nsender\n,\namount\n);\nuint256\nnewIbRatio\n=\nibRatio\n*\nstartSupply\n/ (\nstartSupply\n-\namount\n);\nibRatio\n=\nnewIbRatio\n;\nemit\nNewIBRatio\n(\nnewIbRatio\n);\nemit\nBurned\n(\nmsg\n.\nsender\n,\namount\n);\n}",
      "frank-beard (Kuiper) confirmed",
      "Alex the Entreprenerd (judge) commented:",
      "The warden has identified a way for funds to be stuck without a way to recoup them, this is becauseibRatiois not updated, whiletotalSupplyis.Because this is a specific accounting error, which is effectively a bug in the logic of the protocol, and funds can be irrevocably lost, this is a high severity finding"
    ]
  },
  {
    "row_number": 66,
    "bug_id": " H-03",
    "bug_label": " S2-3",
    "difficulty": 2,
    "bug_description": " \"Signature replay attacks for different identities (nonce on wrong party)\"",
    "line": "QuickAccManager[37]",
    "url": " https://code4rena.com/reports/2021-10-ambire#h-03-signature-replay-attacks-for-different-identities-nonce-on-wrong-party",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by WatchPug",
      "A singleQuickAccountcan serve as the ‚Äúprivilege‚Äù for multiple identities, see the comment inQuickAccManager.sol:",
      "If there exist two different identities thatboth share the same QuickAccount(identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash) the following attack is possible inQuickAccManager.send:",
      "Upon observing a validsendon the first identity, the same transactions can be replayed on the second identity by an attacker callingsendwith the same arguments and just changing theidentityto the second identity.",
      "This is because theidentityis not part of thehash. Including thenonce ofthe identity in the hash is not enough.",
      "Two fresh identities will both take on nonces on zero and lead to the same hash.",
      "Transactions on one identity can be replayed on another one if it uses the sameQuickAccount.\nFor example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.",
      "This issue of using the wrong nonce (on theidentitywhich means the nonces repeat per identity) and not includingidentityaddress leads to other attacks throughout theQuickAccManager:",
      "cancel: attacker can use the same signature to cancel the same transactions on the second identity",
      "execScheduled: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail asscheduled[hash]is deleted.",
      "sendTransfer: same transfers can be replayed on second identity",
      "sendTxns: same transactions can be replayed on second identity",
      "Ivshti (Ambire) confirmed:",
      "Ivshti (Ambire) patched:",
      "GalloDaSballo (judge) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "NOTE: a single accHash can control multiple identities, as long as those identities set it‚Äôs hash in privileges[address(this)]. this is by design",
      "duplicate of #24, but it‚Äôs better documented",
      "mitigation step 1 is not going to be done, since there‚Äôs already plenty of upper level code relying on indexing by identity, and it doesn‚Äôt really hurt if the replay attack is mitigatedplus, it makes it harder to look up the nonce value, as we have to compute the accHash in the client-side codethe replay attack has been fixed herehttps://github.com/AmbireTech/adex-protocol-eth/commit/f70ca38f368da30c9881d1ee5554fd0161c94486",
      "The warden identified a Signature Replay attack, allowing to re-use a signature throughout the system.Requiring the identity to be part of the signatures mitigates the vulnerabilityThe sponsor has mitigated in a subsequent PR"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Nonces should not be indexed by the identity but by theaccHash. This is because nonces are used to stop replay attacks and thus need to be on thesigner(QuickAccountin this case), not on the target contract to call.Theidentityaddressitself needs to be part ofhashas otherwise thesendcan be frontrun and executed by anyone on the other identity by switching out theidentityparameter."
    ]
  },
  {
    "row_number": 67,
    "bug_id": " H-02",
    "bug_label": " S6-4",
    "difficulty": 2,
    "bug_description": " \"Swivel: Taker is charged fees twice in exitVaultFillingVaultInitiate\"",
    "line": "Swivel[268]",
    "url": " https://code4rena.com/reports/2021-09-swivel#h-02-swivel-taker-is-charged-fees-twice-in-exitvaultfillingvaultinitiate",
    "title": "",
    "main_content": [
      "Submitted by itsmeSTYJ, also found by gpersoon.",
      "Taker is charged fees twice inexitVaultFillingVaultInitiate(). Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker‚Äôs net balance is premiumFilled - 2*fee"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "function\nexitVaultFillingVaultInitiate\n(Hash.Order\ncalldata\no\n,\nuint256\na\n, Sig.Components\ncalldata\nc\n)\ninternal\n{\nbytes32\nhash\n=\nvalidOrderHash\n(\no\n,\nc\n);\nrequire\n(\na\n<= (\no\n.\nprincipal\n-\nfilled\n[\nhash\n]),\n'taker amount > available volume'\n);\nfilled\n[\nhash\n] +=\na\n;\nuint256\npremiumFilled\n= (((\na\n*\n1e18\n) /\no\n.\nprincipal\n) *\no\n.\npremium\n) /\n1e18\n;\nuint256\nfee\n= ((\npremiumFilled\n*\n1e18\n) /\nfenominator\n[\n3\n]) /\n1e18\n;\nErc20\nuToken\n=\nErc20\n(\no\n.\nunderlying\n);\n// transfer premium from maker to sender\nuToken\n.\ntransferFrom\n(\no\n.\nmaker\n,\nmsg\n.\nsender\n,\npremiumFilled\n);\n// transfer fee in underlying to swivel from sender\nuToken\n.\ntransferFrom\n(\nmsg\n.\nsender\n,\naddress\n(\nthis\n),\nfee\n);\n// transfer <a> vault.notional (nTokens) from sender to maker\nrequire\n(\nMarketPlace\n(\nmarketPlace\n).\np2pVaultExchange\n(\no\n.\nunderlying\n,\no\n.\nmaturity\n,\nmsg\n.\nsender\n,\no\n.\nmaker\n,\na\n),\n'vault exchange failed'\n);\nemit\nExit\n(\no\n.\nkey\n,\nhash\n,\no\n.\nmaker\n,\no\n.\nvault\n,\no\n.\nexit\n,\nmsg\n.\nsender\n,\na\n,\npremiumFilled\n);\n}",
      "JTraversa (Swivel) confirmed",
      "0xean (judge) commented:",
      "Based on3 ‚Äî High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).This is being upgraded to a high risk. The duplicate of it was at that level by the submitting warden and considering that fees are being incorrectly taken from the taker and not the maker, the maker ends up with a higher balance than expected and the taker has no way to recoup these fees (assets are now lost).",
      "JTraversa (Swivel) commented:",
      "Is that how it is interpreted? I‚Äôd assume that high risk would imply a valid attack path that a user could use to drain deposited funds based on that description.I won‚Äôt fight this one obviously, just think there‚Äôs acleardifferentiation between this and the other high risk issue."
    ]
  },
  {
    "row_number": 68,
    "bug_id": " H-01",
    "bug_label": " S6-3",
    "difficulty": 2,
    "bug_description": " \"Vault fails to track debt correctly that leads to bad debt\"",
    "line": "MochiVault[242]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-01-vault-fails-to-track-debt-correctly-that-leads-to-bad-debt",
    "title": "",
    "main_content": [
      "Submitted by jonah1005, also found by WatchPug",
      "It‚Äôs similar to the issue ‚Äúmisuse amount as increasing debt in the vault contract‚Äù.\nSimilar issue in a different place that leads to different exploit patterns and severity.",
      "When users borrow usdm from a vault, the debt increases by the amount * 1.005.",
      "However, when the contract records the total debt it uses_amountinstead ofincreasingDebt.",
      "MochiVault.sol L242-L249",
      "The contract‚Äôs debt is inconsistent with the total sum of all users‚Äô debt. The bias increases overtime and would break the vault at the end.",
      "For simplicity, we assume there‚Äôs only one user in the vault.\nExample:",
      "User deposits 1.2 M worth of BTC and borrows 1M USDM.",
      "The user‚Äôs debt (details[_id].debt) would be 1.005 M as there‚Äôs a .5 percent fee.",
      "The contract‚Äôs debt is 1M.",
      "BTC price decrease by 20 percent",
      "The liquidator tries to liquidate the position.",
      "The liquidator repays 1.005 M and the contract tries to sub the debt by 1.005 M",
      "The transaction is reverted asdetails[_id].debt -= _usdm;would raise exception.",
      "inaccurate accounting would lead to serious issues. I consider this a high-risk issue."
    ],
    "code_blocks": [
      "uint256\nincreasingDebt\n= (\n_amount\n*\n1005\n) /\n1000\n;",
      "details\n[\n_id\n].\ndebtIndex\n=\n(\ndetails\n[\n_id\n].\ndebtIndex\n* (\ntotalDebt\n)) /\n(\ndetails\n[\n_id\n].\ndebt\n+\n_amount\n);\ndetails\n[\n_id\n].\ndebt\n=\ntotalDebt\n;\ndetails\n[\n_id\n].\nstatus\n=\nStatus\n.\nActive\n;\ndebts\n+=\n_amount\n;"
    ],
    "quotes": null,
    "proof_of_concept": [
      "This is a web3.py script that a liquidation may fail.",
      "deposit_amount =\n10\n**\n18\nbig_deposit = deposit_amount *\n100000\nminter.functions.mint(user, big_deposit).transact()\ndai.functions.approve(vault.address, big_deposit + deposit_amount).transact()\n# create two positions\nvault.functions.mint(user, zero_address).transact()\nvault.functions.mint(user, zero_address).transact()\n# # borrow max amount\nvault.functions.increase(\n0\n, big_deposit, big_deposit, zero_address,\n''\n).transact()\nvault.functions.increase(\n1\n, deposit_amount, deposit_amount, zero_address,\n''\n).transact()\nvault_debt = vault.functions.debts().call()\n# ## This would clear out all debt in vault.\nrepay_amount = vault_debt +\n10\n**\n18\nusdm.functions.approve(vault.address, repay_amount).transact()\nvault.functions.repay(\n0\n, repay_amount).transact()\nprint\n(\n'debt left:'\n, vault.functions.debts().call())\n# ## All the positions would not be liquidated from now on\ndai_price = cssr_factory.functions.getPrice(dai.address).call()\ncssr_factory.functions.setPrice(dai.address, dai_price[\n0\n] //\n10\n).transact()\n## this would revert\nliquidator.functions.triggerLiquidation(dai.address,\n1\n).transact()"
    ],
    "recommended_mitigation": [
      "I believe this is a mistake. Recommend to check the contract to make sureincreasingDebtis used consistently."
    ]
  },
  {
    "row_number": 69,
    "bug_id": " H-04",
    "bug_label": " S2-1",
    "difficulty": 3,
    "bug_description": " \"registerAsset() can overwrite _assetClass value\"",
    "line": "MochiProfileV0[58,61,105,129,148,176,200,224]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-04-registerasset-can-overwrite-_assetclass-value",
    "title": "",
    "main_content": [
      "Submitted by gpersoon, also found by jonah1005 and leastwood",
      "Everyone can call the functionregisterAsset()of MochiProfileV0.sol\nAssuming the liquidity for the asset is sufficient,registerAsset()will reset the _assetClass of an already registered asset toAssetClass.Sigma.",
      "When the _assetClass is changed toAssetClass.SigmathenliquidationFactor(),riskFactor(),maxCollateralFactor(),liquidationFee()keeperFee()maxFee()will also return a different value.\nThen the entire vault will behave differently.\nThe threshold for liquidation will also be different, possibly leading to a liquidation that isn‚Äôt supposed to happen."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Add the following in functionregisterAsset():",
      "require\n(\\\n_assetClass\n\\[\\\n_asset\n] ==\n0\n,\n\"Already exists\"\n);",
      "ryuheimat (Mochi) confirmed"
    ]
  },
  {
    "row_number": 70,
    "bug_id": " H-05",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"debts calculation is not accurate\"",
    "line": "MochiVault[66,79,263],MochiProfileV0[242,258,272]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-05-debts-calculation-is-not-accurate",
    "title": "",
    "main_content": [
      "Submitted by gpersoon",
      "The value of the global variabledebtsin the contractMochiVault.solis calculated in an inconsistent way.",
      "In the functionborrow()the variabledebtsis increased with a value excluding the fee.\nHowever inrepay()andliquidate()it is decreased with the same value asdetails\\[\\_id].debtis decreased, which is including the fee.",
      "This would mean thatdebtswill end up in a negative value when all debts are repay-ed. Luckily the functionrepay()prevents this from happening.",
      "In the meantime the value ofdebtsisn‚Äôt accurate.\nThis value is used directly or indirectly in:",
      "utilizationRatio(),stabilityFee()calculateFeeIndex()ofMochiProfileV0.sol",
      "liveDebtIndex(),accrueDebt(),currentDebt()ofMochiVault.sol",
      "This means the entire debt and claimable calculations are slightly off."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "vault/MochiVaultsol",
      "function\nborrow\n(..)\ndetails\n\\[\\\n_id\n].\ndebt\n=\ntotalDebt\n;\n// includes the fee\ndebts\n+= \\\n_amount\n;\n// excludes the fee\nfunction\nrepay\n(..)\ndebts\n-= \\\n_amount\n;\\\ndetails\n\\[\\\n_id\n].\ndebt\n-= \\\n_amount\n;\nfunction\nliquidate\n(..)\ndebts\n-= \\\n_usdm\n;\ndetails\n\\[\\\n_id\n].\ndebt\n-= \\\n_usdm\n;",
      "seeissue pagefor referenced code."
    ],
    "recommended_mitigation": [
      "In functionborrow():\nreplacedebts += \\_amount;withdebts += totalDebt",
      "ryuheimat (Mochi) confirmed"
    ]
  },
  {
    "row_number": 71,
    "bug_id": " H-06",
    "bug_label": " S3-1",
    "difficulty": 1,
    "bug_description": " \"Referrer can drain ReferralFeePoolV0\"",
    "line": "ReferralFeePoolV0[28]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-06-referrer-can-drain-referralfeepoolv0",
    "title": "",
    "main_content": [
      "Submitted by gzeon",
      "functionclaimRewardAsMochiinReferralFeePoolV0.soldid not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "Did not reduce user reward balance at L28-47 inReferralFeePoolV0.sol"
    ],
    "recommended_mitigation": [
      "Add the following lines",
      "rewards -= reward[msg.sender];\nreward[msg.sender] = 0;",
      "ryuheimat (Mochi) confirmed"
    ]
  },
  {
    "row_number": 72,
    "bug_id": " H-08",
    "bug_label": " S5-1",
    "difficulty": 2,
    "bug_description": " \"Anyone can extend withdraw wait period by depositing zero collateral\"",
    "line": "MochiVault[125,158]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-08-anyone-can-extend-withdraw-wait-period-by-depositing-zero-collateral",
    "title": "",
    "main_content": [
      "Submitted by harleythedog, also found by WatchPug",
      "InMochiVault.sol, the deposit function allows anyone to deposit collateral into any position. A malicious user can call this function with amount = 0, which would reset the amount of time the owner has to wait before they can withdraw their collateral from their position. This is especially troublesome with longer delays, as a malicious user would only have to spend a little gas to lock out all other users from being able to withdraw from their positions, compromising the functionality of the contract altogether."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "thedepositfunctionhere",
      "Notice that calling this function with amount = 0 is not disallowed. This overwriteslastDeposit\\[\\_id], extending the wait period before a withdraw is allowed."
    ],
    "recommended_mitigation": [
      "I would recommend adding:",
      "require(amount > 0, \"zero\")",
      "at the start of the function, as depositing zero collateral does not seem to be a necessary use case to support.",
      "It may also be worthwhile to consider only allowing the owner of a position to deposit collateral.",
      "ryuheimat (Mochi) confirmed"
    ]
  },
  {
    "row_number": 73,
    "bug_id": " H-09",
    "bug_label": " S1-2",
    "difficulty": 1,
    "bug_description": " \"treasury is vulnerable to sandwich attack\"",
    "line": "MochiTreasuryV0[73]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-09-treasury-is-vulnerable-to-sandwich-attack",
    "title": "",
    "main_content": [
      "Submitted by jonah1005",
      "There‚Äôs a permissionless functionveCRVlockinMochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds.MochiTreasuryV0.sol#L73-L94",
      "Attackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "MochiTreasuryV0.sol#L73-L94",
      "Here‚Äôs an exploit pattern",
      "Flashloan and buy CRV the uniswap poolTriggerveCRVlock()The treasury buys CRV at a very high price.Sell CRV and pay back the loan."
    ],
    "recommended_mitigation": [
      "Recommend to addonlyOwnermodifier.",
      "ryuheimat (Mochi) confirmed"
    ]
  },
  {
    "row_number": 74,
    "bug_id": " H-11",
    "bug_label": " S3-2",
    "difficulty": 1,
    "bug_description": " \"treasuryShare is Overwritten in FeePoolV0._shareMochi()\"",
    "line": "FeePoolV0[79,94]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-11-treasuryshare-is-overwritten-in-feepoolv0_sharemochi",
    "title": "",
    "main_content": [
      "Submitted by leastwood",
      "TheFeePoolV0.solcontract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury andvMochicontracts. However, whendistributeMochi()is called to distributemochitokens toveCRVholders, bothmochiShareandtreasuryShareis flushed from the contract when there are stillusdmtokens in the contract.",
      "Manual code review",
      "Discussions with the Mochi team."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "Consider the following scenario:",
      "TheFeePoolV0.solcontract contains 100usdmtokens at an exchange rate of 1:1 withmochitokens.updateReserve()is called to set the split ofusdmtokens such thattreasurySharehas claim on 20usdmtokens andmochiSharehas claim on the other 80 tokens.AveCRVholder seeks to increase their earnings by callingdistributeMochi()beforesendToTreasury()has been called.As a result, 80usdmtokens are converted tomochitokens and  locked in a curve rewards pool.Consequently,mochiShareandtreasuryShareis set to0(aka flushed).The same user callsupdateReserve()to split the leftover 20usdmtokens betweentreasuryShareandmochiShare.mochiShareis now set to 16usdmtokens.The above process is repeated to distributemochitokens toveCRVholders again and again.The end result is thatveCRVholders have been able to receive all tokens that were intended to be distributed to the treasury.",
      "FeePoolV0.solL94"
    ],
    "recommended_mitigation": [
      "Consider removing the line inFeePoolV0.sol(mentioned above), wheretreasuryShareis flushed.",
      "ryuheimat (Mochi) confirmed"
    ]
  },
  {
    "row_number": 75,
    "bug_id": " H-12",
    "bug_label": " S1-2",
    "difficulty": 1,
    "bug_description": " \"feePool is vulnerable to sandwich attack.\"",
    "line": "FeePoolV0[55]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-12-feepool-is-vulnerable-to-sandwich-attack",
    "title": "",
    "main_content": [
      "Submitted by jonah1005",
      "There‚Äôs a permissionless functiondistributeMochiinFeePoolV0.sol L55-L62. Since everyone can trigger this function, an attacker can launch a sandwich attack with flashloan to steal the funds.",
      "The devs have mentioned this concern in the comment. An attacker can steal the funds with a flash loan attack.",
      "Attackers can steal all the funds in the pool. I consider this is a high-risk issue.",
      "ryuheimat (Mochi) disputed:",
      "ghoul-sol (judge) commented:"
    ],
    "code_blocks": null,
    "quotes": [
      "I think this is same case ashttps://github.com/code-423n4/2021-10-mochi-findings/issues/60",
      "The same attack, different part of the code. I‚Äôll keep them both."
    ],
    "proof_of_concept": [
      "FeePoolV0.sol#L55-L62",
      "Please refer toyDai Incidentto check the severity of aharvestfunction without slippage control.",
      "Please refer toMushrooms-finance-theftto check how likely this kind of attack might happen."
    ],
    "recommended_mitigation": [
      "If the dev wants to make this a permissionless control, the contract should calculate a min return based on TWAP and check the slippage."
    ]
  },
  {
    "row_number": 76,
    "bug_id": " H-13",
    "bug_label": " S4-1",
    "difficulty": 1,
    "bug_description": " \"Tokens Can Be Stolen By Frontrunning VestedRewardPool.vest() and VestedRewardPool.lock()\"",
    "line": "VestedRewardPool[36,54]",
    "url": " https://code4rena.com/reports/2021-10-mochi#h-13-tokens-can-be-stolen-by-frontrunning-vestedrewardpoolvest-and-vestedrewardpoollock",
    "title": "",
    "main_content": [
      "Submitted by leastwood",
      "TheVestedRewardPool.solcontract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw theirmochi. Thevest()function does not utilisesafeTransferFrom()to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call tovest()and effectively steal a recipient‚Äôs vested tokens. The same issue applies to thelock()function.",
      "Manual code review\nDiscussions with the Mochi team"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Ensure that users understand that this function should not be interacted directly as this could result in lost mochi tokens. Additionally, it might be worthwhile creating a single externally facing function which calls safeTransferFrom(), vest() and lock() in a single transaction."
    ]
  },
  {
    "row_number": 77,
    "bug_id": " H-02",
    "bug_label": " S6-1",
    "difficulty": 1,
    "bug_description": " \"unstake should update exchange rates first\"",
    "line": "DelegatedStaking[217,226]",
    "url": " https://code4rena.com/reports/2021-10-covalent#h-02-unstake-should-update-exchange-rates-first",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "Theunstakefunction does not immediately update the exchange rates. It first computes thevalidatorSharesRemove = tokensToShares(amount, v.exchangeRate)with the old exchange rate.",
      "Only afterwards, it updates the exchange rates (if the validator is not disabled):",
      "More shares for the amount are burned than required and users will lose rewards in the end."
    ],
    "code_blocks": [
      "// @audit shares are computed here with old rate\nuint128\nvalidatorSharesRemove\n=\ntokensToShares\n(\namount\n,\nv\n.\nexchangeRate\n);\nrequire\n(\nvalidatorSharesRemove\n>\n0\n,\n\"Unstake amount is too small\"\n);\nif\n(\nv\n.\ndisabledEpoch\n==\n0\n) {\n// @audit rates are updated here\nupdateGlobalExchangeRate\n();\nupdateValidator\n(\nv\n);\n// ...\n}"
    ],
    "quotes": null,
    "proof_of_concept": [
      "Demonstrating that users will lose rewards:",
      "Assume someone staked 1000 amount and received 1000 shares, and v.exchangeRate = 1.0. (This user is the single staker)",
      "Several epochs pass, interest accrues, and 1000 tokens accrue for the validator, tokensGivenToValidator = 1000. User should be entitled to 1000 in principal + 1000 in rewards = 2000 tokens.",
      "But user calls unstake(1000), which sets validatorSharesRemove = tokensToShares(amount, v.exchangeRate) = 1000 / 1.0 = 1000. Afterwards, the exchange rate is updated: v.exchangeRate += tokensGivenToValidator / totalShares = 1.0 + 1.0 = 2.0. The staker is updated with s.shares -= validatorSharesRemove = 0 and s.staked -= amount = 0. And the user receives their 1000 tokens but notice how the user‚Äôs shares are now at zero as well.",
      "User tries to claim rewards calling redeemAllRewards which fails as the rewards are 0."
    ],
    "recommended_mitigation": [
      "The exchange rates always need to be updated first before doing anything. Move the updateGlobalExchangeRate() and updateValidator(v) calls to the beginning of the function."
    ]
  },
  {
    "row_number": 78,
    "bug_id": " H-02",
    "bug_label": " S6-4",
    "difficulty": 2,
    "bug_description": " \"Wrong calculation of erc20Delta and ethDelta\"",
    "line": "Swap[200]",
    "url": " https://code4rena.com/reports/2021-10-tally#h-02-wrong-calculation-of-erc20delta-and-ethdelta",
    "title": "",
    "main_content": [
      "Submitted by WatchPug, also found by harleythedog",
      "Swap.solL200-L225",
      "When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215,ethDeltawill always be0.",
      "That‚Äôs becauseoriginalETHBalancealready includes themsg.valuesent by the caller.",
      "Let‚Äôs say the ETH balance of the contract is1 ETHbefore the swap.",
      "A user swaps10 ETHto USDC;",
      "originalETHBalancewill be11 ETH;",
      "If there is1 ETHof refund;",
      "ethDeltawill be0as the new balance is2 ETHandsubOrZero(2, 11)is0.",
      "Similarly,erc20Deltais also computed wrong.",
      "Consider a special case of a user trying to arbitrage fromWBTCtoWBTC, theoriginalERC20Balancealready includes the input amount,erc20Deltawill always be much lower than the actual delta amount.",
      "For example, for an arb swap from1 WBTCto1.1 WBTC, theethDeltawill be0.1 WBTCwhile it should be1.1 WBTC.",
      "User can not get ETH refund for swaps from ETH to ERC20 tokens;",
      "Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.",
      "Consider subtracting the input amount from the originalBalance.",
      "Shadowfiend (Tally) confirmed:",
      "0xean (judge) commented:"
    ],
    "code_blocks": [
      "function\nfillZrxQuote\n(\nIERC20\nzrxBuyTokenAddress\n,\naddress\npayable\nzrxTo\n,\nbytes\ncalldata\nzrxData\n,\nuint256\nethAmount\n)\ninternal\nreturns\n(\nuint256\n,\nuint256\n) {\nuint256\noriginalERC20Balance\n=\n0\n;\nif\n(!\nsignifiesETHOrZero\n(\naddress\n(\nzrxBuyTokenAddress\n))) {\noriginalERC20Balance\n=\nzrxBuyTokenAddress\n.\nbalanceOf\n(\naddress\n(\nthis\n));\n}\nuint256\noriginalETHBalance\n=\naddress\n(\nthis\n).\nbalance\n;\n(\nbool\nsuccess\n,) =\nzrxTo\n.\ncall\n{value:\nethAmount\n}(\nzrxData\n);\nrequire\n(\nsuccess\n,\n\"Swap::fillZrxQuote: Failed to fill quote\"\n);\nuint256\nethDelta\n=\naddress\n(\nthis\n).\nbalance\n.\nsubOrZero\n(\noriginalETHBalance\n);\nuint256\nerc20Delta\n;\nif\n(!\nsignifiesETHOrZero\n(\naddress\n(\nzrxBuyTokenAddress\n))) {\nerc20Delta\n=\nzrxBuyTokenAddress\n.\nbalanceOf\n(\naddress\n(\nthis\n)).\nsubOrZero\n(\noriginalERC20Balance\n);\nrequire\n(\nerc20Delta\n>\n0\n,\n\"Swap::fillZrxQuote: Didn't receive bought token\"\n);\n}\nelse\n{\nrequire\n(\nethDelta\n>\n0\n,\n\"Swap::fillZrxQuote: Didn't receive bought ETH\"\n);\n}\nreturn\n(\nerc20Delta\n,\nethDelta\n);\n}"
    ],
    "quotes": [
      "This doesn‚Äôt allow explicit stealing by an attacker, but does leak value. We would suggest a (2) severity on this.",
      "This results in a user losing assets that they will never be able to recover. Per documentation3 ‚Äî High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).Lost assets are a high sev."
    ],
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Consider subtracting the input amount from the originalBalance."
    ]
  },
  {
    "row_number": 79,
    "bug_id": " H-01",
    "bug_label": " S6-1",
    "difficulty": 1,
    "bug_description": " \"borrow must accrueInterest first\"",
    "line": "UToken[396,403,545,556]",
    "url": " https://code4rena.com/reports/2021-10-union#h-01-borrow-must-accrueinterest-first",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheUToken.borrowfunction first checks the borrowed balance and the old credit limitbeforeaccruing the actual interest on the market:",
      "Thus the borrowed balance of the user does not include the latest interest as it uses the old globalborrowIndexbut the newborrowIndexis only set inaccrueInterest.",
      "In low-activity markets, it could be that theborrowIndexaccruals (accrueInterestcalls) happen infrequently and a long time is between them.\nA borrower could borrow tokens, and borrow more tokens later at a different time without first having their latest debt accrued.\nThis will lead to borrowers being able to borrow more thanmaxBorrowandmore than their credit limitas these checks are performed before updating accruing interest."
    ],
    "code_blocks": [
      "// @audit this uses the old value\nrequire\n(\nborrowBalanceView\n(\nmsg\n.\nsender\n) +\namount\n+\nfee\n<=\nmaxBorrow\n,\n\"UToken: amount large than borrow size max\"\n);\nrequire\n(\n// @audit this calls uToken.calculateInterest(account) which returns old value\nuint256\n(\n_getCreditLimit\n(\nmsg\n.\nsender\n)) >=\namount\n+\nfee\n,\n\"UToken: The loan amount plus fee is greater than credit limit\"\n);\n// @audit accrual only happens here\nrequire\n(\naccrueInterest\n(),\n\"UToken: accrue interest failed\"\n);"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Therequire(accrueInterest(), \"UToken: accrue interest failed\");call should happen at the beginning of the function.",
      "GeraldHost (Union Finance) confirmed",
      "GalloDaSballo (judge) commented:",
      "Agree with the finding, this fundamentally breaks the accounting of the protocolIn protocols that calculate interest, and that have to recalculate state after something changed, it is vital that you accrue all changes up to this point before proceeding with any other state-changing logic"
    ]
  },
  {
    "row_number": 80,
    "bug_id": " H-02",
    "bug_label": " S6-1",
    "difficulty": 1,
    "bug_description": " \"Wrong implementation of CreditLimitByMedian.sol#getLockedAmount() makes it unable to unlock lockedAmount in CreditLimitByMedian model\"",
    "line": "CreditLimitByMedian[27]",
    "url": " https://code4rena.com/reports/2021-10-union#h-02-wrong-implementation-of-creditlimitbymediansolgetlockedamount-makes-it-unable-to-unlock-lockedamount-in-creditlimitbymedian-model",
    "title": "",
    "main_content": [
      "Submitted by WatchPug",
      "CreditLimitByMedian.solL27-L78",
      "getLockedAmount()is used byUserManager.sol#updateLockedData()to update locked amounts.",
      "Based on the context, at L66,newLockedAmount = array[i].lockedAmount - 1;should benewLockedAmount = array[i].lockedAmount - amount;.",
      "The current implementation is wrong and makes it impossible to unlocklockedAmountinCreditLimitByMedianmodel.",
      "Change to:",
      "newLockedAmount = array[i].lockedAmount - amount;",
      "kingjacob (Union) acknowledged",
      "GalloDaSballo (judge) commented:"
    ],
    "code_blocks": [
      "function\ngetLockedAmount\n(\nLockedInfo\n[]\nmemory\narray\n,\naddress\naccount\n,\nuint256\namount\n,\nbool\nisIncrease\n)\npublic\npure\noverride\nreturns\n(\nuint256\n) {\nif\n(\narray\n.\nlength\n==\n0\n)\nreturn\n0\n;\nuint256\nnewLockedAmount\n;\nif\n(\nisIncrease\n) {\n...\n}\nelse\n{\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\narray\n.\nlength\n;\ni\n++) {\nif\n(\narray\n[\ni\n].\nlockedAmount\n>\namount\n) {\nnewLockedAmount\n=\narray\n[\ni\n].\nlockedAmount\n-\n1\n;\n}\nelse\n{\nnewLockedAmount\n=\n0\n;\n}\nif\n(\naccount\n==\narray\n[\ni\n].\nstaker\n) {\nreturn\nnewLockedAmount\n;\n}\n}\n}\nreturn\n0\n;\n}"
    ],
    "quotes": [
      "The warden identified a mistake in the accounting that would make it impossible to unlock funds, mitigation seems to be straightfoward"
    ],
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Change to:newLockedAmount = array[i].lockedAmount - amount;"
    ]
  },
  {
    "row_number": 81,
    "bug_id": " H-02",
    "bug_label": " S6-3",
    "difficulty": 5,
    "bug_description": " \"Approved spender can spend too many tokens\"",
    "line": "WrappedIbbtc[68,91,98], WrappedIbbtcEth[104,111]",
    "url": " https://code4rena.com/reports/2021-10-badgerdao#h-02-approved-spender-can-spend-too-many-tokens",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by WatchPug, jonah1005, gzeon, and TomFrenchTheapprovefunction has not been overridden and therefore uses the internalshares, whereastransfer(From)uses the rebalanced amount.",
      "The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing withpricePerShare.",
      "Many contracts also use the same amount for theapprovecall as for the amount they want to have transferred in a subsequenttransferFromcall, and in this case, they approve an amount that is too large (as the approvedsharesamount yields a higher rebalanced amount)."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "The_allowancesfield should track the rebalanced amounts such that the approval value does not grow. (This does not actually require overriding theapprovefunction.)\nIntransferFrom, the approvals should then be subtracted by thetransferredamount, not theamountInShares:",
      "// _allowances are in rebalanced amounts such that they don't grow\n// need to subtract the transferred amount\n_approve\n(\nsender\n,\n_msgSender\n(),\n_allowances\n[\nsender\n][\n_msgSender\n()].\nsub\n(\namount\n,\n\"ERC20: transfer amount exceeds allowance\"\n));",
      "tabshaikh (Badger) confirmed and resolved:",
      "Fix here:https://github.com/Badger-Finance/rebasing-ibbtc/pull/7"
    ]
  },
  {
    "row_number": 82,
    "bug_id": " H-01",
    "bug_label": " S6-3",
    "difficulty": 1,
    "bug_description": " \"OverlayV1UniswapV3Market computes wrong market liquidity\"",
    "line": "OverlayV1UniswapV3Market[50,90,109,119]",
    "url": " https://code4rena.com/reports/2021-11-overlay#h-01-overlayv1uniswapv3market-computes-wrong-market-liquidity",
    "title": "",
    "main_content": [
      "Submitted by cmichel",
      "TheOverlayV1UniswapV3Market.fetchPricePointtries to compute the market depth in OVL terms asmarketLiquidity (in ETH) / ovlPrice (in ETH per OVL).\nTo get the market liquidityin ETH(and not the other token pair), it uses theethIs0boolean.",
      "However,ethIs0boolean refers to theovlFeed, whereas the_liquidityrefers to themarketFeed, and therefore theethIs0boolean has nothing to do with themarketfeed where the liquidity is taken from:",
      "If theovlFeedandmarketFeeddo not have the same token position for the ETH pair (ETH is either token 0 or token 1 forbothpairs), then the market liquidity & depth is computed wrong (inverted).\nFor example, theOverlayV1Market.depth()function will return a wrong depth which is used in the market cap computation."
    ],
    "code_blocks": [
      "_marketLiquidity\n=\nethIs0\n? (\nuint256\n(\n_liquidity\n) <<\n96\n) /\n_sqrtPrice\n:\nFullMath\n.\nmulDiv\n(\nuint256\n(\n_liquidity\n),\n_sqrtPrice\n,\nX96\n);",
      "// in constructor, if token0 is eth refers to ovlFeed\nethIs0\n=\nIUniswapV3Pool\n(\n_ovlFeed\n).\ntoken0\n() ==\n_eth\n;\n// in fetchPricePoint, _liquidity comes from different market feed\n(\n_ticks\n,\n_liqs\n) =\nIUniswapV3Pool\n(\nmarketFeed\n).\nobserve\n(\n_secondsAgo\n);\n_marketLiquidity\n=\nethIs0\n? (\nuint256\n(\n_liquidity\n) <<\n96\n) /\n_sqrtPrice\n:\nFullMath\n.\nmulDiv\n(\nuint256\n(\n_liquidity\n),\n_sqrtPrice\n,\nX96\n);"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "It seems thatmarketFeed.token0() == WETHshould be used infetchPricePointto compute the liquidity instead ofovlFeed.token0() == WETH.",
      "realisation (Overlay) confirmed:",
      "Yeah, was aware of this, just hadn‚Äôt finalized it in the code as of yet."
    ]
  },
  {
    "row_number": 83,
    "bug_id": " H-02",
    "bug_label": " S6-4",
    "difficulty": 2,
    "bug_description": " \"Can not update target price\"",
    "line": "SwapUtils[1571]",
    "url": " https://code4rena.com/reports/2021-11-bootfinance#h-02-can-not-update-target-price",
    "title": "",
    "main_content": [
      "Submitted by jonah1005, also found by WatchPug",
      "The sanity checks inrampTargetPriceare brokenSwapUtils.sol#L1571-L1581",
      "IffutureTargetPricePreciseis smaller thaninitialTargetPricePrecise0.01 offutureTargetPricePrecisewould never larger thaninitialTargetPricePrecise.",
      "Admin would not be able to ramp the target price. As it‚Äôs one of the most important features of the customswap, I consider this is a high-risk issue",
      "None"
    ],
    "code_blocks": [
      "if\n(\nfutureTargetPricePrecise\n<\ninitialTargetPricePrecise\n) {\nrequire\n(\nfutureTargetPricePrecise\n.\nmul\n(\nMAX_RELATIVE_PRICE_CHANGE\n).\ndiv\n(\nWEI_UNIT\n) >=\ninitialTargetPricePrecise\n,\n\"futureTargetPrice_ is too small\"\n);\n}\nelse\n{\nrequire\n(\nfutureTargetPricePrecise\n<=\ninitialTargetPricePrecise\n.\nmul\n(\nMAX_RELATIVE_PRICE_CHANGE\n).\ndiv\n(\nWEI_UNIT\n),\n\"futureTargetPrice_ is too large\"\n);\n}"
    ],
    "quotes": null,
    "proof_of_concept": [
      "Here‚Äôs a web3.py script to demo that it‚Äôs not possible to change the target price even by 1 wei.",
      "p1, p2, _, _ =swap.functions.targetPriceStorage().call()\nfuture = w3.eth.getBlock(w3.eth.block_number)[\n'timestamp'\n] +\n200\n*\n24\n*\n3600\n# futureTargetPrice_ is too small\nswap.functions.rampTargetPrice(p1 -\n1\n, future).transact()\n# futureTargetPrice_ is too large\nswap.functions.rampTargetPrice(p1 +\n1\n, future).transact()"
    ],
    "recommended_mitigation": [
      "Would it be something like:",
      "if\n(\nfutureTargetPricePrecise\n<\ninitialTargetPricePrecise\n) {\nrequire\n(\nfutureTargetPricePrecise\n.\nmul\n(\nMAX_RELATIVE_PRICE_CHANGE\n+\nWEI_UNIT\n).\ndiv\n(\nWEI_UNIT\n) >=\ninitialTargetPricePrecise\n,\n\"futureTargetPrice_ is too small\"\n);\n}\nelse\n{\nrequire\n(\nfutureTargetPricePrecise\n<=\ninitialTargetPricePrecise\n.\nmul\n(\nMAX_RELATIVE_PRICE_CHANGE\n+\nWEI_UNIT\n).\ndiv\n(\nWEI_UNIT\n),\n\"futureTargetPrice_ is too large\"\n);\n}",
      "I believe the dev would spot this mistake if there‚Äôs a more relaxed timeline.",
      "chickenpie347 (Boot Finance) confirmed"
    ]
  },
  {
    "row_number": 84,
    "bug_id": " H-03",
    "bug_label": " S3-1",
    "difficulty": 1,
    "bug_description": " \"SwapUtils.sol Wrong implementation\"",
    "line": "SwapUtils[661]",
    "url": " https://code4rena.com/reports/2021-11-bootfinance#h-03-swaputilssol-wrong-implementation",
    "title": "",
    "main_content": [
      "Submitted by WatchPug",
      "Based on the context, thetokenPrecisionMultipliersused in price calculation should be calculated in realtime based oninitialTargetPrice,futureTargetPrice,futureTargetPriceTimeand current time, just likegetA()andgetA2().",
      "However, in the current implementation,tokenPrecisionMultipliersused in price calculation is the stored value, it will only be changed when the owner calledrampTargetPrice()andstopRampTargetPrice().",
      "As a result, thetargetPriceset by the owner will not be effective until anothertargetPriceis being set orstopRampTargetPrice()is called."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Consider addingSwap.targetPriceand changing the_xp()at L661 from:",
      "https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667",
      "function\n_xp\n(\nSwap\nstorage\nself\n,\nuint256\n[]\nmemory\nbalances\n)\ninternal\nview\nreturns\n(\nuint256\n[]\nmemory\n)\n{\nreturn\n_xp\n(\nbalances\n,\nself\n.\ntokenPrecisionMultipliers\n);\n}",
      "To:",
      "function\n_xp\n(\nSwap\nstorage\nself\n,\nuint256\n[]\nmemory\nbalances\n)\ninternal\nview\nreturns\n(\nuint256\n[]\nmemory\n)\n{\nuint256\n[\n2\n]\nmemory\ntokenPrecisionMultipliers\n=\nself\n.\ntokenPrecisionMultipliers\n;\ntokenPrecisionMultipliers\n[\n0\n] =\nself\n.\ntargetPrice\n.\noriginalPrecisionMultipliers\n[\n0\n].\nmul\n(\n_getTargetPricePrecise\n(\nself\n)).\ndiv\n(\nWEI_UNIT\n)\nreturn\n_xp\n(\nbalances\n,\ntokenPrecisionMultipliers\n);\n}",
      "chickenpie347 (Boot Finance) confirmed"
    ]
  },
  {
    "row_number": 85,
    "bug_id": " H-04",
    "bug_label": " S6-4",
    "difficulty": 2,
    "bug_description": " \"Swaps are not split when trade crosses target price\"",
    "line": "SwapUtils[735,765,914,1098]",
    "url": " https://code4rena.com/reports/2021-11-bootfinance#h-04-swaps-are-not-split-when-trade-crosses-target-price",
    "title": "",
    "main_content": [
      "Submitted by cmichel, also found by gzeon",
      "The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, seeSwapUtils.determineA.\nThe swap curve is therefore a join of two different curves at the target price.\nWhen doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2.",
      "However, theSwapUtils.swap / _calculateSwapfunction does not do this, it only uses the ‚Äúnew A‚Äù, seegetYCstep 5.",
      "Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for theentire trade.\nThis can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values.",
      "In the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit."
    ],
    "code_blocks": [
      "// 5. Check if we switched A's during the swap\nif\n(\naNew\n==\na\n){\n// We have used the correct A\nreturn\ny\n;\n}\nelse\n{\n// We have switched A's, do it again with the new A\nreturn\ngetY\n(\nself\n,\ntokenIndexFrom\n,\ntokenIndexTo\n,\nx\n,\nxp\n,\naNew\n,\nd\n);\n}"
    ],
    "quotes": null,
    "proof_of_concept": null,
    "recommended_mitigation": [
      "Trades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.",
      "chickenpie347 (Boot Finance) confirmed"
    ]
  },
  {
    "row_number": 86,
    "bug_id": " H-06",
    "bug_label": " S6-3",
    "difficulty": 1,
    "bug_description": " \"Ideal balance is not calculated correctly when providing imbalanced liquidity\"",
    "line": "SwapUtils[1227]",
    "url": " https://code4rena.com/reports/2021-11-bootfinance#h-06-ideal-balance-is-not-calculated-correctly-when-providing-imbalanced-liquidity",
    "title": "",
    "main_content": [
      "Submitted by jonah1005",
      "When a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool.",
      "Take, for example, if there‚Äôs 10000 USD and 10000 DAI in the saddle‚Äôs USD/DAI pool, the user should get the optimal lp if he provides lp with ratio = 1.",
      "However, if thecustomSwappool is created with a target price = 2. The user would get 2 times more lp if he deposits DAI.SwapUtils.sol#L1227-L1245The current implementation does not calculates ideal balance correctly.",
      "If the target price is set to be 10, the ideal balance deviates by 10.\nThe fee deviates a lot. I consider this is a high-risk issues.",
      "None"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "We can observe the issue if we initiates two pools DAI/LINK pool and set the target price to be 4.",
      "For the first pool, we deposit more DAI.",
      "swap = deploy_contract(\n'Swap'\n[dai.address, link.address], [\n18\n,\n18\n],\n'lp'\n,\n'lp'\n,\n1\n,\n85\n,\n10\n**\n7\n,\n0\n,\n0\n,\n4\n*\n10\n**\n18\n)\nlink.functions.approve(swap.address, deposit_amount).transact()\ndai.functions.approve(swap.address, deposit_amount).transact()\nprevious_lp = lptoken.functions.balanceOf(user).call()\nswap.functions.addLiquidity([deposit_amount, deposit_amount //\n10\n],\n10\n,\n10\n**\n18\n).transact()\npost_lp = lptoken.functions.balanceOf(user).call()\nprint\n(\n'get lp'\n, post_lp - previous_lp)",
      "For the second pool, one we deposit more DAI.",
      "swap = deploy_contract(\n'Swap'\n[dai.address, link.address], [\n18\n,\n18\n],\n'lp'\n,\n'lp'\n,\n1\n,\n85\n,\n10\n**\n7\n,\n0\n,\n0\n,\n4\n*\n10\n**\n18\n)\nlink.functions.approve(swap.address, deposit_amount).transact()\ndai.functions.approve(swap.address, deposit_amount).transact()\nprevious_lp = lptoken.functions.balanceOf(user).call()\nswap.functions.addLiquidity([deposit_amount, deposit_amount //\n10\n],\n10\n,\n10\n**\n18\n).transact()\npost_lp = lptoken.functions.balanceOf(user).call()\nprint\n(\n'get lp'\n, post_lp - previous_lp)",
      "We can get roughly 4x more lp in the first case"
    ],
    "recommended_mitigation": [
      "The current implementation usesself.balances",
      "https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1231-L1236",
      "for\n(\nuint256\ni\n=\n0\n;\ni\n<\nself\n.\npooledTokens\n.\nlength\n;\ni\n++) {\nuint256\nidealBalance\n=\nv\n.\nd1\n.\nmul\n(\nself\n.\nbalances\n[\ni\n]).\ndiv\n(\nv\n.\nd0\n);\nfees\n[\ni\n] =\nfeePerToken\n.\nmul\n(\nidealBalance\n.\ndifference\n(\nnewBalances\n[\ni\n]))\n.\ndiv\n(\nFEE_DENOMINATOR\n);\nself\n.\nbalances\n[\ni\n] =\nnewBalances\n[\ni\n].\nsub\n(\nfees\n[\ni\n].\nmul\n(\nself\n.\nadminFee\n).\ndiv\n(\nFEE_DENOMINATOR\n)\n);\nnewBalances\n[\ni\n] =\nnewBalances\n[\ni\n].\nsub\n(\nfees\n[\ni\n]);\n}",
      "Replacesself.balanceswith_xp(self, newBalances)would be a simple fix.\nI consider the team can take balance‚Äôs weighted pool as a reference.WeightedMath.sol#L149-L179",
      "chickenpie347 (Boot Finance) confirmed"
    ]
  },
  {
    "row_number": 87,
    "bug_id": " H-08",
    "bug_label": " S2-1",
    "difficulty": 4,
    "bug_description": " \"Unable to claim vesting due to unbounded timelock loop\"",
    "line": "Vesting[81,148,195]",
    "url": " https://code4rena.com/reports/2021-11-bootfinance#h-08-unable-to-claim-vesting-due-to-unbounded-timelock-loop",
    "title": "",
    "main_content": [
      "Submitted by nathaniel, also found by WatchPug, leastwood, and pauliax",
      "The timelocks for anybeneficiaryare unbounded, and can be vested by someone who is not thebeneficiary. When the array becomes significantly big enough, the vestments will no longer be claimable for thebeneficiary.",
      "Thevest()function in Vesting.sol does not check thebeneficiary, hence anyone can vest for anyone else, pushing a new timelock to thetimelocks[_beneficiary].\nThe_claimableAmount()function (used byclaim()function), then loops through thetimelocks[_beneficiary]to determine the amount to be claimed.\nA malicious actor can easy repeatedly call thevest()function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable.\nThe malicious actor could do this to eachbeneficiary, locking up all the vestments.",
      "Manual code review"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148"
    ],
    "recommended_mitigation": [
      "Create a minimum on the vestment amounts, such that it won‚Äôt be feasible for a malicious actor to create a large amount of vestments.Restrict the vestment contribution of abeneficiarywhererequire(beneficiary == msg.sender)",
      "chickenpie347 (Boot Finance) confirmed"
    ]
  },
  {
    "row_number": 88,
    "bug_id": " H-01",
    "bug_label": " S1-2",
    "difficulty": 2,
    "bug_description": " \"Minting and burning synths exposes users to unlimited slippage\"",
    "line": "VaderPoolV2[126]",
    "url": " https://code4rena.com/reports/2021-11-vader#h-01-minting-and-burning-synths-exposes-users-to-unlimited-slippage",
    "title": "",
    "main_content": [
      "Submitted by TomFrenchBlockchain, also found by cmichel",
      "The amount of synths minted / assets received when minting or burning synths can be manipulated to an unlimited extent by manipulating the reserves of the pool"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "SeeVaderPool.mintSynth:https://github.com/code-423n4/2021-11-vader/blob/607d2b9e253d59c782e921bfc2951184d3f65825/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167",
      "Here a user sendsnativeDepositto the pool and the equivalent amount offoreignAssetis minted as a synth to be sent to the user. However the user can‚Äôt specify the minimum amount of synth that they would accept. A frontrunner can then manipulate the reserves of the pool in order to makeforeignAssetappear more valuable than it really is so the user receives synths which are worth much less than whatnativeDepositis worth. This is equivalent to a swap without a slippage limit.",
      "Burning synths essentially runs the same process in behalf so manipulating the pool in the opposite direction will result in the user getting fewer ofnativeAssetthan they expect."
    ],
    "recommended_mitigation": [
      "Add a argument for the minimum amount of synths to mint or nativeAsset to receive.",
      "SamSteinGG (Vader) acknowledged and disagreed with severity:",
      "We believe the severity should be set to medium as there are no loss of funds and its exploit requires special circumstances to be profitable."
    ]
  },
  {
    "row_number": 89,
    "bug_id": " H-02",
    "bug_label": " S1-1",
    "difficulty": 1,
    "bug_description": " \"Redemption value of synths can be manipulated to drain VaderPool of all native assets\"",
    "line": "VaderPoolV2[126]",
    "url": " https://code4rena.com/reports/2021-11-vader#h-02-redemption-value-of-synths-can-be-manipulated-to-drain-vaderpool-of-all-native-assets",
    "title": "",
    "main_content": [
      "Submitted by TomFrenchBlockchain",
      "Draining of funds fromVaderPool"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "See theVaderPool.mintSynthfunction:https://github.com/code-423n4/2021-11-vader/blob/607d2b9e253d59c782e921bfc2951184d3f65825/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167",
      "As the pool‚Äôs reserves can be manipulated through flashloans similar to on UniswapV2, an attacker may set the exchange rate betweennativeAssetand synths (calculated from the reserves). An attacker can exploit this to drain funds from the pool.",
      "The attacker first flashloans and sells a huge amount offoreignAssetto the pool. The pool now thinksnativeAssetis extremely valuable.The attacker now uses a relatively small amount ofnativeAssetto mint synths usingVaderPool.mintSynth. As the pool thinksnativeAssetis very valuable the attacker will receive a huge amount of synths.The attacker can now manipulate the pool in the opposite direction by buying up theforeignAssetthey sold to the pool.nativeAssetis now back at its normal price, or perhaps artificially low if the attacker wishes.The attacker now burns all of their synths. AsnativeAssetis considered much less valuable than at the point the synths were minted it takes a lot more ofnativeAssetin order to pay out for the burned synths.",
      "For the price of a flashloan and some swap fees, the attacker has now managed to extract a large amount ofnativeAssetfrom the pool. This process can be repeated as long as it is profitable."
    ],
    "recommended_mitigation": [
      "Prevent minting of synths or at the very least tie the exchange rate to a manipulation resistant oracle."
    ]
  },
  {
    "row_number": 90,
    "bug_id": " H-04",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"TwapOracle doesnÈà•Ê™õ calculate VADER:USDV exchange rate correctly\"",
    "line": "TwapOracle[156]",
    "url": " https://code4rena.com/reports/2021-11-vader#h-04-twaporacle-doesnt-calculate-vaderusdv-exchange-rate-correctly",
    "title": "",
    "main_content": [
      "Submitted by TomFrenchBlockchain",
      "Detailed description of the impact of this finding."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/twap/TwapOracle.sol#L156",
      "On L156 ofTwapOraclewe perform the calculation:",
      "result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);",
      "This seems extremely odd as for an 18 decimal token we‚Äôre then calculating",
      "result = ((sumUSD * 18) / sumNative);",
      "This is just plain weird. I expect what was meant is to replace this line with the below so we‚Äôre properly scaling fortoken‚Äôs number of decimals.",
      "uint256 scalingFactor = 10 ** IERC20Metadata(token).decimals()\nresult = (sumUSD * scalingFactor) / sumNative;",
      "Marked as high severity as this exchange rate appears to be used insome form of minting mechanismand correctness of the oracle is listed as one of the key focuses of the audit."
    ],
    "recommended_mitigation": [
      "As above.",
      "SamSteinGG (Vader) confirmed",
      "The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit."
    ]
  },
  {
    "row_number": 91,
    "bug_id": " H-05",
    "bug_label": " S1-1",
    "difficulty": 2,
    "bug_description": " \"LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve.\"",
    "line": "VaderRouterV2[208,237],VaderMath[73]",
    "url": " https://code4rena.com/reports/2021-11-vader#h-05-lps-of-vaderpoolv2-can-manipulate-pool-reserves-to-extract-funds-from-the-reserve",
    "title": "",
    "main_content": [
      "Submitted by TomFrenchBlockchain, also found by WatchPug",
      "Impermanent loss protection can be exploited to drain the reserve."
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "InVaderPoolV2.burnwe calculate the current losses that the LP has made to impermanent loss.",
      "https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/VaderPoolV2.sol#L237-L269",
      "These losses are then refunded to the LP in VADER tokens from the reserve",
      "https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/router/VaderRouterV2.sol#L208-L227",
      "This loss is calculated by the current reserves of the pool so if an LP can manipulate the pool‚Äôs reserves they can artificially engineer a huge amount of IL in order to qualify for a payout up to the size of their LP position.",
      "https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/math/VaderMath.sol#L73-L93",
      "The attack is then as follows.",
      "Be an LP for a reasonable period of time (IL protection scales linearly up to 100% after a year)Flashloan a huge amount of one of the pool‚Äôs assets.Trade against the pool with the flashloaned funds to unbalance it such that your LP position has huge IL.Remove your liquidity and receive compensation from the reserve for the IL you have engineered.Re-add your liquidity back to the pool.Trade against the pool to bring it back into balance.",
      "The attacker now holds the majority of their flashloaned funds (minus slippage/swap fees) along with a large fraction of the value of their LP position in VADER paid out from the reserve. The value of their LP position is unchanged. Given a large enough LP position, the IL protection funds extracted from the reserve will exceed the funds lost to swap fees and the attacker will be able to repay their flashloan with a profit.",
      "This is a high risk issue as after a year any large LP is incentivised and able to perform this attack."
    ],
    "recommended_mitigation": [
      "Use a manipulation resistant oracle for the relative prices of the pool‚Äôs assets (TWAP, etc.)"
    ]
  },
  {
    "row_number": 92,
    "bug_id": " H-09",
    "bug_label": " S6-4",
    "difficulty": 1,
    "bug_description": " \"VaderPoolV2 incorrectly calculates the amount of IL protection to send to LPs\"",
    "line": "TwapOracle[281],BasePoolV2[58],VaderPoolV2[258],VaderReserve[76],VaderMath[73]",
    "url": " https://code4rena.com/reports/2021-11-vader#h-09-vaderpoolv2-incorrectly-calculates-the-amount-of-il-protection-to-send-to-lps",
    "title": "",
    "main_content": [
      "Submitted by TomFrenchBlockchain",
      "TheVaderReservepays out IL fromVaderPoolV2LPs expressed in USDV with VADER (assuming a 1:1 exchange rate)"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "From the TwapOracle, it can be seen thatVaderPoolV2is intended to be deployed with USDV as itsnativeAsset:",
      "https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/twap/TwapOracle.sol#L281-L296https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/BasePoolV2.sol#L58-L59",
      "All the pairs inVaderPoolV2are then USDV:TKN where TKN is some other token, exactly which is irrelevant in this case.",
      "VaderPoolV2offers IL protection where any IL is refunded from theVaderReserve",
      "https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/VaderPoolV2.sol#L258-L268",
      "TheVaderReserveholds a balance of VADER tokens which will be used to pay out this protection.",
      "https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/reserve/VaderReserve.sol#L76-L90",
      "The IL experienced by the LP is calculated inVaderMath.calculateLoss",
      "https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/math/VaderMath.sol#L73-L93",
      "This is the core of the issue. From the variable names it‚Äôs clear that this is written with the assumption that it is work on units of VADER whereas it is provided amounts in terms of USDV. CheckingVaderRouterV2we can see that we pass the output of this calculation directly to the reserve in order to claim VADER.",
      "If an LP experienced 100 USDV worth of IL, instead of claiming the equivalent amount of VADER they would receive exactly 100 VADER as there‚Äôs no handling of the exchange rate between USDV and VADER.",
      "As VADER and USDV are very unlikely to trade at parity LPs could get sustantially more or less than the amount of IL they experienced."
    ],
    "recommended_mitigation": [
      "Add handling for the conversion rate between VADER and USDV using a tamper resistant oracle (TwapOracle could potentially fulfil this role).",
      "SamSteinGG (Vader) confirmed"
    ]
  },
  {
    "row_number": 93,
    "bug_id": " H-10",
    "bug_label": " S1-1",
    "difficulty": 1,
    "bug_description": " \"calculate Loss is vulnerable to flashloan attack\"",
    "line": "VaderMath[69]",
    "url": " https://code4rena.com/reports/2021-11-vader#h-10--calculate-loss-is-vulnerable-to-flashloan-attack",
    "title": "",
    "main_content": [
      "Submitted by jonah1005",
      "The VaderPool would compensate users‚Äô IL. The formula it uses to calculate lp value is vulnerable to manipulation.",
      "The formula to calculate the lp value is similar to warp finance which is known to be unsafe.warpfinance-incident-root-cause-analysis(Please to refer to the POC section)",
      "The Attacker can purchase an old lp position, manipulate price, take IL compensation and drain the reserve.\nI consider this is a high-risk issue.",
      "None"
    ],
    "code_blocks": null,
    "quotes": null,
    "proof_of_concept": [
      "VaderMath.sol#L69-L93",
      "The lp value is calculated as[(A0 * P1) + V0]and// [(A1 * P1) + V1].\nAssume that there‚Äôs an ETH pool and there‚Äôs 100 ETH and 100 Vader in the pool.",
      "Attacker deposit 1 ETH and 1 Vader and own 1% of the liquidity.Wait 1 yearStart flash loan and buy a lot ETH with 99900 Vader.There‚Äôs  0.1 ETH 100,000 Vader in the pool.Burn 1 % lp at the price 1 ETH = 1,000,000 Vader.A0 * P1 + V0 = 1 (eth) * 1,000,000 (price) + 100 (vader)A1 * P1 + V1 = 0.001 (eth) * 1,000,000 (price) + 10,000 (vader)IL compensation would be around9891000."
    ],
    "recommended_mitigation": [
      "Please use the fair lp pricing formula from alpha finance instead.fair-lp-token-pricing",
      "SamSteinGG (Vader) disputed:",
      "The described attack scenario can not be executed as the pool would actually consume the flash loan. The CLP model follows a non-linear curve that actually diminishes in value as the trade size increases, meaning that at most 25% of the total assets in the pool can be drained at a given iteration. This, on top with the fees of each transaction render this attack vector impossible. Please request a tangible attack test from the warden if this is meant to be accepted as valid.",
      "alcueca (judge) commented:",
      "The CLP model isn‚Äôt mentioned in the readme or the whitepaper. The issue is valid according to the materials supplied.",
      "SamSteinGG (Vader) commented:",
      "@alcueca As the grading guidelines of C4 state, a documentation issue cannot constitute more than a low risk finding. We advise the severity to be lowered."
    ]
  }
]
