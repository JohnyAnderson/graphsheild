[
  {
    "code": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;\n10         confirmAt[_merkleRoot] = 1;\n11      }\n\n\n12  function process(bytes memory _message) \n13     public returns (bool _success) {\n14     assert(accept(messages[_msgHash]));\n15     }\n    \n16   function accept(bytes32 _root) \n17     public view returns (bool) {\n18     uint256 _time = confirmAt[_root];\n19      }\n",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 9+  \n17+ \n18+ ",
    "invariants": "9+  assert(_merkleRoot != 0);\n17+ assert(_msgHash != 0);\n18+ assert(_root != 0);",
    "critical-invariants": "17+ assert(_msgHash != 0);\n",
    "ranks": "9+ assert(_merkleRoot != 0); \n17+ assert(_msgHash != 0); ",
    "vulnerabilities": "cross bridge\nID Uniqueness violation"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 library Math {\n    \n3     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4         if (a == 0) {\n5             return 0;\n6         }\n7         uint256 c = a * b;\n8         assert(c / a == b);\n9         return c;\n10     }\n\n11     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n12         return a / b;\n13     }\n\n14     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n15         assert(b <= a);\n16         return a - b;\n17     }\n\n18     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n19         uint256 c = a + b;\n20         assert(c >= a);\n21         return c;\n22     }\n23 }\n",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 8+\n15+\n20+",
    "invariants": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "critical-invariants": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "ranks": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4 contract testlock {\n5             \n6          function test_lock(\n7                  uint lock,\n8                  uint newLock,\n9                  uint amount\n10                  ) external {\n11 \n12                  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n13                  memory config = allLocks[lock];\n14                  config.depositAmount = amount;\n15                  if(newLock != 0) {\n16                      mapLocktoToken(newLock, config);\n17                  }           \n18                }\n19   } \n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 12+ \n",
    "invariants": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "critical-invariants": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "ranks": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw"
  },
  {
    "code": "\"1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\"\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;\n10     uint256 public mainChainId;\n11     address public token;\n12     address public deployer;\n13     \n14     mapping (address => uint) internal _authQuotas;                                     // signatory => quota\n15     mapping (uint => mapping (address => uint)) public sentCount;                       // toChainId => to => sentCount\n16     mapping (uint => mapping (address => mapping (uint => uint))) public sent;          // toChainId => to => nonce => volume\n17     mapping (uint => mapping (address => mapping (uint => uint))) public received;      // fromChainId => to => nonce => volume\n18     mapping (address => uint) public lasttimeUpdateQuotaOf;                             // signatory => lasttime\n19     uint public autoQuotaRatio;\n20     uint public autoQuotaPeriod;\n21     \n22     function setAutoQuota(uint ratio, uint period) virtual external onlyFactory {\n23         autoQuotaRatio  = ratio;\n24         autoQuotaPeriod = period;\n25     }\n26     \n27     modifier onlyFactory {\n28         require(msg.sender == factory, 'Only called by Factory');\n29         _;\n30     }\n31     \n32     modifier updateAutoQuota(address signatory) virtual {\n33         uint quota = authQuotaOf(signatory);\n34         if(_authQuotas[signatory] != quota) {\n35             _authQuotas[signatory] = quota;\n36             lasttimeUpdateQuotaOf[signatory] = now;\n37         }\n38         _;\n39     }\n40     \n41     function authQuotaOf(address signatory) virtual public view returns (uint quota) {\n42         quota = _authQuotas[signatory];\n43         uint ratio  = autoQuotaRatio  != 0 ? autoQuotaRatio  : Factory(factory).getConfig(_autoQuotaRatio_);\n44         uint period = autoQuotaPeriod != 0 ? autoQuotaPeriod : Factory(factory).getConfig(_autoQuotaPeriod_);\n45         if(ratio == 0 || period == 0 || period == uint(-1))\n46             return quota;\n47         uint quotaCap = cap().mul(ratio).div(1e18);\n48         uint delta = quotaCap.mul(now.sub(lasttimeUpdateQuotaOf[signatory])).div(period);\n49         return Math.max(quota, Math.min(quotaCap, quota.add(delta)));\n50     }\n51     \n52     function cap() public view virtual returns (uint);\n53 \n54     function increaseAuthQuotas(address[] memory signatories, uint[] memory increments) virtual external returns (uint[] memory quotas) {\n55         require(signatories.length == increments.length, 'two array lenth not equal');\n56         quotas = new uint[](signatories.length);\n57         for(uint i=0; i<signatories.length; i++)\n58             quotas[i] = increaseAuthQuota(signatories[i], increments[i]);\n59     }\n60     \n61     function increaseAuthQuota(address signatory, uint increment) virtual public updateAutoQuota(signatory) onlyFactory returns (uint quota) {\n62         quota = _authQuotas[signatory].add(increment);\n63         _authQuotas[signatory] = quota;\n64         emit IncreaseAuthQuota(signatory, increment, quota);\n65     }\n66     event IncreaseAuthQuota(address indexed signatory, uint increment, uint quota);\n67     \n68     function decreaseAuthQuotas(address[] memory signatories, uint[] memory decrements) virtual external returns (uint[] memory quotas) {\n69         require(signatories.length == decrements.length, 'two array lenth not equal');\n70         quotas = new uint[](signatories.length);\n71         for(uint i=0; i<signatories.length; i++)\n72             quotas[i] = decreaseAuthQuota(signatories[i], decrements[i]);\n73     }\n74     \n75     function decreaseAuthQuota(address signatory, uint decrement) virtual public onlyFactory returns (uint quota) {\n76         quota = authQuotaOf(signatory);\n77         if(quota < decrement)\n78             decrement = quota;\n79         return _decreaseAuthQuota(signatory, decrement);\n80     }\n81     \n82     function _decreaseAuthQuota(address signatory, uint decrement) virtual internal updateAutoQuota(signatory) returns (uint quota) {\n83         quota = _authQuotas[signatory].sub(decrement);\n84         _authQuotas[signatory] = quota;\n85         emit DecreaseAuthQuota(signatory, decrement, quota);\n86     }\n87     event DecreaseAuthQuota(address indexed signatory, uint decrement, uint quota);\n88     \n89 \n90     function needApprove() virtual public pure returns (bool);\n91     \n92     function send(uint toChainId, address to, uint volume) virtual external payable returns (uint nonce) {\n93         return sendFrom(_msgSender(), toChainId, to, volume);\n94     }\n95     \n96     function sendFrom(address from, uint toChainId, address to, uint volume) virtual public payable returns (uint nonce) {\n97         _chargeFee();\n98         _sendFrom(from, volume);\n99         nonce = sentCount[toChainId][to]++;\n100         sent[toChainId][to][nonce] = volume;\n101         emit Send(from, toChainId, to, nonce, volume);\n102     }\n103     event Send(address indexed from, uint indexed toChainId, address indexed to, uint nonce, uint volume);\n104     \n105     function _sendFrom(address from, uint volume) virtual internal;\n106 \n107     function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n108         _chargeFee();\n109         require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n110         uint N = signatures.length;\n111         require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n112         for(uint i=0; i<N; i++) {\n113             for(uint j=0; j<i; j++)\n114                 require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n115             bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n116             bytes32 digest = keccak256(abi.encodePacked(\"\"\\x19\\x01\"\", _DOMAIN_SEPARATOR, structHash));\n117             address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n118             require(signatory != address(0), \"\"invalid signature\"\");\n119             require(signatory == signatures[i].signatory, \"\"unauthorized\"\");\n120             _decreaseAuthQuota(signatures[i].signatory, volume);\n121             emit Authorize(fromChainId, to, nonce, volume, signatory);\n122         }\n123         received[fromChainId][to][nonce] = volume;\n124         _receive(to, volume);\n125         emit Receive(fromChainId, to, nonce, volume);\n126     }\n127     event Receive(uint256 indexed fromChainId, address indexed to, uint256 indexed nonce, uint256 volume);\n128     event Authorize(uint256 fromChainId, address indexed to, uint256 indexed nonce, uint256 volume, address indexed signatory);\n129     \n130     function _receive(address to, uint256 volume) virtual internal;\n131     \n132     function _chargeFee() virtual internal {\n133         require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');\n134         address payable feeTo = address(Factory(factory).getConfig(_feeTo_));\n135         if(feeTo == address(0))\n136             feeTo = address(uint160(factory));\n137         feeTo.transfer(msg.value);\n138         emit ChargeFee(_msgSender(), feeTo, msg.value);\n139     }\n140     event ChargeFee(address indexed from, address indexed to, uint value);\n141 \n142     uint256[47] private __gap;\n143 }    \"        \"22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n55 require(signatories.length == increments.length, 'two array lenth not equal');\n69 require(signatories.length == decrements.length, 'two array lenth not equal');\n109 require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n111 require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n118 require(signatory != address(0), \"\"invalid signature\"\");\n119 require(signatory == signatures[i].signatory, \"\"unauthorized\"\");\n119+ assert(to == signatory);\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');\"\n22\n",
    "transaction-context": "onlyFactory \n",
    "Critical-points": "modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }",
    "invariants": " require(signatories.length == increments.length, 'two array lenth not equal');",
    "critical-invariants": " require(signatories.length == decrements.length, 'two array lenth not equal');",
    "ranks": " require(received[fromChainId][to][nonce] == 0, 'withdrawn already');",
    "vulnerabilities": " require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }\n\n8 contract ERC20 is ERC20Basic {\n9     function allowance(address owner, address spender) public view returns (uint256);\n10     function transferFrom(address from, address to, uint256 value) public returns (bool);\n11     function approve(address spender, uint256 value) public returns (bool); \n12     event Approval(address indexed owner, address indexed spender, uint256 value);\n13 }\n\n14 contract BasicToken is ERC20Basic {\n15     using SafeMath for uint256;\n\n16     mapping(address => uint256) balances;\n\n17     uint256 totalSupply_;\n\n18     function totalSupply() public view returns (uint256) {\n19         return totalSupply_;\n20     }\n\n21     function transfer(address _to, uint256 _value) public returns (bool) {\n\n22         balances[msg.sender] = balances[msg.sender].sub(_value);\n23         balances[_to] = balances[_to].add(_value);\n    \n24         emit Transfer(msg.sender, _to, _value);\n25         return true;\n26     }\n\n27     function balanceOf(address _owner) public view returns (uint256) {\n28         return balances[_owner];\n29     }\n30 }\n\n31 contract Ownable {\n\n32     address public owner;\n33     address public operator;\n\n34     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n35     event OperatorTransferred(address indexed previousOperator, address indexed newOperator);\n\n36     constructor() public {\n37         owner    = msg.sender;\n38         operator = msg.sender;\n39     }\n\n40     modifier onlyOwner() { \n41          _; }\n42     modifier onlyOwnerOrOperator() {      \n43            _; }\n\n44     function transferOwnership(address _newOwner) external onlyOwner {      \n45         emit OwnershipTransferred(owner, _newOwner);\n46         owner = _newOwner;\n47     }\n  \n48     function transferOperator(address _newOperator) external onlyOwner { \n49         emit OperatorTransferred(operator, _newOperator);\n50         operator = _newOperator;\n51     }\n52 }\n\n53 contract BlackList is Ownable {\n\n54     event Lock(address indexed LockedAddress);\n55     event Unlock(address indexed UnLockedAddress);\n\n56     mapping( address => bool ) public blackList;\n\n57     modifier CheckBlackList {    \n58         _; }\n\n59     function SetLockAddress(address _lockAddress) external onlyOwnerOrOperator returns (bool) { \n        \n60         blackList[_lockAddress] = true;\n        \n61         emit Lock(_lockAddress);\n\n62         return true;\n63     }\n\n64     function UnLockAddress(address _unlockAddress) external onlyOwner returns (bool) {      \n        \n65         blackList[_unlockAddress] = false;\n        \n66         emit Unlock(_unlockAddress);\n\n67         return true;\n68     }\n69 }\n\n70 contract Pausable is Ownable {\n71     event Pause();\n72     event Unpause();\n\n73     bool public paused = false;\n\n74     modifier whenNotPaused() { require(!paused); _; }\n75     modifier whenPaused() { require(paused); _; }\n\n76     function pause() onlyOwnerOrOperator whenNotPaused public {\n77         paused = true;\n78         emit Pause();\n79     }\n\n80     function unpause() onlyOwner whenPaused public {\n81         paused = false;\n82         emit Unpause();\n83     }\n84 }\n\n85 contract StandardToken is ERC20, BasicToken {\n  \n86     mapping (address => mapping (address => uint256)) internal allowed;\n\n87     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        \n88         balances[_from] = balances[_from].sub(_value);\n89         balances[_to] = balances[_to].add(_value);\n90         allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    \n91         emit Transfer(_from, _to, _value);\n92         emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n    \n93         return true;\n94     }\n\n95     function approve(address _spender, uint256 _value) public returns (bool) {\n96         allowed[msg.sender][_spender] = _value;\n    \n97         emit Approval(msg.sender, _spender, _value);\n    \n98         return true;\n99     }\n\n100     function allowance(address _owner, address _spender) public view returns (uint256) {\n101         return allowed[_owner][_spender];\n102     }\n\n103     function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n104         allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n    \n105         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    \n106         return true;\n107     }\n\n108     function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n109         uint256 oldValue = allowed[msg.sender][_spender];\n    \n110         if (_subtractedValue > oldValue) {\n111             allowed[msg.sender][_spender] = 0;\n112         } else {\n113             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n114         }\n    \n115         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n116         return true;\n117     }\n118 }\n\n119 contract MultiTransferToken is StandardToken, Ownable {\n\n120     function MultiTransfer(address[] _to, uint256[] _amount) onlyOwner public returns (bool) {\n        \n121         uint256 ui;\n122         uint256 amountSum = 0;\n    \n123         for (ui = 0; ui < _to.length; ui++) {          \n\n124             amountSum = amountSum.add(_amount[ui]);\n125         }       \n\n126         for (ui = 0; ui < _to.length; ui++) {\n127             balances[msg.sender] = balances[msg.sender].sub(_amount[ui]);\n128             balances[_to[ui]] = balances[_to[ui]].add(_amount[ui]);\n        \n129             emit Transfer(msg.sender, _to[ui], _amount[ui]);\n130         }\n    \n131         return true;\n132     }\n133 }\n\n134 contract BurnableToken is StandardToken, Ownable {\n\n135     event BurnAdminAmount(address indexed burner, uint256 value);\n\n136     function burnAdminAmount(uint256 _value) onlyOwner public {      \n\n137         balances[msg.sender] = balances[msg.sender].sub(_value);\n138         totalSupply_ = totalSupply_.sub(_value);\n    \n139         emit BurnAdminAmount(msg.sender, _value);\n140         emit Transfer(msg.sender, address(0), _value);\n141     }\n142 }\n\n143 contract MintableToken is StandardToken, Ownable {\n144     event Mint(address indexed to, uint256 amount);\n145     event MintFinished();\n\n146     bool public mintingFinished = false;\n\n147     modifier canMint() { require(!mintingFinished); _; }\n\n148     function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n149         totalSupply_ = totalSupply_.add(_amount);\n150         balances[_to] = balances[_to].add(_amount);\n    \n151         emit Mint(_to, _amount);\n152         emit Transfer(address(0), _to, _amount);\n    \n153         return true;\n154     }\n\n155     function finishMinting() onlyOwner canMint public returns (bool) {\n156         mintingFinished = true;\n157         emit MintFinished();\n158         return true;\n159     }\n160 }\n\n161 contract PausableToken is StandardToken, Pausable, BlackList {\n\n162     function transfer(address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {\n163         return super.transfer(_to, _value);\n164     }\n\n165     function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {      \n\n166         return super.transferFrom(_from, _to, _value);\n167     }\n\n168     function approve(address _spender, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {\n169         return super.approve(_spender, _value);\n170     }\n\n171     function increaseApproval(address _spender, uint _addedValue) public whenNotPaused CheckBlackList returns (bool success) {\n172         return super.increaseApproval(_spender, _addedValue);\n173     }\n\n174     function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused CheckBlackList returns (bool success) {\n175         return super.decreaseApproval(_spender, _subtractedValue);\n176     }\n177 }\n",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 21+ \n40+ \n42+ \n44+ \n48+ \n57+ \n59+ \n64+\n87+\n120+\n123+ \n125+ \n136+  \n165+ ",
    "invariants": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);\n",
    "critical-invariants": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);",
    "ranks": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);",
    "vulnerabilities": "incorrect invisibility/ownership\nariithmetic flaw"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;\n7     uint256 public              minBidStep           = 0.25 ether;\n\n8     uint256 public constant     buyNowPrice          = 15 ether;\n9     uint256 public constant     buyNowPriceUntilBid  = 14.75 ether;\n10     uint256 public              buyNowMultiplier     = 20; // 20 = x2\n11     bool    public              boughtNow;\n\n12     uint256 public              auctionDuration      = 24 hours;\n13     bool    public              auctionStarted;\n14     uint256 public              auctionStartTimestamp;\n15     bool    public              auctionEnded;\n16     uint256 public              auctionEndTimestamp;\n\n17     uint256 public              highestBid          = 0.9 ether;\n18     address public              highestBidder;\n19     uint256 public              totalSupply         = 0;\n    \n20     mapping(address => uint) public bids;\n21     mapping(address => bool) public projectProxy;\n\n22     mapping(address => bool) public hasAddressBidded;\n23     address[] bidAdresses;\n24     uint256 totalBidAddresses;\n    \n\n25     constructor() ERC721(\"FlippazOne\", \"FlippazOne\") {\n26         proxyRegistryAddress = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\n27         baseURI = \"ipfs://QmcrAKPLLZhLWDFA6wpiH9QGEz3wsmedZ4TYWM3vGyLPaX\";\n28     }\n\n29     function _baseURI() internal view override returns (string memory) {\n30         return baseURI;\n31     }\n\n32     function editBaseUri(string memory newUri) public onlyOwner{\n33         baseURI = newUri;\n34     }\n    \n35     /* Edit admin functions */\n36     function editBuyNowMultipler(uint256 newMultiplier) public onlyOwner{\n37         buyNowMultiplier = newMultiplier;\n38     }\n\n39     function editMinBidStep(uint256 newMinBidStep) public onlyOwner{\n40         minBidStep = newMinBidStep;\n41     }\n\n42     /// @param newDuration New auction duration in SECONDS\n43     function editDuration(uint256 newDuration) public onlyOwner{\n44         require(auctionStarted, \"Auction has not yet been started\");\n45         auctionEndTimestamp = auctionStartTimestamp + newDuration;\n46         auctionDuration = newDuration;\n47     }\n\n48     function isAuctionActive() public view returns(bool){\n49         if (auctionStarted){\n50             if (!auctionEnded){\n51                 return block.timestamp < auctionEndTimestamp;\n52             }\n53         }\n54         return false;\n55     }\n\n56     function startAuction() public onlyOwner{\n57         require(auctionStarted == false, \"Auction is already started\");\n58         auctionStarted = true;\n59         auctionStartTimestamp = block.timestamp;\n60         auctionEndTimestamp = block.timestamp + auctionDuration;\n61     }\n\n62     function getBidderPaidAmount(address bidder) public view returns(uint256){\n63         return bids[bidder];\n64     }\n\n65     function getBidderByIndex(uint256 bidderIndex) public view returns(address){\n66         return bidAdresses[bidderIndex];\n67     }\n\n    \n68     function bid() public payable {\n69         require(auctionStarted, \"Auction has not yet started\");\n70         require(!auctionEnded, \"Auction has been finished\");\n71         require(!boughtNow, \"Auction has been finished\");\n72         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n\n73         uint256 newBid = bids[_msgSender()] + msg.value;\n74         require(newBid >= highestBid + minBidStep, \"Bid must be at least 0.25 ETH higher than the highest bid\");\n\n75         bids[_msgSender()] += msg.value;\n76         highestBid = newBid;\n77         highestBidder = _msgSender();\n\n78         if (!hasAddressBidded[_msgSender()]){\n79             hasAddressBidded[_msgSender()] = true;\n80             totalBidAddresses++;\n81             bidAdresses.push(_msgSender());\n82         }\n    \n83     }\n\n84     function isBuyNowActive() public view returns(bool){\n85         if (auctionStarted){\n86             if (!auctionEnded){\n87                 if (!boughtNow){\n88                     if (block.timestamp < auctionEndTimestamp){\n89                             return true;\n90                     }\n91                 }\n92             }\n93         }\n94         return false;\n95     }\n\n96     function getBuyNowPrice() public view returns(uint256){\n97         if (highestBid < buyNowPriceUntilBid){\n98             return buyNowPrice;\n99         } else {\n100             uint256 newBuyNowPrice = highestBid * buyNowMultiplier / 10;\n101             return newBuyNowPrice;\n102         }\n103     }\n\n104     function buyNow() public payable {\n105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n108         require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n109         uint256 currentBuyPrice = getBuyNowPrice();\n110         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n        \n111         highestBid = currentBuyPrice;\n112         highestBidder = _msgSender();\n\n113         uint256 tokenId = _tokenIdCounter.current();\n114         _tokenIdCounter.increment();\n115         _mint(_msgSender(), tokenId);\n116         boughtNow = true;\n117         auctionEnded =  true;\n118         totalSupply = 1;\n119     }\n\n120     function endAuction() public {\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n124         uint256 tokenId = _tokenIdCounter.current();\n125         _tokenIdCounter.increment();\n        \n126         if (highestBidder != address(0)){\n127             _safeMint(highestBidder, tokenId);\n128         } else {\n129             _safeMint(owner(), tokenId);\n130         }\n131         totalSupply = 1;\n132         auctionEnded = true;\n133     }\n\n134     function refundBids() public {\n135         require(auctionEnded, \"Please end the auction firstly\");\n136         for (uint256 i = 0; i < totalBidAddresses; i++){\n137             uint256 addressTotalBid = bids[bidAdresses[i]];\n138             if ((addressTotalBid > 0) && (bidAdresses[i] != highestBidder)){\n139                 (bool success, ) = bidAdresses[i].call{value: addressTotalBid}(\"\");\n140                 bids[bidAdresses[i]] = 0;\n141             }\n142         }\n143     }\n\n144     function burn(uint256 tokenId) public { \n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n146         _burn(tokenId);\n147     }\n\n148     function ownerWithdraw() public  {\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n150         (bool success, ) = owner().call{value: highestBid}(\"\");\n151         require(success, \"Failed to withdraw funds.\");\n152     }\n\n153     function ownerWithdrawTo(address toAddress) public  {\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n155         (bool success, ) = toAddress.call{value: highestBid}(\"\");\n156         require(success, \"Failed to withdraw funds.\");\n157     }\n\n158     function ownerWithdrawAll() public  {\n159         (bool success, ) = owner().call{value: address(this).balance}(\"\");\n160         require(success, \"Failed to withdraw funds.\");\n161     }\n\n162     function ownerWithdrawAllTo(address toAddress) public  {\n163         (bool success, ) = toAddress.call{value: address(this).balance}(\"\");\n164         require(success, \"Failed to withdraw funds.\");\n165     }\n\n166     function bidderWithdraw() public  {\n167         uint256 totalBid = getBidderPaidAmount(_msgSender());\n168         require(totalBid > 0, \"Nothing to withdraw\");\n169         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n170         (bool success, ) = _msgSender().call{value: totalBid}(\"\");\n171         require(success, \"Failed to withdraw funds.\");\n172         bids[_msgSender()] = 0;\n173     }\n\n174     function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n175         super._burn(tokenId);\n176     }\n\n177     function tokenURI(uint256 tokenId)\n178         public\n179         view\n180         override(ERC721, ERC721URIStorage)\n181         returns (string memory)\n182     {\n183         require(_exists(tokenId), \"Token does not exist\");\n184         return _baseURI();\n185     }\n\n186     function isApprovedForAll(address _owner, address operator) public view override(ERC721) returns (bool) {\n187         OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(proxyRegistryAddress);\n188         if (address(proxyRegistry.proxies(_owner)) == operator || projectProxy[operator]) return true;\n189         return super.isApprovedForAll(_owner, operator);\n190     }\n191 }\n",
    "transaction-context": "The transaction context is bidding",
    "Critical-points": "Critical program points are 105         \n106        \n107         \n108        \n110        \n121         \n122       \n123       \n124         \n135        \n145        \n149        \n151        \n154       \n156       \n160    \n162   \n164       \n168   \n169     \n171        \n183         ",
    "invariants": "105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n108         require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n110         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n124         uint256 tokenId = _tokenIdCounter.current();\n135         require(auctionEnded, \"Please end the auction firstly\");\n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n151         require(success, \"Failed to withdraw funds.\");\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n156         require(success, \"Failed to withdraw funds.\");\n160         require(success, \"Failed to withdraw funds.\");\n162         onlyOwner\n164         require(success, \"Failed to withdraw funds.\");\n168         require(totalBid > 0, \"Nothing to withdraw\");\n169         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n171         require(success, \"Failed to withdraw funds.\");\n183         require(_exists(tokenId), \"Token does not exist\");",
    "critical-invariants": "162         onlyOwner\n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "ranks": "162         onlyOwner\n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {\n7         uint256 private constant _NOT_ENTERED = 1;\n8         uint256 private constant _ENTERED = 2;\n9         uint256 private _status;\n10         constructor () {\n11             _status = _NOT_ENTERED;\n12         }\n    \n13         modifier nonReentrant() {           \n14             _status = _ENTERED;\n15             _;\n16             _status = _NOT_ENTERED;\n17         }\n18     }\n\n\n19 contract surgeToken{\n  \n20   /** Sells SURGE Tokens And Deposits the BNB into Seller's Address */\n21     function sell(uint256 tokenAmount) public nonReentrant returns (bool) {\n        \n22         address seller = msg.sender;\n        \n23         // make sure seller has this balance        \n24         // calculate the sell fee from this transaction\n25         uint256 tokensToSwap = tokenAmount.mul(sellFee).div(10**2);\n        \n26         // how much BNB are these tokens worth?\n27         uint256 amountBNB = tokensToSwap.mul(calculatePrice());\n        \n28         //reentrant happens here: during call fallback, the attacker invoked purchase multiple times\n29         (bool successful,) = payable(seller).call{value: amountBNB, gas: 40000}(\"\"); \n30         if (successful) {\n31             // subtract full amount from sender\n32             _balances[seller] = _balances[seller].sub(tokenAmount, 'sender does not have this amount to sell');\n33             // if successful, remove tokens from supply\n34             _totalSupply = _totalSupply.sub(tokenAmount);\n35         } else {\n36             revert();\n37         }\n38         emit Transfer(seller, address(this), tokenAmount);\n39         return true;\n40     }\n\n    \n41     function purchase(address buyer, uint256 bnbAmount) internal returns (bool) {\n42         // make sure we don't buy more than the bnb in this contract       \n43         // previous amount of BNB before we received any        \n44         uint256 prevBNBAmount = (address(this).balance).sub(bnbAmount);\n45         // if this is the first purchase, use current balance\n46         prevBNBAmount = prevBNBAmount == 0 ? address(this).balance : prevBNBAmount;\n47         // find the number of tokens we should mint to keep up with the current price\n48         uint256 nShouldPurchase = hyperInflatePrice ? _totalSupply.mul(bnbAmount).div(address(this).balance) : _totalSupply.mul(bnbAmount).div(prevBNBAmount);\n49         // apply our spread to tokens to inflate price relative to total supply\n50         uint256 tokensToSend = nShouldPurchase.mul(spreadDivisor).div(10**2);\n51         // revert if under 1\n52         if (tokensToSend < 1) {\n53             revert('Must Buy More Than One Surge');\n54         }\n55     }\n56 }\n42+\n",
    "transaction-context": "require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "Critical-points": "assert(a == 0 || c / a == b);",
    "invariants": "assert(b <= a);",
    "critical-invariants": "assert(c >= a);",
    "ranks": "require(msg.sender == owner, \"only owner\");\n",
    "vulnerabilities": "require(visrDeposit > 0, \"deposits must be nonzero\");\nrequire(to != address(0) && to != address(this), \"to\");\nrequire(from != address(0) && from != address(this), \"from\");"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;\n7     uint256 public              minBidStep           = 0.25 ether;\n\n8     uint256 public constant     buyNowPrice          = 15 ether;\n9     uint256 public constant     buyNowPriceUntilBid  = 14.75 ether;\n10     uint256 public              buyNowMultiplier     = 20; // 20 = x2\n11     bool    public              boughtNow;\n\n12     uint256 public              auctionDuration      = 24 hours;\n13     bool    public              auctionStarted;\n14     uint256 public              auctionStartTimestamp;\n15     bool    public              auctionEnded;\n16     uint256 public              auctionEndTimestamp;\n\n17     uint256 public              highestBid          = 0.9 ether;\n18     address public              highestBidder;\n19     uint256 public              totalSupply         = 0;\n    \n20     mapping(address => uint) public bids;\n21     mapping(address => bool) public projectProxy;\n\n22     mapping(address => bool) public hasAddressBidded;\n23     address[] bidAdresses;\n24     uint256 totalBidAddresses;\n    \n\n25     constructor() ERC721(\"FlippazOne\", \"FlippazOne\") {\n26         proxyRegistryAddress = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\n27         baseURI = \"ipfs://QmcrAKPLLZhLWDFA6wpiH9QGEz3wsmedZ4TYWM3vGyLPaX\";\n28     }\n\n29     function _baseURI() internal view override returns (string memory) {\n30         return baseURI;\n31     }\n\n32     function editBaseUri(string memory newUri) public onlyOwner{\n33         baseURI = newUri;\n34     }\n    \n35     /* Edit admin functions */\n36     function editBuyNowMultipler(uint256 newMultiplier) public onlyOwner{\n37         buyNowMultiplier = newMultiplier;\n38     }\n\n39     function editMinBidStep(uint256 newMinBidStep) public onlyOwner{\n40         minBidStep = newMinBidStep;\n41     }\n\n42     /// @param newDuration New auction duration in SECONDS\n43     function editDuration(uint256 newDuration) public onlyOwner{\n44         require(auctionStarted, \"Auction has not yet been started\");\n45         auctionEndTimestamp = auctionStartTimestamp + newDuration;\n46         auctionDuration = newDuration;\n47     }\n\n48     function isAuctionActive() public view returns(bool){\n49         if (auctionStarted){\n50             if (!auctionEnded){\n51                 return block.timestamp < auctionEndTimestamp;\n52             }\n53         }\n54         return false;\n55     }\n\n56     function startAuction() public onlyOwner{\n57         require(auctionStarted == false, \"Auction is already started\");\n58         auctionStarted = true;\n59         auctionStartTimestamp = block.timestamp;\n60         auctionEndTimestamp = block.timestamp + auctionDuration;\n61     }\n\n62     function getBidderPaidAmount(address bidder) public view returns(uint256){\n63         return bids[bidder];\n64     }\n\n65     function getBidderByIndex(uint256 bidderIndex) public view returns(address){\n66         return bidAdresses[bidderIndex];\n67     }\n\n    \n68     function bid() public payable {\n69         require(auctionStarted, \"Auction has not yet started\");\n70         require(!auctionEnded, \"Auction has been finished\");\n71         require(!boughtNow, \"Auction has been finished\");\n72         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n\n73         uint256 newBid = bids[_msgSender()] + msg.value;\n74         require(newBid >= highestBid + minBidStep, \"Bid must be at least 0.25 ETH higher than the highest bid\");\n\n75         bids[_msgSender()] += msg.value;\n76         highestBid = newBid;\n77         highestBidder = _msgSender();\n\n78         if (!hasAddressBidded[_msgSender()]){\n79             hasAddressBidded[_msgSender()] = true;\n80             totalBidAddresses++;\n81             bidAdresses.push(_msgSender());\n82         }\n    \n83     }\n\n84     function isBuyNowActive() public view returns(bool){\n85         if (auctionStarted){\n86             if (!auctionEnded){\n87                 if (!boughtNow){\n88                     if (block.timestamp < auctionEndTimestamp){\n89                             return true;\n90                     }\n91                 }\n92             }\n93         }\n94         return false;\n95     }\n\n96     function getBuyNowPrice() public view returns(uint256){\n97         if (highestBid < buyNowPriceUntilBid){\n98             return buyNowPrice;\n99         } else {\n100             uint256 newBuyNowPrice = highestBid * buyNowMultiplier / 10;\n101             return newBuyNowPrice;\n102         }\n103     }\n\n104     function buyNow() public payable {\n105         uint256 currentBuyPrice = getBuyNowPrice();\n106         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n        \n107         highestBid = currentBuyPrice;\n108         highestBidder = _msgSender();\n\n109         uint256 tokenId = _tokenIdCounter.current();\n110         _tokenIdCounter.increment();\n111         _mint(_msgSender(), tokenId);\n112         boughtNow = true;\n113         auctionEnded =  true;\n114         totalSupply = 1;\n115     }\n\n116     function endAuction() public {\n     \n117         uint256 tokenId = _tokenIdCounter.current();\n118         _tokenIdCounter.increment();\n        \n119         if (highestBidder != address(0)){\n120             _safeMint(highestBidder, tokenId);\n121         } else {\n122             _safeMint(owner(), tokenId);\n123         }\n124         totalSupply = 1;\n125         auctionEnded = true;\n126     }\n\n127     function refundBids() public {\n128         for (uint256 i = 0; i < totalBidAddresses; i++){\n129             uint256 addressTotalBid = bids[bidAdresses[i]];\n130             if ((addressTotalBid > 0) && (bidAdresses[i] != highestBidder)){\n131                 (bool success, ) = bidAdresses[i].call{value: addressTotalBid}(\"\");\n132                 bids[bidAdresses[i]] = 0;\n133             }\n134         }\n135     }\n\n136     function burn(uint256 tokenId) public { \n137         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n138         _burn(tokenId);\n139     }\n\n140     function ownerWithdraw() public  {       \n141         (bool success, ) = owner().call{value: highestBid}(\"\");\n142         require(success, \"Failed to withdraw funds.\");\n143     }\n\n144     function ownerWithdrawTo(address toAddress) public  {       \n145         (bool success, ) = toAddress.call{value: highestBid}(\"\");\n146         require(success, \"Failed to withdraw funds.\");\n147     }\n\n148     function ownerWithdrawAll() public  {\n149         (bool success, ) = owner().call{value: address(this).balance}(\"\");\n150         require(success, \"Failed to withdraw funds.\");\n151     }\n\n152     function ownerWithdrawAllTo(address toAddress) public onlyOwner {\n153         (bool success, ) = toAddress.call{value: address(this).balance}(\"\");\n154         require(success, \"Failed to withdraw funds.\");\n155     }\n\n156     function bidderWithdraw() public  {\n157         uint256 totalBid = getBidderPaidAmount(_msgSender());\n158         require(totalBid > 0, \"Nothing to withdraw\");\n159         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n160         (bool success, ) = _msgSender().call{value: totalBid}(\"\");\n161         require(success, \"Failed to withdraw funds.\");\n162         bids[_msgSender()] = 0;\n163     }\n\n164     function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n165         super._burn(tokenId);\n166     }\n\n167     function tokenURI(uint256 tokenId)\n168         public\n169         view\n170         override(ERC721, ERC721URIStorage)\n171         returns (string memory)\n172     {\n173         require(_exists(tokenId), \"Token does not exist\");\n174         return _baseURI();\n175     }\n\n176     function isApprovedForAll(address _owner, address operator) public view override(ERC721) returns (bool) {\n177         OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(proxyRegistryAddress);\n178         if (address(proxyRegistry.proxies(_owner)) == operator || projectProxy[operator]) return true;\n179         return super.isApprovedForAll(_owner, operator);\n180     }\n181 }\n144+ \n",
    "transaction-context": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "Critical-points": " require(success, \"Failed to withdraw funds.\");",
    "invariants": "require(success, \"Failed to withdraw funds.\");",
    "critical-invariants": "require(success, \"Failed to withdraw funds.\");",
    "ranks": "require(totalBid > 0, \"Nothing to withdraw\");",
    "vulnerabilities": "require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }\n10 \n11 // a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n12 \n13 library SafeMathSushiswap {\n14     function add(uint x, uint y) internal pure returns (uint z) {\n15         require((z = x + y) >= x, 'ds-math-add-overflow');\n16     }\n17 \n18     function sub(uint x, uint y) internal pure returns (uint z) {\n19         require((z = x - y) <= x, 'ds-math-sub-underflow');\n20     }\n21 \n22     function mul(uint x, uint y) internal pure returns (uint z) {\n23         require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n24     }\n25 }\n26 \n27 library SushiswapV2Library {\n28     using SafeMathSushiswap for uint;\n29 \n30     // returns sorted token addresses, used to handle return values from pairs sorted in this order\n31     function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n32         require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n33         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n34         require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n35     }\n36 \n37     // calculates the CREATE2 address for a pair without making any external calls\n38     function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n39         (address token0, address token1) = sortTokens(tokenA, tokenB);\n40         pair = address(uint160(uint256(keccak256(abi.encodePacked(\n41                 hex'ff',\n42                 factory,\n43                 keccak256(abi.encodePacked(token0, token1)),\n44                 hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n45             )))));\n46     }\n47 \n48     // fetches and sorts the reserves for a pair\n49     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n50         (address token0,) = sortTokens(tokenA, tokenB);\n51         (uint reserve0, uint reserve1,) = ISushiswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n52         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n53     }\n54 \n55     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n56     function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n57         require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58         require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n59         amountB = amountA.mul(reserveB) / reserveA;\n60     }\n61 \n62     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n63     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n64         require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n66         uint amountInWithFee = amountIn.mul(997);\n67         uint numerator = amountInWithFee.mul(reserveOut);\n68         uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n69         amountOut = numerator / denominator;\n70     }\n71 \n72     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n73     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n74         require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n76         uint numerator = reserveIn.mul(amountOut).mul(1000);\n77         uint denominator = reserveOut.sub(amountOut).mul(997);\n78         amountIn = (numerator / denominator).add(1);\n79     }\n80 \n81     // performs chained getAmountOut calculations on any number of pairs\n82     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n83         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n84         amounts = new uint[](path.length);\n85         amounts[0] = amountIn;\n86         for (uint i; i < path.length - 1; i++) {\n87             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n88             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n89         }\n90     }\n91 \n92     // performs chained getAmountIn calculations on any number of pairs\n93     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n94         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n95         amounts = new uint[](path.length);\n96         amounts[amounts.length - 1] = amountOut;\n97         for (uint i = path.length - 1; i > 0; i--) {\n98             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n99             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n100         }\n101     }\n102 }\n103 \n104 // helper methods for interacting with ERC20 tokens and sending NATIVE that do not consistently return true/false\n105 library TransferHelper {\n106     function safeApprove(address token, address to, uint value) internal {\n107         // bytes4(keccak256(bytes('approve(address,uint256)')));\n108         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n109         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n110     }\n111 \n112     function safeTransfer(address token, address to, uint value) internal {\n113         // bytes4(keccak256(bytes('transfer(address,uint256)')));\n114         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n115         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n116     }\n117 \n118     function safeTransferFrom(address token, address from, address to, uint value) internal {\n119         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n120         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n121         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n122     }\n123 \n124     function safeTransferNative(address to, uint value) internal {\n125         (bool success,) = to.call{value:value}(new bytes(0));\n126         require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n127     }\n128 }\n129 \n130 interface IwNATIVE {\n131     function deposit() external payable;\n132     function transfer(address to, uint value) external returns (bool);\n133     function withdraw(uint) external;\n134 }\n135 \n136 interface AnyswapV1ERC20 {\n137     function mint(address to, uint256 amount) external returns (bool);\n138     function burn(address from, uint256 amount) external returns (bool);\n139     function changeVault(address newVault) external returns (bool);\n140     function depositVault(uint amount, address to) external returns (uint);\n141     function withdrawVault(address from, uint amount, address to) external returns (uint);\n142     function underlying() external view returns (address);\n143 }\n144 \n145 /**\n146  * @dev Interface of the ERC20 standard as defined in the EIP.\n147  */\n148 interface IERC20 {\n149     function totalSupply() external view returns (uint256);\n150     function balanceOf(address account) external view returns (uint256);\n151     function transfer(address recipient, uint256 amount) external returns (bool);\n152     function allowance(address owner, address spender) external view returns (uint256);\n153     function approve(address spender, uint256 amount) external returns (bool);\n154     function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n155     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n156     function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n157 \n158     event Transfer(address indexed from, address indexed to, uint256 value);\n159     event Approval(address indexed owner, address indexed spender, uint256 value);\n160 }\n161 \n162 contract AnyswapV4Router {\n163     using SafeMathSushiswap for uint;\n164 \n165     address public immutable factory;\n166     address public immutable wNATIVE;\n167 \n168     modifier ensure(uint deadline) {\n169         require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n170         _;\n171     }\n172 \n173     constructor(address _factory, address _wNATIVE, address _mpc) {\n174         _newMPC = _mpc;\n175         _newMPCEffectiveTime = block.timestamp;\n176         factory = _factory;\n177         wNATIVE = _wNATIVE;\n178     }\n179 \n180     receive() external payable {\n181         assert(msg.sender == wNATIVE); // only accept Native via fallback from the wNative contract\n182     }\n183 \n184     address private _oldMPC;\n185     address private _newMPC;\n186     uint256 private _newMPCEffectiveTime;\n187 \n188 \n189     event LogChangeMPC(address indexed oldMPC, address indexed newMPC, uint indexed effectiveTime, uint chainID);\n190     event LogChangeRouter(address indexed oldRouter, address indexed newRouter, uint chainID);\n191     event LogAnySwapIn(bytes32 indexed txhash, address indexed token, address indexed to, uint amount, uint fromChainID, uint toChainID);\n192     event LogAnySwapOut(address indexed token, address indexed from, address indexed to, uint amount, uint fromChainID, uint toChainID);\n193     event LogAnySwapTradeTokensForTokens(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n194     event LogAnySwapTradeTokensForNative(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n195 \n196     modifier onlyMPC() {\n197         require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n198         _;\n199     }\n200 \n201     function mpc() public view returns (address) {\n202         if (block.timestamp >= _newMPCEffectiveTime) {\n203             return _newMPC;\n204         }\n205         return _oldMPC;\n206     }\n207 \n208     function cID() public view returns (uint id) {\n209         assembly {id := chainid()}\n210     }\n211 \n212     function changeMPC(address newMPC) public onlyMPC returns (bool) {\n213         require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n214         _oldMPC = mpc();\n215         _newMPC = newMPC;\n216         _newMPCEffectiveTime = block.timestamp + 2*24*3600;\n217         emit LogChangeMPC(_oldMPC, _newMPC, _newMPCEffectiveTime, cID());\n218         return true;\n219     }\n220 \n221     function changeVault(address token, address newVault) public onlyMPC returns (bool) {\n222         require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n223         return AnyswapV1ERC20(token).changeVault(newVault);\n224     }\n225 \n226     function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n227         AnyswapV1ERC20(token).burn(from, amount);\n228         emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n229     }\n230 \n231     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\n232     function anySwapOut(address token, address to, uint amount, uint toChainID) external {\n233         _anySwapOut(msg.sender, token, to, amount, toChainID);\n234     }\n235 \n236     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to` by minting with `underlying`\n237     function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external {\n238         TransferHelper.safeTransferFrom(AnyswapV1ERC20(token).underlying(), msg.sender, token, amount);\n239         AnyswapV1ERC20(token).depositVault(amount, msg.sender);\n240         _anySwapOut(msg.sender, token, to, amount, toChainID);\n241     }\n242 \n243     function anySwapOutUnderlyingWithPermit(\n244         address from,\n245         address token,\n246         address to,\n247         uint amount,\n248         uint deadline,\n249         uint8 v,\n250         bytes32 r,\n251         bytes32 s,\n252         uint toChainID\n253     ) external {\n254         address _underlying = AnyswapV1ERC20(token).underlying();\n255         IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n256         TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n257         AnyswapV1ERC20(token).depositVault(amount, from);\n258         _anySwapOut(from, token, to, amount, toChainID);\n259     }\n260 \n261     function anySwapOutUnderlyingWithTransferPermit(\n262         address from,\n263         address token,\n264         address to,\n265         uint amount,\n266         uint deadline,\n267         uint8 v,\n268         bytes32 r,\n269         bytes32 s,\n270         uint toChainID\n271     ) external {\n272         IERC20(AnyswapV1ERC20(token).underlying()).transferWithPermit(from, token, amount, deadline, v, r, s);\n273         AnyswapV1ERC20(token).depositVault(amount, from);\n274         _anySwapOut(from, token, to, amount, toChainID);\n275     }\n276 \n277     function anySwapOut(address[] calldata tokens, address[] calldata to, uint[] calldata amounts, uint[] calldata toChainIDs) external {\n278         for (uint i = 0; i < tokens.length; i++) {\n279             _anySwapOut(msg.sender, tokens[i], to[i], amounts[i], toChainIDs[i]);\n280         }\n281     }\n282 \n283     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n284     function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n285         AnyswapV1ERC20(token).mint(to, amount);\n286         emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n287     }\n288 \n289     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n290     // triggered by `anySwapOut`\n291     function anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n292         _anySwapIn(txs, token, to, amount, fromChainID);\n293     }\n294 \n295     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying`\n296     function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n297         _anySwapIn(txs, token, to, amount, fromChainID);\n298         AnyswapV1ERC20(token).withdrawVault(to, amount, to);\n299     }\n300 \n301     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying` if possible\n302     function anySwapInAuto(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n303         _anySwapIn(txs, token, to, amount, fromChainID);\n304         AnyswapV1ERC20 _anyToken = AnyswapV1ERC20(token);\n305         address _underlying = _anyToken.underlying();\n306         if (_underlying != address(0) && IERC20(_underlying).balanceOf(token) >= amount) {\n307             _anyToken.withdrawVault(to, amount, to);\n308         }\n309     }\n310 \n311     // extracts mpc fee from bridge fees\n312     function anySwapFeeTo(address token, uint amount) external onlyMPC {\n313         address _mpc = mpc();\n314         AnyswapV1ERC20(token).mint(_mpc, amount);\n315         AnyswapV1ERC20(token).withdrawVault(_mpc, amount, _mpc);\n316     }\n317 \n318     function anySwapIn(bytes32[] calldata txs, address[] calldata tokens, address[] calldata to, uint256[] calldata amounts, uint[] calldata fromChainIDs) external onlyMPC {\n319         for (uint i = 0; i < tokens.length; i++) {\n320             _anySwapIn(txs[i], tokens[i], to[i], amounts[i], fromChainIDs[i]);\n321         }\n322     }\n323 \n324     // **** SWAP ****\n325     // requires the initial amount to have already been sent to the first pair\n326     function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n327         for (uint i; i < path.length - 1; i++) {\n328             (address input, address output) = (path[i], path[i + 1]);\n329             (address token0,) = SushiswapV2Library.sortTokens(input, output);\n330             uint amountOut = amounts[i + 1];\n331             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n332             address to = i < path.length - 2 ? SushiswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n333             ISushiswapV2Pair(SushiswapV2Library.pairFor(factory, input, output)).swap(\n334                 amount0Out, amount1Out, to, new bytes(0)\n335             );\n336         }\n337     }\n338 \n339     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n340     function anySwapOutExactTokensForTokens(\n341         uint amountIn,\n342         uint amountOutMin,\n343         address[] calldata path,\n344         address to,\n345         uint deadline,\n346         uint toChainID\n347     ) external virtual ensure(deadline) {\n348         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n349         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n350     }\n351 \n352     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n353     function anySwapOutExactTokensForTokensUnderlying(\n354         uint amountIn,\n355         uint amountOutMin,\n356         address[] calldata path,\n357         address to,\n358         uint deadline,\n359         uint toChainID\n360     ) external virtual ensure(deadline) {\n361         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n362         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n363         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n364         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n365     }\n366 \n367     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n368     function anySwapOutExactTokensForTokensUnderlyingWithPermit(\n369         address from,\n370         uint amountIn,\n371         uint amountOutMin,\n372         address[] calldata path,\n373         address to,\n374         uint deadline,\n375         uint8 v,\n376         bytes32 r,\n377         bytes32 s,\n378         uint toChainID\n379     ) external virtual ensure(deadline) {\n380         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n381         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n382         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n383         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n384         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n385         {\n386         address[] memory _path = path;\n387         address _from = from;\n388         address _to = to;\n389         uint _amountIn = amountIn;\n390         uint _amountOutMin = amountOutMin;\n391         uint _cID = cID();\n392         uint _toChainID = toChainID;\n393         emit LogAnySwapTradeTokensForTokens(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n394         }\n395     }\n396 \n397     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n398     function anySwapOutExactTokensForTokensUnderlyingWithTransferPermit(\n399         address from,\n400         uint amountIn,\n401         uint amountOutMin,\n402         address[] calldata path,\n403         address to,\n404         uint deadline,\n405         uint8 v,\n406         bytes32 r,\n407         bytes32 s,\n408         uint toChainID\n409     ) external virtual ensure(deadline) {\n410         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n411         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n412         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n413         emit LogAnySwapTradeTokensForTokens(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n414     }\n415 \n416     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n417     // Triggered by `anySwapOutExactTokensForTokens`\n418     function anySwapInExactTokensForTokens(\n419         bytes32 txs,\n420         uint amountIn,\n421         uint amountOutMin,\n422         address[] calldata path,\n423         address to,\n424         uint deadline,\n425         uint fromChainID\n426     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n427         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n428         require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n429         _anySwapIn(txs, path[0], SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n430         _swap(amounts, path, to);\n431     }\n432 \n433     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n434     function anySwapOutExactTokensForNative(\n435         uint amountIn,\n436         uint amountOutMin,\n437         address[] calldata path,\n438         address to,\n439         uint deadline,\n440         uint toChainID\n441     ) external virtual ensure(deadline) {\n442         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n443         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n444     }\n445 \n446     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n447     function anySwapOutExactTokensForNativeUnderlying(\n448         uint amountIn,\n449         uint amountOutMin,\n450         address[] calldata path,\n451         address to,\n452         uint deadline,\n453         uint toChainID\n454     ) external virtual ensure(deadline) {\n455         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n456         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n457         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n458         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n459     }\n460 \n461     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n462     function anySwapOutExactTokensForNativeUnderlyingWithPermit(\n463         address from,\n464         uint amountIn,\n465         uint amountOutMin,\n466         address[] calldata path,\n467         address to,\n468         uint deadline,\n469         uint8 v,\n470         bytes32 r,\n471         bytes32 s,\n472         uint toChainID\n473     ) external virtual ensure(deadline) {\n474         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n475         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n476         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n477         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n478         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n479         {\n480         address[] memory _path = path;\n481         address _from = from;\n482         address _to = to;\n483         uint _amountIn = amountIn;\n484         uint _amountOutMin = amountOutMin;\n485         uint _cID = cID();\n486         uint _toChainID = toChainID;\n487         emit LogAnySwapTradeTokensForNative(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n488         }\n489     }\n490 \n491     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n492     function anySwapOutExactTokensForNativeUnderlyingWithTransferPermit(\n493         address from,\n494         uint amountIn,\n495         uint amountOutMin,\n496         address[] calldata path,\n497         address to,\n498         uint deadline,\n499         uint8 v,\n500         bytes32 r,\n501         bytes32 s,\n502         uint toChainID\n503     ) external virtual ensure(deadline) {\n504         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n505         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n506         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n507         emit LogAnySwapTradeTokensForNative(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n508     }\n509 \n510     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n511     // Triggered by `anySwapOutExactTokensForNative`\n512     function anySwapInExactTokensForNative(\n513         bytes32 txs,\n514         uint amountIn,\n515         uint amountOutMin,\n516         address[] calldata path,\n517         address to,\n518         uint deadline,\n519         uint fromChainID\n520     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n521         require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n522         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n523         require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');\n524         _anySwapIn(txs, path[0],  SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n525         _swap(amounts, path, address(this));\n526         IwNATIVE(wNATIVE).withdraw(amounts[amounts.length - 1]);\n527         TransferHelper.safeTransferNative(to, amounts[amounts.length - 1]);\n528     }\n529 \n530     // **** LIBRARY FUNCTIONS ****\n531     function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {\n532         return SushiswapV2Library.quote(amountA, reserveA, reserveB);\n533     }\n534 \n535     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n536         public\n537         pure\n538         virtual\n539         returns (uint amountOut)\n540     {\n541         return SushiswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n542     }\n543 \n544     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n545         public\n546         pure\n547         virtual\n548         returns (uint amountIn)\n549     {\n550         return SushiswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n551     }\n552 \n553     function getAmountsOut(uint amountIn, address[] memory path)\n554         public\n555         view\n556         virtual\n557         returns (uint[] memory amounts)\n558     {\n559         return SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n560     }\n561 \n562     function getAmountsIn(uint amountOut, address[] memory path)\n563         public\n564         view\n565         virtual\n566         returns (uint[] memory amounts)\n567     {\n568         return SushiswapV2Library.getAmountsIn(factory, amountOut, path);\n569     }\n570 }\n15+ \n",
    "transaction-context": "require((z = x + y) >= x, 'ds-math-add-overflow');",
    "Critical-points": "require((z = x - y) <= x, 'ds-math-sub-underflow');",
    "invariants": "require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');",
    "critical-invariants": " require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');",
    "ranks": "require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');",
    "vulnerabilities": "require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4  contract Lottery {\n5 \n6          mapping (address => mapping(uint64 => uint))\n7          public tickets;\n8          uint64 winningId; \n9          bool drawingPhase; \n10          }\n11          function reset() external{\n12                 delete tickets;\n13                 winningId = 0; \n14                 drawingPhase = false;\n15         }\n16 \n17         function buy(uint64 id, uint amount) external {\n18             require(winningId == 0, \"already drawn\");\n19             receivePayment(msg.sender, amount),\n20             tickets[msg.sender][id] += amount;\n21             }\n22 \n23         function enterDrawingPhase() external {\n24                 drawingPhase = true;\n25         }\n26 \n27          function draw(uint64 id) external {\n28                  require(winningId == 0, \"already drawn\");\n29                  require(id != 0, \"invalid winning number\");\n30                  winningId = id;\n31          }\n32          function claimReward() external {\n33                 require(winningId != 0, \"not drawn\");\n34                }\n35          function multiBuy(uint[] ids, uint[] amounts)\n36          external {\n37                  require(winningId == 0, \"already drawn\");\n38                  uint totalAmount = 0;\n39                  for (int i = 0; i < ids.length; i++) {\n40                  tickets[msg.sender][ids[i]] += amounts[i];\n41                  totalAmount += amounts[i];\n42          }\n43               receivePayment(msg.sender, totalAmount);\n44          }\n45 }\n",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 17+ \n35+ \n",
    "invariants": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "critical-invariants": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "ranks": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "vulnerabilities": "atomicity violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";\n8 import \"./interfaces/IVisor.sol\";\n9 import \"./vVISR.sol\";\n\n10 // @title Rewards Hypervisor\n11 // @notice fractionalize balance \n12 contract RewardsHypervisor {\n13     using SafeERC20 for IERC20;\n14     using SafeMath for uint256;\n\n15     address public owner;\n16     IERC20 public visr;\n17     vVISR public vvisr;\n\n18     modifier onlyOwner {     \n19         _;\n20     }\n\n21     constructor(\n22         address _visr,\n23         address _vvisr\n24     ) {\n25         visr = IERC20(_visr);\n26         vvisr = vVISR(_vvisr);\n27         owner = msg.sender;\n28     }\n\n29     function deposit(\n30         uint256 visrDeposit,\n31         address payable from,\n32         address to\n33     ) external returns (uint256 shares) {\n34         shares = visrDeposit;\n35         if (vvisr.totalSupply() != 0) {\n36           uint256 visrBalance = visr.balanceOf(address(this));\n37           shares = shares.mul(vvisr.totalSupply()).div(visrBalance);\n38         }\n\n39         //this is the buggy line \n40         //call the owner function of the attack contract. \n41         //As long as the attack contract sets the return value to the contract address\n42         // call the delegatedTransferERC20 function of the attack contract. \n43         //Here reentrancy is executed\n44         if(isContract(from)) {        \n45           //deposit func is called again \n46           IVisor(from).delegatedTransferERC20(address(visr), address(this), visrDeposit);\n47         }\n48         else {\n49           visr.safeTransferFrom(from, address(this), visrDeposit);\n50         }\n\n51         vvisr.mint(to, shares);\n52     }\n\n53     // @param shares Number of rewards shares to redeem for VISR\n54     // @param to Address to which redeemed pool assets are sent\n55     // @param from Address from which liquidity tokens are sent\n56     // @return rewards Amount of visr redeemed by the submitted liquidity tokens\n57     function withdraw(\n58         uint256 shares,\n59         address to,\n60         address payable from\n61     ) external returns (uint256 rewards) {\n62         rewards = visr.balanceOf(address(this)).mul(shares).div(vvisr.totalSupply());\n63         visr.safeTransfer(to, rewards);\n      \n64         vvisr.burn(from, shares);\n65     }\n\n66     function snapshot() external onlyOwner {\n67       vvisr.snapshot();\n68     }\n\n69     function transferOwnership(address newOwner) external onlyOwner {\n70       owner = newOwner;\n71     }\n\n72     function transferTokenOwnership(address newOwner) external onlyOwner {\n73       vvisr.transferOwnership(newOwner); \n74     }\n\n75     function isContract(address _addr) private returns (bool isContract){\n76                                 uint32 size;\n77                                 assembly {\n78                                         size := extcodesize(_addr)\n79                                 }\n80                                 return (size > 0);\n81                 }\n\n82 }\n44+\n",
    "transaction-context": "require(IVisor(from).owner() == msg.sender); \n",
    "Critical-points": "assert( IVisor(from) !=  address(this)); \n",
    "invariants": "require(shares > 0, \"shares\");\n require(from != address(0), \"from\");",
    "critical-invariants": "require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n",
    "ranks": " require(amount > 0, \"Invalid amount\");\n require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "vulnerabilities": "require(canTransfer, \"E046\");"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }\n10 \n11 // a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n12 \n13 library SafeMathSushiswap {\n14     function add(uint x, uint y) internal pure returns (uint z) {\n15         require((z = x + y) >= x, 'ds-math-add-overflow');\n16     }\n17 \n18     function sub(uint x, uint y) internal pure returns (uint z) {\n19         require((z = x - y) <= x, 'ds-math-sub-underflow');\n20     }\n21 \n22     function mul(uint x, uint y) internal pure returns (uint z) {\n23         require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n24     }\n25 }\n26 \n27 library SushiswapV2Library {\n28     using SafeMathSushiswap for uint;\n29 \n30     // returns sorted token addresses, used to handle return values from pairs sorted in this order\n31     function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n32         require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n33         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n34         require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n35     }\n36 \n37     // calculates the CREATE2 address for a pair without making any external calls\n38     function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n39         (address token0, address token1) = sortTokens(tokenA, tokenB);\n40         pair = address(uint160(uint256(keccak256(abi.encodePacked(\n41                 hex'ff',\n42                 factory,\n43                 keccak256(abi.encodePacked(token0, token1)),\n44                 hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n45             )))));\n46     }\n47 \n48     // fetches and sorts the reserves for a pair\n49     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n50         (address token0,) = sortTokens(tokenA, tokenB);\n51         (uint reserve0, uint reserve1,) = ISushiswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n52         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n53     }\n54 \n55     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n56     function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n57         require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58         require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n59         amountB = amountA.mul(reserveB) / reserveA;\n60     }\n61 \n62     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n63     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n64         require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n66         uint amountInWithFee = amountIn.mul(997);\n67         uint numerator = amountInWithFee.mul(reserveOut);\n68         uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n69         amountOut = numerator / denominator;\n70     }\n71 \n72     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n73     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n74         require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n76         uint numerator = reserveIn.mul(amountOut).mul(1000);\n77         uint denominator = reserveOut.sub(amountOut).mul(997);\n78         amountIn = (numerator / denominator).add(1);\n79     }\n80 \n81     // performs chained getAmountOut calculations on any number of pairs\n82     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n83         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n84         amounts = new uint[](path.length);\n85         amounts[0] = amountIn;\n86         for (uint i; i < path.length - 1; i++) {\n87             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n88             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n89         }\n90     }\n91 \n92     // performs chained getAmountIn calculations on any number of pairs\n93     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n94         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n95         amounts = new uint[](path.length);\n96         amounts[amounts.length - 1] = amountOut;\n97         for (uint i = path.length - 1; i > 0; i--) {\n98             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n99             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n100         }\n101     }\n102 }\n103 \n104 // helper methods for interacting with ERC20 tokens and sending NATIVE that do not consistently return true/false\n105 library TransferHelper {\n106     function safeApprove(address token, address to, uint value) internal {\n107         // bytes4(keccak256(bytes('approve(address,uint256)')));\n108         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n109         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n110     }\n111 \n112     function safeTransfer(address token, address to, uint value) internal {\n113         // bytes4(keccak256(bytes('transfer(address,uint256)')));\n114         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n115         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n116     }\n117 \n118     function safeTransferFrom(address token, address from, address to, uint value) internal {\n119         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n120         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n121         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n122     }\n123 \n124     function safeTransferNative(address to, uint value) internal {\n125         (bool success,) = to.call{value:value}(new bytes(0));\n126         require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n127     }\n128 }\n129 \n130 interface IwNATIVE {\n131     function deposit() external payable;\n132     function transfer(address to, uint value) external returns (bool);\n133     function withdraw(uint) external;\n134 }\n135 \n136 interface AnyswapV1ERC20 {\n137     function mint(address to, uint256 amount) external returns (bool);\n138     function burn(address from, uint256 amount) external returns (bool);\n139     function changeVault(address newVault) external returns (bool);\n140     function depositVault(uint amount, address to) external returns (uint);\n141     function withdrawVault(address from, uint amount, address to) external returns (uint);\n142     function underlying() external view returns (address);\n143 }\n144 \n145 /**\n146  * @dev Interface of the ERC20 standard as defined in the EIP.\n147  */\n148 interface IERC20 {\n149     function totalSupply() external view returns (uint256);\n150     function balanceOf(address account) external view returns (uint256);\n151     function transfer(address recipient, uint256 amount) external returns (bool);\n152     function allowance(address owner, address spender) external view returns (uint256);\n153     function approve(address spender, uint256 amount) external returns (bool);\n154     function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n155     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n156     function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n157 \n158     event Transfer(address indexed from, address indexed to, uint256 value);\n159     event Approval(address indexed owner, address indexed spender, uint256 value);\n160 }\n161 \n162 contract AnyswapV4Router {\n163     using SafeMathSushiswap for uint;\n164 \n165     address public immutable factory;\n166     address public immutable wNATIVE;\n167 \n168     modifier ensure(uint deadline) {\n169         require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n170         _;\n171     }\n172 \n173     constructor(address _factory, address _wNATIVE, address _mpc) {\n174         _newMPC = _mpc;\n175         _newMPCEffectiveTime = block.timestamp;\n176         factory = _factory;\n177         wNATIVE = _wNATIVE;\n178     }\n179 \n180     receive() external payable {\n181         assert(msg.sender == wNATIVE); // only accept Native via fallback from the wNative contract\n182     }\n183 \n184     address private _oldMPC;\n185     address private _newMPC;\n186     uint256 private _newMPCEffectiveTime;\n187 \n188 \n189     event LogChangeMPC(address indexed oldMPC, address indexed newMPC, uint indexed effectiveTime, uint chainID);\n190     event LogChangeRouter(address indexed oldRouter, address indexed newRouter, uint chainID);\n191     event LogAnySwapIn(bytes32 indexed txhash, address indexed token, address indexed to, uint amount, uint fromChainID, uint toChainID);\n192     event LogAnySwapOut(address indexed token, address indexed from, address indexed to, uint amount, uint fromChainID, uint toChainID);\n193     event LogAnySwapTradeTokensForTokens(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n194     event LogAnySwapTradeTokensForNative(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n195 \n196     modifier onlyMPC() {\n197         require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n198         _;\n199     }\n200 \n201     function mpc() public view returns (address) {\n202         if (block.timestamp >= _newMPCEffectiveTime) {\n203             return _newMPC;\n204         }\n205         return _oldMPC;\n206     }\n207 \n208     function cID() public view returns (uint id) {\n209         assembly {id := chainid()}\n210     }\n211 \n212     function changeMPC(address newMPC) public onlyMPC returns (bool) {\n213         require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n214         _oldMPC = mpc();\n215         _newMPC = newMPC;\n216         _newMPCEffectiveTime = block.timestamp + 2*24*3600;\n217         emit LogChangeMPC(_oldMPC, _newMPC, _newMPCEffectiveTime, cID());\n218         return true;\n219     }\n220 \n221     function changeVault(address token, address newVault) public onlyMPC returns (bool) {\n222         require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n223         return AnyswapV1ERC20(token).changeVault(newVault);\n224     }\n225 \n226     function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n227         AnyswapV1ERC20(token).burn(from, amount);\n228         emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n229     }\n230 \n231     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\n232     function anySwapOut(address token, address to, uint amount, uint toChainID) external {\n233         _anySwapOut(msg.sender, token, to, amount, toChainID);\n234     }\n235 \n236     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to` by minting with `underlying`\n237     function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external {\n238         TransferHelper.safeTransferFrom(AnyswapV1ERC20(token).underlying(), msg.sender, token, amount);\n239         AnyswapV1ERC20(token).depositVault(amount, msg.sender);\n240         _anySwapOut(msg.sender, token, to, amount, toChainID);\n241     }\n242 \n243     function anySwapOutUnderlyingWithPermit(\n244         address from,\n245         address token,\n246         address to,\n247         uint amount,\n248         uint deadline,\n249         uint8 v,\n250         bytes32 r,\n251         bytes32 s,\n252         uint toChainID\n253     ) external {\n254         address _underlying = AnyswapV1ERC20(token).underlying();\n255         IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n256         TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n257         AnyswapV1ERC20(token).depositVault(amount, from);\n258         _anySwapOut(from, token, to, amount, toChainID);\n259     }\n260 \n261     function anySwapOutUnderlyingWithTransferPermit(\n262         address from,\n263         address token,\n264         address to,\n265         uint amount,\n266         uint deadline,\n267         uint8 v,\n268         bytes32 r,\n269         bytes32 s,\n270         uint toChainID\n271     ) external {\n272         IERC20(AnyswapV1ERC20(token).underlying()).transferWithPermit(from, token, amount, deadline, v, r, s);\n273         AnyswapV1ERC20(token).depositVault(amount, from);\n274         _anySwapOut(from, token, to, amount, toChainID);\n275     }\n276 \n277     function anySwapOut(address[] calldata tokens, address[] calldata to, uint[] calldata amounts, uint[] calldata toChainIDs) external {\n278         for (uint i = 0; i < tokens.length; i++) {\n279             _anySwapOut(msg.sender, tokens[i], to[i], amounts[i], toChainIDs[i]);\n280         }\n281     }\n282 \n283     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n284     function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n285         AnyswapV1ERC20(token).mint(to, amount);\n286         emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n287     }\n288 \n289     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n290     // triggered by `anySwapOut`\n291     function anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n292         _anySwapIn(txs, token, to, amount, fromChainID);\n293     }\n294 \n295     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying`\n296     function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n297         _anySwapIn(txs, token, to, amount, fromChainID);\n298         AnyswapV1ERC20(token).withdrawVault(to, amount, to);\n299     }\n300 \n301     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying` if possible\n302     function anySwapInAuto(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n303         _anySwapIn(txs, token, to, amount, fromChainID);\n304         AnyswapV1ERC20 _anyToken = AnyswapV1ERC20(token);\n305         address _underlying = _anyToken.underlying();\n306         if (_underlying != address(0) && IERC20(_underlying).balanceOf(token) >= amount) {\n307             _anyToken.withdrawVault(to, amount, to);\n308         }\n309     }\n310 \n311     // extracts mpc fee from bridge fees\n312     function anySwapFeeTo(address token, uint amount) external onlyMPC {\n313         address _mpc = mpc();\n314         AnyswapV1ERC20(token).mint(_mpc, amount);\n315         AnyswapV1ERC20(token).withdrawVault(_mpc, amount, _mpc);\n316     }\n317 \n318     function anySwapIn(bytes32[] calldata txs, address[] calldata tokens, address[] calldata to, uint256[] calldata amounts, uint[] calldata fromChainIDs) external onlyMPC {\n319         for (uint i = 0; i < tokens.length; i++) {\n320             _anySwapIn(txs[i], tokens[i], to[i], amounts[i], fromChainIDs[i]);\n321         }\n322     }\n323 \n324     // **** SWAP ****\n325     // requires the initial amount to have already been sent to the first pair\n326     function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n327         for (uint i; i < path.length - 1; i++) {\n328             (address input, address output) = (path[i], path[i + 1]);\n329             (address token0,) = SushiswapV2Library.sortTokens(input, output);\n330             uint amountOut = amounts[i + 1];\n331             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n332             address to = i < path.length - 2 ? SushiswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n333             ISushiswapV2Pair(SushiswapV2Library.pairFor(factory, input, output)).swap(\n334                 amount0Out, amount1Out, to, new bytes(0)\n335             );\n336         }\n337     }\n338 \n339     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n340     function anySwapOutExactTokensForTokens(\n341         uint amountIn,\n342         uint amountOutMin,\n343         address[] calldata path,\n344         address to,\n345         uint deadline,\n346         uint toChainID\n347     ) external virtual ensure(deadline) {\n348         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n349         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n350     }\n351 \n352     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n353     function anySwapOutExactTokensForTokensUnderlying(\n354         uint amountIn,\n355         uint amountOutMin,\n356         address[] calldata path,\n357         address to,\n358         uint deadline,\n359         uint toChainID\n360     ) external virtual ensure(deadline) {\n361         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n362         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n363         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n364         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n365     }\n366 \n367     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n368     function anySwapOutExactTokensForTokensUnderlyingWithPermit(\n369         address from,\n370         uint amountIn,\n371         uint amountOutMin,\n372         address[] calldata path,\n373         address to,\n374         uint deadline,\n375         uint8 v,\n376         bytes32 r,\n377         bytes32 s,\n378         uint toChainID\n379     ) external virtual ensure(deadline) {\n380         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n381         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n382         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n383         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n384         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n385         {\n386         address[] memory _path = path;\n387         address _from = from;\n388         address _to = to;\n389         uint _amountIn = amountIn;\n390         uint _amountOutMin = amountOutMin;\n391         uint _cID = cID();\n392         uint _toChainID = toChainID;\n393         emit LogAnySwapTradeTokensForTokens(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n394         }\n395     }\n396 \n397     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n398     function anySwapOutExactTokensForTokensUnderlyingWithTransferPermit(\n399         address from,\n400         uint amountIn,\n401         uint amountOutMin,\n402         address[] calldata path,\n403         address to,\n404         uint deadline,\n405         uint8 v,\n406         bytes32 r,\n407         bytes32 s,\n408         uint toChainID\n409     ) external virtual ensure(deadline) {\n410         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n411         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n412         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n413         emit LogAnySwapTradeTokensForTokens(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n414     }\n415 \n416     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n417     // Triggered by `anySwapOutExactTokensForTokens`\n418     function anySwapInExactTokensForTokens(\n419         bytes32 txs,\n420         uint amountIn,\n421         uint amountOutMin,\n422         address[] calldata path,\n423         address to,\n424         uint deadline,\n425         uint fromChainID\n426     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n427         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n428         require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n429         _anySwapIn(txs, path[0], SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n430         _swap(amounts, path, to);\n431     }\n432 \n433     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n434     function anySwapOutExactTokensForNative(\n435         uint amountIn,\n436         uint amountOutMin,\n437         address[] calldata path,\n438         address to,\n439         uint deadline,\n440         uint toChainID\n441     ) external virtual ensure(deadline) {\n442         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n443         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n444     }\n445 \n446     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n447     function anySwapOutExactTokensForNativeUnderlying(\n448         uint amountIn,\n449         uint amountOutMin,\n450         address[] calldata path,\n451         address to,\n452         uint deadline,\n453         uint toChainID\n454     ) external virtual ensure(deadline) {\n455         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n456         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n457         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n458         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n459     }\n460 \n461     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n462     function anySwapOutExactTokensForNativeUnderlyingWithPermit(\n463         address from,\n464         uint amountIn,\n465         uint amountOutMin,\n466         address[] calldata path,\n467         address to,\n468         uint deadline,\n469         uint8 v,\n470         bytes32 r,\n471         bytes32 s,\n472         uint toChainID\n473     ) external virtual ensure(deadline) {\n474         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n475         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n476         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n477         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n478         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n479         {\n480         address[] memory _path = path;\n481         address _from = from;\n482         address _to = to;\n483         uint _amountIn = amountIn;\n484         uint _amountOutMin = amountOutMin;\n485         uint _cID = cID();\n486         uint _toChainID = toChainID;\n487         emit LogAnySwapTradeTokensForNative(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n488         }\n489     }\n490 \n491     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n492     function anySwapOutExactTokensForNativeUnderlyingWithTransferPermit(\n493         address from,\n494         uint amountIn,\n495         uint amountOutMin,\n496         address[] calldata path,\n497         address to,\n498         uint deadline,\n499         uint8 v,\n500         bytes32 r,\n501         bytes32 s,\n502         uint toChainID\n503     ) external virtual ensure(deadline) {\n504         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n505         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n506         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n507         emit LogAnySwapTradeTokensForNative(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n508     }\n509 \n510     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n511     // Triggered by `anySwapOutExactTokensForNative`\n512     function anySwapInExactTokensForNative(\n513         bytes32 txs,\n514         uint amountIn,\n515         uint amountOutMin,\n516         address[] calldata path,\n517         address to,\n518         uint deadline,\n519         uint fromChainID\n520     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n521         require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n522         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n523         require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');\n524         _anySwapIn(txs, path[0],  SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n525         _swap(amounts, path, address(this));\n526         IwNATIVE(wNATIVE).withdraw(amounts[amounts.length - 1]);\n527         TransferHelper.safeTransferNative(to, amounts[amounts.length - 1]);\n528     }\n529 \n530     // **** LIBRARY FUNCTIONS ****\n531     function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {\n532         return SushiswapV2Library.quote(amountA, reserveA, reserveB);\n533     }\n534 \n535     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n536         public\n537         pure\n538         virtual\n539         returns (uint amountOut)\n540     {\n541         return SushiswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n542     }\n543 \n544     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n545         public\n546         pure\n547         virtual\n548         returns (uint amountIn)\n549     {\n550         return SushiswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n551     }\n552 \n553     function getAmountsOut(uint amountIn, address[] memory path)\n554         public\n555         view\n556         virtual\n557         returns (uint[] memory amounts)\n558     {\n559         return SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n560     }\n561 \n562     function getAmountsIn(uint amountOut, address[] memory path)\n563         public\n564         view\n565         virtual\n566         returns (uint[] memory amounts)\n567     {\n568         return SushiswapV2Library.getAmountsIn(factory, amountOut, path);\n569     }\n570 }\n94+\n",
    "transaction-context": "require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');",
    "Critical-points": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');",
    "invariants": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');",
    "critical-invariants": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');",
    "ranks": "require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');",
    "vulnerabilities": "modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }"
  },
  {
    "code": "1 contract Example {\n2     function flash(\n3         address recipient,\n4         uint256 amount0,\n5         uint256 amount1,\n6         bytes calldata data\n7     ) external isFlashable globallyTransactable transactable isNotEmergency {\n8         uint256 fee = curve.epsilon.mulu(1e18);\n9         \n10         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n11         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n12 \n13         uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n14         uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n15 \n16         if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n17         if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n18 \n19         IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n20 \n21         uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n22         uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n23 \n24         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n25         uint256 paid0 = balance0After - balance0Before;\n26         uint256 paid1 = balance1After - balance1Before;\n27 \n28         IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n29         IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n30 \n31         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n32     }  \n33 }  \n",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are 1+ \n7 \n8+\n9+ \n22+ \n23+ ",
    "invariants": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "critical-invariants": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "ranks": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "vulnerabilities": "money market"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 \n10 import \"\"./lib/FullMath.sol\"\";\n11 \n12 import \"\"./lib/NoDelegateCall.sol\"\";\n13 \n14 import \"\"./Orchestrator.sol\"\";\n15 \n16 import \"\"./ProportionalLiquidity.sol\"\";\n17 \n18 import \"\"./Swaps.sol\"\";\n19 \n20 import \"\"./ViewLiquidity.sol\"\";\n21 \n22 import \"\"./Storage.sol\"\";\n23 \n24 import \"\"./MerkleProver.sol\"\";\n25 \n26 import \"\"./interfaces/IFreeFromUpTo.sol\"\";\n27 \n28 import \"\"./interfaces/ICurveFactory.sol\"\";\n29 \n30 import \"\"./Structs.sol\"\";\n31 \n32 library Curves {\n33     using ABDKMath64x64 for int128;\n34 \n35     event Approval(address indexed _owner, address indexed spender, uint256 value);\n36     event Transfer(address indexed from, address indexed to, uint256 value);\n37 \n38     function add(\n39         uint256 x,\n40         uint256 y,\n41         string memory errorMessage\n42     ) private pure returns (uint256 z) {\n43         require((z = x + y) >= x, errorMessage);\n44     }\n45 \n46     function sub(\n47         uint256 x,\n48         uint256 y,\n49         string memory errorMessage\n50     ) private pure returns (uint256 z) {\n51         require((z = x - y) <= x, errorMessage);\n52     }\n53 \n54     /**\n55      * @dev See {IERC20-transfer}.\n56      *\n57      * Requirements:\n58      *\n59      * - `recipient` cannot be the zero address.\n60      * - the caller must have a balance of at least `amount`.\n61      */\n62     function transfer(\n63         Storage.Curve storage curve,\n64         address recipient,\n65         uint256 amount\n66     ) external returns (bool) {\n67         _transfer(curve, msg.sender, recipient, amount);\n68         return true;\n69     }\n70 \n71     /**\n72      * @dev See {IERC20-approve}.\n73      *\n74      * Requirements:\n75      *\n76      * - `spender` cannot be the zero address.\n77      */\n78     function approve(\n79         Storage.Curve storage curve,\n80         address spender,\n81         uint256 amount\n82     ) external returns (bool) {\n83         _approve(curve, msg.sender, spender, amount);\n84         return true;\n85     }\n86 \n87     /**\n88      * @dev See {IERC20-transferFrom}.\n89      *\n90      * Emits an {Approval} event indicating the updated allowance. This is not\n91      * required by the EIP. See the note at the beginning of {ERC20};\n92      *\n93      * Requirements:\n94      * - `sender` and `recipient` cannot be the zero address.\n95      * - `sender` must have a balance of at least `amount`.\n96      * - the caller must have allowance for `sender`'s tokens of at least\n97      * `amount`\n98      */\n99     function transferFrom(\n100         Storage.Curve storage curve,\n101         address sender,\n102         address recipient,\n103         uint256 amount\n104     ) external returns (bool) {\n105         _transfer(curve, sender, recipient, amount);\n106         _approve(\n107             curve,\n108             sender,\n109             msg.sender,\n110             sub(curve.allowances[sender][msg.sender], amount, \"\"Curve/insufficient-allowance\"\")\n111         );\n112         return true;\n113     }\n114 \n115     /**\n116      * @dev Atomically increases the allowance granted to `spender` by the caller.\n117      *\n118      * This is an alternative to {approve} that can be used as a mitigation for\n119      * problems described in {IERC20-approve}.\n120      *\n121      * Emits an {Approval} event indicating the updated allowance.\n122      *\n123      * Requirements:\n124      *\n125      * - `spender` cannot be the zero address.\n126      */\n127     function increaseAllowance(\n128         Storage.Curve storage curve,\n129         address spender,\n130         uint256 addedValue\n131     ) external returns (bool) {\n132         _approve(\n133             curve,\n134             msg.sender,\n135             spender,\n136             add(curve.allowances[msg.sender][spender], addedValue, \"\"Curve/approval-overflow\"\")\n137         );\n138         return true;\n139     }\n140 \n141     /**\n142      * @dev Atomically decreases the allowance granted to `spender` by the caller.\n143      *\n144      * This is an alternative to {approve} that can be used as a mitigation for\n145      * problems described in {IERC20-approve}.\n146      *\n147      * Emits an {Approval} event indicating the updated allowance.\n148      *\n149      * Requirements:\n150      *\n151      * - `spender` cannot be the zero address.\n152      * - `spender` must have allowance for the caller of at least\n153      * `subtractedValue`.\n154      */\n155     function decreaseAllowance(\n156         Storage.Curve storage curve,\n157         address spender,\n158         uint256 subtractedValue\n159     ) external returns (bool) {\n160         _approve(\n161             curve,\n162             msg.sender,\n163             spender,\n164             sub(curve.allowances[msg.sender][spender], subtractedValue, \"\"Curve/allowance-decrease-underflow\"\")\n165         );\n166         return true;\n167     }\n168 \n169     /**\n170      * @dev Moves tokens `amount` from `sender` to `recipient`.\n171      *\n172      * This is public function is equivalent to {transfer}, and can be used to\n173      * e.g. implement automatic token fees, slashing mechanisms, etc.\n174      *\n175      * Emits a {Transfer} event.\n176      *\n177      * Requirements:\n178      *\n179      * - `sender` cannot be the zero address.\n180      * - `recipient` cannot be the zero address.\n181      * - `sender` must have a balance of at least `amount`.\n182      */\n183     function _transfer(\n184         Storage.Curve storage curve,\n185         address sender,\n186         address recipient,\n187         uint256 amount\n188     ) private {\n189         require(sender != address(0), \"\"ERC20: transfer from the zero address\"\");\n190         require(recipient != address(0), \"\"ERC20: transfer to the zero address\"\");\n191 \n192         curve.balances[sender] = sub(curve.balances[sender], amount, \"\"Curve/insufficient-balance\"\");\n193         curve.balances[recipient] = add(curve.balances[recipient], amount, \"\"Curve/transfer-overflow\"\");\n194         emit Transfer(sender, recipient, amount);\n195     }\n196 \n197     /**\n198      * @dev Sets `amount` as the allowance of `spender` over the `_owner`s tokens.\n199      *\n200      * This is public function is equivalent to `approve`, and can be used to\n201      * e.g. set automatic allowances for certain subsystems, etc.\n202      *\n203      * Emits an {Approval} event.\n204      *\n205      * Requirements:\n206      *\n207      * - `_owner` cannot be the zero address.\n208      * - `spender` cannot be the zero address.\n209      */\n210     function _approve(\n211         Storage.Curve storage curve,\n212         address _owner,\n213         address spender,\n214         uint256 amount\n215     ) private {\n216         require(_owner != address(0), \"\"ERC20: approve from the zero address\"\");\n217         require(spender != address(0), \"\"ERC20: approve to the zero address\"\");\n218 \n219         curve.allowances[_owner][spender] = amount;\n220         emit Approval(_owner, spender, amount);\n221     }\n222 }\n223 \n224 contract Curve is Storage, MerkleProver, NoDelegateCall {\n225     using SafeMath for uint256;\n226     using ABDKMath64x64 for int128;\n227     using SafeERC20 for IERC20;\n228 \n229     address private curveFactory;\n230 \n231     event Approval(address indexed _owner, address indexed spender, uint256 value);\n232 \n233     event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\n234 \n235     event AssetIncluded(address indexed numeraire, address indexed reserve, uint256 weight);\n236 \n237     event AssimilatorIncluded(\n238         address indexed derivative,\n239         address indexed numeraire,\n240         address indexed reserve,\n241         address assimilator\n242     );\n243 \n244     event PartitionRedeemed(address indexed token, address indexed redeemer, uint256 value);\n245 \n246     event OwnershipTransfered(address indexed previousOwner, address indexed newOwner);\n247 \n248     event FrozenSet(bool isFrozen);\n249 \n250     event EmergencyAlarm(bool isEmergency);\n251 \n252     event WhitelistingStopped();\n253 \n254     event Trade(\n255         address indexed trader,\n256         address indexed origin,\n257         address indexed target,\n258         uint256 originAmount,\n259         uint256 targetAmount\n260     );\n261 \n262     event Transfer(address indexed from, address indexed to, uint256 value);\n263 \n264     event Flash(address indexed from, address indexed to, uint256 value0, uint256 value1, uint256 paid0, uint256 paid1);\n265 \n266     modifier onlyOwner() {\n267         require(msg.sender == owner, \"\"Curve/caller-is-not-owner\"\");\n268         _;\n269     }\n270 \n271     modifier nonReentrant() {\n272         require(notEntered, \"\"Curve/re-entered\"\");\n273         notEntered = false;\n274         _;\n275         notEntered = true;\n276     }\n277 \n278     modifier transactable() {\n279         require(!frozen, \"\"Curve/frozen-only-allowing-proportional-withdraw\"\");\n280         _;\n281     }\n282 \n283     modifier isEmergency() {\n284         require(emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n285         _;\n286     }\n287 \n288     modifier isNotEmergency() {\n289         require(!emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n290         _;\n291     }\n292 \n293     modifier deadline(uint256 _deadline) {\n294         require(block.timestamp < _deadline, \"\"Curve/tx-deadline-passed\"\");\n295         _;\n296     }\n297 \n298     modifier inWhitelistingStage() {\n299         require(whitelistingStage, \"\"Curve/whitelist-stage-stopped\"\");\n300         _;\n301     }\n302 \n303     modifier notInWhitelistingStage() {\n304         require(!whitelistingStage, \"\"Curve/whitelist-stage-on-going\"\");\n305         _;\n306     }\n307 \n308     modifier globallyTransactable() {\n309         require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"\"Curve/frozen-globally-only-allowing-proportional-withdraw\"\");\n310         _;\n311     }\n312     \n313     modifier isFlashable() {\n314         require(ICurveFactory(address(curveFactory)).getFlashableState(), \"\"Curve/flashloans-paused\"\");\n315         _;\n316     }\n317 \n318     constructor(\n319         string memory _name,\n320         string memory _symbol,\n321         address[] memory _assets,\n322         uint256[] memory _assetWeights,\n323         address _factory\n324     ) {\n325         owner = msg.sender;\n326         name = _name;\n327         symbol = _symbol;\n328         curveFactory = _factory;\n329         emit OwnershipTransfered(address(0), msg.sender);\n330 \n331         Orchestrator.initialize(curve, numeraires, reserves, derivatives, _assets, _assetWeights);\n332     }\n333 \n334     /// @notice sets the parameters for the pool\n335     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n336     /// @param _beta the value for beta must be less than alpha and greater than 0\n337     /// @param _feeAtHalt the maximum value for the fee at the halt point\n338     /// @param _epsilon the base fee for the pool\n339     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n340     function setParams(\n341         uint256 _alpha,\n342         uint256 _beta,\n343         uint256 _feeAtHalt,\n344         uint256 _epsilon,\n345         uint256 _lambda\n346     ) external onlyOwner {\n347         Orchestrator.setParams(curve, _alpha, _beta, _feeAtHalt, _epsilon, _lambda);\n348     }\n349 \n350     /// @notice excludes an assimilator from the curve\n351     /// @param _derivative the address of the assimilator to exclude\n352     function excludeDerivative(address _derivative) external onlyOwner {\n353         for (uint256 i = 0; i < numeraires.length; i++) {\n354             if (_derivative == numeraires[i]) revert(\"\"Curve/cannot-delete-numeraire\"\");\n355             if (_derivative == reserves[i]) revert(\"\"Curve/cannot-delete-reserve\"\");\n356         }\n357 \n358         delete curve.assimilators[_derivative];\n359     }\n360 \n361     /// @notice view the current parameters of the curve\n362     /// @return alpha_ the current alpha value\n363     ///  beta_ the current beta value\n364     ///  delta_ the current delta value\n365     ///  epsilon_ the current epsilon value\n366     ///  lambda_ the current lambda value\n367     ///  omega_ the current omega value\n368     function viewCurve()\n369         external\n370         view\n371         returns (\n372             uint256 alpha_,\n373             uint256 beta_,\n374             uint256 delta_,\n375             uint256 epsilon_,\n376             uint256 lambda_\n377         )\n378     {\n379         return Orchestrator.viewCurve(curve);\n380     }\n381 \n382     function turnOffWhitelisting() external onlyOwner {\n383         emit WhitelistingStopped();\n384 \n385         whitelistingStage = false;\n386     }\n387 \n388     function setEmergency(bool _emergency) external onlyOwner {\n389         emit EmergencyAlarm(_emergency);\n390 \n391         emergency = _emergency;\n392     }\n393 \n394     function setFrozen(bool _toFreezeOrNotToFreeze) external onlyOwner {\n395         emit FrozenSet(_toFreezeOrNotToFreeze);\n396 \n397         frozen = _toFreezeOrNotToFreeze;\n398     }\n399 \n400     function transferOwnership(address _newOwner) external onlyOwner {\n401         require(_newOwner != address(0), \"\"Curve/new-owner-cannot-be-zeroth-address\"\");\n402 \n403         emit OwnershipTransfered(owner, _newOwner);\n404 \n405         owner = _newOwner;\n406     }\n407 \n408     /// @notice swap a dynamic origin amount for a fixed target amount\n409     /// @param _origin the address of the origin\n410     /// @param _target the address of the target\n411     /// @param _originAmount the origin amount\n412     /// @param _minTargetAmount the minimum target amount\n413     /// @param _deadline deadline in block number after which the trade will not execute\n414     /// @return targetAmount_ the amount of target that has been swapped for the origin amount\n415     function originSwap(\n416         address _origin,\n417         address _target,\n418         uint256 _originAmount,\n419         uint256 _minTargetAmount,\n420         uint256 _deadline\n421     ) external deadline(_deadline) globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant returns (uint256 targetAmount_) {\n422         OriginSwapData memory _swapData;\n423         _swapData._origin = _origin;\n424         _swapData._target = _target;\n425         _swapData._originAmount = _originAmount;\n426         _swapData._recipient = msg.sender;\n427         _swapData._curveFactory = curveFactory;\n428         targetAmount_ = Swaps.originSwap(curve, _swapData);\n429         // targetAmount_ = Swaps.originSwap(curve, _origin, _target, _originAmount, msg.sender,curveFactory);\n430 \n431         require(targetAmount_ >= _minTargetAmount, \"\"Curve/below-min-target-amount\"\");\n432     }\n433 \n434     /// @notice view how much target amount a fixed origin amount will swap for\n435     /// @param _origin the address of the origin\n436     /// @param _target the address of the target\n437     /// @param _originAmount the origin amount\n438     /// @return targetAmount_ the target amount that would have been swapped for the origin amount\n439     function viewOriginSwap(\n440         address _origin,\n441         address _target,\n442         uint256 _originAmount\n443     ) external view globallyTransactable transactable returns (uint256 targetAmount_) {\n444         targetAmount_ = Swaps.viewOriginSwap(curve, _origin, _target, _originAmount);\n445     }\n446 \n447     /// @notice swap a dynamic origin amount for a fixed target amount\n448     /// @param _origin the address of the origin\n449     /// @param _target the address of the target\n450     /// @param _maxOriginAmount the maximum origin amount\n451     /// @param _targetAmount the target amount\n452     /// @param _deadline deadline in block number after which the trade will not execute\n453     /// @return originAmount_ the amount of origin that has been swapped for the target\n454     function targetSwap(\n455         address _origin,\n456         address _target,\n457         uint256 _maxOriginAmount,\n458         uint256 _targetAmount,\n459         uint256 _deadline\n460     ) external deadline(_deadline) globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant returns (uint256 originAmount_) {\n461         TargetSwapData memory _swapData;\n462         _swapData._origin = _origin;\n463         _swapData._target = _target;\n464         _swapData._targetAmount = _targetAmount;\n465         _swapData._recipient = msg.sender;\n466         _swapData._curveFactory = curveFactory;\n467         originAmount_ = Swaps.targetSwap(curve, _swapData);\n468         // originAmount_ = Swaps.targetSwap(curve, _origin, _target, _targetAmount, msg.sender,curveFactory);\n469 \n470         require(originAmount_ <= _maxOriginAmount, \"\"Curve/above-max-origin-amount\"\");\n471     }\n472 \n473     /// @notice view how much of the origin currency the target currency will take\n474     /// @param _origin the address of the origin\n475     /// @param _target the address of the target\n476     /// @param _targetAmount the target amount\n477     /// @return originAmount_ the amount of target that has been swapped for the origin\n478     function viewTargetSwap(\n479         address _origin,\n480         address _target,\n481         uint256 _targetAmount\n482     ) external view globallyTransactable transactable returns (uint256 originAmount_) {\n483         originAmount_ = Swaps.viewTargetSwap(curve, _origin, _target, _targetAmount);\n484     }\n485 \n486     /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n487     /// @param  index Index corresponding to the merkleProof\n488     /// @param  account Address coorresponding to the merkleProof\n489     /// @param  amount Amount coorresponding to the merkleProof, should always be 1\n490     /// @param  merkleProof Merkle proof\n491     /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n492     ///                  the numeraire assets of the pool\n493     /// @return (the amount of curves you receive in return for your deposit,\n494     ///          the amount deposited for each numeraire)\n495     function depositWithWhitelist(\n496         uint256 index,\n497         address account,\n498         uint256 amount,\n499         bytes32[] calldata merkleProof,\n500         uint256 _deposit,\n501         uint256 _deadline\n502     ) external deadline(_deadline) globallyTransactable transactable nonReentrant noDelegateCall inWhitelistingStage returns (uint256, uint256[] memory) {\n503         require(amount == 1, \"\"Curve/invalid-amount\"\");\n504         require(index <= 473, \"\"Curve/index-out-of-range\"\" );\n505         require(isWhitelisted(index, account, amount, merkleProof), \"\"Curve/not-whitelisted\"\");\n506         require(msg.sender == account, \"\"Curve/not-approved-user\"\");\n507 \n508         (uint256 curvesMinted_, uint256[] memory deposits_) =\n509             ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n510 \n511         whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].add(curvesMinted_);\n512 \n513         // 10k max deposit\n514         if (whitelistedDeposited[msg.sender] > 10000e18) {\n515             revert(\"\"Curve/exceed-whitelist-maximum-deposit\"\");\n516         }\n517 \n518         return (curvesMinted_, deposits_);\n519     }\n520 \n521     /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n522     /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n523     ///                  the numeraire assets of the pool\n524     /// @return (the amount of curves you receive in return for your deposit,\n525     ///          the amount deposited for each numeraire)\n526     function deposit(uint256 _deposit, uint256 _deadline)\n527         external\n528         deadline(_deadline)\n529         globallyTransactable\n530         transactable\n531         nonReentrant\n532         noDelegateCall\n533         notInWhitelistingStage\n534         isNotEmergency\n535         returns (uint256, uint256[] memory)\n536     {\n537         // (curvesMinted_,  deposits_)\n538         return ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n539     }\n540 \n541     /// @notice view deposits and curves minted a given deposit would return\n542     /// @param _deposit the full amount of stablecoins you want to deposit. Divided evenly according to the\n543     ///                 prevailing proportions of the numeraire assets of the pool\n544     /// @return (the amount of curves you receive in return for your deposit,\n545     ///          the amount deposited for each numeraire)\n546     function viewDeposit(uint256 _deposit) external view globallyTransactable transactable returns (uint256, uint256[] memory) {\n547         // curvesToMint_, depositsToMake_\n548         return ProportionalLiquidity.viewProportionalDeposit(curve, _deposit);\n549     }\n550 \n551     /// @notice  Emergency withdraw tokens in the event that the oracle somehow bugs out\n552     ///          and no one is able to withdraw due to the invariant check\n553     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n554     ///                        numeraire assets of the pool\n555     /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n556     function emergencyWithdraw(uint256 _curvesToBurn, uint256 _deadline)\n557         external\n558         isEmergency\n559         deadline(_deadline)\n560         nonReentrant\n561         noDelegateCall\n562         returns (uint256[] memory withdrawals_)\n563     {\n564         return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n565     }\n566 \n567     /// @notice  withdrawas amount of curve tokens from the the pool equally from the numeraire assets of the pool with no slippage\n568     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n569     ///                        numeraire assets of the pool\n570     /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n571     function withdraw(uint256 _curvesToBurn, uint256 _deadline)\n572         external\n573         deadline(_deadline)\n574         nonReentrant\n575         noDelegateCall\n576         isNotEmergency\n577         returns (uint256[] memory withdrawals_)\n578     {\n579         if (whitelistingStage) {\n580             whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].sub(_curvesToBurn);\n581         }\n582 \n583         return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n584     }\n585 \n586     /// @notice  views the withdrawal information from the pool\n587     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n588     ///                        numeraire assets of the pool\n589     /// @return the amonnts of numeraire assets withdrawn from the pool\n590     function viewWithdraw(uint256 _curvesToBurn) external view globallyTransactable transactable returns (uint256[] memory) {\n591         return ProportionalLiquidity.viewProportionalWithdraw(curve, _curvesToBurn);\n592     }\n593 \n594     function supportsInterface(bytes4 _interface) public pure returns (bool supports_) {\n595         supports_ =\n596             this.supportsInterface.selector == _interface || // erc165\n597             bytes4(0x7f5828d0) == _interface || // eip173\n598             bytes4(0x36372b07) == _interface; // erc20\n599     }\n600 \n601     /// @notice transfers curve tokens\n602     /// @param _recipient the address of where to send the curve tokens\n603     /// @param _amount the amount of curve tokens to send\n604     /// @return success_ the success bool of the call\n605     function transfer(address _recipient, uint256 _amount) public nonReentrant noDelegateCall isNotEmergency returns (bool success_) {\n606         success_ = Curves.transfer(curve, _recipient, _amount);\n607     }\n608 \n609     /// @notice transfers curve tokens from one address to another address\n610     /// @param _sender the account from which the curve tokens will be sent\n611     /// @param _recipient the account to which the curve tokens will be sent\n612     /// @param _amount the amount of curve tokens to transfer\n613     /// @return success_ the success bool of the call\n614     function transferFrom(\n615         address _sender,\n616         address _recipient,\n617         uint256 _amount\n618     ) public nonReentrant noDelegateCall isNotEmergency returns (bool success_) {\n619         success_ = Curves.transferFrom(curve, _sender, _recipient, _amount);\n620     }\n621 \n622     /// @notice approves a user to spend curve tokens on their behalf\n623     /// @param _spender the account to allow to spend from msg.sender\n624     /// @param _amount the amount to specify the spender can spend\n625     /// @return success_ the success bool of this call\n626     function approve(address _spender, uint256 _amount) public nonReentrant noDelegateCall returns (bool success_) {\n627         success_ = Curves.approve(curve, _spender, _amount);\n628     }\n629     \n630     function flash(\n631         address recipient,\n632         uint256 amount0,\n633         uint256 amount1,\n634         bytes calldata data\n635     ) external isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency {\n636         uint256 fee = curve.epsilon.mulu(1e18);\n637 \n638         require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639         require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n640         \n641         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n642         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n643 \n644         uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n645         uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n646 \n647         if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n648         if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n649 \n650         IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n651 \n652         uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n653         uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n654 \n655         require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656         require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\n657 \n658         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n659         uint256 paid0 = balance0After - balance0Before;\n660         uint256 paid1 = balance1After - balance1Before;\n661 \n662         IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n663         IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n664 \n665         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n666     }    \n667 \n668     /// @notice view the curve token balance of a given account\n669     /// @param _account the account to view the balance of\n670     /// @return balance_ the curve token ballance of the given account\n671     function balanceOf(address _account) public view returns (uint256 balance_) {\n672         balance_ = curve.balances[_account];\n673     }\n674 \n675     /// @notice views the total curve supply of the pool\n676     /// @return totalSupply_ the total supply of curve tokens\n677     function totalSupply() public view returns (uint256 totalSupply_) {\n678         totalSupply_ = curve.totalSupply;\n679     }\n680 \n681     /// @notice views the total allowance one address has to spend from another address\n682     /// @param _owner the address of the owner\n683     /// @param _spender the address of the spender\n684     /// @return allowance_ the amount the owner has allotted the spender\n685     function allowance(address _owner, address _spender) public view returns (uint256 allowance_) {\n686         allowance_ = curve.allowances[_owner][_spender];\n687     }\n688 \n689     /// @notice views the total amount of liquidity in the curve in numeraire value and format - 18 decimals\n690     /// @return total_ the total value in the curve\n691     /// @return individual_ the individual values in the curve\n692     function liquidity() public view returns (uint256 total_, uint256[] memory individual_) {\n693         return ViewLiquidity.viewLiquidity(curve);\n694     }\n695 \n696     /// @notice view the assimilator address for a derivative\n697     /// @return assimilator_ the assimilator address\n698     function assimilator(address _derivative) public view returns (address assimilator_) {\n699         assimilator_ = curve.assimilators[_derivative].addr;\n700     }\n701 }\"\t\"189 require(sender != address(0), \"\"ERC20: transfer from the zero address\"\");\n190 require(recipient != address(0), \"\"ERC20: transfer to the zero address\"\");\n216 require(_owner != address(0), \"\"ERC20: approve from the zero address\"\");\n217 require(spender != address(0), \"\"ERC20: approve to the zero address\"\");\n266     modifier onlyOwner() {\n           require(msg.sender == owner, \"\"Curve/caller-is-not-owner\"\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"\"Curve/re-entered\"\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"\"Curve/frozen-only-allowing-proportional-withdraw\"\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"\"Curve/tx-deadline-passed\"\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"\"Curve/whitelist-stage-stopped\"\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"\"Curve/whitelist-stage-on-going\"\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"\"Curve/frozen-globally-only-allowing-proportional-withdraw\"\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"\"Curve/flashloans-paused\"\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n401 require(_newOwner != address(0), \"\"Curve/new-owner-cannot-be-zeroth-address\"\");\n421  noDelegateCall isNotEmergency nonReentrant\n431  require(targetAmount_ >= _minTargetAmount, \"\"Curve/below-min-target-amount\"\");\n443 globallyTransactable transactable\n460 globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant \n470 require(originAmount_ <= _maxOriginAmount, \"\"Curve/above-max-origin-amount\"\");\n482 globallyTransactable transactable\n502     ) external deadline(_deadline) globallyTransactable transactable nonReentrant noDelegateCall inWhitelistingStage returns (uint256, uint256[] memory) {\n503 require(amount == 1, \"\"Curve/invalid-amount\"\");\n504 require(index <= 473, \"\"Curve/index-out-of-range\"\" );\n505 require(isWhitelisted(index, account, amount, merkleProof), \"\"Curve/not-whitelisted\"\");\n506 require(msg.sender == account, \"\"Curve/not-approved-user\"\");\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall\n635 isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency \n638 require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639 require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n655 require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656 require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\"\n388\n",
    "transaction-context": "onlyOwner",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": "require(_newOwner != address(0), \"\"Curve/new-owner-cannot-be-zeroth-address\"\");",
    "ranks": "noDelegateCall isNotEmergency nonReentrant",
    "vulnerabilities": "require(targetAmount_ >= _minTargetAmount, \"\"Curve/below-min-target-amount\"\");"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n\n2 contract ERC20Interface {\n3     function totalSupply() public view returns (uint);\n4     function balanceOf(address tokenOwner) public view returns (uint balance);\n5     function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n6     function transfer(address to, uint tokens) public returns (bool success);\n7     function approve(address spender, uint tokens) public returns (bool success);\n8     function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n9     event Transfer(address indexed from, address indexed to, uint tokens);\n10     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n11 }\n\n\n\n12 contract SafeMath {\n13     function safeAdd(uint a, uint b) public pure returns (uint c) {\n14         c = a + b;\n15         require(c >= a);\n16     }\n \n17 function safeSub(uint a, uint b) public pure returns (uint c) {\n18         require(b <= a); \n19         c = a - b; } \n\n20 function safeMul(uint a, uint b) public pure returns (uint c) { \n21         c = a * b; \n22  } \n\n23 function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0);\n24         c = a / b;\n25     }\n26 }\n\n\n27 contract AlloHash is ERC20Interface, SafeMath {\n28     string public name;\n29     string public symbol;\n30     uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n\n31     uint256 public _totalSupply;\n\n32     mapping(address => uint) balances;\n33     mapping(address => mapping(address => uint)) allowed;\n\n  \n34     constructor() public {\n35         name = \"AlloHash\";\n36         symbol = \"ALH\";\n37         decimals = 18;\n38         _totalSupply = 180000000000000000000000000;\n\n39         balances[msg.sender] = _totalSupply;\n40         emit Transfer(address(0), msg.sender, _totalSupply);\n41     }\n\n42     function totalSupply() public view returns (uint) {\n43         return _totalSupply  - balances[address(0)];\n44     }\n\n45     function balanceOf(address tokenOwner) public view returns (uint balance) {\n46         return balances[tokenOwner];\n47     }\n\n48     function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n49         return allowed[tokenOwner][spender];\n50     }\n\n51     function approve(address spender, uint tokens) public returns (bool success) {\n52         allowed[msg.sender][spender] = tokens;\n53         emit Approval(msg.sender, spender, tokens);\n54         return true;\n55     }\n\n56     function transfer(address to, uint tokens) public returns (bool success) {\n57         balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n58         balances[to] = safeAdd(balances[to], tokens);\n59         emit Transfer(msg.sender, to, tokens);\n60         return true;\n61     }\n\n62     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n63         balances[from] = safeSub(balances[from], tokens);\n64         allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n65         balances[to] = safeAdd(balances[to], tokens);\n66         emit Transfer(from, to, tokens);\n67         return true;\n68     }\n69 }\n17+\n",
    "transaction-context": "require(b <= a);",
    "Critical-points": " require(a == 0 || c / a == b);",
    "invariants": "assert(balances[msg.sender] >= _value);\n assert( _value > 0); ",
    "critical-invariants": "require(_to != address(0));\nrequire(_value <= balances[msg.sender]);",
    "ranks": "require(msg.sender == owner);",
    "vulnerabilities": "require(msg.sender == owner || msg.sender == operator); "
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";\n8 import \"./interfaces/IVisor.sol\";\n9 import \"./vVISR.sol\";\n\n10 // @title Rewards Hypervisor\n11 // @notice fractionalize balance \n12 contract RewardsHypervisor {\n13     using SafeERC20 for IERC20;\n14     using SafeMath for uint256;\n\n15     address public owner;\n16     IERC20 public visr;\n17     vVISR public vvisr;\n\n18     modifier onlyOwner {\n19         require(msg.sender == owner, \"only owner\");\n20         _;\n21     }\n\n22     constructor(\n23         address _visr,\n24         address _vvisr\n25     ) {\n26         visr = IERC20(_visr);\n27         vvisr = vVISR(_vvisr);\n28         owner = msg.sender;\n29     }\n\n30     function deposit(\n31         uint256 visrDeposit,\n32         address payable from,\n33         address to\n34     ) external returns (uint256 shares) {\n35         require(visrDeposit > 0, \"deposits must be nonzero\");\n36         require(to != address(0) && to != address(this), \"to\");\n37         require(from != address(0) && from != address(this), \"from\");\n\n38         shares = visrDeposit;\n39         if (vvisr.totalSupply() != 0) {\n40           uint256 visrBalance = visr.balanceOf(address(this));\n41           shares = shares.mul(vvisr.totalSupply()).div(visrBalance);\n42         }\n\n43         //this is the buggy line \n44         //call the owner function of the attack contract. \n45         //As long as the attack contract sets the return value to the contract address\n46         // call the delegatedTransferERC20 function of the attack contract. \n47         //Here reentrancy is executed\n48         if(isContract(from)) {\n49           require(IVisor(from).owner() == msg.sender); \n50           //deposit func is called again \n51           assert( IVisor(from) !=  address(this)); \n52           IVisor(from).delegatedTransferERC20(address(visr), address(this), visrDeposit);\n53         }\n54         else {\n55           visr.safeTransferFrom(from, address(this), visrDeposit);\n56         }\n\n57         vvisr.mint(to, shares);\n58     }\n\n59     // @param shares Number of rewards shares to redeem for VISR\n60     // @param to Address to which redeemed pool assets are sent\n61     // @param from Address from which liquidity tokens are sent\n62     // @return rewards Amount of visr redeemed by the submitted liquidity tokens\n63     function withdraw(\n64         uint256 shares,\n65         address to,\n66         address payable from\n67     ) external returns (uint256 rewards) {\n68         require(shares > 0, \"shares\");\n69         require(to != address(0), \"to\");\n70         require(from != address(0), \"from\");\n\n71         rewards = visr.balanceOf(address(this)).mul(shares).div(vvisr.totalSupply());\n72         visr.safeTransfer(to, rewards);\n\n73         require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n74         vvisr.burn(from, shares);\n75     }\n\n76     function snapshot() external onlyOwner {\n77       vvisr.snapshot();\n78     }\n\n79     function transferOwnership(address newOwner) external onlyOwner {\n80       owner = newOwner;\n81     }\n\n82     function transferTokenOwnership(address newOwner) external onlyOwner {\n83       vvisr.transferOwnership(newOwner); \n84     }\n\n85     function isContract(address _addr) private returns (bool isContract){\n86                                 uint32 size;\n87                                 assembly {\n88                                         size := extcodesize(_addr)\n89                                 }\n90                                 return (size > 0);\n91                 }\n\n92 }\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 19+         \n35+        \n36+       \n37+       \n49+         \n51+        \n68+        \n69+       \n70+        ",
    "invariants": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "critical-invariants": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "ranks": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "vulnerabilities": "incorrect visibility/ownership\nreentrancy"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../ERC1967/ERC1967Proxy.sol\";\n\n5 interface ITransparentUpgradeableProxy {\n6     event Upgraded(address indexed implementation);\n7     event AdminChanged(address previousAdmin, address newAdmin);\n8     function admin() external view returns (address);\n9     function implementation() external view returns (address);\n10     function changeAdmin(address) external;\n11     function upgradeTo(address) external;\n12     function upgradeToAndCall(address, bytes memory) payable external;\n13 }\n\n14 /**\n15  * @dev This contract implements a proxy that is upgradeable by an admin.\n16  *\n17  * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n18  * clashing], which can potentially be used in an attack, this contract uses the\n19  * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n20  * things that go hand in hand:\n21  *\n22  * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n23  * that call matches one of the admin functions exposed by the proxy itself.\n24  * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n25  * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n26  * \"admin cannot fallback to proxy target\".\n27  *\n28  * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n29  * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n30  * to sudden errors when trying to call a function from the proxy implementation.\n31  *\n32  * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n33  * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n34  */\n35 contract Proxy is ERC1967Proxy {\n36     /**\n37      * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n38      * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n39      */\n40     constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n41         _changeAdmin(admin_);\n42     }\n\n43     /**\n44      * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n45      */\n46     function _fallback() internal virtual override {\n47         if (msg.sender == _getAdmin()) {\n48             bytes memory ret;\n49             bytes4 selector = msg.sig;\n50             if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n51                 ret = _dispatchUpgradeTo();\n52             } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n53                 ret = _dispatchUpgradeToAndCall();\n54             } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n55                 ret = _dispatchChangeAdmin();\n56             } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n57                 ret = _dispatchAdmin();\n58             } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n59                 ret = _dispatchImplementation();\n60             } else {\n61                 revert('TransparentUpgradeableProxy: admin cannot fallback to proxy target');\n62             }\n63             assembly {\n64                 return(add(ret, 0x20), mload(ret))\n65             }\n66         } else {\n67             super._fallback();\n68         }\n69     }\n\n70     /**\n71      * @dev Returns the current admin.\n72      *\n73      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n74      * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n75      * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n76      */\n77     function _dispatchAdmin() private returns (bytes memory) {\n78         _requireZeroValue();\n\n79         address admin = _getAdmin();\n80         return abi.encode(admin);\n81     }\n\n82     /**\n83      * @dev Returns the current implementation.\n84      *\n85      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n86      * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n87      * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n88      */\n89     function _dispatchImplementation() private returns (bytes memory) {\n90         _requireZeroValue();\n\n91         address implementation = _implementation();\n92         return abi.encode(implementation);\n93     }\n\n94     /**\n95      * @dev Changes the admin of the proxy.\n96      */\n97     function _dispatchChangeAdmin() private returns (bytes memory) {\n98         _requireZeroValue();\n\n99         address newAdmin = abi.decode(msg.data[4:], (address));\n100         _changeAdmin(newAdmin);\n\n101         return \"\";\n102     }\n\n103     /**\n104      * @dev Upgrade the implementation of the proxy.\n105      */\n106     function _dispatchUpgradeTo() private returns (bytes memory) {\n107         _requireZeroValue();\n\n108         address newImplementation = abi.decode(msg.data[4:], (address));\n109         _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n110         return \"\";\n111     }\n\n112     /**\n113      * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n114      * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n115      * proxied contract.\n116      */\n117     function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n118         (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n119         _upgradeToAndCall(newImplementation, data, true);\n\n120         return \"\";\n121     }\n\n122     /**\n123      * @dev Returns the current admin.\n124      */\n125     function _admin() internal view virtual returns (address) {\n126         return _getAdmin();\n127     }\n\n128     /**\n129      * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n130      * emulate some proxy functions being non-payable while still allowing value to pass through.\n131      */\n132     function _requireZeroValue() private {\n133         require(msg.value == 0);\n134     }\n135 }\n108+ \n",
    "transaction-context": "assert(Old(newImplementation) == abi.decode(msg.data[4:], (address)));",
    "Critical-points": "assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\nassert(Old(newAdmin) != Old(newImplementation)); ",
    "invariants": "assert(signatures.length ==calldatas.length);\n",
    "critical-invariants": "assert(signatures.length ==calldatas.length);\n",
    "ranks": "assert(signatures.length ==calldatas.length);\n",
    "vulnerabilities": "assert(signatures.length ==calldatas.length);"
  },
  {
    "code": "1 //SPDX-License-Identifier: GPL-3.0\n2 pragma solidity 0.8.4;\n3 \n4 import \"../libraries/MathLib.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n7 import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n8 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n9 import \"../interfaces/IExchangeFactory.sol\";\n10 \n11 \n12 contract Exchange is ERC20, ReentrancyGuard {\n13     using MathLib for uint256;\n14     using SafeERC20 for IERC20;\n15 \n16     address public immutable baseToken; // address of ERC20 base token (elastic or fixed supply)\n17     address public immutable quoteToken; // address of ERC20 quote token (WETH or a stable coin w/ fixed supply)\n18     address public immutable exchangeFactoryAddress;\n19 \n20     uint256 public constant TOTAL_LIQUIDITY_FEE = 30; // fee provided to liquidity providers + DAO in basis points\n21 \n22     MathLib.InternalBalances public internalBalances =\n23         MathLib.InternalBalances(0, 0, 0);\n24 \n25     event AddLiquidity(\n26         address indexed liquidityProvider,\n27         uint256 baseTokenQtyAdded,\n28         uint256 quoteTokenQtyAdded\n29     );\n30     event RemoveLiquidity(\n31         address indexed liquidityProvider,\n32         uint256 baseTokenQtyRemoved,\n33         uint256 quoteTokenQtyRemoved\n34     );\n35     event Swap(\n36         address indexed sender,\n37         uint256 baseTokenQtyIn,\n38         uint256 quoteTokenQtyIn,\n39         uint256 baseTokenQtyOut,\n40         uint256 quoteTokenQtyOut\n41     );\n42 \n43 \n44     function isNotExpired(uint256 _expirationTimeStamp) internal view {\n45         require(_expirationTimeStamp >= block.timestamp, \"Exchange: EXPIRED\");\n46     }\n47 \n48   \n49     constructor(\n50         string memory _name,\n51         string memory _symbol,\n52         address _baseToken,\n53         address _quoteToken,\n54         address _exchangeFactoryAddress\n55     ) ERC20(_name, _symbol) {\n56         baseToken = _baseToken;\n57         quoteToken = _quoteToken;\n58         exchangeFactoryAddress = _exchangeFactoryAddress;\n59     }\n60 \n61 \n62     function addLiquidity(\n63         uint256 _baseTokenQtyDesired,\n64         uint256 _quoteTokenQtyDesired,\n65         uint256 _baseTokenQtyMin,\n66         uint256 _quoteTokenQtyMin,\n67         address _liquidityTokenRecipient,\n68         uint256 _expirationTimestamp\n69     ) external nonReentrant() {\n70         isNotExpired(_expirationTimestamp);\n71 \n72         MathLib.TokenQtys memory tokenQtys =\n73             MathLib.calculateAddLiquidityQuantities(\n74                 _baseTokenQtyDesired,\n75                 _quoteTokenQtyDesired,\n76                 _baseTokenQtyMin,\n77                 _quoteTokenQtyMin,\n78                 IERC20(baseToken).balanceOf(address(this)),\n79                 IERC20(quoteToken).balanceOf(address(this)),\n80                 this.totalSupply(),\n81                 internalBalances\n82             );\n83         //here is the buggy line \n84         internalBalances.kLast =\n85             internalBalances.baseTokenReserveQty /\n86             internalBalances.quoteTokenReserveQty;\n87 \n88         if (tokenQtys.liquidityTokenFeeQty > 0) {\n89             // mint liquidity tokens to fee address for k growth.\n90             _mint(\n91                 IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n92                 tokenQtys.liquidityTokenFeeQty\n93             );\n94         }\n95         _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient\n96 \n97         if (tokenQtys.baseTokenQty != 0) {\n98             bool isExchangeEmpty =\n99                 IERC20(baseToken).balanceOf(address(this)) == 0;\n100 \n101             // transfer base tokens to Exchange\n102             IERC20(baseToken).safeTransferFrom(\n103                 msg.sender,\n104                 address(this),\n105                 tokenQtys.baseTokenQty\n106             );\n107 \n108             if (isExchangeEmpty) {\n109                 require(\n110                     IERC20(baseToken).balanceOf(address(this)) ==\n111                         tokenQtys.baseTokenQty,\n112                     \"Exchange: FEE_ON_TRANSFER_NOT_SUPPORTED\"\n113                 );\n114             }\n115         }\n116 \n117         if (tokenQtys.quoteTokenQty != 0) {\n118             // transfer quote tokens to Exchange\n119             IERC20(quoteToken).safeTransferFrom(\n120                 msg.sender,\n121                 address(this),\n122                 tokenQtys.quoteTokenQty\n123             );\n124         }\n125 \n126         emit AddLiquidity(\n127             msg.sender,\n128             tokenQtys.baseTokenQty,\n129             tokenQtys.quoteTokenQty\n130         );\n131     }\n132 \n133    \n134     function removeLiquidity(\n135         uint256 _liquidityTokenQty,\n136         uint256 _baseTokenQtyMin,\n137         uint256 _quoteTokenQtyMin,\n138         address _tokenRecipient,\n139         uint256 _expirationTimestamp\n140     ) external nonReentrant() {\n141         isNotExpired(_expirationTimestamp);\n142         require(this.totalSupply() > 0, \"Exchange: INSUFFICIENT_LIQUIDITY\");\n143         require(\n144             _baseTokenQtyMin > 0 && _quoteTokenQtyMin > 0,\n145             \"Exchange: MINS_MUST_BE_GREATER_THAN_ZERO\"\n146         );\n147 \n148     \n149         uint256 baseTokenReserveQty =\n150             IERC20(baseToken).balanceOf(address(this));\n151         uint256 quoteTokenReserveQty =\n152             IERC20(quoteToken).balanceOf(address(this));\n153 \n154         uint256 totalSupplyOfLiquidityTokens = this.totalSupply();\n155         // calculate any DAO fees here.\n156         uint256 liquidityTokenFeeQty =\n157             MathLib.calculateLiquidityTokenFees(\n158                 totalSupplyOfLiquidityTokens,\n159                 internalBalances\n160             );\n161 \n162         totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;\n163 \n164         uint256 baseTokenQtyToReturn =\n165             (_liquidityTokenQty * baseTokenReserveQty) /\n166                 totalSupplyOfLiquidityTokens;\n167         uint256 quoteTokenQtyToReturn =\n168             (_liquidityTokenQty * quoteTokenReserveQty) /\n169                 totalSupplyOfLiquidityTokens;\n170 \n171         require(\n172             baseTokenQtyToReturn >= _baseTokenQtyMin,\n173             \"Exchange: INSUFFICIENT_BASE_QTY\"\n174         );\n175 \n176         require(\n177             quoteTokenQtyToReturn >= _quoteTokenQtyMin,\n178             \"Exchange: INSUFFICIENT_QUOTE_QTY\"\n179         );\n180 \n181         uint256 baseTokenQtyToRemoveFromInternalAccounting =\n182             (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /\n183                 totalSupplyOfLiquidityTokens;\n184 \n185         internalBalances\n186             .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;\n187 \n188 \n189         if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {\n190             internalBalances.quoteTokenReserveQty = 0;\n191         } else {\n192             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;\n193         }\n194 \n195         internalBalances.kLast =\n196             internalBalances.baseTokenReserveQty *\n197             internalBalances.quoteTokenReserveQty;\n198 \n199         if (liquidityTokenFeeQty > 0) {\n200             _mint(\n201                 IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n202                 liquidityTokenFeeQty\n203             );\n204         }\n205 \n206         _burn(msg.sender, _liquidityTokenQty);\n207         IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);\n208         IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);\n209         emit RemoveLiquidity(\n210             msg.sender,\n211             baseTokenQtyToReturn,\n212             quoteTokenQtyToReturn\n213         );\n214     }\n215 \n216     function swapBaseTokenForQuoteToken(\n217         uint256 _baseTokenQty,\n218         uint256 _minQuoteTokenQty,\n219         uint256 _expirationTimestamp\n220     ) external nonReentrant() {\n221         isNotExpired(_expirationTimestamp);\n222         require(\n223             _baseTokenQty > 0 && _minQuoteTokenQty > 0,\n224             \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n225         );\n226 \n227         uint256 quoteTokenQty =\n228             MathLib.calculateQuoteTokenQty(\n229                 _baseTokenQty,\n230                 _minQuoteTokenQty,\n231                 TOTAL_LIQUIDITY_FEE,\n232                 internalBalances\n233             );\n234 \n235         IERC20(baseToken).safeTransferFrom(\n236             msg.sender,\n237             address(this),\n238             _baseTokenQty\n239         );\n240 \n241         IERC20(quoteToken).safeTransfer(msg.sender, quoteTokenQty);\n242         emit Swap(msg.sender, _baseTokenQty, 0, 0, quoteTokenQty);\n243     }\n244 \n245 \n246     function swapQuoteTokenForBaseToken(\n247         uint256 _quoteTokenQty,\n248         uint256 _minBaseTokenQty,\n249         uint256 _expirationTimestamp\n250     ) external nonReentrant() {\n251         isNotExpired(_expirationTimestamp);\n252         require(\n253             _quoteTokenQty > 0 && _minBaseTokenQty > 0,\n254             \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n255         );\n256 \n257         uint256 baseTokenQty =\n258             MathLib.calculateBaseTokenQty(\n259                 _quoteTokenQty,\n260                 _minBaseTokenQty,\n261                 IERC20(baseToken).balanceOf(address(this)),\n262                 TOTAL_LIQUIDITY_FEE,\n263                 internalBalances\n264             );\n265 \n266         IERC20(quoteToken).safeTransferFrom(\n267             msg.sender,\n268             address(this),\n269             _quoteTokenQty\n270         );\n271 \n272         IERC20(baseToken).safeTransfer(msg.sender, baseTokenQty);\n273         emit Swap(msg.sender, 0, _quoteTokenQty, baseTokenQty, 0);\n274     }\n275 }\n",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 147+\n194+\n",
    "invariants": "147+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "critical-invariants": "194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "ranks": "194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";\n8 import \"../../utils/Context.sol\";\n9 import \"../../utils/Strings.sol\";\n10 import \"../../utils/introspection/ERC165.sol\";\n\n11 /**\n12  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n13  * the Metadata extension, but not including the Enumerable extension, which is available separately as\n14  * {ERC721Enumerable}.\n15  */\n16 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n17     using Address for address;\n18     using Strings for uint256;\n\n19     // Token name\n20     string private _name;\n\n21     // Token symbol\n22     string private _symbol;\n\n23     // Mapping from token ID to owner address\n24     mapping(uint256 => address) private _owners;\n\n25     // Mapping owner address to token count\n26     mapping(address => uint256) private _balances;\n\n27     // Mapping from token ID to approved address\n28     mapping(uint256 => address) private _tokenApprovals;\n\n29     // Mapping from owner to operator approvals\n30     mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n\n31     constructor(string memory name_, string memory symbol_) {\n32         _name = name_;\n33         _symbol = symbol_;\n34     }\n\n\n35     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n36         return\n37             interfaceId == type(IERC721).interfaceId ||\n38             interfaceId == type(IERC721Metadata).interfaceId ||\n39             super.supportsInterface(interfaceId);\n40     }\n\n\n41     function balanceOf(address owner) public view virtual override returns (uint256) {\n42         require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n43         return _balances[owner];\n44     }\n\n\n45     function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n46         address owner = _ownerOf(tokenId);\n47         require(owner != address(0), \"ERC721: invalid token ID\");\n48         return owner;\n49     }\n\n\n50     function name() public view virtual override returns (string memory) {\n51         return _name;\n52     }\n\n\n53     function symbol() public view virtual override returns (string memory) {\n54         return _symbol;\n55     }\n\n\n56     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n57         _requireMinted(tokenId);\n\n58         string memory baseURI = _baseURI();\n59         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n60     }\n\n\n61     function _baseURI() internal view virtual returns (string memory) {\n62         return \"\";\n63     }\n\n\n64     function approve(address to, uint256 tokenId) public virtual override {\n65         address owner = ERC721.ownerOf(tokenId);\n66         require(to != owner, \"ERC721: approval to current owner\");\n\n67         require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n\n68         _approve(to, tokenId);\n69     }\n\n\n70     function getApproved(uint256 tokenId) public view virtual override returns (address) {\n71         _requireMinted(tokenId);\n\n72         return _tokenApprovals[tokenId];\n73     }\n\n\n74     function setApprovalForAll(address operator, bool approved) public virtual override {\n75         _setApprovalForAll(_msgSender(), operator, approved);\n76     }\n\n\n77     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n78         return _operatorApprovals[owner][operator];\n79     }\n\n\n80     function transferFrom(\n81         address from,\n82         address to,\n83         uint256 tokenId\n84     ) public virtual override {\n85         //solhint-disable-next-line max-line-length\n86         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n             //watch out for flashloan attacks. Should we check here? \n87         _transfer(from, to, tokenId);\n88     }\n\n\n89     function safeTransferFrom(\n90         address from,\n91         address to,\n92         uint256 tokenId\n93     ) public virtual override {\n94         safeTransferFrom(from, to, tokenId, \"\");\n95     }\n\n96     function safeTransferFrom(\n97         address from,\n98         address to,\n99         uint256 tokenId,\n100         bytes memory data\n101     ) public virtual override {\n102         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n103         _safeTransfer(from, to, tokenId, data);\n104     }\n\n \n105     function _safeTransfer(\n106         address from,\n107         address to,\n108         uint256 tokenId,\n109         bytes memory data\n110     ) internal virtual {\n111         _transfer(from, to, tokenId);\n112         require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n113     }\n\n  \n114     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n115         return _owners[tokenId];\n116     }\n\n\n117     function _exists(uint256 tokenId) internal view virtual returns (bool) {\n118         return _ownerOf(tokenId) != address(0);\n119     }\n\n\n120     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n121         address owner = ERC721.ownerOf(tokenId);\n122         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n123     }\n\n\n124     function _safeMint(address to, uint256 tokenId) internal virtual {\n125         _safeMint(to, tokenId, \"\");\n126     }\n\n\n127     function _safeMint(\n128         address to,\n129         uint256 tokenId,\n130         bytes memory data\n131     ) internal virtual {\n132         _mint(to, tokenId);\n133         require(\n134             _checkOnERC721Received(address(0), to, tokenId, data),\n135             \"ERC721: transfer to non ERC721Receiver implementer\"\n136         );\n137     }\n\n\n138     function _mint(address to, uint256 tokenId) internal virtual {\n139         require(to != address(0), \"ERC721: mint to the zero address\");\n140         require(!_exists(tokenId), \"ERC721: token already minted\");\n\n141         _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n142         // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n143         require(!_exists(tokenId), \"ERC721: token already minted\");\n\n144         unchecked {\n145             // Will not overflow unless all 2**256 token ids are minted to the same owner.\n146             // Given that tokens are minted one by one, it is impossible in practice that\n147             // this ever happens. Might change if we allow batch minting.\n148             // The ERC fails to describe this case.\n149             _balances[to] += 1;\n150         }\n\n151         _owners[tokenId] = to;\n\n152         emit Transfer(address(0), to, tokenId);\n\n153         _afterTokenTransfer(address(0), to, tokenId, 1);\n154     }\n\n\n155     function _burn(uint256 tokenId) internal virtual {\n156         address owner = ERC721.ownerOf(tokenId);\n\n157         _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n158         // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n159         owner = ERC721.ownerOf(tokenId);\n\n160         // Clear approvals\n161         delete _tokenApprovals[tokenId];\n\n162         unchecked {\n163             // Cannot overflow, as that would require more tokens to be burned/transferred\n164             // out than the owner initially received through minting and transferring in.\n165             _balances[owner] -= 1;\n166         }\n167         delete _owners[tokenId];\n\n168         emit Transfer(owner, address(0), tokenId);\n\n169         _afterTokenTransfer(owner, address(0), tokenId, 1);\n170     }\n\n  \n171     function _transfer(\n172         address from,\n173         address to,\n174         uint256 tokenId\n175     ) internal virtual {\n176         require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n177         require(to != address(0), \"ERC721: transfer to the zero address\");\n\n178         _beforeTokenTransfer(from, to, tokenId, 1);\n\n179         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n180         require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n181         // Clear approvals from the previous owner\n182         delete _tokenApprovals[tokenId];\n\n183         unchecked {\n184             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n185             // `from`'s balance is the number of token held, which is at least one before the current\n186             // transfer.\n187             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n188             // all 2**256 token ids to be minted, which in practice is impossible.\n189             _balances[from] -= 1;\n190             _balances[to] += 1;\n191         }\n192         _owners[tokenId] = to;\n\n193         emit Transfer(from, to, tokenId);\n\n194         _afterTokenTransfer(from, to, tokenId, 1);\n195     }\n\n\n196     function _approve(address to, uint256 tokenId) internal virtual {\n197         _tokenApprovals[tokenId] = to;\n198         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n199     }\n\n\n200     function _setApprovalForAll(\n201         address owner,\n202         address operator,\n203         bool approved\n204     ) internal virtual {\n205         require(owner != operator, \"ERC721: approve to caller\");\n206         _operatorApprovals[owner][operator] = approved;\n207         emit ApprovalForAll(owner, operator, approved);\n208     }\n\n209     function _requireMinted(uint256 tokenId) internal view virtual {\n210         require(_exists(tokenId), \"ERC721: invalid token ID\");\n211     }\n\n\n\n212     function _checkOnERC721Received(\n213         address from,\n214         address to,\n215         uint256 tokenId,\n216         bytes memory data\n217     ) private returns (bool) {\n218         if (to.isContract()) {\n219             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n220                 return retval == IERC721Receiver.onERC721Received.selector;\n221             } catch (bytes memory reason) {\n222                 if (reason.length == 0) {\n223                     revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n224                 } else {\n225                     /// @solidity memory-safe-assembly\n226                     assembly {\n227                         revert(add(32, reason), mload(reason))\n228                     }\n229                 }\n230             }\n231         } else {\n232             return true;\n233         }\n234     }\n\n\n235     function _beforeTokenTransfer(\n236         address from,\n237         address to,\n238         uint256, /* firstTokenId */\n239         uint256 batchSize\n240     ) internal virtual {\n241         if (batchSize > 1) {\n242             if (from != address(0)) {\n243                 _balances[from] -= batchSize;\n244             }\n245             if (to != address(0)) {\n246                 _balances[to] += batchSize;\n247             }\n248         }\n249     }\n\n  \n250     function _afterTokenTransfer(\n251         address from,\n252         address to,\n253         uint256 firstTokenId,\n254         uint256 batchSize\n255     ) internal virtual {}\n256 }\n",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 42+ \n47+ \n66+ \n67+ \n87+ \n112+ \n141+ \n141+  \n177+ \n177+ \n210+ ",
    "invariants": "42+ require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n47+ require(owner != address(0), \"ERC721: invalid token ID\");\n66+ require(to != owner, \"ERC721: approval to current owner\");\n67+ require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n112+ require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n141+ require(to != address(0), \"ERC721: mint to the zero address\");\n141+  require(!_exists(tokenId), \"ERC721: token already minted\");\n177+  require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n177+ require(to != address(0), \"ERC721: transfer to the zero address\");\n210+ require(_exists(tokenId), \"ERC721: invalid token ID\");\n",
    "critical-invariants": "87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n",
    "ranks": "87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract SafeMath {\n\n2     function safeAdd(uint a, uint b) public pure returns (uint c) {\n3         c = a + b;\n4         require(c >= a);\n5     }\n\n6     function safeSub(uint a, uint b) public pure returns (uint c) {\n7         require(b <= a);\n8         c = a - b;\n9     }\n\n10     function safeMul(uint a, uint b) public pure returns (uint c) {\n11         c = a * b;\n12         require(a == 0 || c / a == b);\n13     }\n\n14     function safeDiv(uint a, uint b) public pure returns (uint c) {\n15         require(b > 0);\n16         c = a / b;\n17     }\n18 }\n\n\n19 /**\n20 ERC Token Standard #20 Interface\n21 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n22 */\n23 contract ERC20Interface {\n24     function totalSupply() public constant returns (uint);\n25     function balanceOf(address tokenOwner) public constant returns (uint balance);\n26     function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n27     function transfer(address to, uint tokens) public returns (bool success);\n28     function approve(address spender, uint tokens) public returns (bool success);\n29     function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n30     event Transfer(address indexed from, address indexed to, uint tokens);\n31     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n32 }\n\n\n33 /**\n34 Contract function to receive approval and execute function in one call\n\n35 Borrowed from MiniMeToken\n36 */\n37 contract ApproveAndCallFallBack {\n38     function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n39 }\n\n40 /**\n41 ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n42 */\n43 contract SANTAToken is ERC20Interface, SafeMath {\n44     string public symbol;\n45     string public  name;\n46     uint8 public decimals;\n47     uint public _totalSupply;\n\n48     mapping(address => uint) balances;\n49     mapping(address => mapping(address => uint)) allowed;\n\n\n50     // ------------------------------------------------------------------------\n51     // Constructor\n52     // ------------------------------------------------------------------------\n53     constructor() public {\n54         symbol = \"SANTA\";\n55         name = \"santa.investments\";\n56         decimals = 0;\n57         _totalSupply = 100000000;\n58         balances[0x4a1D652Dfb96eec4cF8b7245A278296d6FdE632A] = _totalSupply;\n59         emit Transfer(address(0), 0x4a1D652Dfb96eec4cF8b7245A278296d6FdE632A, _totalSupply);\n60     }\n\n\n61     // ------------------------------------------------------------------------\n62     // Total supply\n63     // ------------------------------------------------------------------------\n64     function totalSupply() public constant returns (uint) {\n65         return _totalSupply  - balances[address(0)];\n66     }\n\n\n67     // ------------------------------------------------------------------------\n68     // Get the token balance for account tokenOwner\n69     // ------------------------------------------------------------------------\n70     function balanceOf(address tokenOwner) public constant returns (uint balance) {\n71         return balances[tokenOwner];\n72     }\n\n\n73     // ------------------------------------------------------------------------\n74     // Transfer the balance from token owner's account to to account\n75     // - Owner's account must have sufficient balance to transfer\n76     // - 0 value transfers are allowed\n77     // ------------------------------------------------------------------------\n78     function transfer(address to, uint tokens) public returns (bool success) {\n79         balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n80         balances[to] = safeAdd(balances[to], tokens);\n81         emit Transfer(msg.sender, to, tokens);\n82         return true;\n83     }\n\n\n84     // ------------------------------------------------------------------------\n85     // Token owner can approve for spender to transferFrom(...) tokens\n86     // from the token owner's account\n87     //\n88     // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n89     // recommends that there are no checks for the approval double-spend attack\n90     // as this should be implemented in user interfaces \n91     // ------------------------------------------------------------------------\n92     function approve(address spender, uint tokens) public returns (bool success) {\n93         allowed[msg.sender][spender] = tokens;\n94         emit Approval(msg.sender, spender, tokens);\n95         return true;\n96     }\n\n\n97     // ------------------------------------------------------------------------\n98     // Transfer tokens from the from account to the to account\n99     // \n100     // The calling account must already have sufficient tokens approve(...)-d\n101     // for spending from the from account and\n102     // - From account must have sufficient balance to transfer\n103     // - Spender must have sufficient allowance to transfer\n104     // - 0 value transfers are allowed\n105     // ------------------------------------------------------------------------\n106     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n107         balances[from] = safeSub(balances[from], tokens);\n108         allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n109         balances[to] = safeAdd(balances[to], tokens);\n110         emit Transfer(from, to, tokens);\n111         return true;\n112     }\n\n\n113     // ------------------------------------------------------------------------\n114     // Returns the amount of tokens approved by the owner that can be\n115     // transferred to the spender's account\n116     // ------------------------------------------------------------------------\n117     function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n118         return allowed[tokenOwner][spender];\n119     }\n\n\n120     // ------------------------------------------------------------------------\n121     // Token owner can approve for spender to transferFrom(...) tokens\n122     // from the token owner's account. The spender contract function\n123     // receiveApproval(...) is then executed\n124     // ------------------------------------------------------------------------\n125     function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n126         allowed[msg.sender][spender] = tokens;\n127         emit Approval(msg.sender, spender, tokens);\n128         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n129         return true;\n130     }\n\n\n131     // ------------------------------------------------------------------------\n132     // Don't accept ETH\n133     // ------------------------------------------------------------------------\n134     function () public payable {\n135         revert();\n136     }\n137 }\n",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 4+ \n7+ \n12+ \n15+ ",
    "invariants": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "critical-invariants": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "ranks": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }\n10 \n11 // a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n12 \n13 library SafeMathSushiswap {\n14     function add(uint x, uint y) internal pure returns (uint z) {\n15         require((z = x + y) >= x, 'ds-math-add-overflow');\n16     }\n17 \n18     function sub(uint x, uint y) internal pure returns (uint z) {\n19         require((z = x - y) <= x, 'ds-math-sub-underflow');\n20     }\n21 \n22     function mul(uint x, uint y) internal pure returns (uint z) {\n23         require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n24     }\n25 }\n26 \n27 library SushiswapV2Library {\n28     using SafeMathSushiswap for uint;\n29 \n30     // returns sorted token addresses, used to handle return values from pairs sorted in this order\n31     function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n32         require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n33         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n34         require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n35     }\n36 \n37     // calculates the CREATE2 address for a pair without making any external calls\n38     function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n39         (address token0, address token1) = sortTokens(tokenA, tokenB);\n40         pair = address(uint160(uint256(keccak256(abi.encodePacked(\n41                 hex'ff',\n42                 factory,\n43                 keccak256(abi.encodePacked(token0, token1)),\n44                 hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n45             )))));\n46     }\n47 \n48     // fetches and sorts the reserves for a pair\n49     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n50         (address token0,) = sortTokens(tokenA, tokenB);\n51         (uint reserve0, uint reserve1,) = ISushiswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n52         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n53     }\n54 \n55     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n56     function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n57         require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58         require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n59         amountB = amountA.mul(reserveB) / reserveA;\n60     }\n61 \n62     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n63     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n64         require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n66         uint amountInWithFee = amountIn.mul(997);\n67         uint numerator = amountInWithFee.mul(reserveOut);\n68         uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n69         amountOut = numerator / denominator;\n70     }\n71 \n72     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n73     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n74         require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n76         uint numerator = reserveIn.mul(amountOut).mul(1000);\n77         uint denominator = reserveOut.sub(amountOut).mul(997);\n78         amountIn = (numerator / denominator).add(1);\n79     }\n80 \n81     // performs chained getAmountOut calculations on any number of pairs\n82     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n83         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n84         amounts = new uint[](path.length);\n85         amounts[0] = amountIn;\n86         for (uint i; i < path.length - 1; i++) {\n87             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n88             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n89         }\n90     }\n91 \n92     // performs chained getAmountIn calculations on any number of pairs\n93     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n94         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n95         amounts = new uint[](path.length);\n96         amounts[amounts.length - 1] = amountOut;\n97         for (uint i = path.length - 1; i > 0; i--) {\n98             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n99             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n100         }\n101     }\n102 }\n103 \n104 // helper methods for interacting with ERC20 tokens and sending NATIVE that do not consistently return true/false\n105 library TransferHelper {\n106     function safeApprove(address token, address to, uint value) internal {\n107         // bytes4(keccak256(bytes('approve(address,uint256)')));\n108         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n109         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n110     }\n111 \n112     function safeTransfer(address token, address to, uint value) internal {\n113         // bytes4(keccak256(bytes('transfer(address,uint256)')));\n114         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n115         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n116     }\n117 \n118     function safeTransferFrom(address token, address from, address to, uint value) internal {\n119         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n120         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n121         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n122     }\n123 \n124     function safeTransferNative(address to, uint value) internal {\n125         (bool success,) = to.call{value:value}(new bytes(0));\n126         require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n127     }\n128 }\n129 \n130 interface IwNATIVE {\n131     function deposit() external payable;\n132     function transfer(address to, uint value) external returns (bool);\n133     function withdraw(uint) external;\n134 }\n135 \n136 interface AnyswapV1ERC20 {\n137     function mint(address to, uint256 amount) external returns (bool);\n138     function burn(address from, uint256 amount) external returns (bool);\n139     function changeVault(address newVault) external returns (bool);\n140     function depositVault(uint amount, address to) external returns (uint);\n141     function withdrawVault(address from, uint amount, address to) external returns (uint);\n142     function underlying() external view returns (address);\n143 }\n144 \n145 /**\n146  * @dev Interface of the ERC20 standard as defined in the EIP.\n147  */\n148 interface IERC20 {\n149     function totalSupply() external view returns (uint256);\n150     function balanceOf(address account) external view returns (uint256);\n151     function transfer(address recipient, uint256 amount) external returns (bool);\n152     function allowance(address owner, address spender) external view returns (uint256);\n153     function approve(address spender, uint256 amount) external returns (bool);\n154     function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n155     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n156     function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n157 \n158     event Transfer(address indexed from, address indexed to, uint256 value);\n159     event Approval(address indexed owner, address indexed spender, uint256 value);\n160 }\n161 \n162 contract AnyswapV4Router {\n163     using SafeMathSushiswap for uint;\n164 \n165     address public immutable factory;\n166     address public immutable wNATIVE;\n167 \n168     modifier ensure(uint deadline) {\n169         require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n170         _;\n171     }\n172 \n173     constructor(address _factory, address _wNATIVE, address _mpc) {\n174         _newMPC = _mpc;\n175         _newMPCEffectiveTime = block.timestamp;\n176         factory = _factory;\n177         wNATIVE = _wNATIVE;\n178     }\n179 \n180     receive() external payable {\n181         assert(msg.sender == wNATIVE); // only accept Native via fallback from the wNative contract\n182     }\n183 \n184     address private _oldMPC;\n185     address private _newMPC;\n186     uint256 private _newMPCEffectiveTime;\n187 \n188 \n189     event LogChangeMPC(address indexed oldMPC, address indexed newMPC, uint indexed effectiveTime, uint chainID);\n190     event LogChangeRouter(address indexed oldRouter, address indexed newRouter, uint chainID);\n191     event LogAnySwapIn(bytes32 indexed txhash, address indexed token, address indexed to, uint amount, uint fromChainID, uint toChainID);\n192     event LogAnySwapOut(address indexed token, address indexed from, address indexed to, uint amount, uint fromChainID, uint toChainID);\n193     event LogAnySwapTradeTokensForTokens(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n194     event LogAnySwapTradeTokensForNative(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n195 \n196     modifier onlyMPC() {\n197         require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n198         _;\n199     }\n200 \n201     function mpc() public view returns (address) {\n202         if (block.timestamp >= _newMPCEffectiveTime) {\n203             return _newMPC;\n204         }\n205         return _oldMPC;\n206     }\n207 \n208     function cID() public view returns (uint id) {\n209         assembly {id := chainid()}\n210     }\n211 \n212     function changeMPC(address newMPC) public onlyMPC returns (bool) {\n213         require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n214         _oldMPC = mpc();\n215         _newMPC = newMPC;\n216         _newMPCEffectiveTime = block.timestamp + 2*24*3600;\n217         emit LogChangeMPC(_oldMPC, _newMPC, _newMPCEffectiveTime, cID());\n218         return true;\n219     }\n220 \n221     function changeVault(address token, address newVault) public onlyMPC returns (bool) {\n222         require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n223         return AnyswapV1ERC20(token).changeVault(newVault);\n224     }\n225 \n226     function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n227         AnyswapV1ERC20(token).burn(from, amount);\n228         emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n229     }\n230 \n231     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\n232     function anySwapOut(address token, address to, uint amount, uint toChainID) external {\n233         _anySwapOut(msg.sender, token, to, amount, toChainID);\n234     }\n235 \n236     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to` by minting with `underlying`\n237     function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external {\n238         TransferHelper.safeTransferFrom(AnyswapV1ERC20(token).underlying(), msg.sender, token, amount);\n239         AnyswapV1ERC20(token).depositVault(amount, msg.sender);\n240         _anySwapOut(msg.sender, token, to, amount, toChainID);\n241     }\n242 \n243     function anySwapOutUnderlyingWithPermit(\n244         address from,\n245         address token,\n246         address to,\n247         uint amount,\n248         uint deadline,\n249         uint8 v,\n250         bytes32 r,\n251         bytes32 s,\n252         uint toChainID\n253     ) external {\n254         address _underlying = AnyswapV1ERC20(token).underlying();\n255         IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n256         TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n257         AnyswapV1ERC20(token).depositVault(amount, from);\n258         _anySwapOut(from, token, to, amount, toChainID);\n259     }\n260 \n261     function anySwapOutUnderlyingWithTransferPermit(\n262         address from,\n263         address token,\n264         address to,\n265         uint amount,\n266         uint deadline,\n267         uint8 v,\n268         bytes32 r,\n269         bytes32 s,\n270         uint toChainID\n271     ) external {\n272         IERC20(AnyswapV1ERC20(token).underlying()).transferWithPermit(from, token, amount, deadline, v, r, s);\n273         AnyswapV1ERC20(token).depositVault(amount, from);\n274         _anySwapOut(from, token, to, amount, toChainID);\n275     }\n276 \n277     function anySwapOut(address[] calldata tokens, address[] calldata to, uint[] calldata amounts, uint[] calldata toChainIDs) external {\n278         for (uint i = 0; i < tokens.length; i++) {\n279             _anySwapOut(msg.sender, tokens[i], to[i], amounts[i], toChainIDs[i]);\n280         }\n281     }\n282 \n283     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n284     function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n285         AnyswapV1ERC20(token).mint(to, amount);\n286         emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n287     }\n288 \n289     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n290     // triggered by `anySwapOut`\n291     function anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n292         _anySwapIn(txs, token, to, amount, fromChainID);\n293     }\n294 \n295     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying`\n296     function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n297         _anySwapIn(txs, token, to, amount, fromChainID);\n298         AnyswapV1ERC20(token).withdrawVault(to, amount, to);\n299     }\n300 \n301     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying` if possible\n302     function anySwapInAuto(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n303         _anySwapIn(txs, token, to, amount, fromChainID);\n304         AnyswapV1ERC20 _anyToken = AnyswapV1ERC20(token);\n305         address _underlying = _anyToken.underlying();\n306         if (_underlying != address(0) && IERC20(_underlying).balanceOf(token) >= amount) {\n307             _anyToken.withdrawVault(to, amount, to);\n308         }\n309     }\n310 \n311     // extracts mpc fee from bridge fees\n312     function anySwapFeeTo(address token, uint amount) external onlyMPC {\n313         address _mpc = mpc();\n314         AnyswapV1ERC20(token).mint(_mpc, amount);\n315         AnyswapV1ERC20(token).withdrawVault(_mpc, amount, _mpc);\n316     }\n317 \n318     function anySwapIn(bytes32[] calldata txs, address[] calldata tokens, address[] calldata to, uint256[] calldata amounts, uint[] calldata fromChainIDs) external onlyMPC {\n319         for (uint i = 0; i < tokens.length; i++) {\n320             _anySwapIn(txs[i], tokens[i], to[i], amounts[i], fromChainIDs[i]);\n321         }\n322     }\n323 \n324     // **** SWAP ****\n325     // requires the initial amount to have already been sent to the first pair\n326     function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n327         for (uint i; i < path.length - 1; i++) {\n328             (address input, address output) = (path[i], path[i + 1]);\n329             (address token0,) = SushiswapV2Library.sortTokens(input, output);\n330             uint amountOut = amounts[i + 1];\n331             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n332             address to = i < path.length - 2 ? SushiswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n333             ISushiswapV2Pair(SushiswapV2Library.pairFor(factory, input, output)).swap(\n334                 amount0Out, amount1Out, to, new bytes(0)\n335             );\n336         }\n337     }\n338 \n339     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n340     function anySwapOutExactTokensForTokens(\n341         uint amountIn,\n342         uint amountOutMin,\n343         address[] calldata path,\n344         address to,\n345         uint deadline,\n346         uint toChainID\n347     ) external virtual ensure(deadline) {\n348         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n349         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n350     }\n351 \n352     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n353     function anySwapOutExactTokensForTokensUnderlying(\n354         uint amountIn,\n355         uint amountOutMin,\n356         address[] calldata path,\n357         address to,\n358         uint deadline,\n359         uint toChainID\n360     ) external virtual ensure(deadline) {\n361         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n362         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n363         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n364         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n365     }\n366 \n367     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n368     function anySwapOutExactTokensForTokensUnderlyingWithPermit(\n369         address from,\n370         uint amountIn,\n371         uint amountOutMin,\n372         address[] calldata path,\n373         address to,\n374         uint deadline,\n375         uint8 v,\n376         bytes32 r,\n377         bytes32 s,\n378         uint toChainID\n379     ) external virtual ensure(deadline) {\n380         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n381         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n382         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n383         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n384         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n385         {\n386         address[] memory _path = path;\n387         address _from = from;\n388         address _to = to;\n389         uint _amountIn = amountIn;\n390         uint _amountOutMin = amountOutMin;\n391         uint _cID = cID();\n392         uint _toChainID = toChainID;\n393         emit LogAnySwapTradeTokensForTokens(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n394         }\n395     }\n396 \n397     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n398     function anySwapOutExactTokensForTokensUnderlyingWithTransferPermit(\n399         address from,\n400         uint amountIn,\n401         uint amountOutMin,\n402         address[] calldata path,\n403         address to,\n404         uint deadline,\n405         uint8 v,\n406         bytes32 r,\n407         bytes32 s,\n408         uint toChainID\n409     ) external virtual ensure(deadline) {\n410         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n411         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n412         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n413         emit LogAnySwapTradeTokensForTokens(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n414     }\n415 \n416     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n417     // Triggered by `anySwapOutExactTokensForTokens`\n418     function anySwapInExactTokensForTokens(\n419         bytes32 txs,\n420         uint amountIn,\n421         uint amountOutMin,\n422         address[] calldata path,\n423         address to,\n424         uint deadline,\n425         uint fromChainID\n426     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n427         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n428         require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n429         _anySwapIn(txs, path[0], SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n430         _swap(amounts, path, to);\n431     }\n432 \n433     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n434     function anySwapOutExactTokensForNative(\n435         uint amountIn,\n436         uint amountOutMin,\n437         address[] calldata path,\n438         address to,\n439         uint deadline,\n440         uint toChainID\n441     ) external virtual ensure(deadline) {\n442         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n443         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n444     }\n445 \n446     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n447     function anySwapOutExactTokensForNativeUnderlying(\n448         uint amountIn,\n449         uint amountOutMin,\n450         address[] calldata path,\n451         address to,\n452         uint deadline,\n453         uint toChainID\n454     ) external virtual ensure(deadline) {\n455         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n456         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n457         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n458         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n459     }\n460 \n461     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n462     function anySwapOutExactTokensForNativeUnderlyingWithPermit(\n463         address from,\n464         uint amountIn,\n465         uint amountOutMin,\n466         address[] calldata path,\n467         address to,\n468         uint deadline,\n469         uint8 v,\n470         bytes32 r,\n471         bytes32 s,\n472         uint toChainID\n473     ) external virtual ensure(deadline) {\n474         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n475         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n476         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n477         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n478         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n479         {\n480         address[] memory _path = path;\n481         address _from = from;\n482         address _to = to;\n483         uint _amountIn = amountIn;\n484         uint _amountOutMin = amountOutMin;\n485         uint _cID = cID();\n486         uint _toChainID = toChainID;\n487         emit LogAnySwapTradeTokensForNative(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n488         }\n489     }\n490 \n491     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n492     function anySwapOutExactTokensForNativeUnderlyingWithTransferPermit(\n493         address from,\n494         uint amountIn,\n495         uint amountOutMin,\n496         address[] calldata path,\n497         address to,\n498         uint deadline,\n499         uint8 v,\n500         bytes32 r,\n501         bytes32 s,\n502         uint toChainID\n503     ) external virtual ensure(deadline) {\n504         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n505         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n506         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n507         emit LogAnySwapTradeTokensForNative(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n508     }\n509 \n510     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n511     // Triggered by `anySwapOutExactTokensForNative`\n512     function anySwapInExactTokensForNative(\n513         bytes32 txs,\n514         uint amountIn,\n515         uint amountOutMin,\n516         address[] calldata path,\n517         address to,\n518         uint deadline,\n519         uint fromChainID\n520     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n521         require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n522         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n523         require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');\n524         _anySwapIn(txs, path[0],  SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n525         _swap(amounts, path, address(this));\n526         IwNATIVE(wNATIVE).withdraw(amounts[amounts.length - 1]);\n527         TransferHelper.safeTransferNative(to, amounts[amounts.length - 1]);\n528     }\n529 \n530     // **** LIBRARY FUNCTIONS ****\n531     function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {\n532         return SushiswapV2Library.quote(amountA, reserveA, reserveB);\n533     }\n534 \n535     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n536         public\n537         pure\n538         virtual\n539         returns (uint amountOut)\n540     {\n541         return SushiswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n542     }\n543 \n544     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n545         public\n546         pure\n547         virtual\n548         returns (uint amountIn)\n549     {\n550         return SushiswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n551     }\n552 \n553     function getAmountsOut(uint amountIn, address[] memory path)\n554         public\n555         view\n556         virtual\n557         returns (uint[] memory amounts)\n558     {\n559         return SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n560     }\n561 \n562     function getAmountsIn(uint amountOut, address[] memory path)\n563         public\n564         view\n565         virtual\n566         returns (uint[] memory amounts)\n567     {\n568         return SushiswapV2Library.getAmountsIn(factory, amountOut, path);\n569     }\n570 }\n520\n",
    "transaction-context": "onlyMPC",
    "Critical-points": "require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');",
    "invariants": " require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "require(cnt > 0 && cnt <= 20);\n",
    "ranks": "require(_value > 0 && balances[msg.sender] >= amount);\n",
    "vulnerabilities": "assert(amount >0);"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n3 \n4  contract Swap {\n5          IERC20 public WEI;\n6          IERC20 public USD;\n7          IUniswapV2Pair public pair; \n8          mapping(address => uint) public debt;\n9          mapping(address => uint) public collateral;\n10 \n11          function liquidate(address user) public {\n12              uint dAmount = debt[user];\n13              uint cAmount = collateral[user];\n14             require(getPrice() * cAmount * 80 / 100 < dAmount,\n15              \"the given user\u2019s fund cannot be liquidated\");\n16             address _this = address(this);\n17            USD.transferFrom(msg.sender, _this, dAmount);\n18             WEI.transferFrom(_this, msg.sender, cAmount);\n19        }\n20          function  calculatePrice() public payable returns (uint) { \n21 \n22 \n23                     return (USD.balanceOf(address(pair)) /\n24              WEI.balanceOf(address(pair)));\n25      }\n26   }\n",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 13+\n23+\n",
    "invariants": "13+ assert(Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair))) == USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)));\n23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n",
    "critical-invariants": "23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n",
    "ranks": "23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1   // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n4 \n5 \n6 contract Chain  {\n7   IStakingBank public immutable stakingBank;\n8 \n9   event LogMint(address indexed minter, uint256 blockId, uint256 staked, uint256 power);\n10   event LogVoter(uint256 indexed blockId, address indexed voter, uint256 vote);\n11 \n12   IStakingBank public immutable stakingBank;\n13 \n14   constructor(\n15     address _contractRegistry,\n16     uint16 _padding,\n17     uint16 _requiredSignatures\n18   ) public BaseChain(_contractRegistry, _padding, _requiredSignatures) {\n19     stakingBank = stakingBankContract();\n20   }\n21 \n22   function submit(\n23     uint32 _dataTimestamp,\n24     bytes32 _root,\n25     bytes32[] memory _keys,\n26     uint256[] memory _values,\n27     uint8[] memory _v,\n28     bytes32[] memory _r,\n29     bytes32[] memory _s\n30   ) public {  \n31     uint32 lastBlockId = getLatestBlockId();\n32     uint32 dataTimestamp = squashedRoots[lastBlockId].extractTimestamp();\n33 \n34 \n35     require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n36 \n37     bytes memory testimony = abi.encodePacked(_dataTimestamp, _root);\n38 \n39     for (uint256 i = 0; i < _keys.length; i++) {\n40       require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n41       fcds[_keys[i]] = FirstClassData(uint224(_values[i]), _dataTimestamp);\n42       testimony = abi.encodePacked(testimony, _keys[i], _values[i]);\n43     }\n44 \n45     bytes32 affidavit = keccak256(testimony);\n46     uint256 power = 0;\n47 \n48     uint256 staked = stakingBank.totalSupply();\n49     address prevSigner = address(0x0);\n50 \n51     uint256 i = 0;\n52 \n53     for (; i < _v.length; i++) {\n54       address signer = recoverSigner(affidavit, _v[i], _r[i], _s[i]);\n55       uint256 balance = stakingBank.balanceOf(signer);\n56 \n57       require(prevSigner < signer, \"validator included more than once\");\n58       prevSigner = signer;\n59       if (balance == 0) continue;\n60 \n61       emit LogVoter(lastBlockId + 1, signer, balance);\n62       power += balance; \n63     }\n64 \n65     require(i >= requiredSignatures, \"not enough signatures\");\n66 \n67     squashedRoots[lastBlockId + 1] = _root.makeSquashedRoot(_dataTimestamp);\n68     blocksCount++;\n69 \n70     emit LogMint(msg.sender, lastBlockId + 1, staked, power);\n71   }\n72 \n73   function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) public view returns (uint256) {\n74     uint32 latestBlockId = getLatestBlockId();\n75 \n76     \n77     uint256 validatorIndex = latestBlockId +\n78       (_timestamp - squashedRoots[latestBlockId].extractTimestamp()) / (padding + 1);\n79 \n80     return uint16(validatorIndex % _numberOfValidators);\n81   }\n82 \n83   function getLeaderAddressAtTime(uint256 _timestamp) public view returns (address) {\n84     uint256 numberOfValidators = stakingBank.getNumberOfValidators();\n85 \n86     if (numberOfValidators == 0) {\n87       return address(0x0);\n88     }\n89 \n90     uint256 validatorIndex = getLeaderIndex(numberOfValidators, _timestamp);\n91 \n92     return stakingBank.addresses(validatorIndex);\n93   }\n94 }\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 30+",
    "invariants": "30+ assert(msg.sender == _contractRegistry);\n30+ assert(msg.sender == _contractRegistry);",
    "critical-invariants": "30+ assert(msg.sender == _contractRegistry);",
    "ranks": "30+ assert(msg.sender == _contractRegistry);",
    "vulnerabilities": "incorrect visibility/ownership"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";\n\n\n9 /**\n10     @title Handles ERC721 deposits and deposit executions.\n11     @author ChainSafe Systems.\n12     @notice This contract is intended to be used with the Bridge contract.\n13  */\n14 contract ERC721Handler is IDepositExecute, HandlerHelpers, ERC721Safe {\n15     using ERC165Checker for address;\n\n16     bytes4 private constant _INTERFACE_ERC721_METADATA = 0x5b5e139f;\n\n17     /**\n18         @param bridgeAddress Contract address of previously deployed Bridge.\n19      */\n20     constructor(\n21         address bridgeAddress\n22     ) public HandlerHelpers(bridgeAddress) {\n23     }\n\n24     /**\n25         @notice A deposit is initiatied by making a deposit in the Bridge contract.\n26         @param resourceID ResourceID used to find address of token to be used for deposit.\n27         @param depositer Address of account making the deposit in the Bridge contract.\n28         @param data Consists of {tokenID} padded to 32 bytes.\n29         @notice Data passed into the function should be constructed as follows:\n30         tokenID                                     uint256    bytes    0  - 32\n31         @notice If the corresponding {tokenAddress} for the parsed {resourceID} supports {_INTERFACE_ERC721_METADATA},\n32         then {metaData} will be set according to the {tokenURI} method in the token contract.\n33         @dev Depending if the corresponding {tokenAddress} for the parsed {resourceID} is\n34         marked true in {_burnList}, deposited tokens will be burned, if not, they will be locked.\n35         @return metaData : the deposited token metadata acquired by calling a {tokenURI} method in the token contract.\n36      */\n37     function deposit(bytes32    resourceID,\n38                     address     depositer,\n39                     bytes       calldata data\n40                     ) external override onlyBridge returns (bytes memory metaData) {\n41         uint         tokenID;\n\n42         (tokenID) = abi.decode(data, (uint));\n\n43         address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n     \n44         // Check if the contract supports metadata, fetch it if it does\n45         if (tokenAddress.supportsInterface(_INTERFACE_ERC721_METADATA)) {\n46             IERC721Metadata erc721 = IERC721Metadata(tokenAddress);\n47             metaData = bytes(erc721.tokenURI(tokenID));\n48         }\n\n49         if (_burnList[tokenAddress]) {\n50             burnERC721(tokenAddress, tokenID);\n51         } else {\n52             lockERC721(tokenAddress, depositer, address(this), tokenID);\n53         }\n54     }\n\n55     /**\n56         @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.\n57         by a relayer on the deposit's destination chain.\n58         @param data Consists of {tokenID}, {resourceID}, {lenDestinationRecipientAddress},\n59         {destinationRecipientAddress}, {lenMeta}, and {metaData} all padded to 32 bytes.\n60         @notice Data passed into the function should be constructed as follows:\n61         tokenID                                     uint256    bytes    0  - 32\n62         destinationRecipientAddress     length      uint256    bytes    32 - 64\n63         destinationRecipientAddress                   bytes    bytes    64 - (64 + len(destinationRecipientAddress))\n64         metadata                        length      uint256    bytes    (64 + len(destinationRecipientAddress)) - (64 + len(destinationRecipientAddress) + 32)\n65         metadata                                      bytes    bytes    (64 + len(destinationRecipientAddress) + 32) - END\n66      */\n67     function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n68         uint         tokenID;\n69         uint         lenDestinationRecipientAddress;\n70         bytes memory destinationRecipientAddress;\n71         uint         offsetMetaData;\n72         uint         lenMetaData;\n73         bytes memory metaData;\n\n74         (tokenID, lenDestinationRecipientAddress) = abi.decode(data, (uint, uint));\n75         offsetMetaData = 64 + lenDestinationRecipientAddress;\n76         destinationRecipientAddress = bytes(data[64:offsetMetaData]);\n77         lenMetaData = abi.decode(data[offsetMetaData:], (uint));\n78         metaData = bytes(data[offsetMetaData + 32:offsetMetaData + 32 + lenMetaData]);\n\n79         bytes20 recipientAddress;\n\n80         assembly {\n81             recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n82         }\n\n83         address tokenAddress = _resourceIDToTokenContractAddress[resourceID];      \n84         if (_burnList[tokenAddress]) {\n85             mintERC721(tokenAddress, address(recipientAddress), tokenID, metaData);\n86         } else {\n87             releaseERC721(tokenAddress, address(this), address(recipientAddress), tokenID);\n88         }\n89     }\n\n90     /**\n91         @notice Used to manually release ERC721 tokens from ERC721Safe.\n92         @param tokenAddress Address of token contract to release.\n93         @param recipient Address to release token to.\n94         @param tokenID The ERC721 token ID to release.\n95      */\n96     function withdraw(address tokenAddress, address recipient, uint tokenID) external override onlyBridge {\n97         releaseERC721(tokenAddress, address(this), recipient, tokenID);\n98     }\n99 }\n",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 43+    \n83+  ",
    "invariants": "43+    require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "critical-invariants": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "ranks": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0;\n2 \n3 contract SimpleDAO {\n4     mapping (address => uint) public credit;\n5     constructor() public {\n6     }\n7     function donate(address to, uint amount) payable public {\n8         credit[to] += amount;\n9     }\n10     function queryCredit(address to) public view returns (uint) {\n11         return credit[to];\n12     }\n13     function withdraw() public {\n14         uint oldBal = address(this).balance; \n15         address payable sender = msg.sender;\n16         uint balSender = msg.sender.balance; // translated OK\n17         uint amount = credit[msg.sender];\n18         if (amount > 0) {\n19             sender.transfer(amount); // VeriSol bug #185 (can't handle msg.sender.transfer)\n20             credit[msg.sender] = 0;  // BUG: \n21         }\n22         uint bal = address(this).balance;       \n23     }\n24 }\n25 \n26 contract Mallory {\n27     SimpleDAO public dao;\n28     uint count;\n29     constructor (address daoAddr) public payable {\n30         count = 0;\n31         dao = SimpleDAO(daoAddr);\n32         require(dao.queryCredit(address(this)) == 0);\n33         require(address(this).balance == 1);\n34     }\n35     function () payable external {\n36         if (count < 2) {\n37             count ++;\n38             dao.withdraw();\n39         }\n40     }\n41     function donate() public {        \n42         dao.donate(address(this), address(this).balance);  //should this not be a send(this.balance)? \n43     }\n44     function getJackpot() public {\n45         dao.withdraw();\n46     }\n47 }  \n",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 22+ ",
    "invariants": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "critical-invariants": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "ranks": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;\n7   IERC20 token1; \n8   address to; \n9   uint tokenPrice; //track price change \n\n10   function liquidate(uint ceilPrice) public {        \n11     tokenPrice = getPrice(); \n         //price is going to change: should we check here? \n12     if (tokenPrice >= ceilPrice){\n13       myToken.transfer(to, 100);\n14     }    \n15   }\n\n16   function getPrice() public{\n17     price = token0.balanceOf(address(this))/token1.balanceOf(address(this));\n         \n18   }  \n19 }\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }\n10 \n11 // a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n12 \n13 library SafeMathSushiswap {\n14     function add(uint x, uint y) internal pure returns (uint z) {\n15         require((z = x + y) >= x, 'ds-math-add-overflow');\n16     }\n17 \n18     function sub(uint x, uint y) internal pure returns (uint z) {\n19         require((z = x - y) <= x, 'ds-math-sub-underflow');\n20     }\n21 \n22     function mul(uint x, uint y) internal pure returns (uint z) {\n23         require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n24     }\n25 }\n26 \n27 library SushiswapV2Library {\n28     using SafeMathSushiswap for uint;\n29 \n30     // returns sorted token addresses, used to handle return values from pairs sorted in this order\n31     function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n32         require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n33         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n34         require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n35     }\n36 \n37     // calculates the CREATE2 address for a pair without making any external calls\n38     function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n39         (address token0, address token1) = sortTokens(tokenA, tokenB);\n40         pair = address(uint160(uint256(keccak256(abi.encodePacked(\n41                 hex'ff',\n42                 factory,\n43                 keccak256(abi.encodePacked(token0, token1)),\n44                 hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n45             )))));\n46     }\n47 \n48     // fetches and sorts the reserves for a pair\n49     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n50         (address token0,) = sortTokens(tokenA, tokenB);\n51         (uint reserve0, uint reserve1,) = ISushiswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n52         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n53     }\n54 \n55     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n56     function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n57         require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58         require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n59         amountB = amountA.mul(reserveB) / reserveA;\n60     }\n61 \n62     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n63     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n64         require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n66         uint amountInWithFee = amountIn.mul(997);\n67         uint numerator = amountInWithFee.mul(reserveOut);\n68         uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n69         amountOut = numerator / denominator;\n70     }\n71 \n72     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n73     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n74         require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n76         uint numerator = reserveIn.mul(amountOut).mul(1000);\n77         uint denominator = reserveOut.sub(amountOut).mul(997);\n78         amountIn = (numerator / denominator).add(1);\n79     }\n80 \n81     // performs chained getAmountOut calculations on any number of pairs\n82     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n83         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n84         amounts = new uint[](path.length);\n85         amounts[0] = amountIn;\n86         for (uint i; i < path.length - 1; i++) {\n87             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n88             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n89         }\n90     }\n91 \n92     // performs chained getAmountIn calculations on any number of pairs\n93     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n94         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n95         amounts = new uint[](path.length);\n96         amounts[amounts.length - 1] = amountOut;\n97         for (uint i = path.length - 1; i > 0; i--) {\n98             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n99             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n100         }\n101     }\n102 }\n103 \n104 // helper methods for interacting with ERC20 tokens and sending NATIVE that do not consistently return true/false\n105 library TransferHelper {\n106     function safeApprove(address token, address to, uint value) internal {\n107         // bytes4(keccak256(bytes('approve(address,uint256)')));\n108         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n109         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n110     }\n111 \n112     function safeTransfer(address token, address to, uint value) internal {\n113         // bytes4(keccak256(bytes('transfer(address,uint256)')));\n114         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n115         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n116     }\n117 \n118     function safeTransferFrom(address token, address from, address to, uint value) internal {\n119         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n120         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n121         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n122     }\n123 \n124     function safeTransferNative(address to, uint value) internal {\n125         (bool success,) = to.call{value:value}(new bytes(0));\n126         require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n127     }\n128 }\n129 \n130 interface IwNATIVE {\n131     function deposit() external payable;\n132     function transfer(address to, uint value) external returns (bool);\n133     function withdraw(uint) external;\n134 }\n135 \n136 interface AnyswapV1ERC20 {\n137     function mint(address to, uint256 amount) external returns (bool);\n138     function burn(address from, uint256 amount) external returns (bool);\n139     function changeVault(address newVault) external returns (bool);\n140     function depositVault(uint amount, address to) external returns (uint);\n141     function withdrawVault(address from, uint amount, address to) external returns (uint);\n142     function underlying() external view returns (address);\n143 }\n144 \n145 /**\n146  * @dev Interface of the ERC20 standard as defined in the EIP.\n147  */\n148 interface IERC20 {\n149     function totalSupply() external view returns (uint256);\n150     function balanceOf(address account) external view returns (uint256);\n151     function transfer(address recipient, uint256 amount) external returns (bool);\n152     function allowance(address owner, address spender) external view returns (uint256);\n153     function approve(address spender, uint256 amount) external returns (bool);\n154     function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n155     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n156     function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n157 \n158     event Transfer(address indexed from, address indexed to, uint256 value);\n159     event Approval(address indexed owner, address indexed spender, uint256 value);\n160 }\n161 \n162 contract AnyswapV4Router {\n163     using SafeMathSushiswap for uint;\n164 \n165     address public immutable factory;\n166     address public immutable wNATIVE;\n167 \n168     modifier ensure(uint deadline) {\n169         require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n170         _;\n171     }\n172 \n173     constructor(address _factory, address _wNATIVE, address _mpc) {\n174         _newMPC = _mpc;\n175         _newMPCEffectiveTime = block.timestamp;\n176         factory = _factory;\n177         wNATIVE = _wNATIVE;\n178     }\n179 \n180     receive() external payable {\n181         assert(msg.sender == wNATIVE); // only accept Native via fallback from the wNative contract\n182     }\n183 \n184     address private _oldMPC;\n185     address private _newMPC;\n186     uint256 private _newMPCEffectiveTime;\n187 \n188 \n189     event LogChangeMPC(address indexed oldMPC, address indexed newMPC, uint indexed effectiveTime, uint chainID);\n190     event LogChangeRouter(address indexed oldRouter, address indexed newRouter, uint chainID);\n191     event LogAnySwapIn(bytes32 indexed txhash, address indexed token, address indexed to, uint amount, uint fromChainID, uint toChainID);\n192     event LogAnySwapOut(address indexed token, address indexed from, address indexed to, uint amount, uint fromChainID, uint toChainID);\n193     event LogAnySwapTradeTokensForTokens(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n194     event LogAnySwapTradeTokensForNative(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n195 \n196     modifier onlyMPC() {\n197         require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n198         _;\n199     }\n200 \n201     function mpc() public view returns (address) {\n202         if (block.timestamp >= _newMPCEffectiveTime) {\n203             return _newMPC;\n204         }\n205         return _oldMPC;\n206     }\n207 \n208     function cID() public view returns (uint id) {\n209         assembly {id := chainid()}\n210     }\n211 \n212     function changeMPC(address newMPC) public onlyMPC returns (bool) {\n213         require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n214         _oldMPC = mpc();\n215         _newMPC = newMPC;\n216         _newMPCEffectiveTime = block.timestamp + 2*24*3600;\n217         emit LogChangeMPC(_oldMPC, _newMPC, _newMPCEffectiveTime, cID());\n218         return true;\n219     }\n220 \n221     function changeVault(address token, address newVault) public onlyMPC returns (bool) {\n222         require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n223         return AnyswapV1ERC20(token).changeVault(newVault);\n224     }\n225 \n226     function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n227         AnyswapV1ERC20(token).burn(from, amount);\n228         emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n229     }\n230 \n231     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\n232     function anySwapOut(address token, address to, uint amount, uint toChainID) external {\n233         _anySwapOut(msg.sender, token, to, amount, toChainID);\n234     }\n235 \n236     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to` by minting with `underlying`\n237     function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external {\n238         TransferHelper.safeTransferFrom(AnyswapV1ERC20(token).underlying(), msg.sender, token, amount);\n239         AnyswapV1ERC20(token).depositVault(amount, msg.sender);\n240         _anySwapOut(msg.sender, token, to, amount, toChainID);\n241     }\n242 \n243     function anySwapOutUnderlyingWithPermit(\n244         address from,\n245         address token,\n246         address to,\n247         uint amount,\n248         uint deadline,\n249         uint8 v,\n250         bytes32 r,\n251         bytes32 s,\n252         uint toChainID\n253     ) external {\n254         address _underlying = AnyswapV1ERC20(token).underlying();\n255         IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n256         TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n257         AnyswapV1ERC20(token).depositVault(amount, from);\n258         _anySwapOut(from, token, to, amount, toChainID);\n259     }\n260 \n261     function anySwapOutUnderlyingWithTransferPermit(\n262         address from,\n263         address token,\n264         address to,\n265         uint amount,\n266         uint deadline,\n267         uint8 v,\n268         bytes32 r,\n269         bytes32 s,\n270         uint toChainID\n271     ) external {\n272         IERC20(AnyswapV1ERC20(token).underlying()).transferWithPermit(from, token, amount, deadline, v, r, s);\n273         AnyswapV1ERC20(token).depositVault(amount, from);\n274         _anySwapOut(from, token, to, amount, toChainID);\n275     }\n276 \n277     function anySwapOut(address[] calldata tokens, address[] calldata to, uint[] calldata amounts, uint[] calldata toChainIDs) external {\n278         for (uint i = 0; i < tokens.length; i++) {\n279             _anySwapOut(msg.sender, tokens[i], to[i], amounts[i], toChainIDs[i]);\n280         }\n281     }\n282 \n283     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n284     function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n285         AnyswapV1ERC20(token).mint(to, amount);\n286         emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n287     }\n288 \n289     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n290     // triggered by `anySwapOut`\n291     function anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n292         _anySwapIn(txs, token, to, amount, fromChainID);\n293     }\n294 \n295     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying`\n296     function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n297         _anySwapIn(txs, token, to, amount, fromChainID);\n298         AnyswapV1ERC20(token).withdrawVault(to, amount, to);\n299     }\n300 \n301     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying` if possible\n302     function anySwapInAuto(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n303         _anySwapIn(txs, token, to, amount, fromChainID);\n304         AnyswapV1ERC20 _anyToken = AnyswapV1ERC20(token);\n305         address _underlying = _anyToken.underlying();\n306         if (_underlying != address(0) && IERC20(_underlying).balanceOf(token) >= amount) {\n307             _anyToken.withdrawVault(to, amount, to);\n308         }\n309     }\n310 \n311     // extracts mpc fee from bridge fees\n312     function anySwapFeeTo(address token, uint amount) external onlyMPC {\n313         address _mpc = mpc();\n314         AnyswapV1ERC20(token).mint(_mpc, amount);\n315         AnyswapV1ERC20(token).withdrawVault(_mpc, amount, _mpc);\n316     }\n317 \n318     function anySwapIn(bytes32[] calldata txs, address[] calldata tokens, address[] calldata to, uint256[] calldata amounts, uint[] calldata fromChainIDs) external onlyMPC {\n319         for (uint i = 0; i < tokens.length; i++) {\n320             _anySwapIn(txs[i], tokens[i], to[i], amounts[i], fromChainIDs[i]);\n321         }\n322     }\n323 \n324     // **** SWAP ****\n325     // requires the initial amount to have already been sent to the first pair\n326     function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n327         for (uint i; i < path.length - 1; i++) {\n328             (address input, address output) = (path[i], path[i + 1]);\n329             (address token0,) = SushiswapV2Library.sortTokens(input, output);\n330             uint amountOut = amounts[i + 1];\n331             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n332             address to = i < path.length - 2 ? SushiswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n333             ISushiswapV2Pair(SushiswapV2Library.pairFor(factory, input, output)).swap(\n334                 amount0Out, amount1Out, to, new bytes(0)\n335             );\n336         }\n337     }\n338 \n339     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n340     function anySwapOutExactTokensForTokens(\n341         uint amountIn,\n342         uint amountOutMin,\n343         address[] calldata path,\n344         address to,\n345         uint deadline,\n346         uint toChainID\n347     ) external virtual ensure(deadline) {\n348         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n349         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n350     }\n351 \n352     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n353     function anySwapOutExactTokensForTokensUnderlying(\n354         uint amountIn,\n355         uint amountOutMin,\n356         address[] calldata path,\n357         address to,\n358         uint deadline,\n359         uint toChainID\n360     ) external virtual ensure(deadline) {\n361         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n362         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n363         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n364         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n365     }\n366 \n367     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n368     function anySwapOutExactTokensForTokensUnderlyingWithPermit(\n369         address from,\n370         uint amountIn,\n371         uint amountOutMin,\n372         address[] calldata path,\n373         address to,\n374         uint deadline,\n375         uint8 v,\n376         bytes32 r,\n377         bytes32 s,\n378         uint toChainID\n379     ) external virtual ensure(deadline) {\n380         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n381         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n382         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n383         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n384         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n385         {\n386         address[] memory _path = path;\n387         address _from = from;\n388         address _to = to;\n389         uint _amountIn = amountIn;\n390         uint _amountOutMin = amountOutMin;\n391         uint _cID = cID();\n392         uint _toChainID = toChainID;\n393         emit LogAnySwapTradeTokensForTokens(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n394         }\n395     }\n396 \n397     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n398     function anySwapOutExactTokensForTokensUnderlyingWithTransferPermit(\n399         address from,\n400         uint amountIn,\n401         uint amountOutMin,\n402         address[] calldata path,\n403         address to,\n404         uint deadline,\n405         uint8 v,\n406         bytes32 r,\n407         bytes32 s,\n408         uint toChainID\n409     ) external virtual ensure(deadline) {\n410         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n411         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n412         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n413         emit LogAnySwapTradeTokensForTokens(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n414     }\n415 \n416     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n417     // Triggered by `anySwapOutExactTokensForTokens`\n418     function anySwapInExactTokensForTokens(\n419         bytes32 txs,\n420         uint amountIn,\n421         uint amountOutMin,\n422         address[] calldata path,\n423         address to,\n424         uint deadline,\n425         uint fromChainID\n426     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n427         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n428         require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n429         _anySwapIn(txs, path[0], SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n430         _swap(amounts, path, to);\n431     }\n432 \n433     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n434     function anySwapOutExactTokensForNative(\n435         uint amountIn,\n436         uint amountOutMin,\n437         address[] calldata path,\n438         address to,\n439         uint deadline,\n440         uint toChainID\n441     ) external virtual ensure(deadline) {\n442         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n443         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n444     }\n445 \n446     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n447     function anySwapOutExactTokensForNativeUnderlying(\n448         uint amountIn,\n449         uint amountOutMin,\n450         address[] calldata path,\n451         address to,\n452         uint deadline,\n453         uint toChainID\n454     ) external virtual ensure(deadline) {\n455         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n456         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n457         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n458         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n459     }\n460 \n461     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n462     function anySwapOutExactTokensForNativeUnderlyingWithPermit(\n463         address from,\n464         uint amountIn,\n465         uint amountOutMin,\n466         address[] calldata path,\n467         address to,\n468         uint deadline,\n469         uint8 v,\n470         bytes32 r,\n471         bytes32 s,\n472         uint toChainID\n473     ) external virtual ensure(deadline) {\n474         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n475         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n476         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n477         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n478         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n479         {\n480         address[] memory _path = path;\n481         address _from = from;\n482         address _to = to;\n483         uint _amountIn = amountIn;\n484         uint _amountOutMin = amountOutMin;\n485         uint _cID = cID();\n486         uint _toChainID = toChainID;\n487         emit LogAnySwapTradeTokensForNative(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n488         }\n489     }\n490 \n491     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n492     function anySwapOutExactTokensForNativeUnderlyingWithTransferPermit(\n493         address from,\n494         uint amountIn,\n495         uint amountOutMin,\n496         address[] calldata path,\n497         address to,\n498         uint deadline,\n499         uint8 v,\n500         bytes32 r,\n501         bytes32 s,\n502         uint toChainID\n503     ) external virtual ensure(deadline) {\n504         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n505         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n506         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n507         emit LogAnySwapTradeTokensForNative(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n508     }\n509 \n510     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n511     // Triggered by `anySwapOutExactTokensForNative`\n512     function anySwapInExactTokensForNative(\n513         bytes32 txs,\n514         uint amountIn,\n515         uint amountOutMin,\n516         address[] calldata path,\n517         address to,\n518         uint deadline,\n519         uint fromChainID\n520     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n521         require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n522         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n523         require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');\n524         _anySwapIn(txs, path[0],  SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n525         _swap(amounts, path, address(this));\n526         IwNATIVE(wNATIVE).withdraw(amounts[amounts.length - 1]);\n527         TransferHelper.safeTransferNative(to, amounts[amounts.length - 1]);\n528     }\n529 \n530     // **** LIBRARY FUNCTIONS ****\n531     function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {\n532         return SushiswapV2Library.quote(amountA, reserveA, reserveB);\n533     }\n534 \n535     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n536         public\n537         pure\n538         virtual\n539         returns (uint amountOut)\n540     {\n541         return SushiswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n542     }\n543 \n544     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n545         public\n546         pure\n547         virtual\n548         returns (uint amountIn)\n549     {\n550         return SushiswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n551     }\n552 \n553     function getAmountsOut(uint amountIn, address[] memory path)\n554         public\n555         view\n556         virtual\n557         returns (uint[] memory amounts)\n558     {\n559         return SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n560     }\n561 \n562     function getAmountsIn(uint amountOut, address[] memory path)\n563         public\n564         view\n565         virtual\n566         returns (uint[] memory amounts)\n567     {\n568         return SushiswapV2Library.getAmountsIn(factory, amountOut, path);\n569     }\n570 }\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 15+  \n19+ \n23+ \n32+  \n34+\n57+ \n58+  \n64+  \n65+ \n74+  \n75+ \n83+  \n94+ \n109+ \n115+ \n121+\n126+ \n168+  \n181+ \n196+ \n212 \n213+\n221 \n222+  \n291 \n296 \n302 \n312 \n318 \n360 \n379 \n409 \n428+  \n454 \n473 \n503 \n520  \n521+ \n523+   ",
    "invariants": "15+  require((z = x + y) >= x, 'ds-math-add-overflow');\n19+  require((z = x - y) <= x, 'ds-math-sub-underflow');\n23+  require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n212 onlyMPC\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n221 onlyMPC\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "ranks": "168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3   contract Swap {\n4           IERC20 public WEI;\n5           IERC20 public USD;\n6           IUniswapV2Pair public pair; \n7           mapping(address => uint) public debt;\n8           mapping(address => uint) public collateral;\n \n9           function liquidate(address user) public {\n10               uint dAmount = debt[user];\n11               uint cAmount = collateral[user];\n12              require(getPrice() * cAmount * 80 / 100 < dAmount,\n13               \"the given user\u2019s fund cannot be liquidated\");\n14              address _this = address(this);\n15             USD.transferFrom(msg.sender, _this, dAmount);\n16              WEI.transferFrom(_this, msg.sender, cAmount);\n17         }\n18           function  getPrice() public payable returns (uint) { \n \n19                price = USD.balanceOf(address(pair)) / WEI.balanceOf(address(pair))\n20                  return price;\n21       }\n22    }\n",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 8+ \n16+\n",
    "invariants": "8+ assert(Old(getPrice())==getPrice());\n16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "ranks": "16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "vulnerabilities": "price manipulation\ninconsistent state update"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;\n10 \n11         function startExecute() external {\n12             require(proposal.sTime == 0, \"\"on-going proposal\"\");\n13             proposal = Proposal(block.timestamp, msg.sender);\n14         }\n15         function execute(uint amount) external {\n16             require(proposal.sTime + 2 days > block.timestamp,\n17             \"\"voting has ended\"\");\n18             votingToken.transferFrom(\n19             msg.sender, address(this), amount);\n20         }\n21         function endExecute() external {\n22             require(proposal.sTime != 0, \"\"no proposal\"\");\n23             require(proposal.sTime + 2 days < block.timestamp,\n24             \"\"voting has not ended\"\");\n25             require(votingToken.balanceOf(address(this))*2 >\n26             votingToken.totalSupply(), \"\"vote failed\"\");\n27             owner = proposal.newOwner;\n28             delete proposal;\n29         }\n30 }\n",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 contract ModifierEntrancy {\n\n3   mapping (address => uint) public tokenBalance;\n4   string constant name = \"Nu Token\";\n5   Bank bank;\n  \n6   constructor() public{\n7       bank = new Bank();\n8   }\n\n9   //If a contract has a zero balance and supports the token give them some token\n10   function airDrop() hasNoBalance supportsToken  public{\n11     tokenBalance[msg.sender] += 20;\n12   }\n  \n13   //Checks that the contract responds the way we want\n14   modifier supportsToken() {\n15     require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());\n16     _;\n17   }\n  \n18   //Checks that the caller has a zero balance\n19   modifier hasNoBalance {\n20       require(tokenBalance[msg.sender] == 0);\n21       _;\n22         }\n23   }\n\n24 contract Bank{\n\n25     function supportsToken() external returns(bytes32) {\n26         return keccak256(abi.encodePacked(\"Nu Token\"));\n27     }\n\n28 }\n15+\n",
    "transaction-context": "require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "Critical-points": "require(tokenBalance[msg.sender] == 0);",
    "invariants": "require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
    "critical-invariants": "require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');",
    "ranks": "require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "vulnerabilities": "require(id < nextPositionID, \"bad position id\");"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;\n7   IERC20 token1; \n8   address to; \n9   uint tokenPrice; //track price change \n\n10   function liquidate(uint ceilPrice) public {        \n11     tokenPrice = getPrice(); \n         //price is going to change: should we check here? \n12     if (tokenPrice >= ceilPrice){\n13       myToken.transfer(to, 100);\n14     }    \n15   }\n\n16   function getPrice() public{\n17     price = token0.balanceOf(address(this))/token1.balanceOf(address(this));\n         \n18   }  \n19 }\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n\n2 contract ERC20Interface {\n3     function totalSupply() public view returns (uint);\n4     function balanceOf(address tokenOwner) public view returns (uint balance);\n5     function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n6     function transfer(address to, uint tokens) public returns (bool success);\n7     function approve(address spender, uint tokens) public returns (bool success);\n8     function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n9     event Transfer(address indexed from, address indexed to, uint tokens);\n10     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n11 }\n\n\n\n12 contract SafeMath {\n13     function safeAdd(uint a, uint b) public pure returns (uint c) {\n14         c = a + b;\n15         require(c >= a);\n16     }\n \n17 function safeSub(uint a, uint b) public pure returns (uint c) {\n18         require(b <= a); \n19         c = a - b; } \n\n20 function safeMul(uint a, uint b) public pure returns (uint c) { \n21         c = a * b; \n22  } \n\n23 function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0);\n24         c = a / b;\n25     }\n26 }\n\n\n27 contract AlloHash is ERC20Interface, SafeMath {\n28     string public name;\n29     string public symbol;\n30     uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n\n31     uint256 public _totalSupply;\n\n32     mapping(address => uint) balances;\n33     mapping(address => mapping(address => uint)) allowed;\n\n  \n34     constructor() public {\n35         name = \"AlloHash\";\n36         symbol = \"ALH\";\n37         decimals = 18;\n38         _totalSupply = 180000000000000000000000000;\n\n39         balances[msg.sender] = _totalSupply;\n40         emit Transfer(address(0), msg.sender, _totalSupply);\n41     }\n\n42     function totalSupply() public view returns (uint) {\n43         return _totalSupply  - balances[address(0)];\n44     }\n\n45     function balanceOf(address tokenOwner) public view returns (uint balance) {\n46         return balances[tokenOwner];\n47     }\n\n48     function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n49         return allowed[tokenOwner][spender];\n50     }\n\n51     function approve(address spender, uint tokens) public returns (bool success) {\n52         allowed[msg.sender][spender] = tokens;\n53         emit Approval(msg.sender, spender, tokens);\n54         return true;\n55     }\n\n56     function transfer(address to, uint tokens) public returns (bool success) {\n57         balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n58         balances[to] = safeAdd(balances[to], tokens);\n59         emit Transfer(msg.sender, to, tokens);\n60         return true;\n61     }\n\n62     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n63         balances[from] = safeSub(balances[from], tokens);\n64         allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n65         balances[to] = safeAdd(balances[to], tokens);\n66         emit Transfer(from, to, tokens);\n67         return true;\n68     }\n69 }\n",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 15+ \n17+ \n21+ \n",
    "invariants": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);\n",
    "critical-invariants": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);",
    "ranks": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;\n8             ++i;\n9         } while (i < 1);\n       \n10     }\n\n11 }\n",
    "transaction-context": "The transaction context is loop",
    "Critical-points": "Critical program points are 9+ ",
    "invariants": "9+ assert (sum == 1);",
    "critical-invariants": "9+ assert (sum == 1);",
    "ranks": "9+ assert (sum == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";\n10 import \"./interfaces/XSushiExchangeRateInterface.sol\";\n11 import \"./interfaces/YVaultTokenInterface.sol\";\n12 import \"../CErc20.sol\";\n13 import \"../CToken.sol\";\n14 import \"../Exponential.sol\";\n15 import \"../EIP20Interface.sol\";\n16 \n17 contract PriceOracleProxy is PriceOracle, Exponential, Denominations {\n18     /// @notice Yvault token version, currently support v1 and v2\n19     enum YvTokenVersion {\n20         V1,\n21         V2\n22     }\n23 \n24     /// @notice Curve token version, currently support v1, v2 and v3\n25     enum CurveTokenVersion {\n26         V1,\n27         V2,\n28         V3\n29     }\n30 \n31     /// @notice Curve pool type, currently support ETH and USD base\n32     enum CurvePoolType {\n33         ETH,\n34         USD\n35     }\n36 \n37     struct YvTokenInfo {\n38         /// @notice Check if this token is a Yvault token\n39         bool isYvToken;\n40         /// @notice The version of Yvault\n41         YvTokenVersion version;\n42     }\n43 \n44     struct CrvTokenInfo {\n45         /// @notice Check if this token is a curve pool token\n46         bool isCrvToken;\n47         /// @notice The curve pool type\n48         CurvePoolType poolType;\n49         /// @notice The curve swap contract address\n50         address curveSwap;\n51     }\n52 \n53     struct AggregatorInfo {\n54         /// @notice The base\n55         address base;\n56         /// @notice The quote denomination\n57         address quote;\n58         /// @notice It's being used or not\n59         bool isUsed;\n60     }\n61 \n62     /// @notice Admin address\n63     address public admin;\n64 \n65     /// @notice Guardian address\n66     address public guardian;\n67 \n68     /// @notice Indicator that this is a PriceOracle contract (for inspection)\n69     bool public constant isPriceOracle = true;\n70 \n71     /// @notice The v1 price oracle, which will continue to serve prices for v1 assets\n72     V1PriceOracleInterface public v1PriceOracle;\n73 \n74     /// @notice The ChainLink registry address\n75     FeedRegistryInterface public registry;\n76 \n77     /// @notice ChainLink quotes\n78     mapping(address => AggregatorInfo) public aggregators;\n79 \n80     /// @notice Check if the underlying address is Uniswap or SushiSwap LP\n81     mapping(address => bool) public isUnderlyingLP;\n82 \n83     /// @notice Yvault token data\n84     mapping(address => YvTokenInfo) public yvTokens;\n85 \n86     /// @notice Curve pool token data\n87     mapping(address => CrvTokenInfo) public crvTokens;\n88 \n89     /// @notice BTC related addresses. All these underlying we use `Denominations.BTC` as the aggregator base.\n90     address[6] public btcAddresses = [\n91         0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, // WBTC\n92         0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D, // renBTC\n93         0x9BE89D2a4cd102D8Fecc6BF9dA793be995C22541, // BBTC\n94         0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa, // tBTC\n95         0x0316EB71485b0Ab14103307bf65a021042c6d380, // HBTC\n96         0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F // ibBTC\n97     ];\n98 \n99     address public cEthAddress;\n100 \n101     address public constant usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n102     address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n103     address public constant sushiAddress = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n104     address public constant xSushiExRateAddress = 0x851a040fC0Dcbb13a272EBC272F2bC2Ce1e11C4d;\n105     address public constant crXSushiAddress = 0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2;\n106 \n107     /**\n108      * @param admin_ The address of admin to set aggregators, LPs, curve tokens, or Yvault tokens\n109      * @param v1PriceOracle_ The address of the v1 price oracle, which will continue to operate and hold prices for collateral assets\n110      * @param cEthAddress_ The address of cETH, which will return a constant 1e18, since all prices relative to ether\n111      * @param registry_ The address of ChainLink registry\n112      */\n113     constructor(\n114         address admin_,\n115         address v1PriceOracle_,\n116         address cEthAddress_,\n117         address registry_\n118     ) public {\n119         admin = admin_;\n120         v1PriceOracle = V1PriceOracleInterface(v1PriceOracle_);\n121         cEthAddress = cEthAddress_;\n122         registry = FeedRegistryInterface(registry_);\n123     }\n124 \n125     /**\n126      * @notice Get the underlying price of a listed cToken asset\n127      * @param cToken The cToken to get the underlying price of\n128      * @return The underlying asset price mantissa (scaled by 1e18)\n129      */\n130     function getUnderlyingPrice(CToken cToken) public view returns (uint256) {\n131         address cTokenAddress = address(cToken);\n132         if (cTokenAddress == cEthAddress) {\n133             // ether always worth 1\n134             return 1e18;\n135         } else if (cTokenAddress == crXSushiAddress) {\n136             // Handle xSUSHI.\n137             uint256 exchangeRate = XSushiExchangeRateInterface(xSushiExRateAddress).getExchangeRate();\n138             return mul_(getTokenPrice(sushiAddress), Exp({mantissa: exchangeRate}));\n139         }\n140 \n141         address underlying = CErc20(cTokenAddress).underlying();\n142 \n143         // Handle LP tokens.\n144         if (isUnderlyingLP[underlying]) {\n145             return getLPFairPrice(underlying);\n146         }\n147 \n148         // Handle Yvault tokens.\n149         if (yvTokens[underlying].isYvToken) {\n150             return getYvTokenPrice(underlying);\n151         }\n152 \n153         // Handle curve pool tokens.\n154         if (crvTokens[underlying].isCrvToken) {\n155             return getCrvTokenPrice(underlying);\n156         }\n157 \n158         return getTokenPrice(underlying);\n159     }\n160 \n161     /*** Internal fucntions ***/\n162 \n163     /**\n164      * @notice Get the price of a specific token. Return 1e18 is it's WETH.\n165      * @param token The token to get the price of\n166      * @return The price\n167      */\n168     function getTokenPrice(address token) internal view returns (uint256) {\n169         if (token == wethAddress) {\n170             // weth always worth 1\n171             return 1e18;\n172         }\n173 \n174         AggregatorInfo memory aggregatorInfo = aggregators[token];\n175         if (aggregatorInfo.isUsed) {\n176             uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n177             if (aggregatorInfo.quote == Denominations.USD) {\n178                 // Convert the price to ETH based if it's USD based.\n179                 price = mul_(price, Exp({mantissa: getUsdcEthPrice()}));\n180             }\n181             uint256 underlyingDecimals = EIP20Interface(token).decimals();\n182             return mul_(price, 10**(18 - underlyingDecimals));\n183         }\n184         return getPriceFromV1(token);\n185     }\n186 \n187     /**\n188      * @notice Get price from ChainLink\n189      * @param base The base token that ChainLink aggregator gets the price of\n190      * @param quote The quote token, currenlty support ETH and USD\n191      * @return The price, scaled by 1e18\n192      */\n193     function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n194         (, int256 price, , , ) = registry.latestRoundData(base, quote);\n195         require(price > 0, \"invalid price\");\n196 \n197         // Extend the decimals to 1e18.\n198         return mul_(uint256(price), 10**(18 - uint256(registry.decimals(base, quote))));\n199     }\n200 \n201     /**\n202      * @notice Get the fair price of a LP. We use the mechanism from Alpha Finance.\n203      *         Ref: https://blog.alphafinance.io/fair-lp-token-pricing/\n204      * @param pair The pair of AMM (Uniswap or SushiSwap)\n205      * @return The price\n206      */\n207     function getLPFairPrice(address pair) internal view returns (uint256) {\n208         address token0 = IUniswapV2Pair(pair).token0();\n209         address token1 = IUniswapV2Pair(pair).token1();\n210         uint256 totalSupply = IUniswapV2Pair(pair).totalSupply();\n211         (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pair).getReserves();\n212         uint256 sqrtR = sqrt(mul_(r0, r1));\n213         uint256 p0 = getTokenPrice(token0);\n214         uint256 p1 = getTokenPrice(token1);\n215         uint256 sqrtP = sqrt(mul_(p0, p1));\n216         return div_(mul_(2, mul_(sqrtR, sqrtP)), totalSupply);\n217     }\n218 \n219     /**\n220      * @notice Get price for Yvault tokens\n221      * @param token The Yvault token\n222      * @return The price\n223      */\n224     function getYvTokenPrice(address token) internal view returns (uint256) {\n225         YvTokenInfo memory yvTokenInfo = yvTokens[token];\n226         require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n227 \n228         uint256 pricePerShare;\n229         address underlying;\n230         if (yvTokenInfo.version == YvTokenVersion.V1) {\n231             pricePerShare = YVaultV1Interface(token).getPricePerFullShare();\n232             underlying = YVaultV1Interface(token).token();\n233         } else {\n234             pricePerShare = YVaultV2Interface(token).pricePerShare();\n235             underlying = YVaultV2Interface(token).token();\n236         }\n237 \n238         uint256 underlyingPrice;\n239         if (crvTokens[underlying].isCrvToken) {\n240             underlyingPrice = getCrvTokenPrice(underlying);\n241         } else {\n242             underlyingPrice = getTokenPrice(underlying);\n243         }\n244         return mul_(underlyingPrice, Exp({mantissa: pricePerShare}));\n245     }\n246 \n247     /**\n248      * @notice Get price for curve pool tokens\n249      * @param token The curve pool token\n250      * @return The price\n251      */\n252     function getCrvTokenPrice(address token) internal view returns (uint256) {\n253         CrvTokenInfo memory crvTokenInfo = crvTokens[token];\n254         require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n255 \n256         uint256 virtualPrice = CurveSwapInterface(crvTokenInfo.curveSwap).get_virtual_price();\n257         if (crvTokenInfo.poolType == CurvePoolType.ETH) {\n258             return virtualPrice;\n259         }\n260 \n261         // We treat USDC as USD and convert the price to ETH base.\n262         return mul_(getUsdcEthPrice(), Exp({mantissa: virtualPrice}));\n263     }\n264 \n265     /**\n266      * @notice Get USDC price\n267      * @dev We treat USDC as USD for convenience\n268      * @return The USDC price\n269      */\n270     function getUsdcEthPrice() internal view returns (uint256) {\n271         return getTokenPrice(usdcAddress) / 1e12;\n272     }\n273 \n274     /**\n275      * @notice Get price from v1 price oracle\n276      * @param token The token to get the price of\n277      * @return The price\n278      */\n279     function getPriceFromV1(address token) internal view returns (uint256) {\n280         return v1PriceOracle.assetPrices(token);\n281     }\n282 \n283     /**\n284      * @notice Compare two strings are the same or not\n285      * @param a The first string\n286      * @param b The second string\n287      * @return The same or not\n288      */\n289     function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n290         return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n291     }\n292 \n293     /**\n294      * @notice Check if the token is one of BTC relared address\n295      * @param token The token address\n296      * @return It's BTC or not\n297      */\n298     function isBtcAddress(address token) internal returns (bool) {\n299         for (uint256 i = 0; i < btcAddresses.length; i++) {\n300             if (btcAddresses[i] == token) {\n301                 return true;\n302             }\n303         }\n304         return false;\n305     }\n306 \n307     /*** Admin or guardian functions ***/\n308 \n309     event AggregatorUpdated(address tokenAddress, address base, address quote, bool isUsed);\n310     event IsLPUpdated(address tokenAddress, bool isLP);\n311     event SetYVaultToken(address token, YvTokenVersion version);\n312     event SetCurveToken(address token, CurvePoolType poolType, address swap);\n313     event SetGuardian(address guardian);\n314     event SetAdmin(address admin);\n315 \n316     /**\n317      * @notice Set ChainLink aggregators for multiple tokens\n318      * @param tokenAddresses The list of underlying tokens\n319      * @param quotes The list of ChainLink aggregator quotes, currently support 'ETH' and 'USD'\n320      */\n321     function _setAggregators(address[] calldata tokenAddresses, string[] calldata quotes) external {\n322         require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323         require(tokenAddresses.length == quotes.length, \"mismatched data\");\n324         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n325             address base;\n326             address quote;\n327             bool isUsed;\n328             if (bytes(quotes[i]).length != 0) {\n329                 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n330                 isUsed = true;\n331 \n332                 base = tokenAddresses[i];\n333                 if (isBtcAddress(tokenAddresses[i])) {\n334                     base = Denominations.BTC;\n335                 }\n336 \n337                 if (compareStrings(quotes[i], \"ETH\")) {\n338                     quote = Denominations.ETH;\n339                 } else if (compareStrings(quotes[i], \"USD\")) {\n340                     quote = Denominations.USD;\n341                 } else {\n342                     revert(\"unsupported denomination\");\n343                 }\n344 \n345                 // Make sure the aggregator exists.\n346                 address aggregator = registry.getFeed(base, quote);\n347                 require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n348             }\n349             aggregators[tokenAddresses[i]] = AggregatorInfo({base: base, quote: quote, isUsed: isUsed});\n350             emit AggregatorUpdated(tokenAddresses[i], base, quote, isUsed);\n351         }\n352     }\n353 \n354     /**\n355      * @notice See assets as LP tokens for multiple tokens\n356      * @param tokenAddresses The list of tokens\n357      * @param isLP The list of cToken properties (it's LP or not)\n358      */\n359     function _setLPs(address[] calldata tokenAddresses, bool[] calldata isLP) external {\n360         require(msg.sender == admin, \"only the admin may set LPs\");\n361         require(tokenAddresses.length == isLP.length, \"mismatched data\");\n362         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n363             isUnderlyingLP[tokenAddresses[i]] = isLP[i];\n364             if (isLP[i]) {\n365                 // Sanity check to make sure the token is LP.\n366                 IUniswapV2Pair(tokenAddresses[i]).token0();\n367                 IUniswapV2Pair(tokenAddresses[i]).token1();\n368             }\n369             emit IsLPUpdated(tokenAddresses[i], isLP[i]);\n370         }\n371     }\n372 \n373     /**\n374      * @notice See assets as Yvault tokens for multiple tokens\n375      * @param tokenAddresses The list of tokens\n376      * @param version The list of vault version\n377      */\n378     function _setYVaultTokens(address[] calldata tokenAddresses, YvTokenVersion[] calldata version) external {\n379         require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n380         require(tokenAddresses.length == version.length, \"mismatched data\");\n381         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n382             // Sanity check to make sure version is right.\n383             if (version[i] == YvTokenVersion.V1) {\n384                 YVaultV1Interface(tokenAddresses[i]).getPricePerFullShare();\n385             } else {\n386                 YVaultV2Interface(tokenAddresses[i]).pricePerShare();\n387             }\n388 \n389             yvTokens[tokenAddresses[i]] = YvTokenInfo({isYvToken: true, version: version[i]});\n390             emit SetYVaultToken(tokenAddresses[i], version[i]);\n391         }\n392     }\n393 \n394     /**\n395      * @notice See assets as curve pool tokens for multiple tokens\n396      * @param tokenAddresses The list of tokens\n397      * @param poolType The list of curve pool type (ETH or USD base only)\n398      * @param swap The list of curve swap address\n399      */\n400     function _setCurveTokens(\n401         address[] calldata tokenAddresses,\n402         CurveTokenVersion[] calldata version,\n403         CurvePoolType[] calldata poolType,\n404         address[] calldata swap\n405     ) external {\n406         require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n407         require(\n408             tokenAddresses.length == version.length &&\n409                 tokenAddresses.length == poolType.length &&\n410                 tokenAddresses.length == swap.length,\n411             \"mismatched data\"\n412         );\n413         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n414             if (version[i] == CurveTokenVersion.V3) {\n415                 // Sanity check to make sure the token minter is right.\n416                 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");\n417             }\n418 \n419             crvTokens[tokenAddresses[i]] = CrvTokenInfo({isCrvToken: true, poolType: poolType[i], curveSwap: swap[i]});\n420             emit SetCurveToken(tokenAddresses[i], poolType[i], swap[i]);\n421         }\n422     }\n423 \n424     /**\n425      * @notice Set guardian for price oracle proxy\n426      * @param _guardian The new guardian\n427      */\n428     function _setGuardian(address _guardian) external {\n429         require(msg.sender == admin, \"only the admin may set new guardian\");\n430         guardian = _guardian;\n431         emit SetGuardian(guardian);\n432     }\n433 \n434     /**\n435      * @notice Set admin for price oracle proxy\n436      * @param _admin The new admin\n437      */\n438     function _setAdmin(address _admin) external {\n439         require(msg.sender == admin, \"only the admin may set new admin\");\n440         admin = _admin;\n441         emit SetAdmin(admin);\n442     }\n443 }\n379\n",
    "transaction-context": "require(msg.sender == admin, \"only the admin may set Yvault tokens\");",
    "Critical-points": "require(tokenAddresses.length == version.length, \"mismatched data\");",
    "invariants": "require(msg.sender == admin, \"only the admin may set curve pool tokens\");",
    "critical-invariants": " require(tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\" );",
    "ranks": " require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       (a,  b) = (1, 3);\n  \n\n8       (a, b) = returnTuple();\n   \n9       (a, b) = returnTupleByName();\n    \n10       //(, b) = returnTuple(); //can;t handle null placeholders\n11       //assert (b == 40);\n12    }\n   \n13    function returnTuple() private pure returns (uint, uint){\n14       return (4, 40); \n15    }\n\n16    function returnTupleByName() private pure returns (uint a, uint b){\n17       a = 5;\n18       b = 55;\n19       return (a,b); \n20    }\n21 }\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n9+ \n\n",
    "invariants": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);\n",
    "critical-invariants": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);",
    "ranks": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n9 import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n10 import \"./interfaces/IPancakePair.sol\";\n11 import \"./interfaces/IPancakeFactory.sol\";\n12 import \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\n13 import \"./interfaces/IGymLevelPool.sol\";\n14 import \"./interfaces/IGymSinglePool.sol\";\n15 /* preserved Line */\n16 /* preserved Line */\n17 /* preserved Line */\n18 /* preserved Line */\n19 /* preserved Line */\n\n20 /**\n21  * @notice GymSinglePool contract:\n22  * - Users can:\n23  *   # Deposit GYMNET\n24  *   # Withdraw assets\n25  */\n\n26 contract GymSinglePool is ReentrancyGuardUpgradeable, OwnableUpgradeable {\n27     using SafeERC20Upgradeable for IERC20Upgradeable;\n\n28    /**\n29      * @notice Info of each user\n30      * One Address can have many Deposits with different periods. Unlimited Amount.\n31      * Total Depsit Tokens = Total amount of user active stake in all.\n32      * Total Depsit Dollar Value = Total Dollar Value over all staking single pools. Calculated when user deposits tokens, and dollar value is for that exact moment rate.\n33      * level = level qualification for this pool. Used internally, for global qualification please check MLM Contract.\n34      * depositId = incremental ID of deposits, eg. if user has 3 stakings then this value will be 2;\n35      * totalClaimt = Total amount of tokens user claimt. \n36      */\n37     struct UserInfo {\n38         uint256 totalDepositTokens;\n39         uint256 totalDepositDollarValue;\n40         uint256 level;\n41         uint256 depositId;\n42         uint256 totalClaimt;\n43     }\n\n44    /** \n45      * @notice Info for each staking by ID\n46      * One Address can have many Deposits with different periods. Unlimited Amount.\n47      * depositTokens = amount of tokens for exact deposit.\n48      * depositDollarValue = Dollar value of deposit.\n49      * stakePeriod = Locking Period - from 3 months to 30 months. value is integer\n50      * depositTimestamp = timestamp of deposit\n51      * withdrawalTimestamp = Timestamp when user can withdraw his locked tokens\n52      * rewardsGained = amount of rewards user has gained during the process\n53      * is_finished = checks if user has already withdrawn tokens\n54      */\n55     struct UserDeposits {\n56         uint256 depositTokens;\n57         uint256 depositDollarValue;\n58         uint256 stakePeriod;\n59         uint256 depositTimestamp;\n60         uint256 withdrawalTimestamp;\n61         uint256 rewardsGained;\n62         uint256 rewardsClaimt;\n63         uint256 rewardDebt;\n64         bool is_finished;\n65     }\n66     /**\n67      * @notice Info of Pool\n68      * @param lastRewardBlock: Last block number that reward distribution occurs\n69      * @param accUTacoPerShare: Accumulated rewardPool per share, times 1e18\n70      * @param rewardPerBlock: How many reward tokens will user get per block\n71      */\n72     struct PoolInfo {\n73         uint256 lastRewardBlock;\n74         uint256 accRewardPerShare;\n75         uint256 rewardPerBlock;\n76     }\n\n77     /// Startblock number\n78     uint256 public startBlock;\n79     uint256 public withdrawFee;\n\n80      // MLM Contract - RelationShip address\n81     address public relationship;\n82     /// Treasury address where will be sent all unused assets\n83     address public treasuryAddress;\n84     /// Info of pool.\n85     PoolInfo public poolInfo;\n86     /// Info of each user that staked tokens.\n87     mapping(address => UserInfo) public userInfo;\n\n88     /// accepts user address and id of element to select - returns information about selected staking by id\n89     mapping (address=>UserDeposits[]) public user_deposits;\n\n90     uint256 private lastChangeBlock;\n\n91     /// GYMNET token contract address\n92     address public tokenAddress;\n\n93     /// address of pancake Router\n94     address public pancakeRouterAddress;\n95     /// WBNB and BUSD Token Pair address, element 0 = Address of WBNB Token, element 1= Address of GYMNET \n96     address[] public wbnbAndUSDTTokenArray;\n97     /// GYMNET and WBNB Token Pair address, element 0 = Address of GYMNET, element 1 = Address of WBNB Token, \n98     address[] public GymWBNBPair;\n\n99     /// Level Qualifications for the pool\n100     uint256[16] public levels;\n101     /// Locking Periods \n102     uint256[6] public months;\n\n103     /// Amount of Total GYMNET Locked in the pool\n104     uint256 public totalGymnetLocked;\n\n105     /// Amount of GYMNET all users has claimt over time.\n106     uint256 public totalClaimtInPool;\n\n107     /// Percent that will be sent to MLM Contract for comission distribution\n108     uint256 public RELATIONSHIP_REWARD;\n\n109     /// 6% comissions\n110     uint256 public poolRewardsAmount;\n\n111     address public holderRewardContractAddress;\n\n112     address public runnerScriptAddress;\n113     uint256 public totalBurntInSinglePool;\n114     bool public isPoolActive;\n115     bool public isInMigrationToVTwo;\n116     uint256 public totalGymnetUnlocked;\n117     uint256 public unlockedTimestampQualification;\n118     address public vaultContractAddress;\n119     address public farmingContractAddress;\n\n120     address public levelPoolContractAddress;\n121     address public newSinglePoolAddress;\n\n122     /* ========== EVENTS ========== */\n\n123     event Initialized(address indexed executor, uint256 at);\n124     event Deposit(address indexed user, uint256 amount,uint indexed period);\n125     event Withdraw(address indexed user, uint256 amount,uint indexed period);\n126     event RewardPaid(address indexed token, address indexed user, uint256 amount);\n127     event ClaimUserReward(address indexed user, uint256 amount);\n\n\n128     modifier onlyRunnerScript() {\n129         require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n130         _;\n131     }\n132     modifier onlyBank() {\n133         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n134         _;\n135     }\n136     receive() external payable {}\n\n137     fallback() external payable {}\n\n138 // all initialize parameters are mandatory\n139     function initialize(\n140         uint256 _startBlock,\n141         address _gym,\n142         address _mlm,\n143         uint256 _gymRewardRate,\n144         address _pancakeRouterAddress,\n145         address[] memory _wbnbAndUSDTTokenArray,\n146         address[] memory _GymWBNBPair\n147     ) external initializer {\n148         require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n\n149         startBlock = _startBlock; // Number of Upcoming Block\n150         relationship = _mlm;  // address of MLM contract\n151         tokenAddress = _gym; // address of GYMNET Contract\n152         pancakeRouterAddress = _pancakeRouterAddress; // Address of Pancake Router\n153         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray; // WBNB And USDT Token Addresses [WBNB,USDT]\n154         GymWBNBPair = _GymWBNBPair; // GYMNET And WBNB Token Addresses [GYMNET,WBNB]\n155         runnerScriptAddress = msg.sender;\n156         isPoolActive = false;\n157         isInMigrationToVTwo = false;\n158         RELATIONSHIP_REWARD = 39; // Relationship commission amount\n159         levels = [0, 0, 200, 200, 2000, 4000, 10000, 20000, 40000, 45000, 50000, 60000, 65000, 70000, 75000, 80000]; // Internal Pool Levels\n160         months = [3, 6, 12, 18, 24, 30]; // Locking Periods\n\n161         poolInfo = PoolInfo({\n162                 lastRewardBlock: _startBlock,\n163                 rewardPerBlock: _gymRewardRate,\n164                 accRewardPerShare: 0\n165             });\n\n166         lastChangeBlock = _startBlock;\n\n167         __Ownable_init();\n168         __ReentrancyGuard_init();\n        \n169         emit Initialized(msg.sender, block.number);\n170     }\n\n\n171     function setPoolInfo(uint256 lastRewardBlock,uint256 accRewardPerShare, uint256 rewardPerBlock) external onlyOwner {\n172         poolInfo = PoolInfo({\n173                 lastRewardBlock: lastRewardBlock,\n174                 accRewardPerShare: accRewardPerShare,\n175                 rewardPerBlock: rewardPerBlock\n176             });\n177     }\n\n178     function updateStartBlock(uint256 _startBlock) external onlyOwner {\n179         startBlock = _startBlock;\n180     }\n\n181     function setMLMAddress(address _relationship) external onlyOwner {\n182         relationship = _relationship;\n183     }\n\n184     function setTokenAddress(address _tokenAddress) external onlyOwner {\n185         tokenAddress = _tokenAddress;\n186     }\n187     function setVaultContractAddress(address _vaultContractAddress) external onlyOwner {\n188         vaultContractAddress = _vaultContractAddress;\n189     }\n190     function setFarmingContractAddress(address _farmingContractAddress) external onlyOwner {\n191         farmingContractAddress = _farmingContractAddress;\n192     }\n\n193     function setLevelPoolContractAddress(address _levelPoolContractAddress) external onlyOwner {\n194         levelPoolContractAddress = _levelPoolContractAddress;\n195     }\n\n196     function setRelationshipReward(uint256 _amount) external onlyOwner {\n197         RELATIONSHIP_REWARD = _amount;\n198     }\n199     function setOnlyRunnerScript(address _onlyRunnerScript) external onlyOwner {\n200         runnerScriptAddress = _onlyRunnerScript;\n201     }\n202     function setNewSinglePoolAddress(address _newSinglePoolAddress) external onlyOwner {\n203         newSinglePoolAddress = _newSinglePoolAddress;\n204     }\n\n205     function setGymWBNBPair(address[] memory  _GymWBNBPair) external onlyOwner {\n206         GymWBNBPair = _GymWBNBPair;\n207     }\n208     function setPancakeRouterAddress(address _pancakeRouterAddress) external onlyOwner {\n209         pancakeRouterAddress = _pancakeRouterAddress;\n210     }\n\n211     function setIsPoolActive(bool _isPoolActive) external onlyOwner {\n212         isPoolActive = _isPoolActive;\n213     }\n214     function setIsInMigrationToVTwo(bool _isInMigrationToVTwo) external onlyOwner {\n215         isInMigrationToVTwo = _isInMigrationToVTwo;\n216     }\n\n217     function setHolderRewardContractAddress(address _holderRewardContractAddress) external onlyOwner {\n218         holderRewardContractAddress = _holderRewardContractAddress;\n219     }\n\n\n220     function setWbnbAndUSDTTokenArray(address[] memory _wbnbAndUSDTTokenArray) external onlyOwner {\n221         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray;\n222     }\n223     function setUnlockedTimestampQualification(uint256 _unlockedTimestampQualification) external onlyOwner {\n224         unlockedTimestampQualification = _unlockedTimestampQualification;\n225     }\n226     function setLevels(uint256[16] calldata _levels) external onlyOwner {\n227         levels = _levels;\n228     }\n\n229      /**\n230      * @notice  Function to set Treasury address\n231      * @param _treasuryAddress Address of treasury address\n232      */\n233     function setTreasuryAddress(address _treasuryAddress) external nonReentrant onlyOwner {\n234         treasuryAddress = _treasuryAddress;\n235     }\n\n236     /**\n237      * @notice Deposit in given pool\n238      * @param _depositAmount: Amount of want token that user wants to deposit\n239      */\n240     function deposit(\n241         uint256 _depositAmount,\n242         uint8 _periodId,\n243         uint256 _referrerId,\n244         bool isUnlocked\n245     ) external  {\n246         require(isPoolActive,'Contract is not running yet');\n247         IGymMLM(relationship).addGymMLM(msg.sender, _referrerId);\n248         _deposit(_depositAmount,_periodId,isUnlocked);\n249     }\n250     /**\n251      * @notice Deposit in given pool\n252      * @param _depositAmount: Amount of want token that user wants to deposit\n253      */\n254     function depositFromOtherContract(\n255         uint256 _depositAmount,\n256         uint8 _periodId,\n257         bool isUnlocked,\n258         address _from\n259     ) external onlyBank {\n260         require(isPoolActive,'Contract is not running yet');\n261         _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n\n262         _updateLevelPoolQualification(_from);\n263     }\n\n264     /**\n265      * @notice To get User level in other contract for single pool.\n266      * @param _user: User address\n267      */\n268     function getUserLevelInSinglePool(address _user) external view returns (uint32) {\n269         uint256 _totalDepositDollarValue = userInfo[_user].totalDepositDollarValue;\n270         uint32 level = 0;\n271         for (uint32 i = 0; i<levels.length ; i++) {\n272             if(_totalDepositDollarValue >= levels[i]) {\n273                 level=i;\n274             }\n275         }\n276         return level;\n277     }\n\n278     /**\n279     Should approve allowance before initiating\n280     accepts depositAmount in WEI\n281     periodID - id of months array accordingly\n282     */\n283     function _deposit(\n284         uint256 _depositAmount,\n285         uint8 _periodId,\n286         bool _isUnlocked\n287     ) private {\n288         UserInfo storage user = userInfo[msg.sender];\n289         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n290         PoolInfo storage pool = poolInfo;\n291         updatePool();\n\n292         uint256 period = months[_periodId];\n293         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n294         uint256 burnTokensAmount = 0;\n\n295         if(!_isUnlocked) {\n296             burnTokensAmount = (_depositAmount * 4) / 100;\n297             totalBurntInSinglePool += burnTokensAmount;\n298             IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n299         }\n\n        \n300         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n\n301         token.safeTransferFrom(msg.sender, address(this), amountToDeposit);\n302         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n303         user.totalDepositTokens += amountToDeposit;\n304         user.totalDepositDollarValue += UsdValueOfGym;\n305         totalGymnetLocked += amountToDeposit;\n306         if(_isUnlocked) {\n307             totalGymnetUnlocked += amountToDeposit;\n308             period = 0; \n309             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n310         }\n\n311         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n312         UserDeposits memory depositDetails = UserDeposits(\n313             {\n314                 depositTokens: amountToDeposit, \n315                 depositDollarValue: UsdValueOfGym,\n316                 stakePeriod: period,\n317                 depositTimestamp: block.timestamp,\n318                 withdrawalTimestamp: lockTimesamp,\n319                 rewardsGained: 0,\n320                 is_finished: false,\n321                 rewardsClaimt: 0,\n322                 rewardDebt: rewardDebt\n323             }\n324         );\n\n325         user_deposits[msg.sender].push(depositDetails);\n326         user.depositId = user_deposits[msg.sender].length;\n        \n\n327        for (uint i = 0; i<levels.length ; i++) {\n328             if(user.totalDepositDollarValue >= levels[i]) {\n329                 user.level=i;\n330             }\n331         }\n332         _updateLevelPoolQualification(msg.sender);\n333         emit Deposit(msg.sender, _depositAmount,_periodId);\n334     }\n\n335      /**\n336     Should approve allowance before initiating\n337     accepts depositAmount in WEI\n338     periodID - id of months array accordingly\n339     */\n340     function _autoDeposit(\n341         uint256 _depositAmount,\n342         uint8 _periodId,\n343         bool _isUnlocked,\n344         address _from\n345     ) private {\n346         UserInfo storage user = userInfo[_from];\n347         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n348         PoolInfo storage pool = poolInfo;\n349         token.approve(address(this), _depositAmount);\n350         updatePool();\n351         uint256 period = months[_periodId];\n352         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n353         uint256 burnTokensAmount = 0;\n354         // if(!_isUnlocked) {\n355         //     uint256 burnTokensAmount = (_depositAmount * 4) / 100;\n356         //     totalBurntInSinglePool += burnTokensAmount;\n357         //     IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n358         // }\n359         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n360         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n361         user.totalDepositTokens += amountToDeposit;\n362         user.totalDepositDollarValue += UsdValueOfGym;\n363         totalGymnetLocked += amountToDeposit;\n364         if(_isUnlocked) {\n365             totalGymnetUnlocked += amountToDeposit;\n366             period = 0; \n367             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n368         }\n\n369         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n370         UserDeposits memory depositDetails = UserDeposits(\n371             {\n372                 depositTokens: amountToDeposit, \n373                 depositDollarValue: UsdValueOfGym,\n374                 stakePeriod: period,\n375                 depositTimestamp: block.timestamp,\n376                 withdrawalTimestamp: lockTimesamp,\n377                 rewardsGained: 0,\n378                 is_finished: false,\n379                 rewardsClaimt: 0,\n380                 rewardDebt: rewardDebt\n381             }\n382         );\n383         user_deposits[_from].push(depositDetails);\n384         user.depositId = user_deposits[_from].length;\n \n385         emit Deposit(_from, amountToDeposit,_periodId);\n386     }\n\n387      /**\n388      * Returns the latest price\n389      */\n390     function getPrice () public view returns (uint) {\n391         uint256[] memory gymPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1000000000000000000,GymWBNBPair);\n392         uint256[] memory BNBPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1, wbnbAndUSDTTokenArray);\n393         return gymPriceInUSD[1] * BNBPriceInUSD[1];\n394     }\n\n\n395     /**\n396      * @notice withdraw one claim\n397      * @param _depositId: is the id of user element. \n398      */\n399     function withdraw(\n400         uint256 _depositId\n401     ) external  {\n402         require(_depositId >= 0, \"Value is not specified\");\n403         updatePool();\n404         _withdraw(_depositId);\n\n405         _updateLevelPoolQualification(msg.sender);\n406     }\n\n407     /**\n408     Should approve allowance before initiating\n409     accepts _depositId - is the id of user element. \n410     */\n411     function _withdraw(\n412             uint256 _depositId\n413         ) private {\n414             UserInfo storage user = userInfo[msg.sender];\n415             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n416             PoolInfo storage pool = poolInfo;\n417             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n418             if(!isInMigrationToVTwo) {\n419                 require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n420             }\n421             require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n\n422             _claim(_depositId,1);\n423             depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n\n424             user.totalDepositTokens -=  depositDetails.depositTokens;\n425             user.totalDepositDollarValue -=  depositDetails.depositDollarValue;\n426             totalGymnetLocked -= depositDetails.depositTokens;\n427             if(depositDetails.stakePeriod == 0) {\n428                 totalGymnetUnlocked -= depositDetails.depositTokens;\n429             }\n            \n430             token.safeTransferFrom(address(this),msg.sender, depositDetails.depositTokens);\n\n431             for (uint i = 0; i<levels.length ; i++) {\n432                 if(user.totalDepositDollarValue >= levels[i]) {\n433                     user.level=i;\n434                 }\n435             }\n436             depositDetails.is_finished = true;\n437             emit Withdraw(msg.sender,  depositDetails.depositTokens,depositDetails.stakePeriod);\n\n\n438         }\n\n\n439     /**\n440      * @notice Claim rewards you gained over period\n441      * @param _depositId: is the id of user element. \n442      */\n443     function claim(\n444         uint256 _depositId\n445     ) external  {\n446         require(_depositId >= 0, \"Value is not specified\");\n447         updatePool();\n448         refreshMyLevel(msg.sender);\n449         _claim(_depositId,0);\n450     }\n\n451    /*\n452     Should approve allowance before initiating\n453     accepts _depositId - is the id of user element. \n454     */\n455     function _claim(\n456             uint256 _depositId,\n457             uint256 fromWithdraw\n458         ) private {\n459             UserInfo storage user = userInfo[msg.sender];\n460             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n461             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n462             PoolInfo storage pool = poolInfo;\n\n463             uint256 pending = pendingReward(_depositId,msg.sender);\n\n464             if(fromWithdraw == 0) {\n465                 require(pending > 0 ,\"No rewards to claim.\");\n466             }\n\n\n467             if (pending > 0) {\n468                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n469                 token.safeTransfer(relationship, distributeRewardTokenAmt);\n470                 IGymMLM(relationship).distributeRewards(pending, address(tokenAddress), msg.sender, 3);\n\n471                 // 6% distribution \n472                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n473                 poolRewardsAmount += calculateDistrubutionReward; \n                \n474                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n475                 safeRewardTransfer(tokenAddress, msg.sender, calcUserRewards);\n\n476                 user.totalClaimt += calcUserRewards;\n477                 totalClaimtInPool += pending;\n478                 depositDetails.rewardsClaimt += pending;\n479                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n480                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n481                  depositDetails.rewardsGained = 0;\n482             }\n            \n483             // token.safeTransferFrom(address(this),msg.sender, depositDetails.rewardsGained);\n\n484         }\n\n\n      \n485    /*\n486     transfers pool commisions to management\n487     */\n488     function transferPoolRewards() public onlyRunnerScript {\n489             require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n490             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n491             token.safeTransfer(holderRewardContractAddress, poolRewardsAmount);\n492             // token.safeTransfer(relationship, poolRewardsAmount/2);\n493             poolRewardsAmount = 0;\n494         }  \n\n\n495     /**\n496      * @notice  Safe transfer function for reward tokens\n497      * @param _rewardToken Address of reward token contract\n498      * @param _to Address of reciever\n499      * @param _amount Amount of reward tokens to transfer\n500      */\n501     function safeRewardTransfer(\n502         address _rewardToken,\n503         address _to,\n504         uint256 _amount\n505     ) internal {\n506         uint256 _bal = IERC20Upgradeable(_rewardToken).balanceOf(address(this));\n507         if (_amount > _bal) {\n508             require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n509         } else {\n510             require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n511         }\n512     }\n513     /**\n514      * @notice To get User Info in other contract.\n515      */\n516     function getUserInfo(address _user) external view returns (UserInfo memory) {\n517         return userInfo[_user];\n518     }\n\n519         /**\n520      * @notice View function to see pending reward on frontend.\n521      * @param _depositId: Staking pool id\n522      * @param _user: User address\n523      */\n524     function pendingReward(uint256 _depositId, address _user) public view returns (uint256) {\n525         UserDeposits storage depositDetails = user_deposits[_user][_depositId];\n526         UserInfo storage user = userInfo[_user];\n527         PoolInfo storage pool = poolInfo;\n528         if(depositDetails.is_finished == true || depositDetails.stakePeriod == 0){\n529             return 0;\n530         }\n      \n531         uint256 _accRewardPerShare = pool.accRewardPerShare;\n532         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n\n533         if (block.number > pool.lastRewardBlock && sharesTotal != 0) {\n534             uint256 _multiplier = block.number - pool.lastRewardBlock;\n535             uint256 _reward = (_multiplier * pool.rewardPerBlock);\n536              _accRewardPerShare = _accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n537         }\n\n538         return (depositDetails.depositTokens * _accRewardPerShare) / (1e18) - (depositDetails.rewardDebt);\n539     }\n\n\n540     /**\n541      * @notice Update reward variables of the given pool to be up-to-date.\n542      */\n543     function updatePool() public {\n544         PoolInfo storage pool = poolInfo;\n545         if (block.number <= pool.lastRewardBlock) {\n546             return;\n547         }\n548         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n549         if (sharesTotal == 0) {\n550             pool.lastRewardBlock = block.number;\n551             return;\n552         }\n553         uint256 multiplier = block.number - pool.lastRewardBlock;\n554         if (multiplier <= 0) {\n555             return;\n556         }\n557         uint256 _rewardPerBlock = pool.rewardPerBlock;\n558         uint256 _reward = (multiplier * _rewardPerBlock);\n559         pool.accRewardPerShare = pool.accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n560         pool.lastRewardBlock = block.number;\n561     }\n562     /**\n563      * @notice Claim All Rewards in one Transaction Internat Function.\n564      * If reinvest = true, Rewards will be reinvested as a new Staking\n565      * Reinvest Period Id is the id of months element\n566      */\n567     function _claimAll(bool reinvest,uint8 reinvestPeriodId) private {\n568         UserInfo storage user = userInfo[msg.sender];\n569         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n570         PoolInfo storage pool = poolInfo;\n571          updatePool();\n572          uint256 distributeRewardTokenAmtTotal = 0;\n573          uint256 calcUserRewardsTotal = 0;\n574          uint256 totalDistribute = 0;\n575         for (uint256 i = 0; i<user.depositId ; i++) {\n576             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n577             uint256 pending = pendingReward(i,msg.sender);\n578             totalDistribute += pending;\n579             if (pending > 0) {\n580                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n581                  distributeRewardTokenAmtTotal += distributeRewardTokenAmt;\n582                 // 6% distribution \n583                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n584                 poolRewardsAmount += calculateDistrubutionReward; \n                \n585                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n586                 calcUserRewardsTotal += calcUserRewards;\n\n587                 user.totalClaimt += calcUserRewards;\n588                 totalClaimtInPool += pending;\n589                 depositDetails.rewardsClaimt += pending;\n590                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n591                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n592                  depositDetails.rewardsGained = 0;\n593             }\n            \n594         }\n595         token.safeTransfer(relationship, distributeRewardTokenAmtTotal);\n596         IGymMLM(relationship).distributeRewards(totalDistribute, address(tokenAddress), msg.sender, 3);\n597         safeRewardTransfer(tokenAddress, msg.sender, calcUserRewardsTotal);\n598         if(reinvest == true) {\n599           _deposit(calcUserRewardsTotal,reinvestPeriodId,false);\n600         }\n601     }\n602     /**\n603      * @notice Claim All Rewards in one Transaction.\n604      */\n605     function claimAll() public {\n606          refreshMyLevel(msg.sender);\n607         _claimAll(false,0);\n608     }\n609     /**\n610      * @notice Claim and Reinvest all rewards public function to trigger internal _claimAll function.\n611      */\n612     function claimAndReinvest(bool reinvest,uint8 periodId) public {\n613         require(isPoolActive,'Contract is not running yet');\n614         _claimAll(reinvest,periodId);\n615     }\n\n616     function refreshMyLevel(address _user) public {\n617         UserInfo storage user = userInfo[_user];\n618         for (uint i = 0; i<levels.length ; i++) {\n619             if(user.totalDepositDollarValue >= levels[i]) {\n620                 user.level=i;\n621             }\n622         }\n623     }\n624     function totalLockedTokens(address _user) public view returns (uint256) {\n625         UserInfo storage user = userInfo[_user];\n626         uint256 totalDepositLocked = 0;\n627         for (uint256 i = 0; i<user.depositId ; i++) {\n628             UserDeposits storage depositDetails = user_deposits[_user][i];\n629             if(depositDetails.stakePeriod != 0 && !depositDetails.is_finished) {\n630                 totalDepositLocked += depositDetails.depositTokens;\n631             } \n632         }\n633         return totalDepositLocked;\n634     }\n\n635     function switchToUnlocked(uint256 _depositId) public {\n636         UserInfo storage user = userInfo[msg.sender];\n637         UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n639         _claim(_depositId,1);\n640         uint256 lockTimesamp = DateTime.addSeconds(block.timestamp,1);\n\n641         depositDetails.stakePeriod = 0;\n642         depositDetails.withdrawalTimestamp = lockTimesamp;\n643         totalGymnetUnlocked += depositDetails.depositTokens;\n\n644     }\n\n645     function _updateLevelPoolQualification(address wallet) internal {\n646         uint256 userLevel = IGymMLM(relationship).getUserCurrentLevel(wallet);\n647         IGymLevelPool(levelPoolContractAddress).updateUserQualification(wallet, userLevel);\n648     }\n\n649     function transferToV2(uint8 _periodId,bool isUnlocked) public {\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n651         UserInfo storage user = userInfo[msg.sender];\n652          require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');\n653          if(isUnlocked) {\n654             _periodId = 0;\n655          }\n656         _claimAll(false,0);\n657         uint256 dollarValueOfDeposits = user.totalDepositDollarValue * 1e18;\n658         IGymSinglePool(newSinglePoolAddress).transferFromOldVersion(\n659              user.totalDepositTokens,\n660              _periodId,\n661              isUnlocked,\n662              msg.sender,\n663              dollarValueOfDeposits\n664         );\n665         for (uint32 i = 0; i<user.depositId ; i++) {\n666             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n667             depositDetails.depositTokens = 0;\n668             depositDetails.is_finished = true;\n669             totalGymnetLocked -= depositDetails.depositTokens;\n670             if(depositDetails.stakePeriod == 0) {\n671                 totalGymnetUnlocked -= depositDetails.depositTokens;\n672             }\n673         }\n\n674         user.totalDepositDollarValue = 0;\n675         user.totalDepositTokens = 0;\n\n676     }\n677     function burnOldTokens() public onlyOwner {\n678         uint256 _bal = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n679         IERC20Burnable(tokenAddress).burnFrom(address(this),_bal);\n680     }\n681 }\n",
    "transaction-context": "The transaction context is liquidity pool",
    "Critical-points": "Critical program points are 128    \n132  \n148   \n171    \n178    \n181     \n184   \n193    \n196    \n199   \n202    \n205  \n211    \n214   \n217    \n220  \n223    \n226 \n233  \n246       \n254       \n260         \n402        \n419      \n421       \n446        \n465      \n488    \n489       \n508          \n510         \n613        \n638       \n650      \n652     ",
    "invariants": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n148    require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n171    onlyOwner\n178    onlyOwner\n181     onlyOwner\n184    onlyOwner\n193    onlyOwner\n196    onlyOwner\n199     onlyOwner\n202    onlyOwner\n205    onlyOwner\n211    onlyOwner\n214    onlyOwner\n217    onlyOwner\n220    onlyOwner\n223    onlyOwner\n226    onlyOwner\n233    onlyOwner\n246         require(isPoolActive,'Contract is not running yet');\n254         onlyBank\n259        onlyBank\n260         require(isPoolActive,'Contract is not running yet');\n402         require(_depositId >= 0, \"Value is not specified\");\n419         require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n421        require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n446         require(_depositId >= 0, \"Value is not specified\");\n465         require(pending > 0 ,\"No rewards to claim.\");\n488         onlyRunnerScript\n\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "critical-invariants": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n488         onlyRunnerScript\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "ranks": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n488         onlyRunnerScript\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Arithmetics {\n\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\n4         c = _a + _b;\n      \n5     }\n\n6     function subtraction(uint _a, uint _b) public pure returns (uint c) {\n7         c = _a - _b;       \n8     }\n\n9     function mutliplication(uint _a, uint _b) public pure returns (uint c) {\n10         c = _a * _b;       \n11     }\n\n12     function division(uint _a, uint _b) public pure returns (uint c) {\n13         c = _a / _b;      \n14     }\n\n15 }\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 4+ \n7+ \n10+ \n13+ ",
    "invariants": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "critical-invariants": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "ranks": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "vulnerabilities": "arithmetic flaw \ninteger overflow/underflow\n"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**\n7  *Submitted for verification at FtmScan.com on 2021-08-31\n8 */\n\n9 // SPDX-License-Identifier: MIT\n10 // File: @openzeppelin/contracts/GSN/Context.sol\n\n11 pragma solidity ^0.5.0;\n\n12 /*\n13  * @dev Provides information about the current execution context, including the\n14  * sender of the transaction and its data. While these are generally available\n15  * via msg.sender and msg.data, they should not be accessed in such a direct\n16  * manner, since when dealing with GSN meta-transactions the account sending and\n17  * paying for execution may not be the actual sender (as far as an application\n18  * is concerned).\n19  *\n20  * This contract is only required for intermediate, library-like contracts.\n21  */\n22 abstract contract Context {\n23     function _msgSender() internal view virtual returns (address payable) {\n24         return msg.sender;\n25     }\n\n26     function _msgData() internal view virtual returns (bytes memory) {\n27         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n28         return msg.data;\n29     }\n30 }\n\n31 // File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\n32 /**\n33  * @dev Interface of the ERC20 standard as defined in the EIP.\n34  */\n35 interface IERC20 {\n36     /**\n37      * @dev Returns the amount of tokens in existence.\n38      */\n39     function totalSupply() external view returns (uint256);\n\n40     /**\n41      * @dev Returns the amount of tokens owned by `account`.\n42      */\n43     function balanceOf(address account) external view returns (uint256);\n\n44     /**\n45      * @dev Moves `amount` tokens from the caller's account to `recipient`.\n46      *\n47      * Returns a boolean value indicating whether the operation succeeded.\n48      *\n49      * Emits a {Transfer} event.\n50      */\n51     function transfer(address recipient, uint256 amount) external returns (bool);\n\n52     /**\n53      * @dev Returns the remaining number of tokens that `spender` will be\n54      * allowed to spend on behalf of `owner` through {transferFrom}. This is\n55      * zero by default.\n56      *\n57      * This value changes when {approve} or {transferFrom} are called.\n58      */\n59     function allowance(address owner, address spender) external view returns (uint256);\n\n60     /**\n61      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n62      *\n63      * Returns a boolean value indicating whether the operation succeeded.\n64      *\n65      * IMPORTANT: Beware that changing an allowance with this method brings the risk\n66      * that someone may use both the old and the new allowance by unfortunate\n67      * transaction ordering. One possible solution to mitigate this race\n68      * condition is to first reduce the spender's allowance to 0 and set the\n69      * desired value afterwards:\n70      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n71      *\n72      * Emits an {Approval} event.\n73      */\n74     function approve(address spender, uint256 amount) external returns (bool);\n\n75     /**\n76      * @dev Moves `amount` tokens from `sender` to `recipient` using the\n77      * allowance mechanism. `amount` is then deducted from the caller's\n78      * allowance.\n79      *\n80      * Returns a boolean value indicating whether the operation succeeded.\n81      *\n82      * Emits a {Transfer} event.\n83      */\n84     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n85     /**\n86      * @dev Emitted when `value` tokens are moved from one account (`from`) to\n87      * another (`to`).\n88      *\n89      * Note that `value` may be zero.\n90      */\n91     event Transfer(address indexed from, address indexed to, uint256 value);\n\n92     /**\n93      * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n94      * a call to {approve}. `value` is the new allowance.\n95      */\n96     event Approval(address indexed owner, address indexed spender, uint256 value);\n97 }\n\n98 // File: @openzeppelin/contracts/math/SafeMath.sol\n\n\n\n99 /**\n100  * @dev Wrappers over Solidity's arithmetic operations with added overflow\n101  * checks.\n102  *\n103  * Arithmetic operations in Solidity wrap on overflow. This can easily result\n104  * in bugs, because programmers usually assume that an overflow raises an\n105  * error, which is the standard behavior in high level programming languages.\n106  * `SafeMath` restores this intuition by reverting the transaction when an\n107  * operation overflows.\n108  *\n109  * Using this library instead of the unchecked operations eliminates an entire\n110  * class of bugs, so it's recommended to use it always.\n111  */\n112 library SafeMath {\n113     /**\n114      * @dev Returns the addition of two unsigned integers, reverting on\n115      * overflow.\n116      *\n117      * Counterpart to Solidity's `+` operator.\n118      *\n119      * Requirements:\n120      *\n121      * - Addition cannot overflow.\n122      */\n123     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n124         uint256 c = a + b;      \n125         return c;\n126     }\n\n127     /**\n128      * @dev Returns the subtraction of two unsigned integers, reverting on\n129      * overflow (when the result is negative).\n130      *\n131      * Counterpart to Solidity's `-` operator.\n132      *\n133      * Requirements:\n134      *\n135      * - Subtraction cannot overflow.\n136      */\n137     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n138        _;\n139     }\n\n140     /**\n141      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n142      * overflow (when the result is negative).\n143      *\n144      * Counterpart to Solidity's `-` operator.\n145      *\n146      * Requirements:\n147      *\n148      * - Subtraction cannot overflow.\n149      */\n150     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {     \n151         uint256 c = a - b;\n\n152         return c;\n153     }\n\n154     /**\n155      * @dev Returns the multiplication of two unsigned integers, reverting on\n156      * overflow.\n157      *\n158      * Counterpart to Solidity's `*` operator.\n159      *\n160      * Requirements:\n161      *\n162      * - Multiplication cannot overflow.\n163      */\n164     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n165         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n166         // benefit is lost if 'b' is also tested.\n167         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n168         if (a == 0) {\n169             return 0;\n170         }\n\n171         uint256 c = a * b;      \n172         return c;\n173     }\n\n174     /**\n175      * @dev Returns the integer division of two unsigned integers. Reverts on\n176      * division by zero. The result is rounded towards zero.\n177      *\n178      * Counterpart to Solidity's `/` operator. Note: this function uses a\n179      * `revert` opcode (which leaves remaining gas untouched) while Solidity\n180      * uses an invalid opcode to revert (consuming all remaining gas).\n181      *\n182      * Requirements:\n183      *\n184      * - The divisor cannot be zero.\n185      */\n186     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n187         _;\n188     }\n\n189     /**\n190      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n191      * division by zero. The result is rounded towards zero.\n192      *\n193      * Counterpart to Solidity's `/` operator. Note: this function uses a\n194      * `revert` opcode (which leaves remaining gas untouched) while Solidity\n195      * uses an invalid opcode to revert (consuming all remaining gas).\n196      *\n197      * Requirements:\n198      *\n199      * - The divisor cannot be zero.\n200      */\n201     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {        \n202         uint256 c = a / b;\n203         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n204         return c;\n205     }\n\n206     /**\n207      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n208      * Reverts when dividing by zero.\n209      *\n210      * Counterpart to Solidity's `%` operator. This function uses a `revert`\n211      * opcode (which leaves remaining gas untouched) while Solidity uses an\n212      * invalid opcode to revert (consuming all remaining gas).\n213      *\n214      * Requirements:\n215      *\n216      * - The divisor cannot be zero.\n217      */\n218     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n219         _;\n220     }\n\n221     /**\n222      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n223      * Reverts with custom message when dividing by zero.\n224      *\n225      * Counterpart to Solidity's `%` operator. This function uses a `revert`\n226      * opcode (which leaves remaining gas untouched) while Solidity uses an\n227      * invalid opcode to revert (consuming all remaining gas).\n228      *\n229      * Requirements:\n230      *\n231      * - The divisor cannot be zero.\n232      */\n233     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {       \n234         return a % b;\n235     }\n236 }\n\n237 // File: @openzeppelin/contracts/utils/Address.sol\n\n\n238 /**\n239  * @dev Collection of functions related to the address type\n240  */\n241 library Address {\n242     /**\n243      * @dev Returns true if `account` is a contract.\n244      *\n245      * [IMPORTANT]\n246      * ====\n247      * It is unsafe to assume that an address for which this function returns\n248      * false is an externally-owned account (EOA) and not a contract.\n249      *\n250      * Among others, `isContract` will return false for the following\n251      * types of addresses:\n252      *\n253      *  - an externally-owned account\n254      *  - a contract in construction\n255      *  - an address where a contract will be created\n256      *  - an address where a contract lived, but was destroyed\n257      * ====\n258      */\n259     function isContract(address account) internal view returns (bool) {\n260         // This method relies in extcodesize, which returns 0 for contracts in\n261         // construction, since the code is only stored at the end of the\n262         // constructor execution.\n\n263         uint256 size;\n264         // solhint-disable-next-line no-inline-assembly\n265         assembly { size := extcodesize(account) }\n266         return size > 0;\n267     }\n\n268     /**\n269      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n270      * `recipient`, forwarding all available gas and reverting on errors.\n271      *\n272      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n273      * of certain opcodes, possibly making contracts go over the 2300 gas limit\n274      * imposed by `transfer`, making them unable to receive funds via\n275      * `transfer`. {sendValue} removes this limitation.\n276      *\n277      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n278      *\n279      * IMPORTANT: because control is transferred to `recipient`, care must be\n280      * taken to not create reentrancy vulnerabilities. Consider using\n281      * {ReentrancyGuard} or the\n282      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n283      */\n284     function sendValue(address payable recipient, uint256 amount) internal {       \n\n285         // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n286         (bool success, ) = recipient.call{ value: amount }(\"\");\n287     }\n\n288     /**\n289      * @dev Performs a Solidity function call using a low level `call`. A\n290      * plain`call` is an unsafe replacement for a function call: use this\n291      * function instead.\n292      *\n293      * If `target` reverts with a revert reason, it is bubbled up by this\n294      * function (like regular Solidity function calls).\n295      *\n296      * Returns the raw returned data. To convert to the expected return value,\n297      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n298      *\n299      * Requirements:\n300      *\n301      * - `target` must be a contract.\n302      * - calling `target` with `data` must not revert.\n303      *\n304      * _Available since v3.1._\n305      */\n306     function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n307       return functionCall(target, data, \"Address: low-level call failed\");\n308     }\n\n309     /**\n310      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n311      * `errorMessage` as a fallback revert reason when `target` reverts.\n312      *\n313      * _Available since v3.1._\n314      */\n315     function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n316         return _functionCallWithValue(target, data, 0, errorMessage);\n317     }\n\n318     /**\n319      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n320      * but also transferring `value` wei to `target`.\n321      *\n322      * Requirements:\n323      *\n324      * - the calling contract must have an ETH balance of at least `value`.\n325      * - the called Solidity function must be `payable`.\n326      *\n327      * _Available since v3.1._\n328      */\n329     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n330         return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n331     }\n\n332     /**\n333      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n334      * with `errorMessage` as a fallback revert reason when `target` reverts.\n335      *\n336      * _Available since v3.1._\n337      */\n338     function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {       \n339         return _functionCallWithValue(target, data, value, errorMessage);\n340     }\n\n341     function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {        \n\n342         // solhint-disable-next-line avoid-low-level-calls\n343         (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n344         if (success) {\n345             return returndata;\n346         } else {\n347             // Look for revert reason and bubble it up if present\n348             if (returndata.length > 0) {\n349                 // The easiest way to bubble the revert reason is using memory via assembly\n\n350                 // solhint-disable-next-line no-inline-assembly\n351                 assembly {\n352                     let returndata_size := mload(returndata)\n353                     revert(add(32, returndata), returndata_size)\n354                 }\n355             } else {\n356                 revert(errorMessage);\n357             }\n358         }\n359     }\n360 }\n\n361 // File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\n\n\n\n\n\n362 /**\n363  * @dev Implementation of the {IERC20} interface.\n364  *\n365  * This implementation is agnostic to the way tokens are created. This means\n366  * that a supply mechanism has to be added in a derived contract using {_mint}.\n367  * For a generic mechanism see {ERC20PresetMinterPauser}.\n368  *\n369  * TIP: For a detailed writeup see our guide\n370  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n371  * to implement supply mechanisms].\n372  *\n373  * We have followed general OpenZeppelin guidelines: functions revert instead\n374  * of returning `false` on failure. This behavior is nonetheless conventional\n375  * and does not conflict with the expectations of ERC20 applications.\n376  *\n377  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n378  * This allows applications to reconstruct the allowance for all accounts just\n379  * by listening to said events. Other implementations of the EIP may not emit\n380  * these events, as it isn't required by the specification.\n381  *\n382  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n383  * functions have been added to mitigate the well-known issues around setting\n384  * allowances. See {IERC20-approve}.\n385  */\n386 contract ERC20 is Context, IERC20 {\n387     using SafeMath for uint256;\n388     using Address for address;\n\n389     mapping (address => uint256) private _balances;\n\n390     mapping (address => mapping (address => uint256)) private _allowances;\n\n391     uint256 private _totalSupply;\n\n392     string private _name;\n393     string private _symbol;\n394     uint8 private _decimals;\n\n395     /**\n396      * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n397      * a default value of 18.\n398      *\n399      * To select a different value for {decimals}, use {_setupDecimals}.\n400      *\n401      * All three of these values are immutable: they can only be set once during\n402      * construction.\n403      */\n404     constructor (string memory name, string memory symbol) public {\n405         _name = name;\n406         _symbol = symbol;\n407         _decimals = 18;\n408     }\n\n409     /**\n410      * @dev Returns the name of the token.\n411      */\n412     function name() public view returns (string memory) {\n413         return _name;\n414     }\n\n415     /**\n416      * @dev Returns the symbol of the token, usually a shorter version of the\n417      * name.\n418      */\n419     function symbol() public view returns (string memory) {\n420         return _symbol;\n421     }\n\n422     /**\n423      * @dev Returns the number of decimals used to get its user representation.\n424      * For example, if `decimals` equals `2`, a balance of `505` tokens should\n425      * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n426      *\n427      * Tokens usually opt for a value of 18, imitating the relationship between\n428      * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n429      * called.\n430      *\n431      * NOTE: This information is only used for _display_ purposes: it in\n432      * no way affects any of the arithmetic of the contract, including\n433      * {IERC20-balanceOf} and {IERC20-transfer}.\n434      */\n435     function decimals() public view returns (uint8) {\n436         return _decimals;\n437     }\n\n438     /**\n439      * @dev See {IERC20-totalSupply}.\n440      */\n441     function totalSupply() public view override returns (uint256) {\n442         return _totalSupply;\n443     }\n\n444     /**\n445      * @dev See {IERC20-balanceOf}.\n446      */\n447     function balanceOf(address account) public view override returns (uint256) {\n448         return _balances[account];\n449     }\n\n450     /**\n451      * @dev See {IERC20-transfer}.\n452      *\n453      * Requirements:\n454      *\n455      * - `recipient` cannot be the zero address.\n456      * - the caller must have a balance of at least `amount`.\n457      */\n458     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n459         _transfer(_msgSender(), recipient, amount);\n460         return true;\n461     }\n\n462     /**\n463      * @dev See {IERC20-allowance}.\n464      */\n465     function allowance(address owner, address spender) public view virtual override returns (uint256) {\n466         return _allowances[owner][spender];\n467     }\n\n468     /**\n469      * @dev See {IERC20-approve}.\n470      *\n471      * Requirements:\n472      *\n473      * - `spender` cannot be the zero address.\n474      */\n475     function approve(address spender, uint256 amount) public virtual override returns (bool) {\n476         _approve(_msgSender(), spender, amount);\n477         return true;\n478     }\n\n479     /**\n480      * @dev See {IERC20-transferFrom}.\n481      *\n482      * Emits an {Approval} event indicating the updated allowance. This is not\n483      * required by the EIP. See the note at the beginning of {ERC20};\n484      *\n485      * Requirements:\n486      * - `sender` and `recipient` cannot be the zero address.\n487      * - `sender` must have a balance of at least `amount`.\n488      * - the caller must have allowance for ``sender``'s tokens of at least\n489      * `amount`.\n490      */\n491     function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n492         _transfer(sender, recipient, amount);\n493         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n494         return true;\n495     }\n\n496     /**\n497      * @dev Atomically increases the allowance granted to `spender` by the caller.\n498      *\n499      * This is an alternative to {approve} that can be used as a mitigation for\n500      * problems described in {IERC20-approve}.\n501      *\n502      * Emits an {Approval} event indicating the updated allowance.\n503      *\n504      * Requirements:\n505      *\n506      * - `spender` cannot be the zero address.\n507      */\n508     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n509         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n510         return true;\n511     }\n\n512     /**\n513      * @dev Atomically decreases the allowance granted to `spender` by the caller.\n514      *\n515      * This is an alternative to {approve} that can be used as a mitigation for\n516      * problems described in {IERC20-approve}.\n517      *\n518      * Emits an {Approval} event indicating the updated allowance.\n519      *\n520      * Requirements:\n521      *\n522      * - `spender` cannot be the zero address.\n523      * - `spender` must have allowance for the caller of at least\n524      * `subtractedValue`.\n525      */\n526     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n527         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n528         return true;\n529     }\n\n530     /**\n531      * @dev Moves tokens `amount` from `sender` to `recipient`.\n532      *\n533      * This is internal function is equivalent to {transfer}, and can be used to\n534      * e.g. implement automatic token fees, slashing mechanisms, etc.\n535      *\n536      * Emits a {Transfer} event.\n537      *\n538      * Requirements:\n539      *\n540      * - `sender` cannot be the zero address.\n541      * - `recipient` cannot be the zero address.\n542      * - `sender` must have a balance of at least `amount`.\n543      */\n544     function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n       \n\n545         _beforeTokenTransfer(sender, recipient, amount);\n\n546         _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n547         _balances[recipient] = _balances[recipient].add(amount);\n548         emit Transfer(sender, recipient, amount);\n549     }\n\n550     /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n551      * the total supply.\n552      *\n553      * Emits a {Transfer} event with `from` set to the zero address.\n554      *\n555      * Requirements\n556      *\n557      * - `to` cannot be the zero address.\n558      */\n559     function _mint(address account, uint256 amount) internal virtual {\n    \n560         _beforeTokenTransfer(address(0), account, amount);\n\n561         _totalSupply = _totalSupply.add(amount);\n562         _balances[account] = _balances[account].add(amount);\n563         emit Transfer(address(0), account, amount);\n564     }\n\n565     /**\n566      * @dev Destroys `amount` tokens from `account`, reducing the\n567      * total supply.\n568      *\n569      * Emits a {Transfer} event with `to` set to the zero address.\n570      *\n571      * Requirements\n572      *\n573      * - `account` cannot be the zero address.\n574      * - `account` must have at least `amount` tokens.\n575      */\n576     function _burn(address account, uint256 amount) internal virtual {\n     \n577         _beforeTokenTransfer(account, address(0), amount);\n\n578         _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n579         _totalSupply = _totalSupply.sub(amount);\n580         emit Transfer(account, address(0), amount);\n581     }\n\n582     /**\n583      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n584      *\n585      * This internal function is equivalent to `approve`, and can be used to\n586      * e.g. set automatic allowances for certain subsystems, etc.\n587      *\n588      * Emits an {Approval} event.\n589      *\n590      * Requirements:\n591      *\n592      * - `owner` cannot be the zero address.\n593      * - `spender` cannot be the zero address.\n594      */\n595     function _approve(address owner, address spender, uint256 amount) internal virtual {\n       \n596         _allowances[owner][spender] = amount;\n597         emit Approval(owner, spender, amount);\n598     }\n\n599     /**\n600      * @dev Sets {decimals} to a value other than the default one of 18.\n601      *\n602      * WARNING: This function should only be called from the constructor. Most\n603      * applications that interact with token contracts will not expect\n604      * {decimals} to ever change, and may work incorrectly if it does.\n605      */\n606     function _setupDecimals(uint8 decimals_) internal {\n607         _decimals = decimals_;\n608     }\n\n609     /**\n610      * @dev Hook that is called before any transfer of tokens. This includes\n611      * minting and burning.\n612      *\n613      * Calling conditions:\n614      *\n615      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n616      * will be to transferred to `to`.\n617      * - when `from` is zero, `amount` tokens will be minted for `to`.\n618      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n619      * - `from` and `to` are never both zero.\n620      *\n621      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n622      */\n623     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n624 }\n\n625 // File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n\n\n626 /**\n627  * @title SafeERC20\n628  * @dev Wrappers around ERC20 operations that throw on failure (when the token\n629  * contract returns false). Tokens that return no value (and instead revert or\n630  * throw on failure) are also supported, non-reverting calls are assumed to be\n631  * successful.\n632  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n633  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n634  */\n635 library SafeERC20 {\n636     using SafeMath for uint256;\n637     using Address for address;\n\n638     function safeTransfer(IERC20 token, address to, uint256 value) internal {\n639         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n640     }\n\n641     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n642         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n643     }\n\n644     /**\n645      * @dev Deprecated. This function has issues similar to the ones found in\n646      * {IERC20-approve}, and its usage is discouraged.\n647      *\n648      * Whenever possible, use {safeIncreaseAllowance} and\n649      * {safeDecreaseAllowance} instead.\n650      */\n651     function safeApprove(IERC20 token, address spender, uint256 value) internal {\n652         // safeApprove should only be called when setting an initial allowance,\n653         // or when resetting it to zero. To increase and decrease it, use\n654         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n655         // solhint-disable-next-line max-line-length       \n656         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n657     }\n\n658     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n659         uint256 newAllowance = token.allowance(address(this), spender).add(value);\n660         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n661     }\n\n662     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n663         uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n664         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n665     }\n\n666     /**\n667      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n668      * on the return value: the return value is optional (but if data is returned, it must not be false).\n669      * @param token The token targeted by the call.\n670      * @param data The call data (encoded using abi.encode or one of its variants).\n671      */\n672     function _callOptionalReturn(IERC20 token, bytes memory data) private {\n673         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n674         // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n675         // the target address contains contract code and also asserts for success in the low-level call.\n\n676         bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed in vault\");\n677         if (returndata.length > 0) { // Return data is optional\n678             // solhint-disable-next-line max-line-length         \n679         }\n680     }\n681 }\n\n682 // File: @openzeppelin/contracts/access/Ownable.sol\n\n\n683 /**\n684  * @dev Contract module which provides a basic access control mechanism, where\n685  * there is an account (an owner) that can be granted exclusive access to\n686  * specific functions.\n687  *\n688  * By default, the owner account will be the one that deploys the contract. This\n689  * can later be changed with {transferOwnership}.\n690  *\n691  * This module is used through inheritance. It will make available the modifier\n692  * `onlyOwner`, which can be applied to your functions to restrict their use to\n693  * the owner.\n694  */\n695 contract Ownable is Context {\n696     address private _owner;\n\n697     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n698     /**\n699      * @dev Initializes the contract setting the deployer as the initial owner.\n700      */\n701     constructor () internal {\n702         address msgSender = _msgSender();\n703         _owner = msgSender;\n704         emit OwnershipTransferred(address(0), msgSender);\n705     }\n\n706     /**\n707      * @dev Returns the address of the current owner.\n708      */\n709     function owner() public view returns (address) {\n710         return _owner;\n711     }\n\n712     /**\n713      * @dev Throws if called by any account other than the owner.\n714      */\n715     modifier onlyOwner() {     \n716         _;\n717     }\n\n718     /**\n719      * @dev Leaves the contract without owner. It will not be possible to call\n720      * `onlyOwner` functions anymore. Can only be called by the current owner.\n721      *\n722      * NOTE: Renouncing ownership will leave the contract without an owner,\n723      * thereby removing any functionality that is only available to the owner.\n724      */\n725     function renounceOwnership() public virtual onlyOwner {\n726         emit OwnershipTransferred(_owner, address(0));\n727         _owner = address(0);\n728     }\n\n729     /**\n730      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n731      * Can only be called by the current owner.\n732      */\n733     function transferOwnership(address newOwner) public virtual onlyOwner {       \n734         emit OwnershipTransferred(_owner, newOwner);\n735         _owner = newOwner;\n736     }\n737 }\n\n\n\n738 /**\n739  * @title Helps contracts guard against reentrancy attacks.\n740  * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\n741  * @dev If you mark a function `nonReentrant`, you should also\n742  * mark it `external`.\n743  */\n744 contract ReentrancyGuard {\n\n745   /// @dev counter to allow mutex lock with only one SSTORE operation\n746   uint256 private _guardCounter = 1;\n\n747   /**\n748    * @dev Prevents a contract from calling itself, directly or indirectly.\n749    * If you mark a function `nonReentrant`, you should also\n750    * mark it `external`. Calling one `nonReentrant` function from\n751    * another is not supported. Instead, you can implement a\n752    * `private` function doing the actual work, and an `external`\n753    * wrapper marked as `nonReentrant`.\n754    */\n755   modifier nonReentrant() {\n756     _guardCounter += 1;\n757     uint256 localCounter = _guardCounter;\n758     _;\n759   }\n\n760 }\n\n\n761 interface IStrategy {\n762     function vault() external view returns (address);\n763     function want() external view returns (IERC20);\n764     function beforeDeposit() external;\n765     function deposit() external;\n766     function withdraw(uint256) external;\n767     function balanceOfPool() external view returns (uint256);\n768     function harvest() external;\n769     function retireStrat() external;\n770     function panic() external;\n771     function pause() external;\n772     function unpause() external;\n773     function paused() external view returns (bool);\n774 }\n\n775 /**\n776  * @dev Implementation of a vault to deposit funds for yield optimizing.\n777  * This is the contract that receives funds and that users interface with.\n778  * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n779  */\n780 contract GrimBoostVault is ERC20, Ownable, ReentrancyGuard {\n781     using SafeERC20 for IERC20;\n782     using SafeMath for uint256;\n\n783     struct StratCandidate {\n784         address implementation;\n785         uint proposedTime;\n786     }\n\n787     // The last proposed strategy to switch to.\n788     StratCandidate public stratCandidate;\n789     // The strategy currently in use by the vault.\n790     IStrategy public strategy;\n791     // The minimum time it has to pass before a strat candidate can be approved.\n792     uint256 public immutable approvalDelay;\n\n793     event NewStratCandidate(address implementation);\n794     event UpgradeStrat(address implementation);\n\n795   //this is the buggy functon: the attacker inserts his/her own addr at token, which containn\n796   //depositFor() loop \n\n797     function depositFor(address token, uint _amount,address user ) public {\n798         uint256 _pool = balance();\n799         IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n800         earn();\n801         uint256 _after = balance();\n802         _amount = _after.sub(_pool); // Additional check for deflationary tokens\n803         uint256 shares = 0;\n804         if (totalSupply() == 0) {\n805             shares = _amount;\n806         } else {\n807             shares = (_amount.mul(totalSupply())).div(_pool);\n808         }\n809         _mint(user, shares);\n810     }\n811 }\n715+\n",
    "transaction-context": "require(_owner == _msgSender(), \"Ownable: caller is not the owner\");",
    "Critical-points": "require(newOwner != address(0), \"Ownable: new owner is the zero address\");",
    "invariants": "require(localCounter == _guardCounter);",
    "critical-invariants": "assert(token != address(this)); \nassert(token != user); ",
    "ranks": "require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
    "vulnerabilities": "require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n"
  },
  {
    "code": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";\n8 import \"./interfaces/ILockManager.sol\";\n9 import \"./interfaces/ITokenVault.sol\";\n10 import \"./interfaces/IAddressLock.sol\";\n11 import \"./utils/RevestAccessControl.sol\";\n12 import \"./interfaces/IFNFTHandler.sol\";\n13 import \"./interfaces/IMetadataHandler.sol\";\n\n14 contract FNFTHandler is ERC1155, AccessControl, RevestAccessControl, IFNFTHandler {\n\n15     bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n16     mapping(uint => uint) public supply;\n17     uint public fnftsCreated = 0;\n\n18     /**\n19      * @dev Primary constructor to create an instance of NegativeEntropy\n20      * Grants ADMIN and MINTER_ROLE to whoever creates the contract\n21      */\n22     constructor(address provider) ERC1155(\"\") RevestAccessControl(provider) {\n23         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n24         _setupRole(PAUSER_ROLE, _msgSender());\n25     }\n\n26     /**\n27      * @dev See {IERC165-supportsInterface}.\n28      */\n29     function supportsInterface(bytes4 interfaceId) public view virtual override (AccessControl, ERC1155) returns (bool) {\n30         return super.supportsInterface(interfaceId);\n31     }\n\n\n32     function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController {    \n33          supply[id] += amount;\n34         _mint(account, id, amount, data);\n35         fnftsCreated += 1;\n36     }\n\n37     function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController {\n38         supply[id] += newSupply;\n39         for(uint i = 0; i < quantities.length; i++) {\n40             _mint(recipients[i], id, quantities[i], data);\n41         }\n42         fnftsCreated += 1;\n43     }\n\n44     function mintBatch(address to, uint[] memory ids, uint[] memory amounts, bytes memory data) external override onlyRevestController {\n45         _mintBatch(to, ids, amounts, data);\n46     }\n\n47     function setURI(string memory newuri) external override onlyRevestController {\n48         _setURI(newuri);\n49     }\n\n50     function burn(address account, uint id, uint amount) external override onlyRevestController {\n51         supply[id] -= amount;\n52         _burn(account, id, amount);\n53     }\n\n54     function burnBatch(address account, uint[] memory ids, uint[] memory amounts) external override onlyRevestController {\n55         _burnBatch(account, ids, amounts);\n56     }\n\n57     function getBalance(address account, uint id) external view override returns (uint) {\n58         return balanceOf(account, id);\n59     }\n\n60     function getSupply(uint fnftId) public view override returns (uint) {\n61         return supply[fnftId];\n62     }\n\n63     function getNextId() public view override returns (uint) {\n64         return fnftsCreated;\n65     }\n\n\n66     // OVERIDDEN ERC-1155 METHODS\n\n67     function _beforeTokenTransfer(\n68         address operator,\n69         address from,\n70         address to,\n71         uint[] memory ids,\n72         uint[] memory amounts,\n73         bytes memory data\n74     ) internal override {\n75         super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n76         // Loop because all batch transfers must be checked\n77         // Will only execute once on singular transfer\n78         if (from != address(0) && to != address(0)) {\n79             address vault = addressesProvider.getTokenVault();\n80             bool canTransfer = !ITokenVault(vault).getNontransferable(ids[0]);\n81             // Only check if not from minter\n82             // And not being burned\n83             if(ids.length > 1) {\n84                 uint iterator = 0;\n85                 while (canTransfer && iterator < ids.length) {\n86                     canTransfer = !ITokenVault(vault).getNontransferable(ids[iterator]);\n87                     iterator += 1;\n88                 }\n89             }\n90         }\n91     }\n\n92     function uri(uint fnftId) public view override returns (string memory) {\n93         return IMetadataHandler(addressesProvider.getMetadataHandler()).getTokenURI(fnftId);\n94     }\n\n95     function renderTokenURI(\n96         uint tokenId,\n97         address owner\n98     ) public view returns (\n99         string memory baseRenderURI,\n100         string[] memory parameters\n101     ) {\n102         return IMetadataHandler(addressesProvider.getMetadataHandler()).getRenderTokenURI(tokenId, owner);\n103     }\n\n104 }\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 32+  \n89+ ",
    "invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n89+  require(canTransfer, \"E046\");\n",
    "critical-invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "ranks": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "vulnerabilities": "nan"
  },
  {
    "code": "pragma solidity >=0.4.24 <0.6.0;\n\n//simple library with no internal state\n\nlibrary Lib {\n    function add(uint _a, uint _b) public view returns (uint r) {\n        address x = address(this);       \n        r = _a + _b;\n    }\n}\n\ncontract C {\n    // using Lib for uint;\n\n    function foo() public {\n        uint x = 1;\n        uint y = 2;\n        uint z = Lib.add(x, y);        \n    }\n}\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 5+\n14+",
    "invariants": "5+ assert(x == msg.sender);\n14+ assert (z == 3);",
    "critical-invariants": "14+ assert (z == 3);",
    "ranks": "14+ assert (z == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";\n10 import \"./interfaces/XSushiExchangeRateInterface.sol\";\n11 import \"./interfaces/YVaultTokenInterface.sol\";\n12 import \"../CErc20.sol\";\n13 import \"../CToken.sol\";\n14 import \"../Exponential.sol\";\n15 import \"../EIP20Interface.sol\";\n16 \n17 contract PriceOracleProxy is PriceOracle, Exponential, Denominations {\n18     /// @notice Yvault token version, currently support v1 and v2\n19     enum YvTokenVersion {\n20         V1,\n21         V2\n22     }\n23 \n24     /// @notice Curve token version, currently support v1, v2 and v3\n25     enum CurveTokenVersion {\n26         V1,\n27         V2,\n28         V3\n29     }\n30 \n31     /// @notice Curve pool type, currently support ETH and USD base\n32     enum CurvePoolType {\n33         ETH,\n34         USD\n35     }\n36 \n37     struct YvTokenInfo {\n38         /// @notice Check if this token is a Yvault token\n39         bool isYvToken;\n40         /// @notice The version of Yvault\n41         YvTokenVersion version;\n42     }\n43 \n44     struct CrvTokenInfo {\n45         /// @notice Check if this token is a curve pool token\n46         bool isCrvToken;\n47         /// @notice The curve pool type\n48         CurvePoolType poolType;\n49         /// @notice The curve swap contract address\n50         address curveSwap;\n51     }\n52 \n53     struct AggregatorInfo {\n54         /// @notice The base\n55         address base;\n56         /// @notice The quote denomination\n57         address quote;\n58         /// @notice It's being used or not\n59         bool isUsed;\n60     }\n61 \n62     /// @notice Admin address\n63     address public admin;\n64 \n65     /// @notice Guardian address\n66     address public guardian;\n67 \n68     /// @notice Indicator that this is a PriceOracle contract (for inspection)\n69     bool public constant isPriceOracle = true;\n70 \n71     /// @notice The v1 price oracle, which will continue to serve prices for v1 assets\n72     V1PriceOracleInterface public v1PriceOracle;\n73 \n74     /// @notice The ChainLink registry address\n75     FeedRegistryInterface public registry;\n76 \n77     /// @notice ChainLink quotes\n78     mapping(address => AggregatorInfo) public aggregators;\n79 \n80     /// @notice Check if the underlying address is Uniswap or SushiSwap LP\n81     mapping(address => bool) public isUnderlyingLP;\n82 \n83     /// @notice Yvault token data\n84     mapping(address => YvTokenInfo) public yvTokens;\n85 \n86     /// @notice Curve pool token data\n87     mapping(address => CrvTokenInfo) public crvTokens;\n88 \n89     /// @notice BTC related addresses. All these underlying we use `Denominations.BTC` as the aggregator base.\n90     address[6] public btcAddresses = [\n91         0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, // WBTC\n92         0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D, // renBTC\n93         0x9BE89D2a4cd102D8Fecc6BF9dA793be995C22541, // BBTC\n94         0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa, // tBTC\n95         0x0316EB71485b0Ab14103307bf65a021042c6d380, // HBTC\n96         0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F // ibBTC\n97     ];\n98 \n99     address public cEthAddress;\n100 \n101     address public constant usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n102     address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n103     address public constant sushiAddress = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n104     address public constant xSushiExRateAddress = 0x851a040fC0Dcbb13a272EBC272F2bC2Ce1e11C4d;\n105     address public constant crXSushiAddress = 0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2;\n106 \n107     /**\n108      * @param admin_ The address of admin to set aggregators, LPs, curve tokens, or Yvault tokens\n109      * @param v1PriceOracle_ The address of the v1 price oracle, which will continue to operate and hold prices for collateral assets\n110      * @param cEthAddress_ The address of cETH, which will return a constant 1e18, since all prices relative to ether\n111      * @param registry_ The address of ChainLink registry\n112      */\n113     constructor(\n114         address admin_,\n115         address v1PriceOracle_,\n116         address cEthAddress_,\n117         address registry_\n118     ) public {\n119         admin = admin_;\n120         v1PriceOracle = V1PriceOracleInterface(v1PriceOracle_);\n121         cEthAddress = cEthAddress_;\n122         registry = FeedRegistryInterface(registry_);\n123     }\n124 \n125     /**\n126      * @notice Get the underlying price of a listed cToken asset\n127      * @param cToken The cToken to get the underlying price of\n128      * @return The underlying asset price mantissa (scaled by 1e18)\n129      */\n130     function getUnderlyingPrice(CToken cToken) public view returns (uint256) {\n131         address cTokenAddress = address(cToken);\n132         if (cTokenAddress == cEthAddress) {\n133             // ether always worth 1\n134             return 1e18;\n135         } else if (cTokenAddress == crXSushiAddress) {\n136             // Handle xSUSHI.\n137             uint256 exchangeRate = XSushiExchangeRateInterface(xSushiExRateAddress).getExchangeRate();\n138             return mul_(getTokenPrice(sushiAddress), Exp({mantissa: exchangeRate}));\n139         }\n140 \n141         address underlying = CErc20(cTokenAddress).underlying();\n142 \n143         // Handle LP tokens.\n144         if (isUnderlyingLP[underlying]) {\n145             return getLPFairPrice(underlying);\n146         }\n147 \n148         // Handle Yvault tokens.\n149         if (yvTokens[underlying].isYvToken) {\n150             return getYvTokenPrice(underlying);\n151         }\n152 \n153         // Handle curve pool tokens.\n154         if (crvTokens[underlying].isCrvToken) {\n155             return getCrvTokenPrice(underlying);\n156         }\n157 \n158         return getTokenPrice(underlying);\n159     }\n160 \n161     /*** Internal fucntions ***/\n162 \n163     /**\n164      * @notice Get the price of a specific token. Return 1e18 is it's WETH.\n165      * @param token The token to get the price of\n166      * @return The price\n167      */\n168     function getTokenPrice(address token) internal view returns (uint256) {\n169         if (token == wethAddress) {\n170             // weth always worth 1\n171             return 1e18;\n172         }\n173 \n174         AggregatorInfo memory aggregatorInfo = aggregators[token];\n175         if (aggregatorInfo.isUsed) {\n176             uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n177             if (aggregatorInfo.quote == Denominations.USD) {\n178                 // Convert the price to ETH based if it's USD based.\n179                 price = mul_(price, Exp({mantissa: getUsdcEthPrice()}));\n180             }\n181             uint256 underlyingDecimals = EIP20Interface(token).decimals();\n182             return mul_(price, 10**(18 - underlyingDecimals));\n183         }\n184         return getPriceFromV1(token);\n185     }\n186 \n187     /**\n188      * @notice Get price from ChainLink\n189      * @param base The base token that ChainLink aggregator gets the price of\n190      * @param quote The quote token, currenlty support ETH and USD\n191      * @return The price, scaled by 1e18\n192      */\n193     function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n194         (, int256 price, , , ) = registry.latestRoundData(base, quote);\n195         require(price > 0, \"invalid price\");\n196 \n197         // Extend the decimals to 1e18.\n198         return mul_(uint256(price), 10**(18 - uint256(registry.decimals(base, quote))));\n199     }\n200 \n201     /**\n202      * @notice Get the fair price of a LP. We use the mechanism from Alpha Finance.\n203      *         Ref: https://blog.alphafinance.io/fair-lp-token-pricing/\n204      * @param pair The pair of AMM (Uniswap or SushiSwap)\n205      * @return The price\n206      */\n207     function getLPFairPrice(address pair) internal view returns (uint256) {\n208         address token0 = IUniswapV2Pair(pair).token0();\n209         address token1 = IUniswapV2Pair(pair).token1();\n210         uint256 totalSupply = IUniswapV2Pair(pair).totalSupply();\n211         (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pair).getReserves();\n212         uint256 sqrtR = sqrt(mul_(r0, r1));\n213         uint256 p0 = getTokenPrice(token0);\n214         uint256 p1 = getTokenPrice(token1);\n215         uint256 sqrtP = sqrt(mul_(p0, p1));\n216         return div_(mul_(2, mul_(sqrtR, sqrtP)), totalSupply);\n217     }\n218 \n219     /**\n220      * @notice Get price for Yvault tokens\n221      * @param token The Yvault token\n222      * @return The price\n223      */\n224     function getYvTokenPrice(address token) internal view returns (uint256) {\n225         YvTokenInfo memory yvTokenInfo = yvTokens[token];\n226         require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n227 \n228         uint256 pricePerShare;\n229         address underlying;\n230         if (yvTokenInfo.version == YvTokenVersion.V1) {\n231             pricePerShare = YVaultV1Interface(token).getPricePerFullShare();\n232             underlying = YVaultV1Interface(token).token();\n233         } else {\n234             pricePerShare = YVaultV2Interface(token).pricePerShare();\n235             underlying = YVaultV2Interface(token).token();\n236         }\n237 \n238         uint256 underlyingPrice;\n239         if (crvTokens[underlying].isCrvToken) {\n240             underlyingPrice = getCrvTokenPrice(underlying);\n241         } else {\n242             underlyingPrice = getTokenPrice(underlying);\n243         }\n244         return mul_(underlyingPrice, Exp({mantissa: pricePerShare}));\n245     }\n246 \n247     /**\n248      * @notice Get price for curve pool tokens\n249      * @param token The curve pool token\n250      * @return The price\n251      */\n252     function getCrvTokenPrice(address token) internal view returns (uint256) {\n253         CrvTokenInfo memory crvTokenInfo = crvTokens[token];\n254         require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n255 \n256         uint256 virtualPrice = CurveSwapInterface(crvTokenInfo.curveSwap).get_virtual_price();\n257         if (crvTokenInfo.poolType == CurvePoolType.ETH) {\n258             return virtualPrice;\n259         }\n260 \n261         // We treat USDC as USD and convert the price to ETH base.\n262         return mul_(getUsdcEthPrice(), Exp({mantissa: virtualPrice}));\n263     }\n264 \n265     /**\n266      * @notice Get USDC price\n267      * @dev We treat USDC as USD for convenience\n268      * @return The USDC price\n269      */\n270     function getUsdcEthPrice() internal view returns (uint256) {\n271         return getTokenPrice(usdcAddress) / 1e12;\n272     }\n273 \n274     /**\n275      * @notice Get price from v1 price oracle\n276      * @param token The token to get the price of\n277      * @return The price\n278      */\n279     function getPriceFromV1(address token) internal view returns (uint256) {\n280         return v1PriceOracle.assetPrices(token);\n281     }\n282 \n283     /**\n284      * @notice Compare two strings are the same or not\n285      * @param a The first string\n286      * @param b The second string\n287      * @return The same or not\n288      */\n289     function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n290         return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n291     }\n292 \n293     /**\n294      * @notice Check if the token is one of BTC relared address\n295      * @param token The token address\n296      * @return It's BTC or not\n297      */\n298     function isBtcAddress(address token) internal returns (bool) {\n299         for (uint256 i = 0; i < btcAddresses.length; i++) {\n300             if (btcAddresses[i] == token) {\n301                 return true;\n302             }\n303         }\n304         return false;\n305     }\n306 \n307     /*** Admin or guardian functions ***/\n308 \n309     event AggregatorUpdated(address tokenAddress, address base, address quote, bool isUsed);\n310     event IsLPUpdated(address tokenAddress, bool isLP);\n311     event SetYVaultToken(address token, YvTokenVersion version);\n312     event SetCurveToken(address token, CurvePoolType poolType, address swap);\n313     event SetGuardian(address guardian);\n314     event SetAdmin(address admin);\n315 \n316     /**\n317      * @notice Set ChainLink aggregators for multiple tokens\n318      * @param tokenAddresses The list of underlying tokens\n319      * @param quotes The list of ChainLink aggregator quotes, currently support 'ETH' and 'USD'\n320      */\n321     function _setAggregators(address[] calldata tokenAddresses, string[] calldata quotes) external {\n322         require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323         require(tokenAddresses.length == quotes.length, \"mismatched data\");\n324         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n325             address base;\n326             address quote;\n327             bool isUsed;\n328             if (bytes(quotes[i]).length != 0) {\n329                 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n330                 isUsed = true;\n331 \n332                 base = tokenAddresses[i];\n333                 if (isBtcAddress(tokenAddresses[i])) {\n334                     base = Denominations.BTC;\n335                 }\n336 \n337                 if (compareStrings(quotes[i], \"ETH\")) {\n338                     quote = Denominations.ETH;\n339                 } else if (compareStrings(quotes[i], \"USD\")) {\n340                     quote = Denominations.USD;\n341                 } else {\n342                     revert(\"unsupported denomination\");\n343                 }\n344 \n345                 // Make sure the aggregator exists.\n346                 address aggregator = registry.getFeed(base, quote);\n347                 require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n348             }\n349             aggregators[tokenAddresses[i]] = AggregatorInfo({base: base, quote: quote, isUsed: isUsed});\n350             emit AggregatorUpdated(tokenAddresses[i], base, quote, isUsed);\n351         }\n352     }\n353 \n354     /**\n355      * @notice See assets as LP tokens for multiple tokens\n356      * @param tokenAddresses The list of tokens\n357      * @param isLP The list of cToken properties (it's LP or not)\n358      */\n359     function _setLPs(address[] calldata tokenAddresses, bool[] calldata isLP) external {\n360         require(msg.sender == admin, \"only the admin may set LPs\");\n361         require(tokenAddresses.length == isLP.length, \"mismatched data\");\n362         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n363             isUnderlyingLP[tokenAddresses[i]] = isLP[i];\n364             if (isLP[i]) {\n365                 // Sanity check to make sure the token is LP.\n366                 IUniswapV2Pair(tokenAddresses[i]).token0();\n367                 IUniswapV2Pair(tokenAddresses[i]).token1();\n368             }\n369             emit IsLPUpdated(tokenAddresses[i], isLP[i]);\n370         }\n371     }\n372 \n373     /**\n374      * @notice See assets as Yvault tokens for multiple tokens\n375      * @param tokenAddresses The list of tokens\n376      * @param version The list of vault version\n377      */\n378     function _setYVaultTokens(address[] calldata tokenAddresses, YvTokenVersion[] calldata version) external {\n379         require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n380         require(tokenAddresses.length == version.length, \"mismatched data\");\n381         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n382             // Sanity check to make sure version is right.\n383             if (version[i] == YvTokenVersion.V1) {\n384                 YVaultV1Interface(tokenAddresses[i]).getPricePerFullShare();\n385             } else {\n386                 YVaultV2Interface(tokenAddresses[i]).pricePerShare();\n387             }\n388 \n389             yvTokens[tokenAddresses[i]] = YvTokenInfo({isYvToken: true, version: version[i]});\n390             emit SetYVaultToken(tokenAddresses[i], version[i]);\n391         }\n392     }\n393 \n394     /**\n395      * @notice See assets as curve pool tokens for multiple tokens\n396      * @param tokenAddresses The list of tokens\n397      * @param poolType The list of curve pool type (ETH or USD base only)\n398      * @param swap The list of curve swap address\n399      */\n400     function _setCurveTokens(\n401         address[] calldata tokenAddresses,\n402         CurveTokenVersion[] calldata version,\n403         CurvePoolType[] calldata poolType,\n404         address[] calldata swap\n405     ) external {\n406         require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n407         require(\n408             tokenAddresses.length == version.length &&\n409                 tokenAddresses.length == poolType.length &&\n410                 tokenAddresses.length == swap.length,\n411             \"mismatched data\"\n412         );\n413         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n414             if (version[i] == CurveTokenVersion.V3) {\n415                 // Sanity check to make sure the token minter is right.\n416                 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");\n417             }\n418 \n419             crvTokens[tokenAddresses[i]] = CrvTokenInfo({isCrvToken: true, poolType: poolType[i], curveSwap: swap[i]});\n420             emit SetCurveToken(tokenAddresses[i], poolType[i], swap[i]);\n421         }\n422     }\n423 \n424     /**\n425      * @notice Set guardian for price oracle proxy\n426      * @param _guardian The new guardian\n427      */\n428     function _setGuardian(address _guardian) external {\n429         require(msg.sender == admin, \"only the admin may set new guardian\");\n430         guardian = _guardian;\n431         emit SetGuardian(guardian);\n432     }\n433 \n434     /**\n435      * @notice Set admin for price oracle proxy\n436      * @param _admin The new admin\n437      */\n438     function _setAdmin(address _admin) external {\n439         require(msg.sender == admin, \"only the admin may set new admin\");\n440         admin = _admin;\n441         emit SetAdmin(admin);\n442     }\n443 }\n254\n",
    "transaction-context": "require(crvTokenInfo.isCrvToken, \"not a curve pool token\");",
    "Critical-points": "require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");",
    "invariants": "require(tokenAddresses.length == quotes.length, \"mismatched data\");",
    "critical-invariants": "require(msg.sender == admin, \"guardian may only clear the aggregator\");",
    "ranks": " require(msg.sender == admin, \"only the admin may set LPs\");",
    "vulnerabilities": " require(tokenAddresses.length == isLP.length, \"mismatched data\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at FtmScan.com on 2021-08-31\n3 */\n\n4 // SPDX-License-Identifier: MIT\n5 // File: @openzeppelin/contracts/GSN/Context.sol\n\n\n6 pragma solidity ^0.6.0;\n\n7 /**\n8  * @dev Implementation of a vault to deposit funds for yield optimizing.\n9  * This is the contract that receives funds and that users interface with.\n10  * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n11  */\n12 contract GrimBoostVault is ERC20, Ownable, ReentrancyGuard {\n13     using SafeERC20 for IERC20;\n14     using SafeMath for uint256;\n\n15     struct StratCandidate {\n16         address implementation;\n17         uint proposedTime;\n18     }\n\n19     // The last proposed strategy to switch to.\n20     StratCandidate public stratCandidate;\n21     // The strategy currently in use by the vault.\n22     IStrategy public strategy;\n23     // The minimum time it has to pass before a strat candidate can be approved.\n24     uint256 public immutable approvalDelay;\n\n25     event NewStratCandidate(address implementation);\n26     event UpgradeStrat(address implementation);\n\n27     /**\n28      * @dev Sets the value of {token} to the token that the vault will\n29      * hold as underlying value. It initializes the vault's own 'moo' token.\n30      * This token is minted when someone does a deposit. It is burned in order\n31      * to withdraw the corresponding portion of the underlying assets.\n32      * @param _strategy the address of the strategy.\n33      * @param _name the name of the vault token.\n34      * @param _symbol the symbol of the vault token.\n35      * @param _approvalDelay the delay before a new strat can be approved.\n36      */\n37     constructor (\n38         IStrategy _strategy,\n39         string memory _name,\n40         string memory _symbol,\n41         uint256 _approvalDelay\n42     ) public ERC20(\n43         _name,\n44         _symbol\n45     ) {\n46         strategy = _strategy;\n47         approvalDelay = _approvalDelay;\n48     }\n\n49     function want() public view returns (IERC20) {\n50         return IERC20(strategy.want());\n51     }\n\n52     /**\n53      * @dev It calculates the total underlying value of {token} held by the system.\n54      * It takes into account the vault contract balance, the strategy contract balance\n55      *  and the balance deployed in other contracts as part of the strategy.\n56      */\n57     function balance() public view returns (uint) {\n58         return want().balanceOf(address(this)).add(IStrategy(strategy).balanceOfPool());\n59     }\n\n60     /**\n61      * @dev Custom logic in here for how much the vault allows to be borrowed.\n62      * We return 100% of tokens for now. Under certain conditions we might\n63      * want to keep some of the system funds at hand in the vault, instead\n64      * of putting them to work.\n65      */\n66     function available() public view returns (uint256) {\n67         return want().balanceOf(address(this));\n68     }\n\n69     /**\n70      * @dev Function for various UIs to display the current value of one of our yield tokens.\n71      * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n72      */\n73     function getPricePerFullShare() public view returns (uint256) {\n74         return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n75     }\n\n76     /**\n77      * @dev A helper function to call deposit() with all the sender's funds.\n78      */\n79     function depositAll() external {\n80         deposit(want().balanceOf(msg.sender));\n81     }\n\n82     /**\n83      * @dev The entrypoint of funds into the system. People deposit with this function\n84      * into the vault. The vault is then in charge of sending funds into the strategy.\n85      */\n86     function deposit(uint _amount) public nonReentrant {\n87         require(_amount > 0, \"!deposit zero\");\n\n88         uint256 _pool = balance();\n89         want().safeTransferFrom(msg.sender, address(this), _amount);\n90         earn();\n91         uint256 _after = balance();\n92         _amount = _after.sub(_pool); // Additional check for deflationary tokens\n93         uint256 shares = 0;\n94         if (totalSupply() == 0) {\n95             shares = _amount;\n96         } else {\n97             shares = (_amount.mul(totalSupply())).div(_pool);\n98         }\n99         _mint(msg.sender, shares);\n100     }\n\n101     /**\n102      * @dev Function to send funds into the strategy and put them to work. It's primarily called\n103      * by the vault's deposit() function.\n104      */\n105     function earn() public {\n106         uint _bal = available();\n107         IERC20(want()).safeTransfer(address(strategy), _bal);\n108         IStrategy(strategy).deposit();\n109     }\n\n110     /**\n111      * @dev A helper function to call withdraw() with all the sender's funds.\n112      */\n113     function withdrawAll() external {\n114         withdraw(balanceOf(msg.sender));\n115     }\n\n116     /**\n117      * @dev Function to exit the system. The vault will withdraw the required tokens\n118      * from the strategy and pay up the token holder. A proportional number of IOU\n119      * tokens are burned in the process.\n120      */\n121     function withdraw(uint256 _shares) public {\n122         uint256 r = (balance().mul(_shares)).div(totalSupply());\n123         _burn(msg.sender, _shares);\n\n124         uint b = want().balanceOf(address(this));\n125         if (b < r) {\n126             uint _withdraw = r.sub(b);\n127             strategy.withdraw(_withdraw);\n128             uint _after = want().balanceOf(address(this));\n129             uint _diff = _after.sub(b);\n130             if (_diff < _withdraw) {\n131                 r = b.add(_diff);\n132             }\n133         }\n\n134         want().safeTransfer(msg.sender, r);\n135     }\n\n136     /** \n137      * @dev Sets the candidate for the new strat to use with this vault.\n138      * @param _implementation The address of the candidate strategy.  \n139      */\n140     function proposeStrat(address _implementation) public onlyOwner {\n141         require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");\n142         stratCandidate = StratCandidate({\n143             implementation: _implementation,\n144             proposedTime: block.timestamp\n145          });\n\n146         emit NewStratCandidate(_implementation);\n147     }\n\n148     /** \n149      * @dev It switches the active strat for the strat candidate. After upgrading, the \n150      * candidate implementation is set to the 0x00 address, and proposedTime to a time \n151      * happening in +100 years for safety. \n152      */\n\n153     function upgradeStrat() public onlyOwner {\n154         require(stratCandidate.implementation != address(0), \"There is no candidate\");\n155         require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n156         emit UpgradeStrat(stratCandidate.implementation);\n\n157         strategy.retireStrat();\n158         strategy = IStrategy(stratCandidate.implementation);\n159         stratCandidate.implementation = address(0);\n160         stratCandidate.proposedTime = 5000000000;\n\n161         earn();\n162     }\n\n163     /**\n164      * @dev Rescues random funds stuck that the strat can't handle.\n165      * @param _token address of the token to rescue.\n166      */\n167     function inCaseTokensGetStuck(address _token) external onlyOwner {\n168         require(_token != address(want()), \"!token\");\n\n169         uint256 amount = IERC20(_token).balanceOf(address(this));\n170         IERC20(_token).safeTransfer(msg.sender, amount);\n171     }\n\n172     function depositFor(address token, uint _amount,address user ) public {\n\n173         uint256 _pool = balance();\n174         IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n175         earn();\n176         uint256 _after = balance();\n177         _amount = _after.sub(_pool); // Additional check for deflationary tokens\n178         uint256 shares = 0;\n179         if (totalSupply() == 0) {\n180             shares = _amount;\n181         } else {\n182             shares = (_amount.mul(totalSupply())).div(_pool);\n183         }\n184         _mint(user, shares);\n185     }\n186 }\n",
    "transaction-context": "The transaction context is money market\ntoken transfer",
    "Critical-points": "Critical program points are 48+ \n87         \n141        \n154       \n155         \n168       \n172 ",
    "invariants": "48+ modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}\n87         require(_amount > 0, \"!deposit zero\");\n141         require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");\n154         require(stratCandidate.implementation != address(0), \"There is no candidate\");\n155         require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n168         require(_token != address(want()), \"!token\");\n172 nonReentrant",
    "critical-invariants": "48+ modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}\n172 nonReentrant\n168 require(_token != address(want()), \"!token\");",
    "ranks": "48+ modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}\n172 nonReentrant\n168 require(_token != address(want()), \"!token\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n3 import \"./ERC3156FlashLenderInterface.sol\";\n4 import \"./ERC3156FlashBorrowerInterface.sol\";\n\n5 /**\n6  * @title Cream's CCollateralCapErc20 Contract\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap\n8  * @author Cream\n9  */\n10 contract CCollateralCapErc20 is CToken, CCollateralCapErc20Interface {\n11     /**\n12      * @notice Initialize the new money market\n13      * @param underlying_ The address of the underlying asset\n14      * @param comptroller_ The address of the Comptroller\n15      * @param interestRateModel_ The address of the interest rate model\n16      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n17      * @param name_ ERC-20 name of this token\n18      * @param symbol_ ERC-20 symbol of this token\n19      * @param decimals_ ERC-20 decimal precision of this token\n20      */\n21     function initialize(\n22         address underlying_,\n23         ComptrollerInterface comptroller_,\n24         InterestRateModel interestRateModel_,\n25         uint256 initialExchangeRateMantissa_,\n26         string memory name_,\n27         string memory symbol_,\n28         uint8 decimals_\n29     ) public {\n30         // CToken initialize does the bulk of the work\n31         super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n32         // Set underlying and sanity check it\n33         underlying = underlying_;\n34         EIP20Interface(underlying).totalSupply();\n35     }\n\n36     /*** User Interface ***/\n\n37     /**\n38      * @notice Sender supplies assets into the market and receives cTokens in exchange\n39      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n40      * @param mintAmount The amount of the underlying asset to supply\n41      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n42      */\n43     function mint(uint256 mintAmount) external returns (uint256) {\n44         (uint256 err, ) = mintInternal(mintAmount, false);\n    \n45     }\n\n46     /**\n47      * @notice Sender redeems cTokens in exchange for the underlying asset\n48      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n49      * @param redeemTokens The number of cTokens to redeem into underlying\n50      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n51      */\n52     function redeem(uint256 redeemTokens) external returns (uint256) {\n53         require(redeemInternal(redeemTokens, false) == 0, \"redeem failed\");\n54     }\n\n55     /**\n56      * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n57      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n58      * @param redeemAmount The amount of underlying to redeem\n59      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n60      */\n61     function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n62         require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n63     }\n\n64     /**\n65      * @notice Sender borrows assets from the protocol to their own address\n66      * @param borrowAmount The amount of the underlying asset to borrow\n67      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n68      */\n69     function borrow(uint256 borrowAmount) external returns (uint256) {\n70         require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n71     }\n\n72     /**\n73      * @notice Sender repays their own borrow\n74      * @param repayAmount The amount to repay\n75      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n76      */\n77     function repayBorrow(uint256 repayAmount) external returns (uint256) {\n78         (uint256 err, ) = repayBorrowInternal(repayAmount, false);\n79         require(err == 0, \"repay failed\");\n80     }\n\n81     /**\n82      * @notice Sender repays a borrow belonging to borrower\n83      * @param borrower the account with the debt being payed off\n84      * @param repayAmount The amount to repay\n85      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n86      */\n87     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n88         (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount, false);\n89         require(err == 0, \"repay behalf failed\");\n90     }\n\n91     /**\n92      * @notice The sender liquidates the borrowers collateral.\n93      *  The collateral seized is transferred to the liquidator.\n94      * @param borrower The borrower of this cToken to be liquidated\n95      * @param repayAmount The amount of the underlying borrowed asset to repay\n96      * @param cTokenCollateral The market in which to seize collateral from the borrower\n97      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n98      */\n99     function liquidateBorrow(\n100         address borrower,\n101         uint256 repayAmount,\n102         CTokenInterface cTokenCollateral\n103     ) external returns (uint256) {\n104         (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral, false);\n105         require(err == 0, \"liquidate borrow failed\");\n106     }\n\n107     /**\n108      * @notice The sender adds to reserves.\n109      * @param addAmount The amount fo underlying token to add as reserves\n110      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n111      */\n112     function _addReserves(uint256 addAmount) external returns (uint256) {\n113         require(_addReservesInternal(addAmount, false) == 0, \"add reserves failed\");\n114     }\n\n115     /**\n116      * @notice Set the given collateral cap for the market.\n117      * @param newCollateralCap New collateral cap for this market. A value of 0 corresponds to no cap.\n118      */\n119     function _setCollateralCap(uint256 newCollateralCap) external {\n120         require(msg.sender == admin, \"admin only\");\n\n121         collateralCap = newCollateralCap;\n122         emit NewCollateralCap(address(this), newCollateralCap);\n123     }\n\n124     /**\n125      * @notice Absorb excess cash into reserves.\n126      */\n127     function gulp() external nonReentrant {\n128         uint256 cashOnChain = getCashOnChain();\n129         uint256 cashPrior = getCashPrior();\n\n130         uint256 excessCash = sub_(cashOnChain, cashPrior);\n131         totalReserves = add_(totalReserves, excessCash);\n132         internalCash = cashOnChain;\n133     }\n\n134     /**\n135      * @notice Get the max flash loan amount\n136      */\n137     function maxFlashLoan() external view returns (uint256) {\n138         uint256 amount = 0;\n139         if (\n140             ComptrollerInterfaceExtension(address(comptroller)).flashloanAllowed(address(this), address(0), amount, \"\")\n141         ) {\n142             amount = getCashPrior();\n143         }\n144         return amount;\n145     }\n\n146     /**\n147      * @notice Get the flash loan fees\n148      * @param amount amount of token to borrow\n149      */\n150     function flashFee(uint256 amount) external view returns (uint256) {\n151         require(\n152             ComptrollerInterfaceExtension(address(comptroller)).flashloanAllowed(address(this), address(0), amount, \"\"),\n153             \"flashloan is paused\"\n154         );\n155         return div_(mul_(amount, flashFeeBips), 10000);\n156     }\n\n157     /**\n158      * @notice Flash loan funds to a given account.\n159      * @param receiver The receiver address for the funds\n160      * @param initiator flash loan initiator\n161      * @param amount The amount of the funds to be loaned\n162      * @param data The other data\n163      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n164      */\n165     function flashLoan(\n166         ERC3156FlashBorrowerInterface receiver,\n167         address initiator,\n168         uint256 amount,\n169         bytes calldata data\n170     ) external nonReentrant returns (bool) {\n171         require(amount > 0, \"invalid flashloan amount\");\n172         accrueInterest();\n173         require(\n174             ComptrollerInterfaceExtension(address(comptroller)).flashloanAllowed(\n175                 address(this),\n176                 address(receiver),\n177                 amount,\n178                 data\n179             ),\n180             \"flashloan is paused\"\n181         );\n182         uint256 cashOnChainBefore = getCashOnChain();\n183         uint256 cashBefore = getCashPrior();\n184         require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n185         uint256 totalFee = this.flashFee(amount);\n\n186         doTransferOut(address(uint160(address(receiver))), amount, false);\n\n187         totalBorrows = add_(totalBorrows, amount);\n\n         \n188         uint256 repaymentAmount = add_(amount, totalFee);\n189         doTransferIn(address(receiver), repaymentAmount, false);\n\n190         uint256 cashOnChainAfter = getCashOnChain();\n\n       \n191         uint256 reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n192         totalReserves = add_(totalReserves, reservesFee);\n193         internalCash = add_(cashBefore, totalFee);\n194         totalBorrows = sub_(totalBorrows, amount);\n\n195         emit Flashloan(address(receiver), amount, totalFee, reservesFee);\n196         return true;\n197     }\n\n198     /**\n199      * @notice Register account collateral tokens if there is space.\n200      * @param account The account to register\n201      * @dev This function could only be called by comptroller.\n202      * @return The actual registered amount of collateral\n203      */\n204     function registerCollateral(address account) external returns (uint256) {\n205         // Make sure accountCollateralTokens of `account` is initialized.\n206         initializeAccountCollateralTokens(account);\n        \n207         uint256 amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n208         return increaseUserCollateralInternal(account, amount);\n209     }\n\n210     /**\n211      * @notice Unregister account collateral tokens if the account still has enough collateral.\n212      * @dev This function could only be called by comptroller.\n213      * @param account The account to unregister\n214      */\n215     function unregisterCollateral(address account) external {\n216         // Make sure accountCollateralTokens of `account` is initialized.\n217         initializeAccountCollateralTokens(account);\n\n218         require(\n219             comptroller.redeemAllowed(address(this), account, accountCollateralTokens[account]) == 0,\n220             \"comptroller rejection\"\n221         );\n\n222         decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n223     }\n\n224     /*** Safe Token ***/\n\n225     /**\n226      * @notice Gets internal balance of this contract in terms of the underlying.\n227      *  It excludes balance from direct transfer.\n228      * @dev This excludes the value of the current message, if any\n229      * @return The quantity of underlying tokens owned by this contract\n230      */\n231     function getCashPrior() internal view returns (uint256) {\n232         return internalCash;\n233     }\n\n234     /**\n235      * @notice Gets total balance of this contract in terms of the underlying\n236      * @dev This excludes the value of the current message, if any\n237      * @return The quantity of underlying tokens owned by this contract\n238      */\n239     function getCashOnChain() internal view returns (uint256) {\n240         EIP20Interface token = EIP20Interface(underlying);\n241         return token.balanceOf(address(this));\n242     }\n\n243     /**\n244      * @notice Initialize the account's collateral tokens. This function should be called in the beginning of every function\n245      *  that accesses accountCollateralTokens or accountTokens.\n246      * @param account The account of accountCollateralTokens that needs to be updated\n247      */\n248     function initializeAccountCollateralTokens(address account) internal {\n249         /**\n250          * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n251          * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n252          * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n253          * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n254          * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n255          */\n256         if (!isCollateralTokenInit[account]) {\n257             if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n258                 accountCollateralTokens[account] = accountTokens[account];\n259                 totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n260                 emit UserCollateralChanged(account, accountCollateralTokens[account]);\n261             }\n262             isCollateralTokenInit[account] = true;\n263         }\n264     }\n\n265     /**\n266      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n267      *      This will revert due to insufficient balance or insufficient allowance.\n268      *      This function returns the actual amount received,\n269      *      which may be less than `amount` if there is a fee attached to the transfer.\n270      *\n271      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n272      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n273      */\n274     function doTransferIn(\n275         address from,\n276         uint256 amount,\n277         bool isNative\n278     ) internal returns (uint256) {\n279         isNative; // unused\n\n280         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n281         uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n282         token.transferFrom(from, address(this), amount);\n\n283         bool success;\n284         assembly {\n285             switch returndatasize()\n286             case 0 {\n287                 // This is a non-standard ERC-20\n288                 success := not(0) // set success to true\n289             }\n290             case 32 {\n291                 // This is a compliant ERC-20\n292                 returndatacopy(0, 0, 32)\n293                 success := mload(0) // Set `success = returndata` of external call\n294             }\n295             default {\n296                 // This is an excessively non-compliant ERC-20, revert.\n297                 revert(0, 0)\n298             }\n299         }\n300         require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n301         // Calculate the amount that was *actually* transferred\n302         uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n303         uint256 transferredIn = sub_(balanceAfter, balanceBefore);\n304         internalCash = add_(internalCash, transferredIn);\n305         return transferredIn;\n306     }\n\n307     /**\n308      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n309      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n310      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n311      *      it is >= amount, this should not revert in normal conditions.\n312      *\n313      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n314      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n315      */\n316     function doTransferOut(\n317         address payable to,\n318         uint256 amount,\n319         bool isNative\n320     ) internal {\n321         isNative; // unused\n\n322         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n323         token.transfer(to, amount);\n\n324         bool success;\n325         assembly {\n326             switch returndatasize()\n327             case 0 {\n328                 // This is a non-standard ERC-20\n329                 success := not(0) // set success to true\n330             }\n331             case 32 {\n332                 // This is a complaint ERC-20\n333                 returndatacopy(0, 0, 32)\n334                 success := mload(0) // Set `success = returndata` of external call\n335             }\n336             default {\n337                 // This is an excessively non-compliant ERC-20, revert.\n338                 revert(0, 0)\n339             }\n340         }\n341         require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n342         internalCash = sub_(internalCash, amount);\n343     }\n\n344     /**\n345      * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n346      * @dev Called by both `transfer` and `transferFrom` internally\n347      * @param spender The address of the account performing the transfer\n348      * @param src The address of the source account\n349      * @param dst The address of the destination account\n350      * @param tokens The number of tokens to transfer\n351      * @return Whether or not the transfer succeeded\n352      */\n353     function transferTokens(\n354         address spender,\n355         address src,\n356         address dst,\n357         uint256 tokens\n358     ) internal returns (uint256) {\n359         // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n360         initializeAccountCollateralTokens(src);\n361         initializeAccountCollateralTokens(dst);\n\n362         /**\n363          * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n364          * The buffer between the two values will be transferred first.\n365          * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n366          * collateralTokens = tokens - bufferTokens\n367          */\n368         uint256 bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n369         uint256 collateralTokens = 0;\n370         if (tokens > bufferTokens) {\n371             collateralTokens = tokens - bufferTokens;\n372         }\n\n373         /**\n374          * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n375          * whether collateralized tokens can be transferred.\n376          */\n377         require(comptroller.transferAllowed(address(this), src, dst, collateralTokens) == 0, \"comptroller rejection\");\n\n378         /* Do not allow self-transfers */\n379         require(src != dst, \"bad input\");\n\n380         /* Get the allowance, infinite for the account owner */\n381         uint256 startingAllowance = 0;\n382         if (spender == src) {\n383             startingAllowance = uint256(-1);\n384         } else {\n385             startingAllowance = transferAllowances[src][spender];\n386         }\n\n387         /* Do the calculations, checking for {under,over}flow */\n388         accountTokens[src] = sub_(accountTokens[src], tokens);\n389         accountTokens[dst] = add_(accountTokens[dst], tokens);\n390         if (collateralTokens > 0) {\n391             accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n392             accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n393             emit UserCollateralChanged(src, accountCollateralTokens[src]);\n394             emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n395         }\n\n396         /* Eat some of the allowance (if necessary) */\n397         if (startingAllowance != uint256(-1)) {\n398             transferAllowances[src][spender] = sub_(startingAllowance, tokens);\n399         }\n\n400         /* We emit a Transfer event */\n401         emit Transfer(src, dst, tokens);\n\n402         comptroller.transferVerify(address(this), src, dst, tokens);\n\n403         return uint256(Error.NO_ERROR);\n404     }\n\n405     /**\n406      * @notice Get the account's cToken balances\n407      * @param account The address of the account\n408      */\n409     function getCTokenBalanceInternal(address account) internal view returns (uint256) {\n410         if (isCollateralTokenInit[account]) {\n411             return accountCollateralTokens[account];\n412         } else {\n413             /**\n414              * If the value of accountCollateralTokens was not initialized, we should return the value of accountTokens.\n415              */\n416             return accountTokens[account];\n417         }\n418     }\n\n419     /**\n420      * @notice Increase user's collateral. Increase as much as we can.\n421      * @param account The address of the account\n422      * @param amount The amount of collateral user wants to increase\n423      * @return The actual increased amount of collateral\n424      */\n425     function increaseUserCollateralInternal(address account, uint256 amount) internal returns (uint256) {\n426         uint256 totalCollateralTokensNew = add_(totalCollateralTokens, amount);\n427         if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n428             // 1. If collateral cap is not set,\n429             // 2. If collateral cap is set but has enough space for this user,\n430             // give all the user needs.\n431             totalCollateralTokens = totalCollateralTokensNew;\n432             accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n\n433             emit UserCollateralChanged(account, accountCollateralTokens[account]);\n434             return amount;\n435         } else if (collateralCap > totalCollateralTokens) {\n436             // If the collateral cap is set but the remaining cap is not enough for this user,\n437             // give the remaining parts to the user.\n438             uint256 gap = sub_(collateralCap, totalCollateralTokens);\n439             totalCollateralTokens = add_(totalCollateralTokens, gap);\n440             accountCollateralTokens[account] = add_(accountCollateralTokens[account], gap);\n\n441             emit UserCollateralChanged(account, accountCollateralTokens[account]);\n442             return gap;\n443         }\n444         return 0;\n445     }\n\n446     /**\n447      * @notice Decrease user's collateral. Reject if the amount can't be fully decrease.\n448      * @param account The address of the account\n449      * @param amount The amount of collateral user wants to decrease\n450      */\n451     function decreaseUserCollateralInternal(address account, uint256 amount) internal {\n452         /*\n453          * Return if amount is zero.\n454          * Put behind `redeemAllowed` for accuring potential COMP rewards.\n455          */\n456         if (amount == 0) {\n457             return;\n458         }\n\n459         totalCollateralTokens = sub_(totalCollateralTokens, amount);\n460         accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n461         emit UserCollateralChanged(account, accountCollateralTokens[account]);\n462     }\n\n463     struct MintLocalVars {\n464         uint256 exchangeRateMantissa;\n465         uint256 mintTokens;\n466         uint256 actualMintAmount;\n467     }\n\n468     /**\n469      * @notice User supplies assets into the market and receives cTokens in exchange\n470      * @dev Assumes interest has already been accrued up to the current block\n471      * @param minter The address of the account which is supplying the assets\n472      * @param mintAmount The amount of the underlying asset to supply\n473      * @param isNative The amount is in native or not\n474      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n475      */\n476     function mintFresh(\n477         address minter,\n478         uint256 mintAmount,\n479         bool isNative\n480     ) internal returns (uint256, uint256) {\n481         // Make sure accountCollateralTokens of `minter` is initialized.\n482         initializeAccountCollateralTokens(minter);\n\n483         /* Fail if mint not allowed */\n484         require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n\n485         /*\n486          * Return if mintAmount is zero.\n487          * Put behind `mintAllowed` for accuring potential COMP rewards.\n488          */\n489         if (mintAmount == 0) {\n490             return (uint256(Error.NO_ERROR), 0);\n491         }\n\n  \n492         MintLocalVars memory vars;\n\n493         vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n494         /////////////////////////\n495         // EFFECTS & INTERACTIONS\n496         // (No safe failures beyond this point)\n\n497         /*\n498          *  We call `doTransferIn` for the minter and the mintAmount.\n499          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n500          *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n501          *  side-effects occurred. The function returns the amount actually transferred,\n502          *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n503          *  of cash.\n504          */\n505         vars.actualMintAmount = doTransferIn(minter, mintAmount, isNative);\n\n506         /*\n507          * We get the current exchange rate and calculate the number of cTokens to be minted:\n508          *  mintTokens = actualMintAmount / exchangeRate\n509          */\n510         vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n511         /*\n512          * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n513          *  totalSupply = totalSupply + mintTokens\n514          *  accountTokens[minter] = accountTokens[minter] + mintTokens\n515          */\n516         totalSupply = add_(totalSupply, vars.mintTokens);\n517         accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n518         /*\n519          * We only allocate collateral tokens if the minter has entered the market.\n520          */\n521         if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n522             increaseUserCollateralInternal(minter, vars.mintTokens);\n523         }\n\n524         /* We emit a Mint event, and a Transfer event */\n525         emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n526         emit Transfer(address(this), minter, vars.mintTokens);\n\n527         /* We call the defense hook */\n528         comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n529         return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n530     }\n\n531     struct RedeemLocalVars {\n532         uint256 exchangeRateMantissa;\n533         uint256 redeemTokens;\n534         uint256 redeemAmount;\n535     }\n\n536     /**\n537      * @notice User redeems cTokens in exchange for the underlying asset\n538      * @dev Assumes interest has already been accrued up to the current block. Only one of redeemTokensIn or redeemAmountIn may be non-zero and it would do nothing if both are zero.\n539      * @param redeemer The address of the account which is redeeming the tokens\n540      * @param redeemTokensIn The number of cTokens to redeem into underlying\n541      * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens\n542      * @param isNative The amount is in native or not\n543      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n544      */\n545     function redeemFresh(\n546         address payable redeemer,\n547         uint256 redeemTokensIn,\n548         uint256 redeemAmountIn,\n549         bool isNative\n550     ) internal returns (uint256) {\n551         // Make sure accountCollateralTokens of `redeemer` is initialized.\n552         initializeAccountCollateralTokens(redeemer);     \n\n553         RedeemLocalVars memory vars;\n\n554         /* exchangeRate = invoke Exchange Rate Stored() */\n555         vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n556         /* If redeemTokensIn > 0: */\n557         if (redeemTokensIn > 0) {\n558             /*\n559              * We calculate the exchange rate and the amount of underlying to be redeemed:\n560              *  redeemTokens = redeemTokensIn\n561              *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n562              */\n563             vars.redeemTokens = redeemTokensIn;\n564             vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n565         } else {\n566             /*\n567              * We get the current exchange rate and calculate the amount to be redeemed:\n568              *  redeemTokens = redeemAmountIn / exchangeRate\n569              *  redeemAmount = redeemAmountIn\n570              */\n571             vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n572             vars.redeemAmount = redeemAmountIn;\n573         }\n\n574         /**\n575          * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n576          * The buffer between the two values will be redeemed first.\n577          * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n578          * collateralTokens = redeemTokens - bufferTokens\n579          */\n580         uint256 bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n581         uint256 collateralTokens = 0;\n582         if (vars.redeemTokens > bufferTokens) {\n583             collateralTokens = vars.redeemTokens - bufferTokens;\n584         }\n \n585         /* Verify market's block number equals current block number */\n586         require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n\n      \n587         /////////////////////////\n588         // EFFECTS & INTERACTIONS\n589         // (No safe failures beyond this point)\n\n590         /*\n591          * We calculate the new total supply and redeemer balance, checking for underflow:\n592          *  totalSupplyNew = totalSupply - redeemTokens\n593          *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n594          */\n595         totalSupply = sub_(totalSupply, vars.redeemTokens);\n596         accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n597         /*\n598          * We only deallocate collateral tokens if the redeemer needs to redeem them.\n599          */\n600         decreaseUserCollateralInternal(redeemer, collateralTokens);\n\n601         /*\n602          * We invoke doTransferOut for the redeemer and the redeemAmount.\n603          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n604          *  On success, the cToken has redeemAmount less of cash.\n605          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n606          */\n607         doTransferOut(redeemer, vars.redeemAmount, isNative);\n\n608         /* We emit a Transfer event, and a Redeem event */\n609         emit Transfer(redeemer, address(this), vars.redeemTokens);\n610         emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n611         /* We call the defense hook */\n612         comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n613         return uint256(Error.NO_ERROR);\n614     }\n\n615     /**\n616      * @notice Transfers collateral tokens (this market) to the liquidator.\n617      * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n618      *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n619      * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n620      * @param liquidator The account receiving seized collateral\n621      * @param borrower The account having collateral seized\n622      * @param seizeTokens The number of cTokens to seize\n623      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n624      */\n625     function seizeInternal(\n626         address seizerToken,\n627         address liquidator,\n628         address borrower,\n629         uint256 seizeTokens\n630     ) internal returns (uint256) {\n631         // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n632         initializeAccountCollateralTokens(liquidator);\n633         initializeAccountCollateralTokens(borrower);\n\n634         /* Fail if seize not allowed */\n635         require(\n636             comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\n637             \"comptroller rejection\"\n638         );\n\n639         /*\n640          * Return if seizeTokens is zero.\n641          * Put behind `seizeAllowed` for accuring potential COMP rewards.\n642          */\n643         if (seizeTokens == 0) {\n644             return uint256(Error.NO_ERROR);\n645         }\n\n646         /* Fail if borrower = liquidator */\n647         require(borrower != liquidator, \"invalid account pair\");\n\n648         /*\n649          * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n650          *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n651          *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n652          *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n653          *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n654          */\n655         accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n656         accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n657         accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n658         accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n659         /* Emit a Transfer, UserCollateralChanged events */\n660         emit Transfer(borrower, liquidator, seizeTokens);\n661         emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n662         emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n663         /* We call the defense hook */\n664         comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n665         return uint256(Error.NO_ERROR);\n666     }\n667 }\n586+\n",
    "transaction-context": " require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");",
    "Critical-points": "require(err == 0, \"mint failed\");",
    "invariants": "require(redeemInternal(redeemTokens, false) == 0, \"redeem failed\");",
    "critical-invariants": "require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");",
    "ranks": "require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");",
    "vulnerabilities": "require(err == 0, \"repay failed\");"
  }
]