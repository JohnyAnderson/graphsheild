[
  {
    "code": "1 pragma solidity ^0.4.16;\n \n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n \n3 contract TokenERC20 {\n4     string public name;\n5     string public symbol;\n6     uint8 public decimals = 18;  // 18 \n7     uint256 public totalSupply;\n \n8     mapping (address => uint256) public balanceOf;  //\n9     mapping (address => mapping (address => uint256)) public allowance;\n \n10     event Transfer(address indexed from, address indexed to, uint256 value);\n \n11     event Burn(address indexed from, uint256 value);\n \n \n12     function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {\n13         totalSupply = initialSupply * 10 ** uint256(decimals);\n14         balanceOf[msg.sender] = totalSupply;\n15         name = tokenName;\n16         symbol = tokenSymbol;\n17     }\n \n \n18     function _transfer(address _from, address _to, uint _value) internal {\n19         require(_to != 0x0);\n20         require(balanceOf[_from] >= _value);\n21         require(balanceOf[_to] + _value > balanceOf[_to]);\n22         uint previousBalances = balanceOf[_from] + balanceOf[_to];\n23         balanceOf[_from] -= _value;\n24         balanceOf[_to] += _value;\n25         Transfer(_from, _to, _value);\n26         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n27     }\n \n28     function transfer(address _to, uint256 _value) public returns (bool) {\n29         _transfer(msg.sender, _to, _value);\n30         return true;\n31     }\n \n32     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n33         require(_value <= allowance[_from][msg.sender]);     // Check allowance\n34         allowance[_from][msg.sender] -= _value;\n35         _transfer(_from, _to, _value);\n36         return true;\n37     }\n \n38     function approve(address _spender, uint256 _value) public\n39         returns (bool success) {\n40         allowance[msg.sender][_spender] = _value;\n41         return true;\n42     }\n \n43     function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n44         tokenRecipient spender = tokenRecipient(_spender);\n45         if (approve(_spender, _value)) {\n46             spender.receiveApproval(msg.sender, _value, this, _extraData);\n47             return true;\n48         }\n49     }\n \n50     function burn(uint256 _value) public returns (bool success) {\n51         require(balanceOf[msg.sender] >= _value);\n52         balanceOf[msg.sender] -= _value;\n53         totalSupply -= _value;\n54         Burn(msg.sender, _value);\n55         return true;\n56     }\n \n57     function burnFrom(address _from, uint256 _value) public returns (bool success) {\n58         require(balanceOf[_from] >= _value);\n59         require(_value <= allowance[_from][msg.sender]);\n60         balanceOf[_from] -= _value;\n61         allowance[_from][msg.sender] -= _value;\n62         totalSupply -= _value;\n63         Burn(_from, _value);\n",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 51+ \n58+  \n59+ ",
    "invariants": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "critical-invariants": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "ranks": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{\n\n\n7 //reentrant here \n8     function work(uint256 id, address goblin, uint256 loan, uint256 maxReturn, bytes calldata data)\n9         external payable\n10         onlyEOA accrue(msg.value)\n11     {\n12         // 1. Sanity check the input position, or add a new position of ID is 0.\n13         if (id == 0) {\n14             id = nextPositionID++;\n15             positions[id].goblin = goblin;\n16             positions[id].owner = msg.sender;\n17         } else {\n18             require(id < nextPositionID, \"bad position id\");\n19             require(positions[id].goblin == goblin, \"bad position goblin\");\n20             require(positions[id].owner == msg.sender, \"not position owner\");\n21         }\n22         emit Work(id, loan);\n23         // 2. Make sure the goblin can accept more debt and remove the existing debt.\n24         require(config.isGoblin(goblin), \"not a goblin\");\n25         require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n26         uint256 debt = _removeDebt(id).add(loan);\n27         // 3. Perform the actual work, using a new scope to avoid stack-too-deep errors.\n28         uint256 back;\n29         {\n30             uint256 sendETH = msg.value.add(loan);\n31             require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");\n32             uint256 beforeETH = address(this).balance.sub(sendETH);\n33             Goblin(goblin).work.value(sendETH)(id, msg.sender, debt, data);\n34             back = address(this).balance.sub(beforeETH);\n35         }\n36         // 4. Check and update position debt.\n37         uint256 lessDebt = Math.min(debt, Math.min(back, maxReturn));\n38         debt = debt.sub(lessDebt);\n39         if (debt > 0) {\n40             require(debt >= config.minDebtSize(), \"too small debt size\");\n41             uint256 health = Goblin(goblin).health(id);\n42             uint256 workFactor = config.workFactor(goblin, debt);\n43             require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n44             _addDebt(id, debt);\n45         }\n46         // 5. Return excess ETH back.\n47         if (back > lessDebt) SafeToken.safeTransferETH(msg.sender, back - lessDebt);\n48     }\n49 }\n  \n19+\n",
    "transaction-context": "require(positions[id].goblin == goblin, \"bad position goblin\");",
    "Critical-points": "require(positions[id].owner == msg.sender, \"not position owner\");",
    "invariants": "require(config.isGoblin(goblin), \"not a goblin\");",
    "critical-invariants": " require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");",
    "ranks": " require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");",
    "vulnerabilities": " require(debt >= config.minDebtSize(), \"too small debt size\");"
  },
  {
    "code": "1 contract Example {\n2     function flash(\n3         address recipient,\n4         uint256 amount0,\n5         uint256 amount1,\n6         bytes calldata data\n7     ) external isFlashable globallyTransactable transactable isNotEmergency {\n8         uint256 fee = curve.epsilon.mulu(1e18);\n9         \n10         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n11         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n12 \n13         uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n14         uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n15 \n16         if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n17         if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n18 \n19         IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n20 \n21         uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n22         uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n23 \n24         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n25         uint256 paid0 = balance0After - balance0Before;\n26         uint256 paid1 = balance1After - balance1Before;\n27 \n28         IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n29         IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n30 \n31         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n32     }  \n33 }  \n22+\n",
    "transaction-context": "assert(balance0Before.add(fee0) <= balance0After);",
    "Critical-points": "assert(balance1Before.add(fee1) <= balance1After);",
    "invariants": "nan",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n9 import \"./Swapper.sol\";\n\n10 /**\n11  * @title Anyswap Facet\n12  * @author Li.Finance (https://li.finance)\n13  * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n14  */\n15 contract AnyswapFacet is ILiFi, Swapper {\n16     /* ========== Types ========== */\n\n17     struct AnyswapData {\n18         address token;\n19         address router;\n20         uint256 amount;\n21         address recipient;\n22         uint256 toChainId;\n23     }\n\n24     /* ========== Public Bridge Functions ========== */\n\n25     /**\n26      * @notice Bridges tokens via Anyswap\n27      * @param _lifiData data used purely for tracking and analytics\n28      * @param _anyswapData data specific to Anyswap\n29      */\n30     function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n31         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n32         if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n33             if (underlyingToken == address(0)) {\n34                 underlyingToken = _anyswapData.token;\n35             }\n\n36             uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n37             LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n38             require(\n39                 LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n40                 \"ERR_INVALID_AMOUNT\"\n41             );\n42         } else {\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n44         }\n\n45         _startBridge(_anyswapData);\n\n46         emit LiFiTransferStarted(\n47             _lifiData.transactionId,\n48             _lifiData.integrator,\n49             _lifiData.referrer,\n50             _lifiData.sendingAssetId,\n51             _lifiData.receivingAssetId,\n52             _lifiData.receiver,\n53             _lifiData.amount,\n54             _lifiData.destinationChainId,\n55             block.timestamp\n56         );\n57     }\n\n58     /**\n59      * @notice Performs a swap before bridging via Anyswap\n60      * @param _lifiData data used purely for tracking and analytics\n61      * @param _swapData an array of swap related data for performing swaps before bridging\n62      * @param _anyswapData data specific to Anyswap\n63      */\n64     function swapAndStartBridgeTokensViaAnyswap(\n65         LiFiData memory _lifiData,\n66         LibSwap.SwapData[] calldata _swapData,\n67         AnyswapData memory _anyswapData\n68     ) public payable {\n69         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n70         if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n71             if (underlyingToken == address(0)) {\n72                 underlyingToken = _anyswapData.token;\n73             }\n\n74             uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n75             // Swap\n76             _executeSwaps(_lifiData, _swapData);\n\n77             uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n79             _anyswapData.amount = _postSwapBalance;\n80         } else {\n81             uint256 _fromBalance = address(this).balance;\n\n82             // Swap\n83             _executeSwaps(_lifiData, _swapData);\n\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n85             uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n87             _anyswapData.amount = _postSwapBalance;\n88         }\n\n89         _startBridge(_anyswapData);\n\n90         emit LiFiTransferStarted(\n91             _lifiData.transactionId,\n92             _lifiData.integrator,\n93             _lifiData.referrer,\n94             _lifiData.sendingAssetId,\n95             _lifiData.receivingAssetId,\n96             _lifiData.receiver,\n97             _lifiData.amount,\n98             _lifiData.destinationChainId,\n99             block.timestamp\n100         );\n101     }\n\n102     /* ========== Internal Functions ========== */\n\n103     /**\n104      * @dev Conatains the business logic for the bridge via Anyswap\n105      * @param _anyswapData data specific to Anyswap\n106      */\n107     function _startBridge(AnyswapData memory _anyswapData) internal {\n108         // Check chain id\n109         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n110         if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n111             IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n112                 _anyswapData.token,\n113                 _anyswapData.recipient,\n114                 _anyswapData.toChainId\n115             );\n116             return;\n117         }\n\n118         if (_anyswapData.token != address(0)) {\n119             // Has underlying token?\n120             if (underlyingToken != address(0)) {\n121                 // Give Anyswap approval to bridge tokens\n122                 LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n123                 IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n124                     _anyswapData.token,\n125                     _anyswapData.recipient,\n126                     _anyswapData.amount,\n127                     _anyswapData.toChainId\n128                 );\n129             } else {\n130                 // Give Anyswap approval to bridge tokens\n131                 LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n132                 IAnyswapRouter(_anyswapData.router).anySwapOut(\n133                     _anyswapData.token,\n134                     _anyswapData.recipient,\n135                     _anyswapData.amount,\n136                     _anyswapData.toChainId\n137                 );\n138             }\n139         }\n140     }\n141 }\n",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 38            \n43          \n78             \n84    \n86          \n109+ ",
    "invariants": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "critical-invariants": "109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "ranks": "109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "vulnerabilities": "ID uniquness violation"
  },
  {
    "code": "1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n7 \n8 import \"./lib/ABDKMath64x64.sol\";\n9 \n10 import \"./lib/FullMath.sol\";\n11 \n12 import \"./lib/NoDelegateCall.sol\";\n13 \n14 import \"./Orchestrator.sol\";\n15 \n16 import \"./ProportionalLiquidity.sol\";\n17 \n18 import \"./Swaps.sol\";\n19 \n20 import \"./ViewLiquidity.sol\";\n21 \n22 import \"./Storage.sol\";\n23 \n24 import \"./MerkleProver.sol\";\n25 \n26 import \"./interfaces/IFreeFromUpTo.sol\";\n27 \n28 import \"./interfaces/ICurveFactory.sol\";\n29 \n30 import \"./Structs.sol\";\n31 \n32 library Curves {\n33     using ABDKMath64x64 for int128;\n34 \n35     event Approval(address indexed _owner, address indexed spender, uint256 value);\n36     event Transfer(address indexed from, address indexed to, uint256 value);\n37 \n38     function add(\n39         uint256 x,\n40         uint256 y,\n41         string memory errorMessage\n42     ) private pure returns (uint256 z) {\n43         require((z = x + y) >= x, errorMessage);\n44     }\n45 \n46     function sub(\n47         uint256 x,\n48         uint256 y,\n49         string memory errorMessage\n50     ) private pure returns (uint256 z) {\n51         require((z = x - y) <= x, errorMessage);\n52     }\n53 \n54     /**\n55      * @dev See {IERC20-transfer}.\n56      *\n57      * Requirements:\n58      *\n59      * - `recipient` cannot be the zero address.\n60      * - the caller must have a balance of at least `amount`.\n61      */\n62     function transfer(\n63         Storage.Curve storage curve,\n64         address recipient,\n65         uint256 amount\n66     ) external returns (bool) {\n67         _transfer(curve, msg.sender, recipient, amount);\n68         return true;\n69     }\n70 \n71     /**\n72      * @dev See {IERC20-approve}.\n73      *\n74      * Requirements:\n75      *\n76      * - `spender` cannot be the zero address.\n77      */\n78     function approve(\n79         Storage.Curve storage curve,\n80         address spender,\n81         uint256 amount\n82     ) external returns (bool) {\n83         _approve(curve, msg.sender, spender, amount);\n84         return true;\n85     }\n86 \n87     /**\n88      * @dev See {IERC20-transferFrom}.\n89      *\n90      * Emits an {Approval} event indicating the updated allowance. This is not\n91      * required by the EIP. See the note at the beginning of {ERC20};\n92      *\n93      * Requirements:\n94      * - `sender` and `recipient` cannot be the zero address.\n95      * - `sender` must have a balance of at least `amount`.\n96      * - the caller must have allowance for `sender`'s tokens of at least\n97      * `amount`\n98      */\n99     function transferFrom(\n100         Storage.Curve storage curve,\n101         address sender,\n102         address recipient,\n103         uint256 amount\n104     ) external returns (bool) {\n105         _transfer(curve, sender, recipient, amount);\n106         _approve(\n107             curve,\n108             sender,\n109             msg.sender,\n110             sub(curve.allowances[sender][msg.sender], amount, \"Curve/insufficient-allowance\")\n111         );\n112         return true;\n113     }\n114 \n115     /**\n116      * @dev Atomically increases the allowance granted to `spender` by the caller.\n117      *\n118      * This is an alternative to {approve} that can be used as a mitigation for\n119      * problems described in {IERC20-approve}.\n120      *\n121      * Emits an {Approval} event indicating the updated allowance.\n122      *\n123      * Requirements:\n124      *\n125      * - `spender` cannot be the zero address.\n126      */\n127     function increaseAllowance(\n128         Storage.Curve storage curve,\n129         address spender,\n130         uint256 addedValue\n131     ) external returns (bool) {\n132         _approve(\n133             curve,\n134             msg.sender,\n135             spender,\n136             add(curve.allowances[msg.sender][spender], addedValue, \"Curve/approval-overflow\")\n137         );\n138         return true;\n139     }\n140 \n141     /**\n142      * @dev Atomically decreases the allowance granted to `spender` by the caller.\n143      *\n144      * This is an alternative to {approve} that can be used as a mitigation for\n145      * problems described in {IERC20-approve}.\n146      *\n147      * Emits an {Approval} event indicating the updated allowance.\n148      *\n149      * Requirements:\n150      *\n151      * - `spender` cannot be the zero address.\n152      * - `spender` must have allowance for the caller of at least\n153      * `subtractedValue`.\n154      */\n155     function decreaseAllowance(\n156         Storage.Curve storage curve,\n157         address spender,\n158         uint256 subtractedValue\n159     ) external returns (bool) {\n160         _approve(\n161             curve,\n162             msg.sender,\n163             spender,\n164             sub(curve.allowances[msg.sender][spender], subtractedValue, \"Curve/allowance-decrease-underflow\")\n165         );\n166         return true;\n167     }\n168 \n169     /**\n170      * @dev Moves tokens `amount` from `sender` to `recipient`.\n171      *\n172      * This is public function is equivalent to {transfer}, and can be used to\n173      * e.g. implement automatic token fees, slashing mechanisms, etc.\n174      *\n175      * Emits a {Transfer} event.\n176      *\n177      * Requirements:\n178      *\n179      * - `sender` cannot be the zero address.\n180      * - `recipient` cannot be the zero address.\n181      * - `sender` must have a balance of at least `amount`.\n182      */\n183     function _transfer(\n184         Storage.Curve storage curve,\n185         address sender,\n186         address recipient,\n187         uint256 amount\n188     ) private {\n189         require(sender != address(0), \"ERC20: transfer from the zero address\");\n190         require(recipient != address(0), \"ERC20: transfer to the zero address\");\n191 \n192         curve.balances[sender] = sub(curve.balances[sender], amount, \"Curve/insufficient-balance\");\n193         curve.balances[recipient] = add(curve.balances[recipient], amount, \"Curve/transfer-overflow\");\n194         emit Transfer(sender, recipient, amount);\n195     }\n196 \n197     /**\n198      * @dev Sets `amount` as the allowance of `spender` over the `_owner`s tokens.\n199      *\n200      * This is public function is equivalent to `approve`, and can be used to\n201      * e.g. set automatic allowances for certain subsystems, etc.\n202      *\n203      * Emits an {Approval} event.\n204      *\n205      * Requirements:\n206      *\n207      * - `_owner` cannot be the zero address.\n208      * - `spender` cannot be the zero address.\n209      */\n210     function _approve(\n211         Storage.Curve storage curve,\n212         address _owner,\n213         address spender,\n214         uint256 amount\n215     ) private {\n216         require(_owner != address(0), \"ERC20: approve from the zero address\");\n217         require(spender != address(0), \"ERC20: approve to the zero address\");\n218 \n219         curve.allowances[_owner][spender] = amount;\n220         emit Approval(_owner, spender, amount);\n221     }\n222 }\n223 \n224 contract Curve is Storage, MerkleProver, NoDelegateCall {\n225     using SafeMath for uint256;\n226     using ABDKMath64x64 for int128;\n227     using SafeERC20 for IERC20;\n228 \n229     address private curveFactory;\n230 \n231     event Approval(address indexed _owner, address indexed spender, uint256 value);\n232 \n233     event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\n234 \n235     event AssetIncluded(address indexed numeraire, address indexed reserve, uint256 weight);\n236 \n237     event AssimilatorIncluded(\n238         address indexed derivative,\n239         address indexed numeraire,\n240         address indexed reserve,\n241         address assimilator\n242     );\n243 \n244     event PartitionRedeemed(address indexed token, address indexed redeemer, uint256 value);\n245 \n246     event OwnershipTransfered(address indexed previousOwner, address indexed newOwner);\n247 \n248     event FrozenSet(bool isFrozen);\n249 \n250     event EmergencyAlarm(bool isEmergency);\n251 \n252     event WhitelistingStopped();\n253 \n254     event Trade(\n255         address indexed trader,\n256         address indexed origin,\n257         address indexed target,\n258         uint256 originAmount,\n259         uint256 targetAmount\n260     );\n261 \n262     event Transfer(address indexed from, address indexed to, uint256 value);\n263 \n264     event Flash(address indexed from, address indexed to, uint256 value0, uint256 value1, uint256 paid0, uint256 paid1);\n265 \n266     modifier onlyOwner() {\n267         require(msg.sender == owner, \"Curve/caller-is-not-owner\");\n268         _;\n269     }\n270 \n271     modifier nonReentrant() {\n272         require(notEntered, \"Curve/re-entered\");\n273         notEntered = false;\n274         _;\n275         notEntered = true;\n276     }\n277 \n278     modifier transactable() {\n279         require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n280         _;\n281     }\n282 \n283     modifier isEmergency() {\n284         require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n285         _;\n286     }\n287 \n288     modifier isNotEmergency() {\n289         require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n290         _;\n291     }\n292 \n293     modifier deadline(uint256 _deadline) {\n294         require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n295         _;\n296     }\n297 \n298     modifier inWhitelistingStage() {\n299         require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n300         _;\n301     }\n302 \n303     modifier notInWhitelistingStage() {\n304         require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n305         _;\n306     }\n307 \n308     modifier globallyTransactable() {\n309         require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n310         _;\n311     }\n312     \n313     modifier isFlashable() {\n314         require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n315         _;\n316     }\n317 \n318     constructor(\n319         string memory _name,\n320         string memory _symbol,\n321         address[] memory _assets,\n322         uint256[] memory _assetWeights,\n323         address _factory\n324     ) {\n325         owner = msg.sender;\n326         name = _name;\n327         symbol = _symbol;\n328         curveFactory = _factory;\n329         emit OwnershipTransfered(address(0), msg.sender);\n330 \n331         Orchestrator.initialize(curve, numeraires, reserves, derivatives, _assets, _assetWeights);\n332     }\n333 \n334     /// @notice sets the parameters for the pool\n335     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n336     /// @param _beta the value for beta must be less than alpha and greater than 0\n337     /// @param _feeAtHalt the maximum value for the fee at the halt point\n338     /// @param _epsilon the base fee for the pool\n339     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n340     function setParams(\n341         uint256 _alpha,\n342         uint256 _beta,\n343         uint256 _feeAtHalt,\n344         uint256 _epsilon,\n345         uint256 _lambda\n346     ) external onlyOwner {\n347         Orchestrator.setParams(curve, _alpha, _beta, _feeAtHalt, _epsilon, _lambda);\n348     }\n349 \n350     /// @notice excludes an assimilator from the curve\n351     /// @param _derivative the address of the assimilator to exclude\n352     function excludeDerivative(address _derivative) external onlyOwner {\n353         for (uint256 i = 0; i < numeraires.length; i++) {\n354             if (_derivative == numeraires[i]) revert(\"Curve/cannot-delete-numeraire\");\n355             if (_derivative == reserves[i]) revert(\"Curve/cannot-delete-reserve\");\n356         }\n357 \n358         delete curve.assimilators[_derivative];\n359     }\n360 \n361     /// @notice view the current parameters of the curve\n362     /// @return alpha_ the current alpha value\n363     ///  beta_ the current beta value\n364     ///  delta_ the current delta value\n365     ///  epsilon_ the current epsilon value\n366     ///  lambda_ the current lambda value\n367     ///  omega_ the current omega value\n368     function viewCurve()\n369         external\n370         view\n371         returns (\n372             uint256 alpha_,\n373             uint256 beta_,\n374             uint256 delta_,\n375             uint256 epsilon_,\n376             uint256 lambda_\n377         )\n378     {\n379         return Orchestrator.viewCurve(curve);\n380     }\n381 \n382     function turnOffWhitelisting() external onlyOwner {\n383         emit WhitelistingStopped();\n384 \n385         whitelistingStage = false;\n386     }\n387 \n388     function setEmergency(bool _emergency) external onlyOwner {\n389         emit EmergencyAlarm(_emergency);\n390 \n391         emergency = _emergency;\n392     }\n393 \n394     function setFrozen(bool _toFreezeOrNotToFreeze) external onlyOwner {\n395         emit FrozenSet(_toFreezeOrNotToFreeze);\n396 \n397         frozen = _toFreezeOrNotToFreeze;\n398     }\n399 \n400     function transferOwnership(address _newOwner) external onlyOwner {\n401         require(_newOwner != address(0), \"Curve/new-owner-cannot-be-zeroth-address\");\n402 \n403         emit OwnershipTransfered(owner, _newOwner);\n404 \n405         owner = _newOwner;\n406     }\n407 \n408     /// @notice swap a dynamic origin amount for a fixed target amount\n409     /// @param _origin the address of the origin\n410     /// @param _target the address of the target\n411     /// @param _originAmount the origin amount\n412     /// @param _minTargetAmount the minimum target amount\n413     /// @param _deadline deadline in block number after which the trade will not execute\n414     /// @return targetAmount_ the amount of target that has been swapped for the origin amount\n415     function originSwap(\n416         address _origin,\n417         address _target,\n418         uint256 _originAmount,\n419         uint256 _minTargetAmount,\n420         uint256 _deadline\n421     ) external deadline(_deadline) globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant returns (uint256 targetAmount_) {\n422         OriginSwapData memory _swapData;\n423         _swapData._origin = _origin;\n424         _swapData._target = _target;\n425         _swapData._originAmount = _originAmount;\n426         _swapData._recipient = msg.sender;\n427         _swapData._curveFactory = curveFactory;\n428         targetAmount_ = Swaps.originSwap(curve, _swapData);\n429         // targetAmount_ = Swaps.originSwap(curve, _origin, _target, _originAmount, msg.sender,curveFactory);\n430 \n431         require(targetAmount_ >= _minTargetAmount, \"Curve/below-min-target-amount\");\n432     }\n433 \n434     /// @notice view how much target amount a fixed origin amount will swap for\n435     /// @param _origin the address of the origin\n436     /// @param _target the address of the target\n437     /// @param _originAmount the origin amount\n438     /// @return targetAmount_ the target amount that would have been swapped for the origin amount\n439     function viewOriginSwap(\n440         address _origin,\n441         address _target,\n442         uint256 _originAmount\n443     ) external view globallyTransactable transactable returns (uint256 targetAmount_) {\n444         targetAmount_ = Swaps.viewOriginSwap(curve, _origin, _target, _originAmount);\n445     }\n446 \n447     /// @notice swap a dynamic origin amount for a fixed target amount\n448     /// @param _origin the address of the origin\n449     /// @param _target the address of the target\n450     /// @param _maxOriginAmount the maximum origin amount\n451     /// @param _targetAmount the target amount\n452     /// @param _deadline deadline in block number after which the trade will not execute\n453     /// @return originAmount_ the amount of origin that has been swapped for the target\n454     function targetSwap(\n455         address _origin,\n456         address _target,\n457         uint256 _maxOriginAmount,\n458         uint256 _targetAmount,\n459         uint256 _deadline\n460     ) external deadline(_deadline) globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant returns (uint256 originAmount_) {\n461         TargetSwapData memory _swapData;\n462         _swapData._origin = _origin;\n463         _swapData._target = _target;\n464         _swapData._targetAmount = _targetAmount;\n465         _swapData._recipient = msg.sender;\n466         _swapData._curveFactory = curveFactory;\n467         originAmount_ = Swaps.targetSwap(curve, _swapData);\n468         // originAmount_ = Swaps.targetSwap(curve, _origin, _target, _targetAmount, msg.sender,curveFactory);\n469 \n470         require(originAmount_ <= _maxOriginAmount, \"Curve/above-max-origin-amount\");\n471     }\n472 \n473     /// @notice view how much of the origin currency the target currency will take\n474     /// @param _origin the address of the origin\n475     /// @param _target the address of the target\n476     /// @param _targetAmount the target amount\n477     /// @return originAmount_ the amount of target that has been swapped for the origin\n478     function viewTargetSwap(\n479         address _origin,\n480         address _target,\n481         uint256 _targetAmount\n482     ) external view globallyTransactable transactable returns (uint256 originAmount_) {\n483         originAmount_ = Swaps.viewTargetSwap(curve, _origin, _target, _targetAmount);\n484     }\n485 \n486     /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n487     /// @param  index Index corresponding to the merkleProof\n488     /// @param  account Address coorresponding to the merkleProof\n489     /// @param  amount Amount coorresponding to the merkleProof, should always be 1\n490     /// @param  merkleProof Merkle proof\n491     /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n492     ///                  the numeraire assets of the pool\n493     /// @return (the amount of curves you receive in return for your deposit,\n494     ///          the amount deposited for each numeraire)\n495     function depositWithWhitelist(\n496         uint256 index,\n497         address account,\n498         uint256 amount,\n499         bytes32[] calldata merkleProof,\n500         uint256 _deposit,\n501         uint256 _deadline\n502     ) external deadline(_deadline) globallyTransactable transactable nonReentrant noDelegateCall inWhitelistingStage returns (uint256, uint256[] memory) {\n503         require(amount == 1, \"Curve/invalid-amount\");\n504         require(index <= 473, \"Curve/index-out-of-range\" );\n505         require(isWhitelisted(index, account, amount, merkleProof), \"Curve/not-whitelisted\");\n506         require(msg.sender == account, \"Curve/not-approved-user\");\n507 \n508         (uint256 curvesMinted_, uint256[] memory deposits_) =\n509             ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n510 \n511         whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].add(curvesMinted_);\n512 \n513         // 10k max deposit\n514         if (whitelistedDeposited[msg.sender] > 10000e18) {\n515             revert(\"Curve/exceed-whitelist-maximum-deposit\");\n516         }\n517 \n518         return (curvesMinted_, deposits_);\n519     }\n520 \n521     /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n522     /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n523     ///                  the numeraire assets of the pool\n524     /// @return (the amount of curves you receive in return for your deposit,\n525     ///          the amount deposited for each numeraire)\n526     function deposit(uint256 _deposit, uint256 _deadline)\n527         external\n528         deadline(_deadline)\n529         globallyTransactable\n530         transactable\n531         nonReentrant\n532         noDelegateCall\n533         notInWhitelistingStage\n534         isNotEmergency\n535         returns (uint256, uint256[] memory)\n536     {\n537         // (curvesMinted_,  deposits_)\n538         return ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n539     }\n540 \n541     /// @notice view deposits and curves minted a given deposit would return\n542     /// @param _deposit the full amount of stablecoins you want to deposit. Divided evenly according to the\n543     ///                 prevailing proportions of the numeraire assets of the pool\n544     /// @return (the amount of curves you receive in return for your deposit,\n545     ///          the amount deposited for each numeraire)\n546     function viewDeposit(uint256 _deposit) external view globallyTransactable transactable returns (uint256, uint256[] memory) {\n547         // curvesToMint_, depositsToMake_\n548         return ProportionalLiquidity.viewProportionalDeposit(curve, _deposit);\n549     }\n550 \n551     /// @notice  Emergency withdraw tokens in the event that the oracle somehow bugs out\n552     ///          and no one is able to withdraw due to the invariant check\n553     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n554     ///                        numeraire assets of the pool\n555     /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n556     function emergencyWithdraw(uint256 _curvesToBurn, uint256 _deadline)\n557         external\n558         isEmergency\n559         deadline(_deadline)\n560         nonReentrant\n561         noDelegateCall\n562         returns (uint256[] memory withdrawals_)\n563     {\n564         return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n565     }\n566 \n567     /// @notice  withdrawas amount of curve tokens from the the pool equally from the numeraire assets of the pool with no slippage\n568     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n569     ///                        numeraire assets of the pool\n570     /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n571     function withdraw(uint256 _curvesToBurn, uint256 _deadline)\n572         external\n573         deadline(_deadline)\n574         nonReentrant\n575         noDelegateCall\n576         isNotEmergency\n577         returns (uint256[] memory withdrawals_)\n578     {\n579         if (whitelistingStage) {\n580             whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].sub(_curvesToBurn);\n581         }\n582 \n583         return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n584     }\n585 \n586     /// @notice  views the withdrawal information from the pool\n587     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n588     ///                        numeraire assets of the pool\n589     /// @return the amonnts of numeraire assets withdrawn from the pool\n590     function viewWithdraw(uint256 _curvesToBurn) external view globallyTransactable transactable returns (uint256[] memory) {\n591         return ProportionalLiquidity.viewProportionalWithdraw(curve, _curvesToBurn);\n592     }\n593 \n594     function supportsInterface(bytes4 _interface) public pure returns (bool supports_) {\n595         supports_ =\n596             this.supportsInterface.selector == _interface || // erc165\n597             bytes4(0x7f5828d0) == _interface || // eip173\n598             bytes4(0x36372b07) == _interface; // erc20\n599     }\n600 \n601     /// @notice transfers curve tokens\n602     /// @param _recipient the address of where to send the curve tokens\n603     /// @param _amount the amount of curve tokens to send\n604     /// @return success_ the success bool of the call\n605     function transfer(address _recipient, uint256 _amount) public nonReentrant noDelegateCall isNotEmergency returns (bool success_) {\n606         success_ = Curves.transfer(curve, _recipient, _amount);\n607     }\n608 \n609     /// @notice transfers curve tokens from one address to another address\n610     /// @param _sender the account from which the curve tokens will be sent\n611     /// @param _recipient the account to which the curve tokens will be sent\n612     /// @param _amount the amount of curve tokens to transfer\n613     /// @return success_ the success bool of the call\n614     function transferFrom(\n615         address _sender,\n616         address _recipient,\n617         uint256 _amount\n618     ) public nonReentrant noDelegateCall isNotEmergency returns (bool success_) {\n619         success_ = Curves.transferFrom(curve, _sender, _recipient, _amount);\n620     }\n621 \n622     /// @notice approves a user to spend curve tokens on their behalf\n623     /// @param _spender the account to allow to spend from msg.sender\n624     /// @param _amount the amount to specify the spender can spend\n625     /// @return success_ the success bool of this call\n626     function approve(address _spender, uint256 _amount) public nonReentrant noDelegateCall returns (bool success_) {\n627         success_ = Curves.approve(curve, _spender, _amount);\n628     }\n629     \n630     function flash(\n631         address recipient,\n632         uint256 amount0,\n633         uint256 amount1,\n634         bytes calldata data\n635     ) external isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency {\n636         uint256 fee = curve.epsilon.mulu(1e18);\n637 \n638         require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639         require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n640         \n641         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n642         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n643 \n644         uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n645         uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n646 \n647         if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n648         if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n649 \n650         IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n651 \n652         uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n653         uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n654 \n655         require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656         require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\n657 \n658         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n659         uint256 paid0 = balance0After - balance0Before;\n660         uint256 paid1 = balance1After - balance1Before;\n661 \n662         IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n663         IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n664 \n665         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n666     }    \n667 \n668     /// @notice view the curve token balance of a given account\n669     /// @param _account the account to view the balance of\n670     /// @return balance_ the curve token ballance of the given account\n671     function balanceOf(address _account) public view returns (uint256 balance_) {\n672         balance_ = curve.balances[_account];\n673     }\n674 \n675     /// @notice views the total curve supply of the pool\n676     /// @return totalSupply_ the total supply of curve tokens\n677     function totalSupply() public view returns (uint256 totalSupply_) {\n678         totalSupply_ = curve.totalSupply;\n679     }\n680 \n681     /// @notice views the total allowance one address has to spend from another address\n682     /// @param _owner the address of the owner\n683     /// @param _spender the address of the spender\n684     /// @return allowance_ the amount the owner has allotted the spender\n685     function allowance(address _owner, address _spender) public view returns (uint256 allowance_) {\n686         allowance_ = curve.allowances[_owner][_spender];\n687     }\n688 \n689     /// @notice views the total amount of liquidity in the curve in numeraire value and format - 18 decimals\n690     /// @return total_ the total value in the curve\n691     /// @return individual_ the individual values in the curve\n692     function liquidity() public view returns (uint256 total_, uint256[] memory individual_) {\n693         return ViewLiquidity.viewLiquidity(curve);\n694     }\n695 \n696     /// @notice view the assimilator address for a derivative\n697     /// @return assimilator_ the assimilator address\n698     function assimilator(address _derivative) public view returns (address assimilator_) {\n699         assimilator_ = curve.assimilators[_derivative].addr;\n700     }\n701 }\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 189 \n190 \n216\n217\n266\n271\n278\n283\n288\n293\n298\n303\n308\n313\n346\n352\n382 \n388\n394\n400\n401\n421\n431\n443\n460\n470\n482\n502\n503\n504 \n505\n506\n529 \n530\n531\n532 \n533\n534\n546 \n560\n561\n574\n575\n576 \n590\n618\n626 \n635\n638\n639 \n655 \n656 ",
    "invariants": "189 require(sender != address(0), \"ERC20: transfer from the zero address\");\n190 require(recipient != address(0), \"ERC20: transfer to the zero address\");\n216 require(_owner != address(0), \"ERC20: approve from the zero address\");\n217 require(spender != address(0), \"ERC20: approve to the zero address\");\n266     modifier onlyOwner() {\n           require(msg.sender == owner, \"Curve/caller-is-not-owner\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n401 require(_newOwner != address(0), \"Curve/new-owner-cannot-be-zeroth-address\");\n421  noDelegateCall isNotEmergency nonReentrant\n431  require(targetAmount_ >= _minTargetAmount, \"Curve/below-min-target-amount\");\n443 globallyTransactable transactable\n460 globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant \n470 require(originAmount_ <= _maxOriginAmount, \"Curve/above-max-origin-amount\");\n482 globallyTransactable transactable\n502 globallyTransactable transactable nonReentrant noDelegateCall\n503 require(amount == 1, \"Curve/invalid-amount\");\n504 require(index <= 473, \"Curve/index-out-of-range\" );\n505 require(isWhitelisted(index, account, amount, merkleProof), \"Curve/not-whitelisted\");\n506 require(msg.sender == account, \"Curve/not-approved-user\");\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall\n635 isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency \n638 require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639 require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n655 require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656 require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');",
    "critical-invariants": "266     modifier onlyOwner() {\n           require(msg.sender == owner, \"Curve/caller-is-not-owner\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall",
    "ranks": "266     modifier onlyOwner() {\n           require(msg.sender == owner, \"Curve/caller-is-not-owner\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n9 import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n10 import \"./interfaces/IPancakePair.sol\";\n11 import \"./interfaces/IPancakeFactory.sol\";\n12 import \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\n13 import \"./interfaces/IGymLevelPool.sol\";\n14 import \"./interfaces/IGymSinglePool.sol\";\n15 /* preserved Line */\n16 /* preserved Line */\n17 /* preserved Line */\n18 /* preserved Line */\n19 /* preserved Line */\n\n20 /**\n21  * @notice GymSinglePool contract:\n22  * - Users can:\n23  *   # Deposit GYMNET\n24  *   # Withdraw assets\n25  */\n\n26 contract GymSinglePool is ReentrancyGuardUpgradeable, OwnableUpgradeable {\n27     using SafeERC20Upgradeable for IERC20Upgradeable;\n\n28    /**\n29      * @notice Info of each user\n30      * One Address can have many Deposits with different periods. Unlimited Amount.\n31      * Total Depsit Tokens = Total amount of user active stake in all.\n32      * Total Depsit Dollar Value = Total Dollar Value over all staking single pools. Calculated when user deposits tokens, and dollar value is for that exact moment rate.\n33      * level = level qualification for this pool. Used internally, for global qualification please check MLM Contract.\n34      * depositId = incremental ID of deposits, eg. if user has 3 stakings then this value will be 2;\n35      * totalClaimt = Total amount of tokens user claimt. \n36      */\n37     struct UserInfo {\n38         uint256 totalDepositTokens;\n39         uint256 totalDepositDollarValue;\n40         uint256 level;\n41         uint256 depositId;\n42         uint256 totalClaimt;\n43     }\n\n44    /** \n45      * @notice Info for each staking by ID\n46      * One Address can have many Deposits with different periods. Unlimited Amount.\n47      * depositTokens = amount of tokens for exact deposit.\n48      * depositDollarValue = Dollar value of deposit.\n49      * stakePeriod = Locking Period - from 3 months to 30 months. value is integer\n50      * depositTimestamp = timestamp of deposit\n51      * withdrawalTimestamp = Timestamp when user can withdraw his locked tokens\n52      * rewardsGained = amount of rewards user has gained during the process\n53      * is_finished = checks if user has already withdrawn tokens\n54      */\n55     struct UserDeposits {\n56         uint256 depositTokens;\n57         uint256 depositDollarValue;\n58         uint256 stakePeriod;\n59         uint256 depositTimestamp;\n60         uint256 withdrawalTimestamp;\n61         uint256 rewardsGained;\n62         uint256 rewardsClaimt;\n63         uint256 rewardDebt;\n64         bool is_finished;\n65     }\n66     /**\n67      * @notice Info of Pool\n68      * @param lastRewardBlock: Last block number that reward distribution occurs\n69      * @param accUTacoPerShare: Accumulated rewardPool per share, times 1e18\n70      * @param rewardPerBlock: How many reward tokens will user get per block\n71      */\n72     struct PoolInfo {\n73         uint256 lastRewardBlock;\n74         uint256 accRewardPerShare;\n75         uint256 rewardPerBlock;\n76     }\n\n77     /// Startblock number\n78     uint256 public startBlock;\n79     uint256 public withdrawFee;\n\n80      // MLM Contract - RelationShip address\n81     address public relationship;\n82     /// Treasury address where will be sent all unused assets\n83     address public treasuryAddress;\n84     /// Info of pool.\n85     PoolInfo public poolInfo;\n86     /// Info of each user that staked tokens.\n87     mapping(address => UserInfo) public userInfo;\n\n88     /// accepts user address and id of element to select - returns information about selected staking by id\n89     mapping (address=>UserDeposits[]) public user_deposits;\n\n90     uint256 private lastChangeBlock;\n\n91     /// GYMNET token contract address\n92     address public tokenAddress;\n\n93     /// address of pancake Router\n94     address public pancakeRouterAddress;\n95     /// WBNB and BUSD Token Pair address, element 0 = Address of WBNB Token, element 1= Address of GYMNET \n96     address[] public wbnbAndUSDTTokenArray;\n97     /// GYMNET and WBNB Token Pair address, element 0 = Address of GYMNET, element 1 = Address of WBNB Token, \n98     address[] public GymWBNBPair;\n\n99     /// Level Qualifications for the pool\n100     uint256[16] public levels;\n101     /// Locking Periods \n102     uint256[6] public months;\n\n103     /// Amount of Total GYMNET Locked in the pool\n104     uint256 public totalGymnetLocked;\n\n105     /// Amount of GYMNET all users has claimt over time.\n106     uint256 public totalClaimtInPool;\n\n107     /// Percent that will be sent to MLM Contract for comission distribution\n108     uint256 public RELATIONSHIP_REWARD;\n\n109     /// 6% comissions\n110     uint256 public poolRewardsAmount;\n\n111     address public holderRewardContractAddress;\n\n112     address public runnerScriptAddress;\n113     uint256 public totalBurntInSinglePool;\n114     bool public isPoolActive;\n115     bool public isInMigrationToVTwo;\n116     uint256 public totalGymnetUnlocked;\n117     uint256 public unlockedTimestampQualification;\n118     address public vaultContractAddress;\n119     address public farmingContractAddress;\n\n120     address public levelPoolContractAddress;\n121     address public newSinglePoolAddress;\n\n122     /* ========== EVENTS ========== */\n\n123     event Initialized(address indexed executor, uint256 at);\n124     event Deposit(address indexed user, uint256 amount,uint indexed period);\n125     event Withdraw(address indexed user, uint256 amount,uint indexed period);\n126     event RewardPaid(address indexed token, address indexed user, uint256 amount);\n127     event ClaimUserReward(address indexed user, uint256 amount);\n\n\n128     modifier onlyRunnerScript() {\n129         require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n130         _;\n131     }\n132     modifier onlyBank() {\n133         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n134         _;\n135     }\n136     receive() external payable {}\n\n137     fallback() external payable {}\n\n138 // all initialize parameters are mandatory\n139     function initialize(\n140         uint256 _startBlock,\n141         address _gym,\n142         address _mlm,\n143         uint256 _gymRewardRate,\n144         address _pancakeRouterAddress,\n145         address[] memory _wbnbAndUSDTTokenArray,\n146         address[] memory _GymWBNBPair\n147     ) external initializer {\n148         require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n\n149         startBlock = _startBlock; // Number of Upcoming Block\n150         relationship = _mlm;  // address of MLM contract\n151         tokenAddress = _gym; // address of GYMNET Contract\n152         pancakeRouterAddress = _pancakeRouterAddress; // Address of Pancake Router\n153         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray; // WBNB And USDT Token Addresses [WBNB,USDT]\n154         GymWBNBPair = _GymWBNBPair; // GYMNET And WBNB Token Addresses [GYMNET,WBNB]\n155         runnerScriptAddress = msg.sender;\n156         isPoolActive = false;\n157         isInMigrationToVTwo = false;\n158         RELATIONSHIP_REWARD = 39; // Relationship commission amount\n159         levels = [0, 0, 200, 200, 2000, 4000, 10000, 20000, 40000, 45000, 50000, 60000, 65000, 70000, 75000, 80000]; // Internal Pool Levels\n160         months = [3, 6, 12, 18, 24, 30]; // Locking Periods\n\n161         poolInfo = PoolInfo({\n162                 lastRewardBlock: _startBlock,\n163                 rewardPerBlock: _gymRewardRate,\n164                 accRewardPerShare: 0\n165             });\n\n166         lastChangeBlock = _startBlock;\n\n167         __Ownable_init();\n168         __ReentrancyGuard_init();\n        \n169         emit Initialized(msg.sender, block.number);\n170     }\n\n\n171     function setPoolInfo(uint256 lastRewardBlock,uint256 accRewardPerShare, uint256 rewardPerBlock) external onlyOwner {\n172         poolInfo = PoolInfo({\n173                 lastRewardBlock: lastRewardBlock,\n174                 accRewardPerShare: accRewardPerShare,\n175                 rewardPerBlock: rewardPerBlock\n176             });\n177     }\n\n178     function updateStartBlock(uint256 _startBlock) external onlyOwner {\n179         startBlock = _startBlock;\n180     }\n\n181     function setMLMAddress(address _relationship) external onlyOwner {\n182         relationship = _relationship;\n183     }\n\n184     function setTokenAddress(address _tokenAddress) external onlyOwner {\n185         tokenAddress = _tokenAddress;\n186     }\n187     function setVaultContractAddress(address _vaultContractAddress) external onlyOwner {\n188         vaultContractAddress = _vaultContractAddress;\n189     }\n190     function setFarmingContractAddress(address _farmingContractAddress) external onlyOwner {\n191         farmingContractAddress = _farmingContractAddress;\n192     }\n\n193     function setLevelPoolContractAddress(address _levelPoolContractAddress) external onlyOwner {\n194         levelPoolContractAddress = _levelPoolContractAddress;\n195     }\n\n196     function setRelationshipReward(uint256 _amount) external onlyOwner {\n197         RELATIONSHIP_REWARD = _amount;\n198     }\n199     function setOnlyRunnerScript(address _onlyRunnerScript) external onlyOwner {\n200         runnerScriptAddress = _onlyRunnerScript;\n201     }\n202     function setNewSinglePoolAddress(address _newSinglePoolAddress) external onlyOwner {\n203         newSinglePoolAddress = _newSinglePoolAddress;\n204     }\n\n205     function setGymWBNBPair(address[] memory  _GymWBNBPair) external onlyOwner {\n206         GymWBNBPair = _GymWBNBPair;\n207     }\n208     function setPancakeRouterAddress(address _pancakeRouterAddress) external onlyOwner {\n209         pancakeRouterAddress = _pancakeRouterAddress;\n210     }\n\n211     function setIsPoolActive(bool _isPoolActive) external onlyOwner {\n212         isPoolActive = _isPoolActive;\n213     }\n214     function setIsInMigrationToVTwo(bool _isInMigrationToVTwo) external onlyOwner {\n215         isInMigrationToVTwo = _isInMigrationToVTwo;\n216     }\n\n217     function setHolderRewardContractAddress(address _holderRewardContractAddress) external onlyOwner {\n218         holderRewardContractAddress = _holderRewardContractAddress;\n219     }\n\n\n220     function setWbnbAndUSDTTokenArray(address[] memory _wbnbAndUSDTTokenArray) external onlyOwner {\n221         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray;\n222     }\n223     function setUnlockedTimestampQualification(uint256 _unlockedTimestampQualification) external onlyOwner {\n224         unlockedTimestampQualification = _unlockedTimestampQualification;\n225     }\n226     function setLevels(uint256[16] calldata _levels) external onlyOwner {\n227         levels = _levels;\n228     }\n\n229      /**\n230      * @notice  Function to set Treasury address\n231      * @param _treasuryAddress Address of treasury address\n232      */\n233     function setTreasuryAddress(address _treasuryAddress) external nonReentrant onlyOwner {\n234         treasuryAddress = _treasuryAddress;\n235     }\n\n236     /**\n237      * @notice Deposit in given pool\n238      * @param _depositAmount: Amount of want token that user wants to deposit\n239      */\n240     function deposit(\n241         uint256 _depositAmount,\n242         uint8 _periodId,\n243         uint256 _referrerId,\n244         bool isUnlocked\n245     ) external  {\n246         require(isPoolActive,'Contract is not running yet');\n247         IGymMLM(relationship).addGymMLM(msg.sender, _referrerId);\n248         _deposit(_depositAmount,_periodId,isUnlocked);\n249     }\n250     /**\n251      * @notice Deposit in given pool\n252      * @param _depositAmount: Amount of want token that user wants to deposit\n253      */\n254     function depositFromOtherContract(\n255         uint256 _depositAmount,\n256         uint8 _periodId,\n257         bool isUnlocked,\n258         address _from\n259     ) external onlyBank {\n260         require(isPoolActive,'Contract is not running yet');\n261         _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n\n262         _updateLevelPoolQualification(_from);\n263     }\n\n264     /**\n265      * @notice To get User level in other contract for single pool.\n266      * @param _user: User address\n267      */\n268     function getUserLevelInSinglePool(address _user) external view returns (uint32) {\n269         uint256 _totalDepositDollarValue = userInfo[_user].totalDepositDollarValue;\n270         uint32 level = 0;\n271         for (uint32 i = 0; i<levels.length ; i++) {\n272             if(_totalDepositDollarValue >= levels[i]) {\n273                 level=i;\n274             }\n275         }\n276         return level;\n277     }\n\n278     /**\n279     Should approve allowance before initiating\n280     accepts depositAmount in WEI\n281     periodID - id of months array accordingly\n282     */\n283     function _deposit(\n284         uint256 _depositAmount,\n285         uint8 _periodId,\n286         bool _isUnlocked\n287     ) private {\n288         UserInfo storage user = userInfo[msg.sender];\n289         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n290         PoolInfo storage pool = poolInfo;\n291         updatePool();\n\n292         uint256 period = months[_periodId];\n293         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n294         uint256 burnTokensAmount = 0;\n\n295         if(!_isUnlocked) {\n296             burnTokensAmount = (_depositAmount * 4) / 100;\n297             totalBurntInSinglePool += burnTokensAmount;\n298             IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n299         }\n\n        \n300         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n\n301         token.safeTransferFrom(msg.sender, address(this), amountToDeposit);\n302         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n303         user.totalDepositTokens += amountToDeposit;\n304         user.totalDepositDollarValue += UsdValueOfGym;\n305         totalGymnetLocked += amountToDeposit;\n306         if(_isUnlocked) {\n307             totalGymnetUnlocked += amountToDeposit;\n308             period = 0; \n309             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n310         }\n\n311         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n312         UserDeposits memory depositDetails = UserDeposits(\n313             {\n314                 depositTokens: amountToDeposit, \n315                 depositDollarValue: UsdValueOfGym,\n316                 stakePeriod: period,\n317                 depositTimestamp: block.timestamp,\n318                 withdrawalTimestamp: lockTimesamp,\n319                 rewardsGained: 0,\n320                 is_finished: false,\n321                 rewardsClaimt: 0,\n322                 rewardDebt: rewardDebt\n323             }\n324         );\n\n325         user_deposits[msg.sender].push(depositDetails);\n326         user.depositId = user_deposits[msg.sender].length;\n        \n\n327        for (uint i = 0; i<levels.length ; i++) {\n328             if(user.totalDepositDollarValue >= levels[i]) {\n329                 user.level=i;\n330             }\n331         }\n332         _updateLevelPoolQualification(msg.sender);\n333         emit Deposit(msg.sender, _depositAmount,_periodId);\n334     }\n\n335      /**\n336     Should approve allowance before initiating\n337     accepts depositAmount in WEI\n338     periodID - id of months array accordingly\n339     */\n340     function _autoDeposit(\n341         uint256 _depositAmount,\n342         uint8 _periodId,\n343         bool _isUnlocked,\n344         address _from\n345     ) private {\n346         UserInfo storage user = userInfo[_from];\n347         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n348         PoolInfo storage pool = poolInfo;\n349         token.approve(address(this), _depositAmount);\n350         updatePool();\n351         uint256 period = months[_periodId];\n352         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n353         uint256 burnTokensAmount = 0;\n354         // if(!_isUnlocked) {\n355         //     uint256 burnTokensAmount = (_depositAmount * 4) / 100;\n356         //     totalBurntInSinglePool += burnTokensAmount;\n357         //     IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n358         // }\n359         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n360         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n361         user.totalDepositTokens += amountToDeposit;\n362         user.totalDepositDollarValue += UsdValueOfGym;\n363         totalGymnetLocked += amountToDeposit;\n364         if(_isUnlocked) {\n365             totalGymnetUnlocked += amountToDeposit;\n366             period = 0; \n367             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n368         }\n\n369         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n370         UserDeposits memory depositDetails = UserDeposits(\n371             {\n372                 depositTokens: amountToDeposit, \n373                 depositDollarValue: UsdValueOfGym,\n374                 stakePeriod: period,\n375                 depositTimestamp: block.timestamp,\n376                 withdrawalTimestamp: lockTimesamp,\n377                 rewardsGained: 0,\n378                 is_finished: false,\n379                 rewardsClaimt: 0,\n380                 rewardDebt: rewardDebt\n381             }\n382         );\n383         user_deposits[_from].push(depositDetails);\n384         user.depositId = user_deposits[_from].length;\n \n385         emit Deposit(_from, amountToDeposit,_periodId);\n386     }\n\n387      /**\n388      * Returns the latest price\n389      */\n390     function getPrice () public view returns (uint) {\n391         uint256[] memory gymPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1000000000000000000,GymWBNBPair);\n392         uint256[] memory BNBPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1, wbnbAndUSDTTokenArray);\n393         return gymPriceInUSD[1] * BNBPriceInUSD[1];\n394     }\n\n\n395     /**\n396      * @notice withdraw one claim\n397      * @param _depositId: is the id of user element. \n398      */\n399     function withdraw(\n400         uint256 _depositId\n401     ) external  {\n402         require(_depositId >= 0, \"Value is not specified\");\n403         updatePool();\n404         _withdraw(_depositId);\n\n405         _updateLevelPoolQualification(msg.sender);\n406     }\n\n407     /**\n408     Should approve allowance before initiating\n409     accepts _depositId - is the id of user element. \n410     */\n411     function _withdraw(\n412             uint256 _depositId\n413         ) private {\n414             UserInfo storage user = userInfo[msg.sender];\n415             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n416             PoolInfo storage pool = poolInfo;\n417             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n418             if(!isInMigrationToVTwo) {\n419                 require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n420             }\n421             require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n\n422             _claim(_depositId,1);\n423             depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n\n424             user.totalDepositTokens -=  depositDetails.depositTokens;\n425             user.totalDepositDollarValue -=  depositDetails.depositDollarValue;\n426             totalGymnetLocked -= depositDetails.depositTokens;\n427             if(depositDetails.stakePeriod == 0) {\n428                 totalGymnetUnlocked -= depositDetails.depositTokens;\n429             }\n            \n430             token.safeTransferFrom(address(this),msg.sender, depositDetails.depositTokens);\n\n431             for (uint i = 0; i<levels.length ; i++) {\n432                 if(user.totalDepositDollarValue >= levels[i]) {\n433                     user.level=i;\n434                 }\n435             }\n436             depositDetails.is_finished = true;\n437             emit Withdraw(msg.sender,  depositDetails.depositTokens,depositDetails.stakePeriod);\n\n\n438         }\n\n\n439     /**\n440      * @notice Claim rewards you gained over period\n441      * @param _depositId: is the id of user element. \n442      */\n443     function claim(\n444         uint256 _depositId\n445     ) external  {\n446         require(_depositId >= 0, \"Value is not specified\");\n447         updatePool();\n448         refreshMyLevel(msg.sender);\n449         _claim(_depositId,0);\n450     }\n\n451    /*\n452     Should approve allowance before initiating\n453     accepts _depositId - is the id of user element. \n454     */\n455     function _claim(\n456             uint256 _depositId,\n457             uint256 fromWithdraw\n458         ) private {\n459             UserInfo storage user = userInfo[msg.sender];\n460             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n461             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n462             PoolInfo storage pool = poolInfo;\n\n463             uint256 pending = pendingReward(_depositId,msg.sender);\n\n464             if(fromWithdraw == 0) {\n465                 require(pending > 0 ,\"No rewards to claim.\");\n466             }\n\n\n467             if (pending > 0) {\n468                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n469                 token.safeTransfer(relationship, distributeRewardTokenAmt);\n470                 IGymMLM(relationship).distributeRewards(pending, address(tokenAddress), msg.sender, 3);\n\n471                 // 6% distribution \n472                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n473                 poolRewardsAmount += calculateDistrubutionReward; \n                \n474                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n475                 safeRewardTransfer(tokenAddress, msg.sender, calcUserRewards);\n\n476                 user.totalClaimt += calcUserRewards;\n477                 totalClaimtInPool += pending;\n478                 depositDetails.rewardsClaimt += pending;\n479                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n480                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n481                  depositDetails.rewardsGained = 0;\n482             }\n            \n483             // token.safeTransferFrom(address(this),msg.sender, depositDetails.rewardsGained);\n\n484         }\n\n\n      \n485    /*\n486     transfers pool commisions to management\n487     */\n488     function transferPoolRewards() public onlyRunnerScript {\n489             require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n490             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n491             token.safeTransfer(holderRewardContractAddress, poolRewardsAmount);\n492             // token.safeTransfer(relationship, poolRewardsAmount/2);\n493             poolRewardsAmount = 0;\n494         }  \n\n\n495     /**\n496      * @notice  Safe transfer function for reward tokens\n497      * @param _rewardToken Address of reward token contract\n498      * @param _to Address of reciever\n499      * @param _amount Amount of reward tokens to transfer\n500      */\n501     function safeRewardTransfer(\n502         address _rewardToken,\n503         address _to,\n504         uint256 _amount\n505     ) internal {\n506         uint256 _bal = IERC20Upgradeable(_rewardToken).balanceOf(address(this));\n507         if (_amount > _bal) {\n508             require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n509         } else {\n510             require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n511         }\n512     }\n513     /**\n514      * @notice To get User Info in other contract.\n515      */\n516     function getUserInfo(address _user) external view returns (UserInfo memory) {\n517         return userInfo[_user];\n518     }\n\n519         /**\n520      * @notice View function to see pending reward on frontend.\n521      * @param _depositId: Staking pool id\n522      * @param _user: User address\n523      */\n524     function pendingReward(uint256 _depositId, address _user) public view returns (uint256) {\n525         UserDeposits storage depositDetails = user_deposits[_user][_depositId];\n526         UserInfo storage user = userInfo[_user];\n527         PoolInfo storage pool = poolInfo;\n528         if(depositDetails.is_finished == true || depositDetails.stakePeriod == 0){\n529             return 0;\n530         }\n      \n531         uint256 _accRewardPerShare = pool.accRewardPerShare;\n532         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n\n533         if (block.number > pool.lastRewardBlock && sharesTotal != 0) {\n534             uint256 _multiplier = block.number - pool.lastRewardBlock;\n535             uint256 _reward = (_multiplier * pool.rewardPerBlock);\n536              _accRewardPerShare = _accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n537         }\n\n538         return (depositDetails.depositTokens * _accRewardPerShare) / (1e18) - (depositDetails.rewardDebt);\n539     }\n\n\n540     /**\n541      * @notice Update reward variables of the given pool to be up-to-date.\n542      */\n543     function updatePool() public {\n544         PoolInfo storage pool = poolInfo;\n545         if (block.number <= pool.lastRewardBlock) {\n546             return;\n547         }\n548         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n549         if (sharesTotal == 0) {\n550             pool.lastRewardBlock = block.number;\n551             return;\n552         }\n553         uint256 multiplier = block.number - pool.lastRewardBlock;\n554         if (multiplier <= 0) {\n555             return;\n556         }\n557         uint256 _rewardPerBlock = pool.rewardPerBlock;\n558         uint256 _reward = (multiplier * _rewardPerBlock);\n559         pool.accRewardPerShare = pool.accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n560         pool.lastRewardBlock = block.number;\n561     }\n562     /**\n563      * @notice Claim All Rewards in one Transaction Internat Function.\n564      * If reinvest = true, Rewards will be reinvested as a new Staking\n565      * Reinvest Period Id is the id of months element\n566      */\n567     function _claimAll(bool reinvest,uint8 reinvestPeriodId) private {\n568         UserInfo storage user = userInfo[msg.sender];\n569         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n570         PoolInfo storage pool = poolInfo;\n571          updatePool();\n572          uint256 distributeRewardTokenAmtTotal = 0;\n573          uint256 calcUserRewardsTotal = 0;\n574          uint256 totalDistribute = 0;\n575         for (uint256 i = 0; i<user.depositId ; i++) {\n576             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n577             uint256 pending = pendingReward(i,msg.sender);\n578             totalDistribute += pending;\n579             if (pending > 0) {\n580                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n581                  distributeRewardTokenAmtTotal += distributeRewardTokenAmt;\n582                 // 6% distribution \n583                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n584                 poolRewardsAmount += calculateDistrubutionReward; \n                \n585                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n586                 calcUserRewardsTotal += calcUserRewards;\n\n587                 user.totalClaimt += calcUserRewards;\n588                 totalClaimtInPool += pending;\n589                 depositDetails.rewardsClaimt += pending;\n590                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n591                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n592                  depositDetails.rewardsGained = 0;\n593             }\n            \n594         }\n595         token.safeTransfer(relationship, distributeRewardTokenAmtTotal);\n596         IGymMLM(relationship).distributeRewards(totalDistribute, address(tokenAddress), msg.sender, 3);\n597         safeRewardTransfer(tokenAddress, msg.sender, calcUserRewardsTotal);\n598         if(reinvest == true) {\n599           _deposit(calcUserRewardsTotal,reinvestPeriodId,false);\n600         }\n601     }\n602     /**\n603      * @notice Claim All Rewards in one Transaction.\n604      */\n605     function claimAll() public {\n606          refreshMyLevel(msg.sender);\n607         _claimAll(false,0);\n608     }\n609     /**\n610      * @notice Claim and Reinvest all rewards public function to trigger internal _claimAll function.\n611      */\n612     function claimAndReinvest(bool reinvest,uint8 periodId) public {\n613         require(isPoolActive,'Contract is not running yet');\n614         _claimAll(reinvest,periodId);\n615     }\n\n616     function refreshMyLevel(address _user) public {\n617         UserInfo storage user = userInfo[_user];\n618         for (uint i = 0; i<levels.length ; i++) {\n619             if(user.totalDepositDollarValue >= levels[i]) {\n620                 user.level=i;\n621             }\n622         }\n623     }\n624     function totalLockedTokens(address _user) public view returns (uint256) {\n625         UserInfo storage user = userInfo[_user];\n626         uint256 totalDepositLocked = 0;\n627         for (uint256 i = 0; i<user.depositId ; i++) {\n628             UserDeposits storage depositDetails = user_deposits[_user][i];\n629             if(depositDetails.stakePeriod != 0 && !depositDetails.is_finished) {\n630                 totalDepositLocked += depositDetails.depositTokens;\n631             } \n632         }\n633         return totalDepositLocked;\n634     }\n\n635     function switchToUnlocked(uint256 _depositId) public {\n636         UserInfo storage user = userInfo[msg.sender];\n637         UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n639         _claim(_depositId,1);\n640         uint256 lockTimesamp = DateTime.addSeconds(block.timestamp,1);\n\n641         depositDetails.stakePeriod = 0;\n642         depositDetails.withdrawalTimestamp = lockTimesamp;\n643         totalGymnetUnlocked += depositDetails.depositTokens;\n\n644     }\n\n645     function _updateLevelPoolQualification(address wallet) internal {\n646         uint256 userLevel = IGymMLM(relationship).getUserCurrentLevel(wallet);\n647         IGymLevelPool(levelPoolContractAddress).updateUserQualification(wallet, userLevel);\n648     }\n\n649     function transferToV2(uint8 _periodId,bool isUnlocked) public {\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n651         UserInfo storage user = userInfo[msg.sender];\n652          require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');\n653          if(isUnlocked) {\n654             _periodId = 0;\n655          }\n656         _claimAll(false,0);\n657         uint256 dollarValueOfDeposits = user.totalDepositDollarValue * 1e18;\n658         IGymSinglePool(newSinglePoolAddress).transferFromOldVersion(\n659              user.totalDepositTokens,\n660              _periodId,\n661              isUnlocked,\n662              msg.sender,\n663              dollarValueOfDeposits\n664         );\n665         for (uint32 i = 0; i<user.depositId ; i++) {\n666             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n667             depositDetails.depositTokens = 0;\n668             depositDetails.is_finished = true;\n669             totalGymnetLocked -= depositDetails.depositTokens;\n670             if(depositDetails.stakePeriod == 0) {\n671                 totalGymnetUnlocked -= depositDetails.depositTokens;\n672             }\n673         }\n\n674         user.totalDepositDollarValue = 0;\n675         user.totalDepositTokens = 0;\n\n676     }\n677     function burnOldTokens() public onlyOwner {\n678         uint256 _bal = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n679         IERC20Burnable(tokenAddress).burnFrom(address(this),_bal);\n680     }\n681 }\n254\n",
    "transaction-context": "onlyBank",
    "Critical-points": " onlyBank",
    "invariants": "require(isPoolActive,'Contract is not running yet');",
    "critical-invariants": "require(_depositId >= 0, \"Value is not specified\");",
    "ranks": "require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");",
    "vulnerabilities": "require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";\n10 import \"./interfaces/XSushiExchangeRateInterface.sol\";\n11 import \"./interfaces/YVaultTokenInterface.sol\";\n12 import \"../CErc20.sol\";\n13 import \"../CToken.sol\";\n14 import \"../Exponential.sol\";\n15 import \"../EIP20Interface.sol\";\n16 \n17 contract PriceOracleProxy is PriceOracle, Exponential, Denominations {\n18     /// @notice Yvault token version, currently support v1 and v2\n19     enum YvTokenVersion {\n20         V1,\n21         V2\n22     }\n23 \n24     /// @notice Curve token version, currently support v1, v2 and v3\n25     enum CurveTokenVersion {\n26         V1,\n27         V2,\n28         V3\n29     }\n30 \n31     /// @notice Curve pool type, currently support ETH and USD base\n32     enum CurvePoolType {\n33         ETH,\n34         USD\n35     }\n36 \n37     struct YvTokenInfo {\n38         /// @notice Check if this token is a Yvault token\n39         bool isYvToken;\n40         /// @notice The version of Yvault\n41         YvTokenVersion version;\n42     }\n43 \n44     struct CrvTokenInfo {\n45         /// @notice Check if this token is a curve pool token\n46         bool isCrvToken;\n47         /// @notice The curve pool type\n48         CurvePoolType poolType;\n49         /// @notice The curve swap contract address\n50         address curveSwap;\n51     }\n52 \n53     struct AggregatorInfo {\n54         /// @notice The base\n55         address base;\n56         /// @notice The quote denomination\n57         address quote;\n58         /// @notice It's being used or not\n59         bool isUsed;\n60     }\n61 \n62     /// @notice Admin address\n63     address public admin;\n64 \n65     /// @notice Guardian address\n66     address public guardian;\n67 \n68     /// @notice Indicator that this is a PriceOracle contract (for inspection)\n69     bool public constant isPriceOracle = true;\n70 \n71     /// @notice The v1 price oracle, which will continue to serve prices for v1 assets\n72     V1PriceOracleInterface public v1PriceOracle;\n73 \n74     /// @notice The ChainLink registry address\n75     FeedRegistryInterface public registry;\n76 \n77     /// @notice ChainLink quotes\n78     mapping(address => AggregatorInfo) public aggregators;\n79 \n80     /// @notice Check if the underlying address is Uniswap or SushiSwap LP\n81     mapping(address => bool) public isUnderlyingLP;\n82 \n83     /// @notice Yvault token data\n84     mapping(address => YvTokenInfo) public yvTokens;\n85 \n86     /// @notice Curve pool token data\n87     mapping(address => CrvTokenInfo) public crvTokens;\n88 \n89     /// @notice BTC related addresses. All these underlying we use `Denominations.BTC` as the aggregator base.\n90     address[6] public btcAddresses = [\n91         0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, // WBTC\n92         0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D, // renBTC\n93         0x9BE89D2a4cd102D8Fecc6BF9dA793be995C22541, // BBTC\n94         0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa, // tBTC\n95         0x0316EB71485b0Ab14103307bf65a021042c6d380, // HBTC\n96         0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F // ibBTC\n97     ];\n98 \n99     address public cEthAddress;\n100 \n101     address public constant usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n102     address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n103     address public constant sushiAddress = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n104     address public constant xSushiExRateAddress = 0x851a040fC0Dcbb13a272EBC272F2bC2Ce1e11C4d;\n105     address public constant crXSushiAddress = 0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2;\n106 \n107     /**\n108      * @param admin_ The address of admin to set aggregators, LPs, curve tokens, or Yvault tokens\n109      * @param v1PriceOracle_ The address of the v1 price oracle, which will continue to operate and hold prices for collateral assets\n110      * @param cEthAddress_ The address of cETH, which will return a constant 1e18, since all prices relative to ether\n111      * @param registry_ The address of ChainLink registry\n112      */\n113     constructor(\n114         address admin_,\n115         address v1PriceOracle_,\n116         address cEthAddress_,\n117         address registry_\n118     ) public {\n119         admin = admin_;\n120         v1PriceOracle = V1PriceOracleInterface(v1PriceOracle_);\n121         cEthAddress = cEthAddress_;\n122         registry = FeedRegistryInterface(registry_);\n123     }\n124 \n125     /**\n126      * @notice Get the underlying price of a listed cToken asset\n127      * @param cToken The cToken to get the underlying price of\n128      * @return The underlying asset price mantissa (scaled by 1e18)\n129      */\n130     function getUnderlyingPrice(CToken cToken) public view returns (uint256) {\n131         address cTokenAddress = address(cToken);\n132         if (cTokenAddress == cEthAddress) {\n133             // ether always worth 1\n134             return 1e18;\n135         } else if (cTokenAddress == crXSushiAddress) {\n136             // Handle xSUSHI.\n137             uint256 exchangeRate = XSushiExchangeRateInterface(xSushiExRateAddress).getExchangeRate();\n138             return mul_(getTokenPrice(sushiAddress), Exp({mantissa: exchangeRate}));\n139         }\n140 \n141         address underlying = CErc20(cTokenAddress).underlying();\n142 \n143         // Handle LP tokens.\n144         if (isUnderlyingLP[underlying]) {\n145             return getLPFairPrice(underlying);\n146         }\n147 \n148         // Handle Yvault tokens.\n149         if (yvTokens[underlying].isYvToken) {\n150             return getYvTokenPrice(underlying);\n151         }\n152 \n153         // Handle curve pool tokens.\n154         if (crvTokens[underlying].isCrvToken) {\n155             return getCrvTokenPrice(underlying);\n156         }\n157 \n158         return getTokenPrice(underlying);\n159     }\n160 \n161     /*** Internal fucntions ***/\n162 \n163     /**\n164      * @notice Get the price of a specific token. Return 1e18 is it's WETH.\n165      * @param token The token to get the price of\n166      * @return The price\n167      */\n168     function getTokenPrice(address token) internal view returns (uint256) {\n169         if (token == wethAddress) {\n170             // weth always worth 1\n171             return 1e18;\n172         }\n173 \n174         AggregatorInfo memory aggregatorInfo = aggregators[token];\n175         if (aggregatorInfo.isUsed) {\n176             uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n177             if (aggregatorInfo.quote == Denominations.USD) {\n178                 // Convert the price to ETH based if it's USD based.\n179                 price = mul_(price, Exp({mantissa: getUsdcEthPrice()}));\n180             }\n181             uint256 underlyingDecimals = EIP20Interface(token).decimals();\n182             return mul_(price, 10**(18 - underlyingDecimals));\n183         }\n184         return getPriceFromV1(token);\n185     }\n186 \n187     /**\n188      * @notice Get price from ChainLink\n189      * @param base The base token that ChainLink aggregator gets the price of\n190      * @param quote The quote token, currenlty support ETH and USD\n191      * @return The price, scaled by 1e18\n192      */\n193     function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n194         (, int256 price, , , ) = registry.latestRoundData(base, quote);\n195         require(price > 0, \"invalid price\");\n196 \n197         // Extend the decimals to 1e18.\n198         return mul_(uint256(price), 10**(18 - uint256(registry.decimals(base, quote))));\n199     }\n200 \n201     /**\n202      * @notice Get the fair price of a LP. We use the mechanism from Alpha Finance.\n203      *         Ref: https://blog.alphafinance.io/fair-lp-token-pricing/\n204      * @param pair The pair of AMM (Uniswap or SushiSwap)\n205      * @return The price\n206      */\n207     function getLPFairPrice(address pair) internal view returns (uint256) {\n208         address token0 = IUniswapV2Pair(pair).token0();\n209         address token1 = IUniswapV2Pair(pair).token1();\n210         uint256 totalSupply = IUniswapV2Pair(pair).totalSupply();\n211         (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pair).getReserves();\n212         uint256 sqrtR = sqrt(mul_(r0, r1));\n213         uint256 p0 = getTokenPrice(token0);\n214         uint256 p1 = getTokenPrice(token1);\n215         uint256 sqrtP = sqrt(mul_(p0, p1));\n216         return div_(mul_(2, mul_(sqrtR, sqrtP)), totalSupply);\n217     }\n218 \n219     /**\n220      * @notice Get price for Yvault tokens\n221      * @param token The Yvault token\n222      * @return The price\n223      */\n224     function getYvTokenPrice(address token) internal view returns (uint256) {\n225         YvTokenInfo memory yvTokenInfo = yvTokens[token];\n226         require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n227 \n228         uint256 pricePerShare;\n229         address underlying;\n230         if (yvTokenInfo.version == YvTokenVersion.V1) {\n231             pricePerShare = YVaultV1Interface(token).getPricePerFullShare();\n232             underlying = YVaultV1Interface(token).token();\n233         } else {\n234             pricePerShare = YVaultV2Interface(token).pricePerShare();\n235             underlying = YVaultV2Interface(token).token();\n236         }\n237 \n238         uint256 underlyingPrice;\n239         if (crvTokens[underlying].isCrvToken) {\n240             underlyingPrice = getCrvTokenPrice(underlying);\n241         } else {\n242             underlyingPrice = getTokenPrice(underlying);\n243         }\n244         return mul_(underlyingPrice, Exp({mantissa: pricePerShare}));\n245     }\n246 \n247     /**\n248      * @notice Get price for curve pool tokens\n249      * @param token The curve pool token\n250      * @return The price\n251      */\n252     function getCrvTokenPrice(address token) internal view returns (uint256) {\n253         CrvTokenInfo memory crvTokenInfo = crvTokens[token];\n254         require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n255 \n256         uint256 virtualPrice = CurveSwapInterface(crvTokenInfo.curveSwap).get_virtual_price();\n257         if (crvTokenInfo.poolType == CurvePoolType.ETH) {\n258             return virtualPrice;\n259         }\n260 \n261         // We treat USDC as USD and convert the price to ETH base.\n262         return mul_(getUsdcEthPrice(), Exp({mantissa: virtualPrice}));\n263     }\n264 \n265     /**\n266      * @notice Get USDC price\n267      * @dev We treat USDC as USD for convenience\n268      * @return The USDC price\n269      */\n270     function getUsdcEthPrice() internal view returns (uint256) {\n271         return getTokenPrice(usdcAddress) / 1e12;\n272     }\n273 \n274     /**\n275      * @notice Get price from v1 price oracle\n276      * @param token The token to get the price of\n277      * @return The price\n278      */\n279     function getPriceFromV1(address token) internal view returns (uint256) {\n280         return v1PriceOracle.assetPrices(token);\n281     }\n282 \n283     /**\n284      * @notice Compare two strings are the same or not\n285      * @param a The first string\n286      * @param b The second string\n287      * @return The same or not\n288      */\n289     function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n290         return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n291     }\n292 \n293     /**\n294      * @notice Check if the token is one of BTC relared address\n295      * @param token The token address\n296      * @return It's BTC or not\n297      */\n298     function isBtcAddress(address token) internal returns (bool) {\n299         for (uint256 i = 0; i < btcAddresses.length; i++) {\n300             if (btcAddresses[i] == token) {\n301                 return true;\n302             }\n303         }\n304         return false;\n305     }\n306 \n307     /*** Admin or guardian functions ***/\n308 \n309     event AggregatorUpdated(address tokenAddress, address base, address quote, bool isUsed);\n310     event IsLPUpdated(address tokenAddress, bool isLP);\n311     event SetYVaultToken(address token, YvTokenVersion version);\n312     event SetCurveToken(address token, CurvePoolType poolType, address swap);\n313     event SetGuardian(address guardian);\n314     event SetAdmin(address admin);\n315 \n316     /**\n317      * @notice Set ChainLink aggregators for multiple tokens\n318      * @param tokenAddresses The list of underlying tokens\n319      * @param quotes The list of ChainLink aggregator quotes, currently support 'ETH' and 'USD'\n320      */\n321     function _setAggregators(address[] calldata tokenAddresses, string[] calldata quotes) external {\n322         require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323         require(tokenAddresses.length == quotes.length, \"mismatched data\");\n324         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n325             address base;\n326             address quote;\n327             bool isUsed;\n328             if (bytes(quotes[i]).length != 0) {\n329                 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n330                 isUsed = true;\n331 \n332                 base = tokenAddresses[i];\n333                 if (isBtcAddress(tokenAddresses[i])) {\n334                     base = Denominations.BTC;\n335                 }\n336 \n337                 if (compareStrings(quotes[i], \"ETH\")) {\n338                     quote = Denominations.ETH;\n339                 } else if (compareStrings(quotes[i], \"USD\")) {\n340                     quote = Denominations.USD;\n341                 } else {\n342                     revert(\"unsupported denomination\");\n343                 }\n344 \n345                 // Make sure the aggregator exists.\n346                 address aggregator = registry.getFeed(base, quote);\n347                 require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n348             }\n349             aggregators[tokenAddresses[i]] = AggregatorInfo({base: base, quote: quote, isUsed: isUsed});\n350             emit AggregatorUpdated(tokenAddresses[i], base, quote, isUsed);\n351         }\n352     }\n353 \n354     /**\n355      * @notice See assets as LP tokens for multiple tokens\n356      * @param tokenAddresses The list of tokens\n357      * @param isLP The list of cToken properties (it's LP or not)\n358      */\n359     function _setLPs(address[] calldata tokenAddresses, bool[] calldata isLP) external {\n360         require(msg.sender == admin, \"only the admin may set LPs\");\n361         require(tokenAddresses.length == isLP.length, \"mismatched data\");\n362         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n363             isUnderlyingLP[tokenAddresses[i]] = isLP[i];\n364             if (isLP[i]) {\n365                 // Sanity check to make sure the token is LP.\n366                 IUniswapV2Pair(tokenAddresses[i]).token0();\n367                 IUniswapV2Pair(tokenAddresses[i]).token1();\n368             }\n369             emit IsLPUpdated(tokenAddresses[i], isLP[i]);\n370         }\n371     }\n372 \n373     /**\n374      * @notice See assets as Yvault tokens for multiple tokens\n375      * @param tokenAddresses The list of tokens\n376      * @param version The list of vault version\n377      */\n378     function _setYVaultTokens(address[] calldata tokenAddresses, YvTokenVersion[] calldata version) external {\n379         require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n380         require(tokenAddresses.length == version.length, \"mismatched data\");\n381         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n382             // Sanity check to make sure version is right.\n383             if (version[i] == YvTokenVersion.V1) {\n384                 YVaultV1Interface(tokenAddresses[i]).getPricePerFullShare();\n385             } else {\n386                 YVaultV2Interface(tokenAddresses[i]).pricePerShare();\n387             }\n388 \n389             yvTokens[tokenAddresses[i]] = YvTokenInfo({isYvToken: true, version: version[i]});\n390             emit SetYVaultToken(tokenAddresses[i], version[i]);\n391         }\n392     }\n393 \n394     /**\n395      * @notice See assets as curve pool tokens for multiple tokens\n396      * @param tokenAddresses The list of tokens\n397      * @param poolType The list of curve pool type (ETH or USD base only)\n398      * @param swap The list of curve swap address\n399      */\n400     function _setCurveTokens(\n401         address[] calldata tokenAddresses,\n402         CurveTokenVersion[] calldata version,\n403         CurvePoolType[] calldata poolType,\n404         address[] calldata swap\n405     ) external {\n406         require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n407         require(\n408             tokenAddresses.length == version.length &&\n409                 tokenAddresses.length == poolType.length &&\n410                 tokenAddresses.length == swap.length,\n411             \"mismatched data\"\n412         );\n413         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n414             if (version[i] == CurveTokenVersion.V3) {\n415                 // Sanity check to make sure the token minter is right.\n416                 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");\n417             }\n418 \n419             crvTokens[tokenAddresses[i]] = CrvTokenInfo({isCrvToken: true, poolType: poolType[i], curveSwap: swap[i]});\n420             emit SetCurveToken(tokenAddresses[i], poolType[i], swap[i]);\n421         }\n422     }\n423 \n424     /**\n425      * @notice Set guardian for price oracle proxy\n426      * @param _guardian The new guardian\n427      */\n428     function _setGuardian(address _guardian) external {\n429         require(msg.sender == admin, \"only the admin may set new guardian\");\n430         guardian = _guardian;\n431         emit SetGuardian(guardian);\n432     }\n433 \n434     /**\n435      * @notice Set admin for price oracle proxy\n436      * @param _admin The new admin\n437      */\n438     function _setAdmin(address _admin) external {\n439         require(msg.sender == admin, \"only the admin may set new admin\");\n440         admin = _admin;\n441         emit SetAdmin(admin);\n442     }\n443 }\n429\n",
    "transaction-context": " require(msg.sender == admin, \"only the admin may set new guardian\");",
    "Critical-points": "require(msg.sender == admin, \"only the admin may set new admin\");",
    "invariants": "modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }",
    "critical-invariants": "nonReentrant ",
    "ranks": "assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);",
    "vulnerabilities": "assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }\n10 \n11 // a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n12 \n13 library SafeMathSushiswap {\n14     function add(uint x, uint y) internal pure returns (uint z) {\n15         require((z = x + y) >= x, 'ds-math-add-overflow');\n16     }\n17 \n18     function sub(uint x, uint y) internal pure returns (uint z) {\n19         require((z = x - y) <= x, 'ds-math-sub-underflow');\n20     }\n21 \n22     function mul(uint x, uint y) internal pure returns (uint z) {\n23         require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n24     }\n25 }\n26 \n27 library SushiswapV2Library {\n28     using SafeMathSushiswap for uint;\n29 \n30     // returns sorted token addresses, used to handle return values from pairs sorted in this order\n31     function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n32         require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n33         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n34         require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n35     }\n36 \n37     // calculates the CREATE2 address for a pair without making any external calls\n38     function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n39         (address token0, address token1) = sortTokens(tokenA, tokenB);\n40         pair = address(uint160(uint256(keccak256(abi.encodePacked(\n41                 hex'ff',\n42                 factory,\n43                 keccak256(abi.encodePacked(token0, token1)),\n44                 hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n45             )))));\n46     }\n47 \n48     // fetches and sorts the reserves for a pair\n49     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n50         (address token0,) = sortTokens(tokenA, tokenB);\n51         (uint reserve0, uint reserve1,) = ISushiswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n52         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n53     }\n54 \n55     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n56     function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n57         require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58         require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n59         amountB = amountA.mul(reserveB) / reserveA;\n60     }\n61 \n62     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n63     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n64         require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n66         uint amountInWithFee = amountIn.mul(997);\n67         uint numerator = amountInWithFee.mul(reserveOut);\n68         uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n69         amountOut = numerator / denominator;\n70     }\n71 \n72     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n73     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n74         require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n76         uint numerator = reserveIn.mul(amountOut).mul(1000);\n77         uint denominator = reserveOut.sub(amountOut).mul(997);\n78         amountIn = (numerator / denominator).add(1);\n79     }\n80 \n81     // performs chained getAmountOut calculations on any number of pairs\n82     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n83         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n84         amounts = new uint[](path.length);\n85         amounts[0] = amountIn;\n86         for (uint i; i < path.length - 1; i++) {\n87             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n88             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n89         }\n90     }\n91 \n92     // performs chained getAmountIn calculations on any number of pairs\n93     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n94         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n95         amounts = new uint[](path.length);\n96         amounts[amounts.length - 1] = amountOut;\n97         for (uint i = path.length - 1; i > 0; i--) {\n98             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n99             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n100         }\n101     }\n102 }\n103 \n104 // helper methods for interacting with ERC20 tokens and sending NATIVE that do not consistently return true/false\n105 library TransferHelper {\n106     function safeApprove(address token, address to, uint value) internal {\n107         // bytes4(keccak256(bytes('approve(address,uint256)')));\n108         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n109         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n110     }\n111 \n112     function safeTransfer(address token, address to, uint value) internal {\n113         // bytes4(keccak256(bytes('transfer(address,uint256)')));\n114         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n115         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n116     }\n117 \n118     function safeTransferFrom(address token, address from, address to, uint value) internal {\n119         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n120         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n121         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n122     }\n123 \n124     function safeTransferNative(address to, uint value) internal {\n125         (bool success,) = to.call{value:value}(new bytes(0));\n126         require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n127     }\n128 }\n129 \n130 interface IwNATIVE {\n131     function deposit() external payable;\n132     function transfer(address to, uint value) external returns (bool);\n133     function withdraw(uint) external;\n134 }\n135 \n136 interface AnyswapV1ERC20 {\n137     function mint(address to, uint256 amount) external returns (bool);\n138     function burn(address from, uint256 amount) external returns (bool);\n139     function changeVault(address newVault) external returns (bool);\n140     function depositVault(uint amount, address to) external returns (uint);\n141     function withdrawVault(address from, uint amount, address to) external returns (uint);\n142     function underlying() external view returns (address);\n143 }\n144 \n145 /**\n146  * @dev Interface of the ERC20 standard as defined in the EIP.\n147  */\n148 interface IERC20 {\n149     function totalSupply() external view returns (uint256);\n150     function balanceOf(address account) external view returns (uint256);\n151     function transfer(address recipient, uint256 amount) external returns (bool);\n152     function allowance(address owner, address spender) external view returns (uint256);\n153     function approve(address spender, uint256 amount) external returns (bool);\n154     function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n155     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n156     function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n157 \n158     event Transfer(address indexed from, address indexed to, uint256 value);\n159     event Approval(address indexed owner, address indexed spender, uint256 value);\n160 }\n161 \n162 contract AnyswapV4Router {\n163     using SafeMathSushiswap for uint;\n164 \n165     address public immutable factory;\n166     address public immutable wNATIVE;\n167 \n168     modifier ensure(uint deadline) {\n169         require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n170         _;\n171     }\n172 \n173     constructor(address _factory, address _wNATIVE, address _mpc) {\n174         _newMPC = _mpc;\n175         _newMPCEffectiveTime = block.timestamp;\n176         factory = _factory;\n177         wNATIVE = _wNATIVE;\n178     }\n179 \n180     receive() external payable {\n181         assert(msg.sender == wNATIVE); // only accept Native via fallback from the wNative contract\n182     }\n183 \n184     address private _oldMPC;\n185     address private _newMPC;\n186     uint256 private _newMPCEffectiveTime;\n187 \n188 \n189     event LogChangeMPC(address indexed oldMPC, address indexed newMPC, uint indexed effectiveTime, uint chainID);\n190     event LogChangeRouter(address indexed oldRouter, address indexed newRouter, uint chainID);\n191     event LogAnySwapIn(bytes32 indexed txhash, address indexed token, address indexed to, uint amount, uint fromChainID, uint toChainID);\n192     event LogAnySwapOut(address indexed token, address indexed from, address indexed to, uint amount, uint fromChainID, uint toChainID);\n193     event LogAnySwapTradeTokensForTokens(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n194     event LogAnySwapTradeTokensForNative(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n195 \n196     modifier onlyMPC() {\n197         require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n198         _;\n199     }\n200 \n201     function mpc() public view returns (address) {\n202         if (block.timestamp >= _newMPCEffectiveTime) {\n203             return _newMPC;\n204         }\n205         return _oldMPC;\n206     }\n207 \n208     function cID() public view returns (uint id) {\n209         assembly {id := chainid()}\n210     }\n211 \n212     function changeMPC(address newMPC) public onlyMPC returns (bool) {\n213         require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n214         _oldMPC = mpc();\n215         _newMPC = newMPC;\n216         _newMPCEffectiveTime = block.timestamp + 2*24*3600;\n217         emit LogChangeMPC(_oldMPC, _newMPC, _newMPCEffectiveTime, cID());\n218         return true;\n219     }\n220 \n221     function changeVault(address token, address newVault) public onlyMPC returns (bool) {\n222         require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n223         return AnyswapV1ERC20(token).changeVault(newVault);\n224     }\n225 \n226     function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n227         AnyswapV1ERC20(token).burn(from, amount);\n228         emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n229     }\n230 \n231     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\n232     function anySwapOut(address token, address to, uint amount, uint toChainID) external {\n233         _anySwapOut(msg.sender, token, to, amount, toChainID);\n234     }\n235 \n236     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to` by minting with `underlying`\n237     function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external {\n238         TransferHelper.safeTransferFrom(AnyswapV1ERC20(token).underlying(), msg.sender, token, amount);\n239         AnyswapV1ERC20(token).depositVault(amount, msg.sender);\n240         _anySwapOut(msg.sender, token, to, amount, toChainID);\n241     }\n242 \n243     function anySwapOutUnderlyingWithPermit(\n244         address from,\n245         address token,\n246         address to,\n247         uint amount,\n248         uint deadline,\n249         uint8 v,\n250         bytes32 r,\n251         bytes32 s,\n252         uint toChainID\n253     ) external {\n254         address _underlying = AnyswapV1ERC20(token).underlying();\n255         IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n256         TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n257         AnyswapV1ERC20(token).depositVault(amount, from);\n258         _anySwapOut(from, token, to, amount, toChainID);\n259     }\n260 \n261     function anySwapOutUnderlyingWithTransferPermit(\n262         address from,\n263         address token,\n264         address to,\n265         uint amount,\n266         uint deadline,\n267         uint8 v,\n268         bytes32 r,\n269         bytes32 s,\n270         uint toChainID\n271     ) external {\n272         IERC20(AnyswapV1ERC20(token).underlying()).transferWithPermit(from, token, amount, deadline, v, r, s);\n273         AnyswapV1ERC20(token).depositVault(amount, from);\n274         _anySwapOut(from, token, to, amount, toChainID);\n275     }\n276 \n277     function anySwapOut(address[] calldata tokens, address[] calldata to, uint[] calldata amounts, uint[] calldata toChainIDs) external {\n278         for (uint i = 0; i < tokens.length; i++) {\n279             _anySwapOut(msg.sender, tokens[i], to[i], amounts[i], toChainIDs[i]);\n280         }\n281     }\n282 \n283     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n284     function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n285         AnyswapV1ERC20(token).mint(to, amount);\n286         emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n287     }\n288 \n289     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n290     // triggered by `anySwapOut`\n291     function anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n292         _anySwapIn(txs, token, to, amount, fromChainID);\n293     }\n294 \n295     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying`\n296     function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n297         _anySwapIn(txs, token, to, amount, fromChainID);\n298         AnyswapV1ERC20(token).withdrawVault(to, amount, to);\n299     }\n300 \n301     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying` if possible\n302     function anySwapInAuto(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n303         _anySwapIn(txs, token, to, amount, fromChainID);\n304         AnyswapV1ERC20 _anyToken = AnyswapV1ERC20(token);\n305         address _underlying = _anyToken.underlying();\n306         if (_underlying != address(0) && IERC20(_underlying).balanceOf(token) >= amount) {\n307             _anyToken.withdrawVault(to, amount, to);\n308         }\n309     }\n310 \n311     // extracts mpc fee from bridge fees\n312     function anySwapFeeTo(address token, uint amount) external onlyMPC {\n313         address _mpc = mpc();\n314         AnyswapV1ERC20(token).mint(_mpc, amount);\n315         AnyswapV1ERC20(token).withdrawVault(_mpc, amount, _mpc);\n316     }\n317 \n318     function anySwapIn(bytes32[] calldata txs, address[] calldata tokens, address[] calldata to, uint256[] calldata amounts, uint[] calldata fromChainIDs) external onlyMPC {\n319         for (uint i = 0; i < tokens.length; i++) {\n320             _anySwapIn(txs[i], tokens[i], to[i], amounts[i], fromChainIDs[i]);\n321         }\n322     }\n323 \n324     // **** SWAP ****\n325     // requires the initial amount to have already been sent to the first pair\n326     function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n327         for (uint i; i < path.length - 1; i++) {\n328             (address input, address output) = (path[i], path[i + 1]);\n329             (address token0,) = SushiswapV2Library.sortTokens(input, output);\n330             uint amountOut = amounts[i + 1];\n331             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n332             address to = i < path.length - 2 ? SushiswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n333             ISushiswapV2Pair(SushiswapV2Library.pairFor(factory, input, output)).swap(\n334                 amount0Out, amount1Out, to, new bytes(0)\n335             );\n336         }\n337     }\n338 \n339     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n340     function anySwapOutExactTokensForTokens(\n341         uint amountIn,\n342         uint amountOutMin,\n343         address[] calldata path,\n344         address to,\n345         uint deadline,\n346         uint toChainID\n347     ) external virtual ensure(deadline) {\n348         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n349         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n350     }\n351 \n352     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n353     function anySwapOutExactTokensForTokensUnderlying(\n354         uint amountIn,\n355         uint amountOutMin,\n356         address[] calldata path,\n357         address to,\n358         uint deadline,\n359         uint toChainID\n360     ) external virtual ensure(deadline) {\n361         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n362         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n363         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n364         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n365     }\n366 \n367     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n368     function anySwapOutExactTokensForTokensUnderlyingWithPermit(\n369         address from,\n370         uint amountIn,\n371         uint amountOutMin,\n372         address[] calldata path,\n373         address to,\n374         uint deadline,\n375         uint8 v,\n376         bytes32 r,\n377         bytes32 s,\n378         uint toChainID\n379     ) external virtual ensure(deadline) {\n380         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n381         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n382         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n383         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n384         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n385         {\n386         address[] memory _path = path;\n387         address _from = from;\n388         address _to = to;\n389         uint _amountIn = amountIn;\n390         uint _amountOutMin = amountOutMin;\n391         uint _cID = cID();\n392         uint _toChainID = toChainID;\n393         emit LogAnySwapTradeTokensForTokens(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n394         }\n395     }\n396 \n397     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n398     function anySwapOutExactTokensForTokensUnderlyingWithTransferPermit(\n399         address from,\n400         uint amountIn,\n401         uint amountOutMin,\n402         address[] calldata path,\n403         address to,\n404         uint deadline,\n405         uint8 v,\n406         bytes32 r,\n407         bytes32 s,\n408         uint toChainID\n409     ) external virtual ensure(deadline) {\n410         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n411         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n412         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n413         emit LogAnySwapTradeTokensForTokens(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n414     }\n415 \n416     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n417     // Triggered by `anySwapOutExactTokensForTokens`\n418     function anySwapInExactTokensForTokens(\n419         bytes32 txs,\n420         uint amountIn,\n421         uint amountOutMin,\n422         address[] calldata path,\n423         address to,\n424         uint deadline,\n425         uint fromChainID\n426     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n427         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n428         require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n429         _anySwapIn(txs, path[0], SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n430         _swap(amounts, path, to);\n431     }\n432 \n433     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n434     function anySwapOutExactTokensForNative(\n435         uint amountIn,\n436         uint amountOutMin,\n437         address[] calldata path,\n438         address to,\n439         uint deadline,\n440         uint toChainID\n441     ) external virtual ensure(deadline) {\n442         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n443         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n444     }\n445 \n446     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n447     function anySwapOutExactTokensForNativeUnderlying(\n448         uint amountIn,\n449         uint amountOutMin,\n450         address[] calldata path,\n451         address to,\n452         uint deadline,\n453         uint toChainID\n454     ) external virtual ensure(deadline) {\n455         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n456         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n457         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n458         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n459     }\n460 \n461     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n462     function anySwapOutExactTokensForNativeUnderlyingWithPermit(\n463         address from,\n464         uint amountIn,\n465         uint amountOutMin,\n466         address[] calldata path,\n467         address to,\n468         uint deadline,\n469         uint8 v,\n470         bytes32 r,\n471         bytes32 s,\n472         uint toChainID\n473     ) external virtual ensure(deadline) {\n474         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n475         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n476         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n477         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n478         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n479         {\n480         address[] memory _path = path;\n481         address _from = from;\n482         address _to = to;\n483         uint _amountIn = amountIn;\n484         uint _amountOutMin = amountOutMin;\n485         uint _cID = cID();\n486         uint _toChainID = toChainID;\n487         emit LogAnySwapTradeTokensForNative(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n488         }\n489     }\n490 \n491     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n492     function anySwapOutExactTokensForNativeUnderlyingWithTransferPermit(\n493         address from,\n494         uint amountIn,\n495         uint amountOutMin,\n496         address[] calldata path,\n497         address to,\n498         uint deadline,\n499         uint8 v,\n500         bytes32 r,\n501         bytes32 s,\n502         uint toChainID\n503     ) external virtual ensure(deadline) {\n504         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n505         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n506         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n507         emit LogAnySwapTradeTokensForNative(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n508     }\n509 \n510     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n511     // Triggered by `anySwapOutExactTokensForNative`\n512     function anySwapInExactTokensForNative(\n513         bytes32 txs,\n514         uint amountIn,\n515         uint amountOutMin,\n516         address[] calldata path,\n517         address to,\n518         uint deadline,\n519         uint fromChainID\n520     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n521         require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n522         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n523         require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');\n524         _anySwapIn(txs, path[0],  SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n525         _swap(amounts, path, address(this));\n526         IwNATIVE(wNATIVE).withdraw(amounts[amounts.length - 1]);\n527         TransferHelper.safeTransferNative(to, amounts[amounts.length - 1]);\n528     }\n529 \n530     // **** LIBRARY FUNCTIONS ****\n531     function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {\n532         return SushiswapV2Library.quote(amountA, reserveA, reserveB);\n533     }\n534 \n535     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n536         public\n537         pure\n538         virtual\n539         returns (uint amountOut)\n540     {\n541         return SushiswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n542     }\n543 \n544     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n545         public\n546         pure\n547         virtual\n548         returns (uint amountIn)\n549     {\n550         return SushiswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n551     }\n552 \n553     function getAmountsOut(uint amountIn, address[] memory path)\n554         public\n555         view\n556         virtual\n557         returns (uint[] memory amounts)\n558     {\n559         return SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n560     }\n561 \n562     function getAmountsIn(uint amountOut, address[] memory path)\n563         public\n564         view\n565         virtual\n566         returns (uint[] memory amounts)\n567     {\n568         return SushiswapV2Library.getAmountsIn(factory, amountOut, path);\n569     }\n570 }\n58+ \n",
    "transaction-context": "require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');",
    "Critical-points": "require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');",
    "invariants": "require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');",
    "critical-invariants": " require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');",
    "ranks": " require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');",
    "vulnerabilities": "require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');"
  },
  {
    "code": "1 contract DODO {\n2     function init(\n3         address maintainer,\n4         address baseTokenAddress,\n5         address quoteTokenAddress,\n6         uint256 lpFeeRate,\n7         uint256 mtFeeRate,\n8         uint256 k,\n9         uint256 i,\n10         bool isOpenTWAP\n11     ) external {\n12         require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n13         _BASE_TOKEN_ = IERC20(baseTokenAddress);\n14         _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n15         \n16         require(i > 0 && i <= 10**36); \n17         _I_ = i; \n18        \n19         require(k <= 10**18); \n20         _K_ = k; \n21        \n22         _LP_FEE_RATE_ = lpFeeRate; \n23         _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRate); \n24         _MAINTAINER_ = maintainer; \n25         \n26         _IS_OPEN_TWAP_ = isOpenTWAP; \n27         if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32); \n28         \n29         string memory connect = \"_\"; \n30         string memory suffix = \"DLP\"; \n31 \n32         name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this)))); \n33         symbol = \"DLP\"; \n34         decimals = _BASE_TOKEN_.decimals(); \n35         \n36         uint256 chainId; \n37         assembly{\n38             chainId := chainid()\n39         }\n40         abi.encode(\n41         0x8b73x3x69bb8fe3e512ecc4cf759cc79239fb179b0ffacaa9a75d522b39400f, \n42         keccak256(name)), \n43         keccak256(\"I\")),\n44         chainId, \n45         address(this)\n46         )\n47  }; \n48 }\n1+\n",
    "transaction-context": "modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n",
    "Critical-points": "nonReentrant",
    "invariants": "require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");",
    "critical-invariants": "require(i > 0 && i <= 10**36);      ",
    "ranks": "require(k <= 10**18); ",
    "vulnerabilities": "require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n9 import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n10 import \"./interfaces/IPancakePair.sol\";\n11 import \"./interfaces/IPancakeFactory.sol\";\n12 import \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\n13 import \"./interfaces/IGymLevelPool.sol\";\n14 import \"./interfaces/IGymSinglePool.sol\";\n15 /* preserved Line */\n16 /* preserved Line */\n17 /* preserved Line */\n18 /* preserved Line */\n19 /* preserved Line */\n\n20 /**\n21  * @notice GymSinglePool contract:\n22  * - Users can:\n23  *   # Deposit GYMNET\n24  *   # Withdraw assets\n25  */\n\n26 contract GymSinglePool is ReentrancyGuardUpgradeable, OwnableUpgradeable {\n27     using SafeERC20Upgradeable for IERC20Upgradeable;\n\n28    /**\n29      * @notice Info of each user\n30      * One Address can have many Deposits with different periods. Unlimited Amount.\n31      * Total Depsit Tokens = Total amount of user active stake in all.\n32      * Total Depsit Dollar Value = Total Dollar Value over all staking single pools. Calculated when user deposits tokens, and dollar value is for that exact moment rate.\n33      * level = level qualification for this pool. Used internally, for global qualification please check MLM Contract.\n34      * depositId = incremental ID of deposits, eg. if user has 3 stakings then this value will be 2;\n35      * totalClaimt = Total amount of tokens user claimt. \n36      */\n37     struct UserInfo {\n38         uint256 totalDepositTokens;\n39         uint256 totalDepositDollarValue;\n40         uint256 level;\n41         uint256 depositId;\n42         uint256 totalClaimt;\n43     }\n\n44    /** \n45      * @notice Info for each staking by ID\n46      * One Address can have many Deposits with different periods. Unlimited Amount.\n47      * depositTokens = amount of tokens for exact deposit.\n48      * depositDollarValue = Dollar value of deposit.\n49      * stakePeriod = Locking Period - from 3 months to 30 months. value is integer\n50      * depositTimestamp = timestamp of deposit\n51      * withdrawalTimestamp = Timestamp when user can withdraw his locked tokens\n52      * rewardsGained = amount of rewards user has gained during the process\n53      * is_finished = checks if user has already withdrawn tokens\n54      */\n55     struct UserDeposits {\n56         uint256 depositTokens;\n57         uint256 depositDollarValue;\n58         uint256 stakePeriod;\n59         uint256 depositTimestamp;\n60         uint256 withdrawalTimestamp;\n61         uint256 rewardsGained;\n62         uint256 rewardsClaimt;\n63         uint256 rewardDebt;\n64         bool is_finished;\n65     }\n66     /**\n67      * @notice Info of Pool\n68      * @param lastRewardBlock: Last block number that reward distribution occurs\n69      * @param accUTacoPerShare: Accumulated rewardPool per share, times 1e18\n70      * @param rewardPerBlock: How many reward tokens will user get per block\n71      */\n72     struct PoolInfo {\n73         uint256 lastRewardBlock;\n74         uint256 accRewardPerShare;\n75         uint256 rewardPerBlock;\n76     }\n\n77     /// Startblock number\n78     uint256 public startBlock;\n79     uint256 public withdrawFee;\n\n80      // MLM Contract - RelationShip address\n81     address public relationship;\n82     /// Treasury address where will be sent all unused assets\n83     address public treasuryAddress;\n84     /// Info of pool.\n85     PoolInfo public poolInfo;\n86     /// Info of each user that staked tokens.\n87     mapping(address => UserInfo) public userInfo;\n\n88     /// accepts user address and id of element to select - returns information about selected staking by id\n89     mapping (address=>UserDeposits[]) public user_deposits;\n\n90     uint256 private lastChangeBlock;\n\n91     /// GYMNET token contract address\n92     address public tokenAddress;\n\n93     /// address of pancake Router\n94     address public pancakeRouterAddress;\n95     /// WBNB and BUSD Token Pair address, element 0 = Address of WBNB Token, element 1= Address of GYMNET \n96     address[] public wbnbAndUSDTTokenArray;\n97     /// GYMNET and WBNB Token Pair address, element 0 = Address of GYMNET, element 1 = Address of WBNB Token, \n98     address[] public GymWBNBPair;\n\n99     /// Level Qualifications for the pool\n100     uint256[16] public levels;\n101     /// Locking Periods \n102     uint256[6] public months;\n\n103     /// Amount of Total GYMNET Locked in the pool\n104     uint256 public totalGymnetLocked;\n\n105     /// Amount of GYMNET all users has claimt over time.\n106     uint256 public totalClaimtInPool;\n\n107     /// Percent that will be sent to MLM Contract for comission distribution\n108     uint256 public RELATIONSHIP_REWARD;\n\n109     /// 6% comissions\n110     uint256 public poolRewardsAmount;\n\n111     address public holderRewardContractAddress;\n\n112     address public runnerScriptAddress;\n113     uint256 public totalBurntInSinglePool;\n114     bool public isPoolActive;\n115     bool public isInMigrationToVTwo;\n116     uint256 public totalGymnetUnlocked;\n117     uint256 public unlockedTimestampQualification;\n118     address public vaultContractAddress;\n119     address public farmingContractAddress;\n\n120     address public levelPoolContractAddress;\n121     address public newSinglePoolAddress;\n\n122     /* ========== EVENTS ========== */\n\n123     event Initialized(address indexed executor, uint256 at);\n124     event Deposit(address indexed user, uint256 amount,uint indexed period);\n125     event Withdraw(address indexed user, uint256 amount,uint indexed period);\n126     event RewardPaid(address indexed token, address indexed user, uint256 amount);\n127     event ClaimUserReward(address indexed user, uint256 amount);\n\n\n128     modifier onlyRunnerScript() {\n129         require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n130         _;\n131     }\n132     modifier onlyBank() {\n133         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n134         _;\n135     }\n136     receive() external payable {}\n\n137     fallback() external payable {}\n\n138 // all initialize parameters are mandatory\n139     function initialize(\n140         uint256 _startBlock,\n141         address _gym,\n142         address _mlm,\n143         uint256 _gymRewardRate,\n144         address _pancakeRouterAddress,\n145         address[] memory _wbnbAndUSDTTokenArray,\n146         address[] memory _GymWBNBPair\n147     ) external initializer {\n148         require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n\n149         startBlock = _startBlock; // Number of Upcoming Block\n150         relationship = _mlm;  // address of MLM contract\n151         tokenAddress = _gym; // address of GYMNET Contract\n152         pancakeRouterAddress = _pancakeRouterAddress; // Address of Pancake Router\n153         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray; // WBNB And USDT Token Addresses [WBNB,USDT]\n154         GymWBNBPair = _GymWBNBPair; // GYMNET And WBNB Token Addresses [GYMNET,WBNB]\n155         runnerScriptAddress = msg.sender;\n156         isPoolActive = false;\n157         isInMigrationToVTwo = false;\n158         RELATIONSHIP_REWARD = 39; // Relationship commission amount\n159         levels = [0, 0, 200, 200, 2000, 4000, 10000, 20000, 40000, 45000, 50000, 60000, 65000, 70000, 75000, 80000]; // Internal Pool Levels\n160         months = [3, 6, 12, 18, 24, 30]; // Locking Periods\n\n161         poolInfo = PoolInfo({\n162                 lastRewardBlock: _startBlock,\n163                 rewardPerBlock: _gymRewardRate,\n164                 accRewardPerShare: 0\n165             });\n\n166         lastChangeBlock = _startBlock;\n\n167         __Ownable_init();\n168         __ReentrancyGuard_init();\n        \n169         emit Initialized(msg.sender, block.number);\n170     }\n\n\n171     function setPoolInfo(uint256 lastRewardBlock,uint256 accRewardPerShare, uint256 rewardPerBlock) external onlyOwner {\n172         poolInfo = PoolInfo({\n173                 lastRewardBlock: lastRewardBlock,\n174                 accRewardPerShare: accRewardPerShare,\n175                 rewardPerBlock: rewardPerBlock\n176             });\n177     }\n\n178     function updateStartBlock(uint256 _startBlock) external onlyOwner {\n179         startBlock = _startBlock;\n180     }\n\n181     function setMLMAddress(address _relationship) external onlyOwner {\n182         relationship = _relationship;\n183     }\n\n184     function setTokenAddress(address _tokenAddress) external onlyOwner {\n185         tokenAddress = _tokenAddress;\n186     }\n187     function setVaultContractAddress(address _vaultContractAddress) external onlyOwner {\n188         vaultContractAddress = _vaultContractAddress;\n189     }\n190     function setFarmingContractAddress(address _farmingContractAddress) external onlyOwner {\n191         farmingContractAddress = _farmingContractAddress;\n192     }\n\n193     function setLevelPoolContractAddress(address _levelPoolContractAddress) external onlyOwner {\n194         levelPoolContractAddress = _levelPoolContractAddress;\n195     }\n\n196     function setRelationshipReward(uint256 _amount) external onlyOwner {\n197         RELATIONSHIP_REWARD = _amount;\n198     }\n199     function setOnlyRunnerScript(address _onlyRunnerScript) external onlyOwner {\n200         runnerScriptAddress = _onlyRunnerScript;\n201     }\n202     function setNewSinglePoolAddress(address _newSinglePoolAddress) external onlyOwner {\n203         newSinglePoolAddress = _newSinglePoolAddress;\n204     }\n\n205     function setGymWBNBPair(address[] memory  _GymWBNBPair) external onlyOwner {\n206         GymWBNBPair = _GymWBNBPair;\n207     }\n208     function setPancakeRouterAddress(address _pancakeRouterAddress) external onlyOwner {\n209         pancakeRouterAddress = _pancakeRouterAddress;\n210     }\n\n211     function setIsPoolActive(bool _isPoolActive) external onlyOwner {\n212         isPoolActive = _isPoolActive;\n213     }\n214     function setIsInMigrationToVTwo(bool _isInMigrationToVTwo) external onlyOwner {\n215         isInMigrationToVTwo = _isInMigrationToVTwo;\n216     }\n\n217     function setHolderRewardContractAddress(address _holderRewardContractAddress) external onlyOwner {\n218         holderRewardContractAddress = _holderRewardContractAddress;\n219     }\n\n\n220     function setWbnbAndUSDTTokenArray(address[] memory _wbnbAndUSDTTokenArray) external onlyOwner {\n221         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray;\n222     }\n223     function setUnlockedTimestampQualification(uint256 _unlockedTimestampQualification) external onlyOwner {\n224         unlockedTimestampQualification = _unlockedTimestampQualification;\n225     }\n226     function setLevels(uint256[16] calldata _levels) external onlyOwner {\n227         levels = _levels;\n228     }\n\n229      /**\n230      * @notice  Function to set Treasury address\n231      * @param _treasuryAddress Address of treasury address\n232      */\n233     function setTreasuryAddress(address _treasuryAddress) external nonReentrant onlyOwner {\n234         treasuryAddress = _treasuryAddress;\n235     }\n\n236     /**\n237      * @notice Deposit in given pool\n238      * @param _depositAmount: Amount of want token that user wants to deposit\n239      */\n240     function deposit(\n241         uint256 _depositAmount,\n242         uint8 _periodId,\n243         uint256 _referrerId,\n244         bool isUnlocked\n245     ) external  {\n246         require(isPoolActive,'Contract is not running yet');\n247         IGymMLM(relationship).addGymMLM(msg.sender, _referrerId);\n248         _deposit(_depositAmount,_periodId,isUnlocked);\n249     }\n250     /**\n251      * @notice Deposit in given pool\n252      * @param _depositAmount: Amount of want token that user wants to deposit\n253      */\n254     function depositFromOtherContract(\n255         uint256 _depositAmount,\n256         uint8 _periodId,\n257         bool isUnlocked,\n258         address _from\n259     ) external onlyBank {\n260         require(isPoolActive,'Contract is not running yet');\n261         _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n\n262         _updateLevelPoolQualification(_from);\n263     }\n\n264     /**\n265      * @notice To get User level in other contract for single pool.\n266      * @param _user: User address\n267      */\n268     function getUserLevelInSinglePool(address _user) external view returns (uint32) {\n269         uint256 _totalDepositDollarValue = userInfo[_user].totalDepositDollarValue;\n270         uint32 level = 0;\n271         for (uint32 i = 0; i<levels.length ; i++) {\n272             if(_totalDepositDollarValue >= levels[i]) {\n273                 level=i;\n274             }\n275         }\n276         return level;\n277     }\n\n278     /**\n279     Should approve allowance before initiating\n280     accepts depositAmount in WEI\n281     periodID - id of months array accordingly\n282     */\n283     function _deposit(\n284         uint256 _depositAmount,\n285         uint8 _periodId,\n286         bool _isUnlocked\n287     ) private {\n288         UserInfo storage user = userInfo[msg.sender];\n289         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n290         PoolInfo storage pool = poolInfo;\n291         updatePool();\n\n292         uint256 period = months[_periodId];\n293         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n294         uint256 burnTokensAmount = 0;\n\n295         if(!_isUnlocked) {\n296             burnTokensAmount = (_depositAmount * 4) / 100;\n297             totalBurntInSinglePool += burnTokensAmount;\n298             IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n299         }\n\n        \n300         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n\n301         token.safeTransferFrom(msg.sender, address(this), amountToDeposit);\n302         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n303         user.totalDepositTokens += amountToDeposit;\n304         user.totalDepositDollarValue += UsdValueOfGym;\n305         totalGymnetLocked += amountToDeposit;\n306         if(_isUnlocked) {\n307             totalGymnetUnlocked += amountToDeposit;\n308             period = 0; \n309             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n310         }\n\n311         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n312         UserDeposits memory depositDetails = UserDeposits(\n313             {\n314                 depositTokens: amountToDeposit, \n315                 depositDollarValue: UsdValueOfGym,\n316                 stakePeriod: period,\n317                 depositTimestamp: block.timestamp,\n318                 withdrawalTimestamp: lockTimesamp,\n319                 rewardsGained: 0,\n320                 is_finished: false,\n321                 rewardsClaimt: 0,\n322                 rewardDebt: rewardDebt\n323             }\n324         );\n\n325         user_deposits[msg.sender].push(depositDetails);\n326         user.depositId = user_deposits[msg.sender].length;\n        \n\n327        for (uint i = 0; i<levels.length ; i++) {\n328             if(user.totalDepositDollarValue >= levels[i]) {\n329                 user.level=i;\n330             }\n331         }\n332         _updateLevelPoolQualification(msg.sender);\n333         emit Deposit(msg.sender, _depositAmount,_periodId);\n334     }\n\n335      /**\n336     Should approve allowance before initiating\n337     accepts depositAmount in WEI\n338     periodID - id of months array accordingly\n339     */\n340     function _autoDeposit(\n341         uint256 _depositAmount,\n342         uint8 _periodId,\n343         bool _isUnlocked,\n344         address _from\n345     ) private {\n346         UserInfo storage user = userInfo[_from];\n347         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n348         PoolInfo storage pool = poolInfo;\n349         token.approve(address(this), _depositAmount);\n350         updatePool();\n351         uint256 period = months[_periodId];\n352         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n353         uint256 burnTokensAmount = 0;\n354         // if(!_isUnlocked) {\n355         //     uint256 burnTokensAmount = (_depositAmount * 4) / 100;\n356         //     totalBurntInSinglePool += burnTokensAmount;\n357         //     IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n358         // }\n359         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n360         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n361         user.totalDepositTokens += amountToDeposit;\n362         user.totalDepositDollarValue += UsdValueOfGym;\n363         totalGymnetLocked += amountToDeposit;\n364         if(_isUnlocked) {\n365             totalGymnetUnlocked += amountToDeposit;\n366             period = 0; \n367             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n368         }\n\n369         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n370         UserDeposits memory depositDetails = UserDeposits(\n371             {\n372                 depositTokens: amountToDeposit, \n373                 depositDollarValue: UsdValueOfGym,\n374                 stakePeriod: period,\n375                 depositTimestamp: block.timestamp,\n376                 withdrawalTimestamp: lockTimesamp,\n377                 rewardsGained: 0,\n378                 is_finished: false,\n379                 rewardsClaimt: 0,\n380                 rewardDebt: rewardDebt\n381             }\n382         );\n383         user_deposits[_from].push(depositDetails);\n384         user.depositId = user_deposits[_from].length;\n \n385         emit Deposit(_from, amountToDeposit,_periodId);\n386     }\n\n387      /**\n388      * Returns the latest price\n389      */\n390     function getPrice () public view returns (uint) {\n391         uint256[] memory gymPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1000000000000000000,GymWBNBPair);\n392         uint256[] memory BNBPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1, wbnbAndUSDTTokenArray);\n393         return gymPriceInUSD[1] * BNBPriceInUSD[1];\n394     }\n\n\n395     /**\n396      * @notice withdraw one claim\n397      * @param _depositId: is the id of user element. \n398      */\n399     function withdraw(\n400         uint256 _depositId\n401     ) external  {\n402         require(_depositId >= 0, \"Value is not specified\");\n403         updatePool();\n404         _withdraw(_depositId);\n\n405         _updateLevelPoolQualification(msg.sender);\n406     }\n\n407     /**\n408     Should approve allowance before initiating\n409     accepts _depositId - is the id of user element. \n410     */\n411     function _withdraw(\n412             uint256 _depositId\n413         ) private {\n414             UserInfo storage user = userInfo[msg.sender];\n415             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n416             PoolInfo storage pool = poolInfo;\n417             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n418             if(!isInMigrationToVTwo) {\n419                 require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n420             }\n421             require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n\n422             _claim(_depositId,1);\n423             depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n\n424             user.totalDepositTokens -=  depositDetails.depositTokens;\n425             user.totalDepositDollarValue -=  depositDetails.depositDollarValue;\n426             totalGymnetLocked -= depositDetails.depositTokens;\n427             if(depositDetails.stakePeriod == 0) {\n428                 totalGymnetUnlocked -= depositDetails.depositTokens;\n429             }\n            \n430             token.safeTransferFrom(address(this),msg.sender, depositDetails.depositTokens);\n\n431             for (uint i = 0; i<levels.length ; i++) {\n432                 if(user.totalDepositDollarValue >= levels[i]) {\n433                     user.level=i;\n434                 }\n435             }\n436             depositDetails.is_finished = true;\n437             emit Withdraw(msg.sender,  depositDetails.depositTokens,depositDetails.stakePeriod);\n\n\n438         }\n\n\n439     /**\n440      * @notice Claim rewards you gained over period\n441      * @param _depositId: is the id of user element. \n442      */\n443     function claim(\n444         uint256 _depositId\n445     ) external  {\n446         require(_depositId >= 0, \"Value is not specified\");\n447         updatePool();\n448         refreshMyLevel(msg.sender);\n449         _claim(_depositId,0);\n450     }\n\n451    /*\n452     Should approve allowance before initiating\n453     accepts _depositId - is the id of user element. \n454     */\n455     function _claim(\n456             uint256 _depositId,\n457             uint256 fromWithdraw\n458         ) private {\n459             UserInfo storage user = userInfo[msg.sender];\n460             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n461             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n462             PoolInfo storage pool = poolInfo;\n\n463             uint256 pending = pendingReward(_depositId,msg.sender);\n\n464             if(fromWithdraw == 0) {\n465                 require(pending > 0 ,\"No rewards to claim.\");\n466             }\n\n\n467             if (pending > 0) {\n468                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n469                 token.safeTransfer(relationship, distributeRewardTokenAmt);\n470                 IGymMLM(relationship).distributeRewards(pending, address(tokenAddress), msg.sender, 3);\n\n471                 // 6% distribution \n472                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n473                 poolRewardsAmount += calculateDistrubutionReward; \n                \n474                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n475                 safeRewardTransfer(tokenAddress, msg.sender, calcUserRewards);\n\n476                 user.totalClaimt += calcUserRewards;\n477                 totalClaimtInPool += pending;\n478                 depositDetails.rewardsClaimt += pending;\n479                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n480                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n481                  depositDetails.rewardsGained = 0;\n482             }\n            \n483             // token.safeTransferFrom(address(this),msg.sender, depositDetails.rewardsGained);\n\n484         }\n\n\n      \n485    /*\n486     transfers pool commisions to management\n487     */\n488     function transferPoolRewards() public onlyRunnerScript {\n489             require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n490             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n491             token.safeTransfer(holderRewardContractAddress, poolRewardsAmount);\n492             // token.safeTransfer(relationship, poolRewardsAmount/2);\n493             poolRewardsAmount = 0;\n494         }  \n\n\n495     /**\n496      * @notice  Safe transfer function for reward tokens\n497      * @param _rewardToken Address of reward token contract\n498      * @param _to Address of reciever\n499      * @param _amount Amount of reward tokens to transfer\n500      */\n501     function safeRewardTransfer(\n502         address _rewardToken,\n503         address _to,\n504         uint256 _amount\n505     ) internal {\n506         uint256 _bal = IERC20Upgradeable(_rewardToken).balanceOf(address(this));\n507         if (_amount > _bal) {\n508             require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n509         } else {\n510             require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n511         }\n512     }\n513     /**\n514      * @notice To get User Info in other contract.\n515      */\n516     function getUserInfo(address _user) external view returns (UserInfo memory) {\n517         return userInfo[_user];\n518     }\n\n519         /**\n520      * @notice View function to see pending reward on frontend.\n521      * @param _depositId: Staking pool id\n522      * @param _user: User address\n523      */\n524     function pendingReward(uint256 _depositId, address _user) public view returns (uint256) {\n525         UserDeposits storage depositDetails = user_deposits[_user][_depositId];\n526         UserInfo storage user = userInfo[_user];\n527         PoolInfo storage pool = poolInfo;\n528         if(depositDetails.is_finished == true || depositDetails.stakePeriod == 0){\n529             return 0;\n530         }\n      \n531         uint256 _accRewardPerShare = pool.accRewardPerShare;\n532         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n\n533         if (block.number > pool.lastRewardBlock && sharesTotal != 0) {\n534             uint256 _multiplier = block.number - pool.lastRewardBlock;\n535             uint256 _reward = (_multiplier * pool.rewardPerBlock);\n536              _accRewardPerShare = _accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n537         }\n\n538         return (depositDetails.depositTokens * _accRewardPerShare) / (1e18) - (depositDetails.rewardDebt);\n539     }\n\n\n540     /**\n541      * @notice Update reward variables of the given pool to be up-to-date.\n542      */\n543     function updatePool() public {\n544         PoolInfo storage pool = poolInfo;\n545         if (block.number <= pool.lastRewardBlock) {\n546             return;\n547         }\n548         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n549         if (sharesTotal == 0) {\n550             pool.lastRewardBlock = block.number;\n551             return;\n552         }\n553         uint256 multiplier = block.number - pool.lastRewardBlock;\n554         if (multiplier <= 0) {\n555             return;\n556         }\n557         uint256 _rewardPerBlock = pool.rewardPerBlock;\n558         uint256 _reward = (multiplier * _rewardPerBlock);\n559         pool.accRewardPerShare = pool.accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n560         pool.lastRewardBlock = block.number;\n561     }\n562     /**\n563      * @notice Claim All Rewards in one Transaction Internat Function.\n564      * If reinvest = true, Rewards will be reinvested as a new Staking\n565      * Reinvest Period Id is the id of months element\n566      */\n567     function _claimAll(bool reinvest,uint8 reinvestPeriodId) private {\n568         UserInfo storage user = userInfo[msg.sender];\n569         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n570         PoolInfo storage pool = poolInfo;\n571          updatePool();\n572          uint256 distributeRewardTokenAmtTotal = 0;\n573          uint256 calcUserRewardsTotal = 0;\n574          uint256 totalDistribute = 0;\n575         for (uint256 i = 0; i<user.depositId ; i++) {\n576             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n577             uint256 pending = pendingReward(i,msg.sender);\n578             totalDistribute += pending;\n579             if (pending > 0) {\n580                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n581                  distributeRewardTokenAmtTotal += distributeRewardTokenAmt;\n582                 // 6% distribution \n583                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n584                 poolRewardsAmount += calculateDistrubutionReward; \n                \n585                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n586                 calcUserRewardsTotal += calcUserRewards;\n\n587                 user.totalClaimt += calcUserRewards;\n588                 totalClaimtInPool += pending;\n589                 depositDetails.rewardsClaimt += pending;\n590                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n591                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n592                  depositDetails.rewardsGained = 0;\n593             }\n            \n594         }\n595         token.safeTransfer(relationship, distributeRewardTokenAmtTotal);\n596         IGymMLM(relationship).distributeRewards(totalDistribute, address(tokenAddress), msg.sender, 3);\n597         safeRewardTransfer(tokenAddress, msg.sender, calcUserRewardsTotal);\n598         if(reinvest == true) {\n599           _deposit(calcUserRewardsTotal,reinvestPeriodId,false);\n600         }\n601     }\n602     /**\n603      * @notice Claim All Rewards in one Transaction.\n604      */\n605     function claimAll() public {\n606          refreshMyLevel(msg.sender);\n607         _claimAll(false,0);\n608     }\n609     /**\n610      * @notice Claim and Reinvest all rewards public function to trigger internal _claimAll function.\n611      */\n612     function claimAndReinvest(bool reinvest,uint8 periodId) public {\n613         require(isPoolActive,'Contract is not running yet');\n614         _claimAll(reinvest,periodId);\n615     }\n\n616     function refreshMyLevel(address _user) public {\n617         UserInfo storage user = userInfo[_user];\n618         for (uint i = 0; i<levels.length ; i++) {\n619             if(user.totalDepositDollarValue >= levels[i]) {\n620                 user.level=i;\n621             }\n622         }\n623     }\n624     function totalLockedTokens(address _user) public view returns (uint256) {\n625         UserInfo storage user = userInfo[_user];\n626         uint256 totalDepositLocked = 0;\n627         for (uint256 i = 0; i<user.depositId ; i++) {\n628             UserDeposits storage depositDetails = user_deposits[_user][i];\n629             if(depositDetails.stakePeriod != 0 && !depositDetails.is_finished) {\n630                 totalDepositLocked += depositDetails.depositTokens;\n631             } \n632         }\n633         return totalDepositLocked;\n634     }\n\n635     function switchToUnlocked(uint256 _depositId) public {\n636         UserInfo storage user = userInfo[msg.sender];\n637         UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n639         _claim(_depositId,1);\n640         uint256 lockTimesamp = DateTime.addSeconds(block.timestamp,1);\n\n641         depositDetails.stakePeriod = 0;\n642         depositDetails.withdrawalTimestamp = lockTimesamp;\n643         totalGymnetUnlocked += depositDetails.depositTokens;\n\n644     }\n\n645     function _updateLevelPoolQualification(address wallet) internal {\n646         uint256 userLevel = IGymMLM(relationship).getUserCurrentLevel(wallet);\n647         IGymLevelPool(levelPoolContractAddress).updateUserQualification(wallet, userLevel);\n648     }\n\n649     function transferToV2(uint8 _periodId,bool isUnlocked) public {\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n651         UserInfo storage user = userInfo[msg.sender];\n652          require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');\n653          if(isUnlocked) {\n654             _periodId = 0;\n655          }\n656         _claimAll(false,0);\n657         uint256 dollarValueOfDeposits = user.totalDepositDollarValue * 1e18;\n658         IGymSinglePool(newSinglePoolAddress).transferFromOldVersion(\n659              user.totalDepositTokens,\n660              _periodId,\n661              isUnlocked,\n662              msg.sender,\n663              dollarValueOfDeposits\n664         );\n665         for (uint32 i = 0; i<user.depositId ; i++) {\n666             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n667             depositDetails.depositTokens = 0;\n668             depositDetails.is_finished = true;\n669             totalGymnetLocked -= depositDetails.depositTokens;\n670             if(depositDetails.stakePeriod == 0) {\n671                 totalGymnetUnlocked -= depositDetails.depositTokens;\n672             }\n673         }\n\n674         user.totalDepositDollarValue = 0;\n675         user.totalDepositTokens = 0;\n\n676     }\n677     function burnOldTokens() public onlyOwner {\n678         uint256 _bal = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n679         IERC20Burnable(tokenAddress).burnFrom(address(this),_bal);\n680     }\n681 }\n613\n",
    "transaction-context": "require(isPoolActive,'Contract is not running yet');",
    "Critical-points": "require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');",
    "invariants": "require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');",
    "critical-invariants": " require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "ranks": "modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }",
    "vulnerabilities": "nonReentrant"
  },
  {
    "code": "1 pragma solidity ^0.5.2;\n\n2 // Tests that function with inline assembly generates non-det result\n3 contract AssemblyTest\n4 {\n5         bool b;\n6         int x;\n7     constructor () public {\n8   }\n        \n9 function foo() public {\n10                 b = bar(x);\n11                 if (b)\n12                 assert(false);\n13         }\n14 function bar(int x) public returns (bool) { \n15         uint256 size;\n16         assembly { size := x }\n17         return size > 0;\n18         }\n19 }\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 12+ ",
    "invariants": "12+ assert(false);",
    "critical-invariants": "12+ assert(false);",
    "ranks": "12+ assert(false);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;\n10 \n11         function startExecute() external {\n12             require(proposal.sTime == 0, \"\"on-going proposal\"\");\n13             proposal = Proposal(block.timestamp, msg.sender);\n14         }\n15         function execute(uint amount) external {\n16             require(proposal.sTime + 2 days > block.timestamp,\n17             \"\"voting has ended\"\");\n18             votingToken.transferFrom(\n19             msg.sender, address(this), amount);\n20         }\n21         function endExecute() external {\n22             require(proposal.sTime != 0, \"\"no proposal\"\");\n23             require(proposal.sTime + 2 days < block.timestamp,\n24             \"\"voting has not ended\"\");\n25             require(votingToken.balanceOf(address(this))*2 >\n26             votingToken.totalSupply(), \"\"vote failed\"\");\n27             owner = proposal.newOwner;\n28             delete proposal;\n29         }\n30 }\n",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 //simple library with no internal state\n\n3 library Lib {\n4     function add(uint _a, uint _b) public view returns (uint r) {\n5         address x = address(this);\n6         assert(x == msg.sender);\n7         r = _a + _b;\n8     }\n9 }\n\n10 contract C {\n11     // using Lib for uint;\n\n12     function foo() public {\n13         uint x = 1;\n14         uint y = 2;\n15         uint z = Lib.add(x, y);\n16         assert (z == 3);\n17     }\n18 }\n6+\n",
    "transaction-context": "assert(x == msg.sender);",
    "Critical-points": "assert (z == 3);",
    "invariants": "assert(a == x + 1);",
    "critical-invariants": "assert(a == x); ",
    "ranks": "assert (a == x + 4); ",
    "vulnerabilities": "assert (b == x + 4);  "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n\n7         a = 10;\n8         b = address(0x10);\n9         c = address(0x12);\n\n10         assert(b != c);\n11     }\n12}\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+ ",
    "invariants": "10+ assert(b != c);",
    "critical-invariants": "10+ assert(b != c);",
    "ranks": "10+ assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n2 import \"./../../Libraries/VeriSolContracts.sol\";\n3 //import \"./VeriSolContracts.sol\";\n4 //import \"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\";\n\n5 contract LoopFor {\n\n6     // test Loop invariant with for loop\n7     constructor(uint n) public {\n8         require (n >= 0);\n9         uint y = 0;\n10         for (uint x = n; x != 0; x --) {         \n11             y++;\n12         }\n      \n13     }\n\n14     // test Loop invariant with while loop\n15     function Foo(uint n) public {\n16         require (n >= 0);\n17         uint y = 0;\n18         uint x = n;\n19         while (x != 0) {          \n20             y++;\n21             x--;\n22         }     \n23     }\n\n24     // test Loop invariant with do-while loop    \n25     function Bar(uint n) public {\n26         require (n > 0);\n27         uint y = 0;\n28         uint x = n;\n29         do {          \n30             y++;\n31             x--;\n32         } while (x != 0);       \n33     }\n34 }\n29+ \n",
    "transaction-context": "assert(x + y == n);",
    "Critical-points": "assert (y == n);",
    "invariants": " require(msg.sender != address(0));",
    "critical-invariants": "assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "ranks": "require(_balances[sender] >= amount);",
    "vulnerabilities": "require(amount > 0, \"Cannot withdraw 0\");"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Arithmetics {\n\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\n4         c = _a + _b;\n      \n5     }\n\n6     function subtraction(uint _a, uint _b) public pure returns (uint c) {\n7         c = _a - _b;       \n8     }\n\n9     function mutliplication(uint _a, uint _b) public pure returns (uint c) {\n10         c = _a * _b;       \n11     }\n\n12     function division(uint _a, uint _b) public pure returns (uint c) {\n13         c = _a / _b;      \n14     }\n\n15 }\n10+ \n",
    "transaction-context": "assert (c == _a * _b);",
    "Critical-points": "assert (c == _a / _b);",
    "invariants": "assert(finished = true);",
    "critical-invariants": "assert(canceled = true); ",
    "ranks": " assert(!(finished && canceled)); ",
    "vulnerabilities": "require(lockDev == false);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }\n\n7     function testConstructor() public {\n8         assert (a == 1);\n9     }\n10 }\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+ ",
    "invariants": "8+ assert (a == 1);",
    "critical-invariants": "8+ assert (a == 1);",
    "ranks": "8+ assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n\n2 contract Token {\n3     uint256 public totalSupply;\n4     function balanceOf(address _owner) constant returns (uint256 balance);\n5     function transfer(address _to, uint256 _value) returns (bool success);\n6     function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n7     function approve(address _spender, uint256 _value) returns (bool success);\n8     function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n9     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n10     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n11 }\n\n12 contract StandardToken is Token {\n13 \tbool public disabled = false;\n14     function transfer(address _to, uint256 _value) returns (bool success) {\n15         if (disabled != true && balances[msg.sender] >= _value && _value > 0) {\n16             balances[msg.sender] -= _value;\n17             balances[_to] += _value;\n18             Transfer(msg.sender, _to, _value);\n19             return true;\n20         } else { return false; }\n21     }\n22     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n23         if (disabled != true && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n24             balances[_to] += _value;\n25             balances[_from] -= _value;\n26             allowed[_from][msg.sender] -= _value;\n27             Transfer(_from, _to, _value);\n28             return true;\n29         } else { return false; }\n30     }\n31     function balanceOf(address _owner) constant returns (uint256 balance) {\n32         return balances[_owner];\n33     }\n34     function approve(address _spender, uint256 _value) returns (bool success) {\n35         allowed[msg.sender][_spender] = _value;\n36         Approval(msg.sender, _spender, _value);\n37         return true;\n38     }\n39     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n40       return allowed[_owner][_spender];\n41     }\n42     mapping (address => uint256) balances;\n43     mapping (address => mapping (address => uint256)) allowed;\n44 }\n\n45 contract NexxusToken is StandardToken {\n\n46     function () {return;}\n\n47     string public name = \"Nexxus\";\n48     uint8 public decimals = 8;\n49     string public symbol = \"NXX\";\n50     address public owner;\n\n51     function NexxusToken() {\n52         totalSupply = 31800000000000000;\n53         owner = msg.sender;\n54         balances[owner] = totalSupply;\n55     }\n56     function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n57         allowed[msg.sender][_spender] = _value;\n58         Approval(msg.sender, _spender, _value);\n59         if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { return; }\n60         return true;\n61     }\n62 \tfunction mintToken(uint256 _amount) {\n63         if (msg.sender == owner) {\n64     \t\ttotalSupply += _amount;\n65             balances[owner] += _amount;\n66     \t\tTransfer(0, owner, _amount);\n67         }\n68 \t}\n69 \tfunction disableToken(bool _disable) { \n70         if (msg.sender == owner)\n71 \t\t\tdisabled = _disable;\n72     }\n73 }\n",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 12+ \n22+   \n62+ \n69+",
    "invariants": "12+ assert(!disabled);\n22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n62+ assert(msg.sender == owner);\n69+ assert(msg.sender == owner);",
    "critical-invariants": "22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n69+ assert(msg.sender == owner);",
    "ranks": "22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n69+ assert(msg.sender == owner);",
    "vulnerabilities": "incorrect invisibility/ownership\natomicity violation\ninteger overflow/underflow"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract MappingNested {\n\n3     mapping (uint => mapping (uint => uint)) m;\n4     mapping (uint => uint[]) n;\n5     uint[] p;\n  \n\n6     constructor() public {\n7         // assert(m[0][22] == 0); \n\n8         m[10][20] = 11;\n9         m[20][10] = 21;\n10         assert (m[10][20] == 11);\n11         assert (m[20][10] == 21);\n12         assert (n[0].length == 0);\n13         n[0].push(22);\n14         n[0].push(33);\n15         assert (n[0].length == 2);\n16         assert (n[1].length == 0); \n17         assert (p.length == 0); \n18     }\n\n19 }\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+         \n11+      \n12+        \n15+        \n16+\n17+         ",
    "invariants": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);\n12+         assert (n[0].length == 0);\n15+         assert (n[0].length == 2);\n16+         assert (n[1].length == 0); \n17+         assert (p.length == 0); ",
    "critical-invariants": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);",
    "ranks": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n9 import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n10 import \"./interfaces/IPancakePair.sol\";\n11 import \"./interfaces/IPancakeFactory.sol\";\n12 import \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\n13 import \"./interfaces/IGymLevelPool.sol\";\n14 import \"./interfaces/IGymSinglePool.sol\";\n15 /* preserved Line */\n16 /* preserved Line */\n17 /* preserved Line */\n18 /* preserved Line */\n19 /* preserved Line */\n\n20 /**\n21  * @notice GymSinglePool contract:\n22  * - Users can:\n23  *   # Deposit GYMNET\n24  *   # Withdraw assets\n25  */\n\n26 contract GymSinglePool is ReentrancyGuardUpgradeable, OwnableUpgradeable {\n27     using SafeERC20Upgradeable for IERC20Upgradeable;\n\n28    /**\n29      * @notice Info of each user\n30      * One Address can have many Deposits with different periods. Unlimited Amount.\n31      * Total Depsit Tokens = Total amount of user active stake in all.\n32      * Total Depsit Dollar Value = Total Dollar Value over all staking single pools. Calculated when user deposits tokens, and dollar value is for that exact moment rate.\n33      * level = level qualification for this pool. Used internally, for global qualification please check MLM Contract.\n34      * depositId = incremental ID of deposits, eg. if user has 3 stakings then this value will be 2;\n35      * totalClaimt = Total amount of tokens user claimt. \n36      */\n37     struct UserInfo {\n38         uint256 totalDepositTokens;\n39         uint256 totalDepositDollarValue;\n40         uint256 level;\n41         uint256 depositId;\n42         uint256 totalClaimt;\n43     }\n\n44    /** \n45      * @notice Info for each staking by ID\n46      * One Address can have many Deposits with different periods. Unlimited Amount.\n47      * depositTokens = amount of tokens for exact deposit.\n48      * depositDollarValue = Dollar value of deposit.\n49      * stakePeriod = Locking Period - from 3 months to 30 months. value is integer\n50      * depositTimestamp = timestamp of deposit\n51      * withdrawalTimestamp = Timestamp when user can withdraw his locked tokens\n52      * rewardsGained = amount of rewards user has gained during the process\n53      * is_finished = checks if user has already withdrawn tokens\n54      */\n55     struct UserDeposits {\n56         uint256 depositTokens;\n57         uint256 depositDollarValue;\n58         uint256 stakePeriod;\n59         uint256 depositTimestamp;\n60         uint256 withdrawalTimestamp;\n61         uint256 rewardsGained;\n62         uint256 rewardsClaimt;\n63         uint256 rewardDebt;\n64         bool is_finished;\n65     }\n66     /**\n67      * @notice Info of Pool\n68      * @param lastRewardBlock: Last block number that reward distribution occurs\n69      * @param accUTacoPerShare: Accumulated rewardPool per share, times 1e18\n70      * @param rewardPerBlock: How many reward tokens will user get per block\n71      */\n72     struct PoolInfo {\n73         uint256 lastRewardBlock;\n74         uint256 accRewardPerShare;\n75         uint256 rewardPerBlock;\n76     }\n\n77     /// Startblock number\n78     uint256 public startBlock;\n79     uint256 public withdrawFee;\n\n80      // MLM Contract - RelationShip address\n81     address public relationship;\n82     /// Treasury address where will be sent all unused assets\n83     address public treasuryAddress;\n84     /// Info of pool.\n85     PoolInfo public poolInfo;\n86     /// Info of each user that staked tokens.\n87     mapping(address => UserInfo) public userInfo;\n\n88     /// accepts user address and id of element to select - returns information about selected staking by id\n89     mapping (address=>UserDeposits[]) public user_deposits;\n\n90     uint256 private lastChangeBlock;\n\n91     /// GYMNET token contract address\n92     address public tokenAddress;\n\n93     /// address of pancake Router\n94     address public pancakeRouterAddress;\n95     /// WBNB and BUSD Token Pair address, element 0 = Address of WBNB Token, element 1= Address of GYMNET \n96     address[] public wbnbAndUSDTTokenArray;\n97     /// GYMNET and WBNB Token Pair address, element 0 = Address of GYMNET, element 1 = Address of WBNB Token, \n98     address[] public GymWBNBPair;\n\n99     /// Level Qualifications for the pool\n100     uint256[16] public levels;\n101     /// Locking Periods \n102     uint256[6] public months;\n\n103     /// Amount of Total GYMNET Locked in the pool\n104     uint256 public totalGymnetLocked;\n\n105     /// Amount of GYMNET all users has claimt over time.\n106     uint256 public totalClaimtInPool;\n\n107     /// Percent that will be sent to MLM Contract for comission distribution\n108     uint256 public RELATIONSHIP_REWARD;\n\n109     /// 6% comissions\n110     uint256 public poolRewardsAmount;\n\n111     address public holderRewardContractAddress;\n\n112     address public runnerScriptAddress;\n113     uint256 public totalBurntInSinglePool;\n114     bool public isPoolActive;\n115     bool public isInMigrationToVTwo;\n116     uint256 public totalGymnetUnlocked;\n117     uint256 public unlockedTimestampQualification;\n118     address public vaultContractAddress;\n119     address public farmingContractAddress;\n\n120     address public levelPoolContractAddress;\n121     address public newSinglePoolAddress;\n\n122     /* ========== EVENTS ========== */\n\n123     event Initialized(address indexed executor, uint256 at);\n124     event Deposit(address indexed user, uint256 amount,uint indexed period);\n125     event Withdraw(address indexed user, uint256 amount,uint indexed period);\n126     event RewardPaid(address indexed token, address indexed user, uint256 amount);\n127     event ClaimUserReward(address indexed user, uint256 amount);\n\n\n128     modifier onlyRunnerScript() {\n129         require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n130         _;\n131     }\n132     modifier onlyBank() {\n133         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n134         _;\n135     }\n136     receive() external payable {}\n\n137     fallback() external payable {}\n\n138 // all initialize parameters are mandatory\n139     function initialize(\n140         uint256 _startBlock,\n141         address _gym,\n142         address _mlm,\n143         uint256 _gymRewardRate,\n144         address _pancakeRouterAddress,\n145         address[] memory _wbnbAndUSDTTokenArray,\n146         address[] memory _GymWBNBPair\n147     ) external initializer {\n148         require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n\n149         startBlock = _startBlock; // Number of Upcoming Block\n150         relationship = _mlm;  // address of MLM contract\n151         tokenAddress = _gym; // address of GYMNET Contract\n152         pancakeRouterAddress = _pancakeRouterAddress; // Address of Pancake Router\n153         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray; // WBNB And USDT Token Addresses [WBNB,USDT]\n154         GymWBNBPair = _GymWBNBPair; // GYMNET And WBNB Token Addresses [GYMNET,WBNB]\n155         runnerScriptAddress = msg.sender;\n156         isPoolActive = false;\n157         isInMigrationToVTwo = false;\n158         RELATIONSHIP_REWARD = 39; // Relationship commission amount\n159         levels = [0, 0, 200, 200, 2000, 4000, 10000, 20000, 40000, 45000, 50000, 60000, 65000, 70000, 75000, 80000]; // Internal Pool Levels\n160         months = [3, 6, 12, 18, 24, 30]; // Locking Periods\n\n161         poolInfo = PoolInfo({\n162                 lastRewardBlock: _startBlock,\n163                 rewardPerBlock: _gymRewardRate,\n164                 accRewardPerShare: 0\n165             });\n\n166         lastChangeBlock = _startBlock;\n\n167         __Ownable_init();\n168         __ReentrancyGuard_init();\n        \n169         emit Initialized(msg.sender, block.number);\n170     }\n\n\n171     function setPoolInfo(uint256 lastRewardBlock,uint256 accRewardPerShare, uint256 rewardPerBlock) external onlyOwner {\n172         poolInfo = PoolInfo({\n173                 lastRewardBlock: lastRewardBlock,\n174                 accRewardPerShare: accRewardPerShare,\n175                 rewardPerBlock: rewardPerBlock\n176             });\n177     }\n\n178     function updateStartBlock(uint256 _startBlock) external onlyOwner {\n179         startBlock = _startBlock;\n180     }\n\n181     function setMLMAddress(address _relationship) external onlyOwner {\n182         relationship = _relationship;\n183     }\n\n184     function setTokenAddress(address _tokenAddress) external onlyOwner {\n185         tokenAddress = _tokenAddress;\n186     }\n187     function setVaultContractAddress(address _vaultContractAddress) external onlyOwner {\n188         vaultContractAddress = _vaultContractAddress;\n189     }\n190     function setFarmingContractAddress(address _farmingContractAddress) external onlyOwner {\n191         farmingContractAddress = _farmingContractAddress;\n192     }\n\n193     function setLevelPoolContractAddress(address _levelPoolContractAddress) external onlyOwner {\n194         levelPoolContractAddress = _levelPoolContractAddress;\n195     }\n\n196     function setRelationshipReward(uint256 _amount) external onlyOwner {\n197         RELATIONSHIP_REWARD = _amount;\n198     }\n199     function setOnlyRunnerScript(address _onlyRunnerScript) external onlyOwner {\n200         runnerScriptAddress = _onlyRunnerScript;\n201     }\n202     function setNewSinglePoolAddress(address _newSinglePoolAddress) external onlyOwner {\n203         newSinglePoolAddress = _newSinglePoolAddress;\n204     }\n\n205     function setGymWBNBPair(address[] memory  _GymWBNBPair) external onlyOwner {\n206         GymWBNBPair = _GymWBNBPair;\n207     }\n208     function setPancakeRouterAddress(address _pancakeRouterAddress) external onlyOwner {\n209         pancakeRouterAddress = _pancakeRouterAddress;\n210     }\n\n211     function setIsPoolActive(bool _isPoolActive) external onlyOwner {\n212         isPoolActive = _isPoolActive;\n213     }\n214     function setIsInMigrationToVTwo(bool _isInMigrationToVTwo) external onlyOwner {\n215         isInMigrationToVTwo = _isInMigrationToVTwo;\n216     }\n\n217     function setHolderRewardContractAddress(address _holderRewardContractAddress) external onlyOwner {\n218         holderRewardContractAddress = _holderRewardContractAddress;\n219     }\n\n\n220     function setWbnbAndUSDTTokenArray(address[] memory _wbnbAndUSDTTokenArray) external onlyOwner {\n221         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray;\n222     }\n223     function setUnlockedTimestampQualification(uint256 _unlockedTimestampQualification) external onlyOwner {\n224         unlockedTimestampQualification = _unlockedTimestampQualification;\n225     }\n226     function setLevels(uint256[16] calldata _levels) external onlyOwner {\n227         levels = _levels;\n228     }\n\n229      /**\n230      * @notice  Function to set Treasury address\n231      * @param _treasuryAddress Address of treasury address\n232      */\n233     function setTreasuryAddress(address _treasuryAddress) external nonReentrant onlyOwner {\n234         treasuryAddress = _treasuryAddress;\n235     }\n\n236     /**\n237      * @notice Deposit in given pool\n238      * @param _depositAmount: Amount of want token that user wants to deposit\n239      */\n240     function deposit(\n241         uint256 _depositAmount,\n242         uint8 _periodId,\n243         uint256 _referrerId,\n244         bool isUnlocked\n245     ) external  {\n246         require(isPoolActive,'Contract is not running yet');\n247         IGymMLM(relationship).addGymMLM(msg.sender, _referrerId);\n248         _deposit(_depositAmount,_periodId,isUnlocked);\n249     }\n250     /**\n251      * @notice Deposit in given pool\n252      * @param _depositAmount: Amount of want token that user wants to deposit\n253      */\n254     function depositFromOtherContract(\n255         uint256 _depositAmount,\n256         uint8 _periodId,\n257         bool isUnlocked,\n258         address _from\n259     ) external onlyBank {\n260         require(isPoolActive,'Contract is not running yet');\n261         _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n\n262         _updateLevelPoolQualification(_from);\n263     }\n\n264     /**\n265      * @notice To get User level in other contract for single pool.\n266      * @param _user: User address\n267      */\n268     function getUserLevelInSinglePool(address _user) external view returns (uint32) {\n269         uint256 _totalDepositDollarValue = userInfo[_user].totalDepositDollarValue;\n270         uint32 level = 0;\n271         for (uint32 i = 0; i<levels.length ; i++) {\n272             if(_totalDepositDollarValue >= levels[i]) {\n273                 level=i;\n274             }\n275         }\n276         return level;\n277     }\n\n278     /**\n279     Should approve allowance before initiating\n280     accepts depositAmount in WEI\n281     periodID - id of months array accordingly\n282     */\n283     function _deposit(\n284         uint256 _depositAmount,\n285         uint8 _periodId,\n286         bool _isUnlocked\n287     ) private {\n288         UserInfo storage user = userInfo[msg.sender];\n289         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n290         PoolInfo storage pool = poolInfo;\n291         updatePool();\n\n292         uint256 period = months[_periodId];\n293         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n294         uint256 burnTokensAmount = 0;\n\n295         if(!_isUnlocked) {\n296             burnTokensAmount = (_depositAmount * 4) / 100;\n297             totalBurntInSinglePool += burnTokensAmount;\n298             IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n299         }\n\n        \n300         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n\n301         token.safeTransferFrom(msg.sender, address(this), amountToDeposit);\n302         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n303         user.totalDepositTokens += amountToDeposit;\n304         user.totalDepositDollarValue += UsdValueOfGym;\n305         totalGymnetLocked += amountToDeposit;\n306         if(_isUnlocked) {\n307             totalGymnetUnlocked += amountToDeposit;\n308             period = 0; \n309             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n310         }\n\n311         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n312         UserDeposits memory depositDetails = UserDeposits(\n313             {\n314                 depositTokens: amountToDeposit, \n315                 depositDollarValue: UsdValueOfGym,\n316                 stakePeriod: period,\n317                 depositTimestamp: block.timestamp,\n318                 withdrawalTimestamp: lockTimesamp,\n319                 rewardsGained: 0,\n320                 is_finished: false,\n321                 rewardsClaimt: 0,\n322                 rewardDebt: rewardDebt\n323             }\n324         );\n\n325         user_deposits[msg.sender].push(depositDetails);\n326         user.depositId = user_deposits[msg.sender].length;\n        \n\n327        for (uint i = 0; i<levels.length ; i++) {\n328             if(user.totalDepositDollarValue >= levels[i]) {\n329                 user.level=i;\n330             }\n331         }\n332         _updateLevelPoolQualification(msg.sender);\n333         emit Deposit(msg.sender, _depositAmount,_periodId);\n334     }\n\n335      /**\n336     Should approve allowance before initiating\n337     accepts depositAmount in WEI\n338     periodID - id of months array accordingly\n339     */\n340     function _autoDeposit(\n341         uint256 _depositAmount,\n342         uint8 _periodId,\n343         bool _isUnlocked,\n344         address _from\n345     ) private {\n346         UserInfo storage user = userInfo[_from];\n347         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n348         PoolInfo storage pool = poolInfo;\n349         token.approve(address(this), _depositAmount);\n350         updatePool();\n351         uint256 period = months[_periodId];\n352         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n353         uint256 burnTokensAmount = 0;\n354         // if(!_isUnlocked) {\n355         //     uint256 burnTokensAmount = (_depositAmount * 4) / 100;\n356         //     totalBurntInSinglePool += burnTokensAmount;\n357         //     IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n358         // }\n359         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n360         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n361         user.totalDepositTokens += amountToDeposit;\n362         user.totalDepositDollarValue += UsdValueOfGym;\n363         totalGymnetLocked += amountToDeposit;\n364         if(_isUnlocked) {\n365             totalGymnetUnlocked += amountToDeposit;\n366             period = 0; \n367             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n368         }\n\n369         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n370         UserDeposits memory depositDetails = UserDeposits(\n371             {\n372                 depositTokens: amountToDeposit, \n373                 depositDollarValue: UsdValueOfGym,\n374                 stakePeriod: period,\n375                 depositTimestamp: block.timestamp,\n376                 withdrawalTimestamp: lockTimesamp,\n377                 rewardsGained: 0,\n378                 is_finished: false,\n379                 rewardsClaimt: 0,\n380                 rewardDebt: rewardDebt\n381             }\n382         );\n383         user_deposits[_from].push(depositDetails);\n384         user.depositId = user_deposits[_from].length;\n \n385         emit Deposit(_from, amountToDeposit,_periodId);\n386     }\n\n387      /**\n388      * Returns the latest price\n389      */\n390     function getPrice () public view returns (uint) {\n391         uint256[] memory gymPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1000000000000000000,GymWBNBPair);\n392         uint256[] memory BNBPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1, wbnbAndUSDTTokenArray);\n393         return gymPriceInUSD[1] * BNBPriceInUSD[1];\n394     }\n\n\n395     /**\n396      * @notice withdraw one claim\n397      * @param _depositId: is the id of user element. \n398      */\n399     function withdraw(\n400         uint256 _depositId\n401     ) external  {\n402         require(_depositId >= 0, \"Value is not specified\");\n403         updatePool();\n404         _withdraw(_depositId);\n\n405         _updateLevelPoolQualification(msg.sender);\n406     }\n\n407     /**\n408     Should approve allowance before initiating\n409     accepts _depositId - is the id of user element. \n410     */\n411     function _withdraw(\n412             uint256 _depositId\n413         ) private {\n414             UserInfo storage user = userInfo[msg.sender];\n415             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n416             PoolInfo storage pool = poolInfo;\n417             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n418             if(!isInMigrationToVTwo) {\n419                 require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n420             }\n421             require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n\n422             _claim(_depositId,1);\n423             depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n\n424             user.totalDepositTokens -=  depositDetails.depositTokens;\n425             user.totalDepositDollarValue -=  depositDetails.depositDollarValue;\n426             totalGymnetLocked -= depositDetails.depositTokens;\n427             if(depositDetails.stakePeriod == 0) {\n428                 totalGymnetUnlocked -= depositDetails.depositTokens;\n429             }\n            \n430             token.safeTransferFrom(address(this),msg.sender, depositDetails.depositTokens);\n\n431             for (uint i = 0; i<levels.length ; i++) {\n432                 if(user.totalDepositDollarValue >= levels[i]) {\n433                     user.level=i;\n434                 }\n435             }\n436             depositDetails.is_finished = true;\n437             emit Withdraw(msg.sender,  depositDetails.depositTokens,depositDetails.stakePeriod);\n\n\n438         }\n\n\n439     /**\n440      * @notice Claim rewards you gained over period\n441      * @param _depositId: is the id of user element. \n442      */\n443     function claim(\n444         uint256 _depositId\n445     ) external  {\n446         require(_depositId >= 0, \"Value is not specified\");\n447         updatePool();\n448         refreshMyLevel(msg.sender);\n449         _claim(_depositId,0);\n450     }\n\n451    /*\n452     Should approve allowance before initiating\n453     accepts _depositId - is the id of user element. \n454     */\n455     function _claim(\n456             uint256 _depositId,\n457             uint256 fromWithdraw\n458         ) private {\n459             UserInfo storage user = userInfo[msg.sender];\n460             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n461             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n462             PoolInfo storage pool = poolInfo;\n\n463             uint256 pending = pendingReward(_depositId,msg.sender);\n\n464             if(fromWithdraw == 0) {\n465                 require(pending > 0 ,\"No rewards to claim.\");\n466             }\n\n\n467             if (pending > 0) {\n468                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n469                 token.safeTransfer(relationship, distributeRewardTokenAmt);\n470                 IGymMLM(relationship).distributeRewards(pending, address(tokenAddress), msg.sender, 3);\n\n471                 // 6% distribution \n472                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n473                 poolRewardsAmount += calculateDistrubutionReward; \n                \n474                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n475                 safeRewardTransfer(tokenAddress, msg.sender, calcUserRewards);\n\n476                 user.totalClaimt += calcUserRewards;\n477                 totalClaimtInPool += pending;\n478                 depositDetails.rewardsClaimt += pending;\n479                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n480                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n481                  depositDetails.rewardsGained = 0;\n482             }\n            \n483             // token.safeTransferFrom(address(this),msg.sender, depositDetails.rewardsGained);\n\n484         }\n\n\n      \n485    /*\n486     transfers pool commisions to management\n487     */\n488     function transferPoolRewards() public onlyRunnerScript {\n489             require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n490             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n491             token.safeTransfer(holderRewardContractAddress, poolRewardsAmount);\n492             // token.safeTransfer(relationship, poolRewardsAmount/2);\n493             poolRewardsAmount = 0;\n494         }  \n\n\n495     /**\n496      * @notice  Safe transfer function for reward tokens\n497      * @param _rewardToken Address of reward token contract\n498      * @param _to Address of reciever\n499      * @param _amount Amount of reward tokens to transfer\n500      */\n501     function safeRewardTransfer(\n502         address _rewardToken,\n503         address _to,\n504         uint256 _amount\n505     ) internal {\n506         uint256 _bal = IERC20Upgradeable(_rewardToken).balanceOf(address(this));\n507         if (_amount > _bal) {\n508             require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n509         } else {\n510             require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n511         }\n512     }\n513     /**\n514      * @notice To get User Info in other contract.\n515      */\n516     function getUserInfo(address _user) external view returns (UserInfo memory) {\n517         return userInfo[_user];\n518     }\n\n519         /**\n520      * @notice View function to see pending reward on frontend.\n521      * @param _depositId: Staking pool id\n522      * @param _user: User address\n523      */\n524     function pendingReward(uint256 _depositId, address _user) public view returns (uint256) {\n525         UserDeposits storage depositDetails = user_deposits[_user][_depositId];\n526         UserInfo storage user = userInfo[_user];\n527         PoolInfo storage pool = poolInfo;\n528         if(depositDetails.is_finished == true || depositDetails.stakePeriod == 0){\n529             return 0;\n530         }\n      \n531         uint256 _accRewardPerShare = pool.accRewardPerShare;\n532         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n\n533         if (block.number > pool.lastRewardBlock && sharesTotal != 0) {\n534             uint256 _multiplier = block.number - pool.lastRewardBlock;\n535             uint256 _reward = (_multiplier * pool.rewardPerBlock);\n536              _accRewardPerShare = _accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n537         }\n\n538         return (depositDetails.depositTokens * _accRewardPerShare) / (1e18) - (depositDetails.rewardDebt);\n539     }\n\n\n540     /**\n541      * @notice Update reward variables of the given pool to be up-to-date.\n542      */\n543     function updatePool() public {\n544         PoolInfo storage pool = poolInfo;\n545         if (block.number <= pool.lastRewardBlock) {\n546             return;\n547         }\n548         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n549         if (sharesTotal == 0) {\n550             pool.lastRewardBlock = block.number;\n551             return;\n552         }\n553         uint256 multiplier = block.number - pool.lastRewardBlock;\n554         if (multiplier <= 0) {\n555             return;\n556         }\n557         uint256 _rewardPerBlock = pool.rewardPerBlock;\n558         uint256 _reward = (multiplier * _rewardPerBlock);\n559         pool.accRewardPerShare = pool.accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n560         pool.lastRewardBlock = block.number;\n561     }\n562     /**\n563      * @notice Claim All Rewards in one Transaction Internat Function.\n564      * If reinvest = true, Rewards will be reinvested as a new Staking\n565      * Reinvest Period Id is the id of months element\n566      */\n567     function _claimAll(bool reinvest,uint8 reinvestPeriodId) private {\n568         UserInfo storage user = userInfo[msg.sender];\n569         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n570         PoolInfo storage pool = poolInfo;\n571          updatePool();\n572          uint256 distributeRewardTokenAmtTotal = 0;\n573          uint256 calcUserRewardsTotal = 0;\n574          uint256 totalDistribute = 0;\n575         for (uint256 i = 0; i<user.depositId ; i++) {\n576             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n577             uint256 pending = pendingReward(i,msg.sender);\n578             totalDistribute += pending;\n579             if (pending > 0) {\n580                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n581                  distributeRewardTokenAmtTotal += distributeRewardTokenAmt;\n582                 // 6% distribution \n583                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n584                 poolRewardsAmount += calculateDistrubutionReward; \n                \n585                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n586                 calcUserRewardsTotal += calcUserRewards;\n\n587                 user.totalClaimt += calcUserRewards;\n588                 totalClaimtInPool += pending;\n589                 depositDetails.rewardsClaimt += pending;\n590                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n591                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n592                  depositDetails.rewardsGained = 0;\n593             }\n            \n594         }\n595         token.safeTransfer(relationship, distributeRewardTokenAmtTotal);\n596         IGymMLM(relationship).distributeRewards(totalDistribute, address(tokenAddress), msg.sender, 3);\n597         safeRewardTransfer(tokenAddress, msg.sender, calcUserRewardsTotal);\n598         if(reinvest == true) {\n599           _deposit(calcUserRewardsTotal,reinvestPeriodId,false);\n600         }\n601     }\n602     /**\n603      * @notice Claim All Rewards in one Transaction.\n604      */\n605     function claimAll() public {\n606          refreshMyLevel(msg.sender);\n607         _claimAll(false,0);\n608     }\n609     /**\n610      * @notice Claim and Reinvest all rewards public function to trigger internal _claimAll function.\n611      */\n612     function claimAndReinvest(bool reinvest,uint8 periodId) public {\n613         require(isPoolActive,'Contract is not running yet');\n614         _claimAll(reinvest,periodId);\n615     }\n\n616     function refreshMyLevel(address _user) public {\n617         UserInfo storage user = userInfo[_user];\n618         for (uint i = 0; i<levels.length ; i++) {\n619             if(user.totalDepositDollarValue >= levels[i]) {\n620                 user.level=i;\n621             }\n622         }\n623     }\n624     function totalLockedTokens(address _user) public view returns (uint256) {\n625         UserInfo storage user = userInfo[_user];\n626         uint256 totalDepositLocked = 0;\n627         for (uint256 i = 0; i<user.depositId ; i++) {\n628             UserDeposits storage depositDetails = user_deposits[_user][i];\n629             if(depositDetails.stakePeriod != 0 && !depositDetails.is_finished) {\n630                 totalDepositLocked += depositDetails.depositTokens;\n631             } \n632         }\n633         return totalDepositLocked;\n634     }\n\n635     function switchToUnlocked(uint256 _depositId) public {\n636         UserInfo storage user = userInfo[msg.sender];\n637         UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n639         _claim(_depositId,1);\n640         uint256 lockTimesamp = DateTime.addSeconds(block.timestamp,1);\n\n641         depositDetails.stakePeriod = 0;\n642         depositDetails.withdrawalTimestamp = lockTimesamp;\n643         totalGymnetUnlocked += depositDetails.depositTokens;\n\n644     }\n\n645     function _updateLevelPoolQualification(address wallet) internal {\n646         uint256 userLevel = IGymMLM(relationship).getUserCurrentLevel(wallet);\n647         IGymLevelPool(levelPoolContractAddress).updateUserQualification(wallet, userLevel);\n648     }\n\n649     function transferToV2(uint8 _periodId,bool isUnlocked) public {\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n651         UserInfo storage user = userInfo[msg.sender];\n652          require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');\n653          if(isUnlocked) {\n654             _periodId = 0;\n655          }\n656         _claimAll(false,0);\n657         uint256 dollarValueOfDeposits = user.totalDepositDollarValue * 1e18;\n658         IGymSinglePool(newSinglePoolAddress).transferFromOldVersion(\n659              user.totalDepositTokens,\n660              _periodId,\n661              isUnlocked,\n662              msg.sender,\n663              dollarValueOfDeposits\n664         );\n665         for (uint32 i = 0; i<user.depositId ; i++) {\n666             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n667             depositDetails.depositTokens = 0;\n668             depositDetails.is_finished = true;\n669             totalGymnetLocked -= depositDetails.depositTokens;\n670             if(depositDetails.stakePeriod == 0) {\n671                 totalGymnetUnlocked -= depositDetails.depositTokens;\n672             }\n673         }\n\n674         user.totalDepositDollarValue = 0;\n675         user.totalDepositTokens = 0;\n\n676     }\n677     function burnOldTokens() public onlyOwner {\n678         uint256 _bal = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n679         IERC20Burnable(tokenAddress).burnFrom(address(this),_bal);\n680     }\n681 }\n446\n",
    "transaction-context": "require(_depositId >= 0, \"Value is not specified\");",
    "Critical-points": "require(pending > 0 ,\"No rewards to claim.\");",
    "invariants": "onlyRunnerScript",
    "critical-invariants": " require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");",
    "ranks": "require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");",
    "vulnerabilities": "require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {\n7     uint x;\n8     constructor (uint a) public {x = a;}\n9 }\n\n10 contract B is A {\n11     constructor (uint a) A(a) public {x++;}\n12 }    contract C is A, B {\n13     constructor (uint a) B(a) public {x++; \n14 }\n15 }\n",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+ ",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;\n10         confirmAt[_merkleRoot] = 1;\n11      }\n\n\n12  function process(bytes memory _message) \n13     public returns (bool _success) {\n14     assert(accept(messages[_msgHash]));\n15     }\n    \n16   function accept(bytes32 _root) \n17     public view returns (bool) {\n18     uint256 _time = confirmAt[_root];\n19      }\"        \"9+  assert(_merkleRoot != 0);\n17+ assert(_msgHash != 0);\n18+ assert(_root != 0);\"\n\"1     function _stETHTransferFrom(address from, address to, uint256 amount) internal returns () {      \n2         _asset.safeTransferFrom(from, to, amount);\n3       }\n4     }\n\n5     function _beforeWithdraw(uint256 shares) internal {\n6         lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n      \n7     }\n\n9+ \n",
    "transaction-context": "assert(_merkleRoot != 0);",
    "Critical-points": "assert(_msgHash != 0);",
    "invariants": "assert(_root != 0);",
    "critical-invariants": "require(amount > 0);\n",
    "ranks": "assert(lastRoundAssets > 0);",
    "vulnerabilities": "require(depositQueue.size()==1, \"Cannot process multiple deposits\");"
  },
  {
    "code": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {\n6         owner = msg.sender;\n7     }\n\n8     modifier onlyOwner {\n9         require(msg.sender == owner);\n10         _;\n11     }\n\n12     function transferOwnership(address newOwner) onlyOwner {\n13         owner = newOwner;\n14     }\n15 }\n\n16 contract PylonToken is owned {\n17     // Public variables of the token\n18     string public standard = \"Pylon Token - The first decentralized energy exchange platform powered by renewable energy\";\n19     string public name = 'Pylon Token';\n20     string public symbol = 'PYLNT';\n21     uint8 public decimals = 18;\n22     uint256 public totalSupply = 3750000000000000000000000;\n\n23     // This creates an array with all balances\n24     mapping (address => uint256) public balanceOf;\n25     mapping (address => bool) public frozenAccount;\n\n26     // This notifies about accounts locked\n27     event FrozenFunds(address target, bool frozen);\n\n28     // This generates a public event on the blockchain that will notify clients\n29     event Transfer(address indexed from, address indexed to, uint256 value);\n\n30     // This notifies clients about the amount burnt\n31     event Burn(address indexed from, uint256 value);\n\n32     using SafeMath for uint256;\n\n33     address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535;  //Chip-chap Klenergy Address of ether beneficiary account\n34     uint256 public fundingGoal = 21230434782608700000000;     // Foundig goal in weis = 21230,434782608700000000 Ethers\n35     uint256 public amountRaised;    // Quantity of weis investeds\n36     uint256 public deadline; // durationInMinutes * 60 / 17 + 5000;        // Last moment to invest\n37     uint256 public price = 6608695652173910;           // Ether cost of each token in weis 0,006608695652173910 ethers\n\n38     uint256 public totalTokensToSend = 3250000000000000000000000; // Total tokens offered in the total ICO\n\n39     uint256 public maxEtherInvestment = 826086956521739000000; //Ethers. To mofify the day when starts crowdsale, equivalent to 190.000\u20ac = 826,086956521739000000 ether\n40     uint256 public maxTokens = 297619047619048000000000; // 297,619.047619048000000000 PYLNT = 190.000 \u20ac + 56% bonus\n\n41     uint256 public bonusCap = 750000000000000000000000; // 750,000.000000000000000000 PYLNT last day before Crowdsale as 1,52\u20ac/token\n42     uint256 public pylonSelled = 0;\n\n43     uint256 public startBlockBonus;\n\n44     uint256 public endBlockBonus1;\n\n45     uint256 public endBlockBonus2;\n\n46     uint256 public endBlockBonus3;\n\n47     uint256 public qnt10k = 6578947368421050000000; // 6,578.947368421050000000 PYLNT = 10.000 \u20ac\n\n48     bool fundingGoalReached = false; // If founding goal is reached or not\n49     bool crowdsaleClosed = false;    // If crowdsale is closed or open\n\n50     event GoalReached(address deposit, uint256 amountDeposited);\n51     event FundTransfer(address backer, uint256 amount, bool isContribution);\n52     event LogQuantity(uint256 _amount, string _message);\n\n53     // Chequear\n54     uint256 public startBlock = getBlockNumber();\n\n55     bool public paused = false;\n\n56     //uint256 public balanceInvestor;\n57     //uint256 public ultimosTokensEntregados;\n\n58     modifier contributionOpen() {\n59         require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline);\n60         _;\n61     }\n\n62     modifier notPaused() {\n63         require(!paused);\n64         _;\n65     }\n\n66     function crowdsale() onlyOwner{\n67         paused = false;\n68     }\n\n69     event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value, uint256 amount);\n\n\n70     function PylonToken(\n71         uint256 initialSupply,\n72         string tokenName,\n73         uint8 decimalUnits,\n74         string tokenSymbol,\n75         address centralMinter,\n76         address ifSuccessfulSendTo,\n77         uint256 fundingGoalInWeis,\n78         uint256 durationInMinutes,\n79         uint256 weisCostOfEachToken\n80     ) {\n81         if (centralMinter != 0) owner = centralMinter;\n\n82         balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n83         totalSupply = initialSupply;                        // Update total supply\n84         name = tokenName;                                   // Set the name for display purposes\n85         symbol = tokenSymbol;                               // Set the symbol for display purposes\n86         decimals = decimalUnits;                            // Amount of decimals for display purposes\n\n87         beneficiary = ifSuccessfulSendTo;\n88         fundingGoal = fundingGoalInWeis;\n89         startBlock = getBlockNumber();\n90         startBlockBonus = getBlockNumber();\n91         endBlockBonus1 = getBlockNumber() + 15246 + 12600 + 500;    // 3 days + 35,5h + margen error = 15246 + 12600 + 500\n92         endBlockBonus2 = getBlockNumber() + 30492 + 12600 + 800;    // 6 days + 35,5h + margen error = 30492 + 12600 + 800\n93         endBlockBonus3 = getBlockNumber() + 45738 + 12600 + 1100;   // 9 days + 35,5h + margen error = 45738 + 12600 + 1100\n94         deadline = getBlockNumber() + (durationInMinutes * 60 / 17) + 5000; // durationInMinutes * 60 / 17 + 12600 + 5000 = Calculo bloques + margen error\n95         price = weisCostOfEachToken;\n96     }\n\n\n97     function _transfer(address _from, address _to, uint _value) internal {\n98         require(_to != 0x0);                             \n99         require(balanceOf[_from] >= _value);                \n100         require(balanceOf[_to] + _value > balanceOf[_to]);  \n101         require(!frozenAccount[_from]);                     \n102         require(!frozenAccount[_to]);                      \n103         balanceOf[_from] -= _value;                         \n104         balanceOf[_to] += _value;                          \n105         Transfer(_from, _to, _value);\n106     }\n\n\n107     function transfer(address _to, uint256 _value) {\n108         _transfer(msg.sender, _to, _value);\n109     }\n\n\n110     function burn(uint256 _value) onlyOwner returns (bool success) {\n111         require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n112         balanceOf[msg.sender] -= _value;            // Subtract from the sender\n113         totalSupply -= _value;                      // Updates totalSupply\n114         Burn(msg.sender, _value);\n115         return true;\n116     }\n\n  \n117     function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n118         require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n119         balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n120         totalSupply -= _value;                              // Update totalSupply\n121         Burn(_from, _value);\n122         return true;\n123     }\n\n\n124     function mintToken(address target, uint256 mintedAmount) onlyOwner {\n125         balanceOf[target] += mintedAmount;\n126         totalSupply += mintedAmount;\n127         Transfer(0, owner, mintedAmount);\n128         Transfer(owner, target, mintedAmount);\n129     }\n\n\n130     function freezeAccount(address target, bool freeze) onlyOwner {\n131         frozenAccount[target] = freeze;\n132         FrozenFunds(target, freeze);\n133     }\n\n\n134     function () payable notPaused{\n135         buyTokens(msg.sender);\n136     }\n\n137     // low level token purchase function\n138     function buyTokens(address investor) payable notPaused {\n139         require (!crowdsaleClosed); // Check if crowdsale is open or not\n140         require(investor != 0x0);  \n141         require(validPurchase()); \n142         require(maxEtherInvestment >= msg.value); \n143         require(balanceOf[investor] <= maxTokens); \n144         require(amountRaised <= fundingGoal); \n145         require(pylonSelled <= totalTokensToSend); \n\n\n146         //Check if It's time for pre ICO or ICO\n147         if(startBlockBonus <= getBlockNumber() && startBlock <= getBlockNumber() && endBlockBonus3 >= getBlockNumber() && pylonSelled <= bonusCap){\n148           buyPreIco(investor);\n149         } else if(deadline >= getBlockNumber()){\n150           buyIco(investor);\n151         }\n\n152     }\n\n153     function buyIco(address investor) internal{\n154       uint256 weiAmount = msg.value;\n\n155       // calculate token amount to be sent\n156       uint256 tokens = weiAmount.mul(10**18).div(price);\n\n157       require((balanceOf[investor] + tokens) <= maxTokens);    \n158       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n160      balanceOf[this] -= tokens;\n161       balanceOf[investor] += tokens;\n162       amountRaised += weiAmount; // update state amount raised\n163       pylonSelled += tokens; // Total tokens selled\n\n164       beneficiary.transfer(weiAmount); //Transfer ethers to beneficiary\n\n165       frozenAccount[investor] = true;\n166       FrozenFunds(investor, true);\n\n167       TokenPurchase(msg.sender, investor, weiAmount, tokens);\n168     }\n\n169     function buyPreIco(address investor) internal{\n170       uint256 weiAmount = msg.value;\n\n171       uint256 bonusPrice = 0;\n172       uint256 tokens = weiAmount.mul(10**18).div(price);\n\n173       if(endBlockBonus1 >= getBlockNumber()){\n174         if(tokens == qnt10k.mul(19) ){\n175           bonusPrice = 2775652173913040;\n176         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n177           bonusPrice = 2907826086956520;\n178         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n179           bonusPrice = 3040000000000000;\n180         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n181           bonusPrice = 3172173913043480;\n182         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n183           bonusPrice = 3304347826086960;\n184         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n185           bonusPrice = 3436521739130430;\n186         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n187           bonusPrice = 3568695652173910;\n188         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n189           bonusPrice = 3700869565217390;\n190         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n191           bonusPrice = 3833043478260870;\n192         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n193           bonusPrice = 3965217391304350;\n194         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n195           bonusPrice = 4097391304347830;\n196         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n197           bonusPrice = 4229565217391300;\n198         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n199           bonusPrice = 4361739130434780;\n200         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n201           bonusPrice = 4493913043478260;\n202         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n203           bonusPrice = 4626086956521740;\n204         }else{\n205           bonusPrice = 5286956521739130;\n206         }\n207       }else if(endBlockBonus2 >= getBlockNumber()){\n208         if(tokens == qnt10k.mul(19) ){\n209           bonusPrice = 3436521739130430;\n210         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n211           bonusPrice = 3568695652173910;\n212         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n213           bonusPrice = 3700869565217390;\n214         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n215           bonusPrice = 3833043478260870;\n216         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n217           bonusPrice = 3965217391304350;\n218         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n219           bonusPrice = 4097391304347830;\n220         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n221           bonusPrice = 4229565217391300;\n222         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n223           bonusPrice = 4361739130434780;\n224         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n225           bonusPrice = 4493913043478260;\n226         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n227           bonusPrice = 4626086956521740;\n228         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n229           bonusPrice = 4758260869565220;\n230         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n231           bonusPrice = 4890434782608700;\n232         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n233           bonusPrice = 5022608695652170;\n234         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n235           bonusPrice = 5154782608695650;\n236         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n237           bonusPrice = 5286956521739130;\n238         }else{\n239           bonusPrice = 5947826086956520;\n240         }\n241       }else{\n242         if(tokens == qnt10k.mul(19) ){\n243           bonusPrice = 3766956521739130;\n244         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n245           bonusPrice = 3899130434782610;\n246         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n247           bonusPrice = 4031304347826090;\n248         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n249           bonusPrice = 4163478260869570;\n250         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n251           bonusPrice = 4295652173913040;\n252         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n253           bonusPrice = 4427826086956520;\n254         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n255           bonusPrice = 4560000000000000;\n256         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n257           bonusPrice = 4692173913043480;\n258         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n259           bonusPrice = 4824347826086960;\n260         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n261           bonusPrice = 4956521739130430;\n262         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n263           bonusPrice = 5088695652173910;\n264         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n265           bonusPrice = 5220869565217390;\n266         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n267           bonusPrice = 5353043478260870;\n268         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n269           bonusPrice = 5485217391304350;\n270         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n271           bonusPrice = 5617391304347830;\n272         }else{\n273           bonusPrice = 6278260869565220;\n274         }\n275       }\n\n276       tokens = weiAmount.mul(10**18).div(bonusPrice);\n\n277       require(pylonSelled + tokens <= bonusCap); // Check if want to sell more than total tokens for pre-ico\n278       require(balanceOf[investor] + tokens <= maxTokens); // Check if the investor has more tokens than 5% of total supply\n279       require(balanceOf[this] >= tokens);             // checks if it has enough to sell\n\n280       balanceOf[this] -= tokens;\n281       balanceOf[investor] += tokens;\n282       amountRaised += weiAmount; // update state amount raised\n283       pylonSelled += tokens; // Total tokens selled\n\n284       beneficiary.transfer(weiAmount); //Transfer ethers to beneficiary\n\n285       frozenAccount[investor] = true;\n286       FrozenFunds(investor, true);\n\n287       TokenPurchase(msg.sender, investor, weiAmount, tokens);\n\n288     }\n\n289     modifier afterDeadline() { if (now >= deadline) _; }\n\n290     /**\n291      * Check if goal was reached\n292      *\n293      * Checks if the goal or time limit has been reached and ends the campaign\n294      */\n295     function checkGoalReached() afterDeadline onlyOwner {\n296         if (amountRaised >= fundingGoal){\n297             fundingGoalReached = true;\n298             GoalReached(beneficiary, amountRaised);\n299         }\n300         crowdsaleClosed = true;\n301     }\n\n\n302     // @return true if the transaction can buy tokens\n303     function validPurchase() internal constant returns (bool) {\n304         uint256 current = getBlockNumber();\n305         bool withinPeriod = current >= startBlock && current <= deadline;\n306         bool nonZeroPurchase = msg.value != 0;\n307         return withinPeriod && nonZeroPurchase;\n308     }\n\n309     //////////\n310     // Testing specific methods\n311     //////////\n\n312     /// @notice This function is overridden by the test Mocks.\n313     function getBlockNumber() internal constant returns (uint256) {\n314         return block.number;\n315     }\n\n316     /// @notice Pauses the contribution if there is any issue\n317     function pauseContribution() onlyOwner {\n318         paused = true;\n319     }\n\n320     /// @notice Resumes the contribution\n321     function resumeContribution() onlyOwner {\n322         paused = false;\n323     }\n324 }\n325 /**\n326  * @title SafeMath\n327  * @dev Math operations with safety checks that throw on error\n328  */\n329 library SafeMath {\n330   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n331     uint256 c = a * b;\n332     assert(a == 0 || c / a == b);\n333     return c;\n334   }\n\n335   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n336     // assert(b > 0); // Solidity automatically throws when dividing by 0\n337     uint256 c = a / b;\n338     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n339     return c;\n340   }\n\n341   function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n342     assert(b <= a);\n343     return a - b;\n344   }\n\n345   function add(uint256 a, uint256 b) internal constant returns (uint256) {\n346     uint256 c = a + b;\n347     assert(c >= a);\n348     return c;\n349   }\n350 }\n",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 12+         \n63+        \n101+                                    \n102+                 \n103+      \n104+                          \n105+      \n140+   \n141+ \n142+   \n143+     \n144+       \n145+         \n157+         \n158+           \n159+       \n277+       \n278+      \n332+     \n342+     \n347+     ",
    "invariants": "12+         require(msg.sender == owner);\n63+         require(!paused);\n101+         require(_to != 0x0);                             \n102+         require(balanceOf[_from] >= _value);                \n103+         require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+         require(!frozenAccount[_from]);                     \n105+         require(!frozenAccount[_to]);   \n140+         require(investor != 0x0);  \n141+         require(validPurchase()); \n142+         require(maxEtherInvestment >= msg.value); \n143+        require(balanceOf[investor] <= maxTokens); \n144+         require(amountRaised <= fundingGoal); \n145+         require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159+       require(pylonSelled + tokens <= totalTokensToSend);\n277+       require(pylonSelled + tokens <= bonusCap); \n278+      require(balanceOf[investor] + tokens <= maxTokens); \n332+    assert(a == 0 || c / a == b);\n342+     assert(b <= a);\n347+     assert(c >= a);",
    "critical-invariants": "63+         require(!paused);\n101+       require(_to != 0x0);                             \n102+       require(balanceOf[_from] >= _value);                \n103+       require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+       require(!frozenAccount[_from]);                     \n105+       require(!frozenAccount[_to]);   \n140+       require(investor != 0x0);  \n141+       require(validPurchase()); \n142+       require(maxEtherInvestment >= msg.value); \n143+       require(balanceOf[investor] <= maxTokens); \n144+       require(amountRaised <= fundingGoal); \n145+       require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n277       require(pylonSelled + tokens <= bonusCap); \n278       require(balanceOf[investor] + tokens <= maxTokens); ",
    "ranks": "63+         require(!paused);\n101+       require(_to != 0x0);                             \n102+       require(balanceOf[_from] >= _value);                \n103+       require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+       require(!frozenAccount[_from]);                     \n105+       require(!frozenAccount[_to]);   \n140+       require(investor != 0x0);  \n141+       require(validPurchase()); \n142+       require(maxEtherInvestment >= msg.value); \n143+       require(balanceOf[investor] <= maxTokens); \n144+       require(amountRaised <= fundingGoal); \n145+       require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n277       require(pylonSelled + tokens <= bonusCap); \n278       require(balanceOf[investor] + tokens <= maxTokens); ",
    "vulnerabilities": "incorrect visibility/ownership\ninteger overflow/underflow \narithmetic flaw \n"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Consts {\n\n4     constructor () public {\n5         uint a;\n6         address b;\n7         address c;\n\n8         a = 10;\n9         b = address(0x10);\n10       c = address(0x12);\n\n11     }\n12 }\n10+\n",
    "transaction-context": " assert(b != c);",
    "Critical-points": "assert (a == 1 || a == 2);\n",
    "invariants": "assert (a == 1 || a == 2);",
    "critical-invariants": " assert (sum == 1);",
    "ranks": "assert (c == _a + _b);",
    "vulnerabilities": "assert (c == _a - _b);"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;\n7     uint256 public              minBidStep           = 0.25 ether;\n\n8     uint256 public constant     buyNowPrice          = 15 ether;\n9     uint256 public constant     buyNowPriceUntilBid  = 14.75 ether;\n10     uint256 public              buyNowMultiplier     = 20; // 20 = x2\n11     bool    public              boughtNow;\n\n12     uint256 public              auctionDuration      = 24 hours;\n13     bool    public              auctionStarted;\n14     uint256 public              auctionStartTimestamp;\n15     bool    public              auctionEnded;\n16     uint256 public              auctionEndTimestamp;\n\n17     uint256 public              highestBid          = 0.9 ether;\n18     address public              highestBidder;\n19     uint256 public              totalSupply         = 0;\n    \n20     mapping(address => uint) public bids;\n21     mapping(address => bool) public projectProxy;\n\n22     mapping(address => bool) public hasAddressBidded;\n23     address[] bidAdresses;\n24     uint256 totalBidAddresses;\n    \n\n25     constructor() ERC721(\"FlippazOne\", \"FlippazOne\") {\n26         proxyRegistryAddress = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\n27         baseURI = \"ipfs://QmcrAKPLLZhLWDFA6wpiH9QGEz3wsmedZ4TYWM3vGyLPaX\";\n28     }\n\n29     function _baseURI() internal view override returns (string memory) {\n30         return baseURI;\n31     }\n\n32     function editBaseUri(string memory newUri) public onlyOwner{\n33         baseURI = newUri;\n34     }\n    \n35     /* Edit admin functions */\n36     function editBuyNowMultipler(uint256 newMultiplier) public onlyOwner{\n37         buyNowMultiplier = newMultiplier;\n38     }\n\n39     function editMinBidStep(uint256 newMinBidStep) public onlyOwner{\n40         minBidStep = newMinBidStep;\n41     }\n\n42     /// @param newDuration New auction duration in SECONDS\n43     function editDuration(uint256 newDuration) public onlyOwner{\n44         require(auctionStarted, \"Auction has not yet been started\");\n45         auctionEndTimestamp = auctionStartTimestamp + newDuration;\n46         auctionDuration = newDuration;\n47     }\n\n48     function isAuctionActive() public view returns(bool){\n49         if (auctionStarted){\n50             if (!auctionEnded){\n51                 return block.timestamp < auctionEndTimestamp;\n52             }\n53         }\n54         return false;\n55     }\n\n56     function startAuction() public onlyOwner{\n57         require(auctionStarted == false, \"Auction is already started\");\n58         auctionStarted = true;\n59         auctionStartTimestamp = block.timestamp;\n60         auctionEndTimestamp = block.timestamp + auctionDuration;\n61     }\n\n62     function getBidderPaidAmount(address bidder) public view returns(uint256){\n63         return bids[bidder];\n64     }\n\n65     function getBidderByIndex(uint256 bidderIndex) public view returns(address){\n66         return bidAdresses[bidderIndex];\n67     }\n\n    \n68     function bid() public payable {\n69         require(auctionStarted, \"Auction has not yet started\");\n70         require(!auctionEnded, \"Auction has been finished\");\n71         require(!boughtNow, \"Auction has been finished\");\n72         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n\n73         uint256 newBid = bids[_msgSender()] + msg.value;\n74         require(newBid >= highestBid + minBidStep, \"Bid must be at least 0.25 ETH higher than the highest bid\");\n\n75         bids[_msgSender()] += msg.value;\n76         highestBid = newBid;\n77         highestBidder = _msgSender();\n\n78         if (!hasAddressBidded[_msgSender()]){\n79             hasAddressBidded[_msgSender()] = true;\n80             totalBidAddresses++;\n81             bidAdresses.push(_msgSender());\n82         }\n    \n83     }\n\n84     function isBuyNowActive() public view returns(bool){\n85         if (auctionStarted){\n86             if (!auctionEnded){\n87                 if (!boughtNow){\n88                     if (block.timestamp < auctionEndTimestamp){\n89                             return true;\n90                     }\n91                 }\n92             }\n93         }\n94         return false;\n95     }\n\n96     function getBuyNowPrice() public view returns(uint256){\n97         if (highestBid < buyNowPriceUntilBid){\n98             return buyNowPrice;\n99         } else {\n100             uint256 newBuyNowPrice = highestBid * buyNowMultiplier / 10;\n101             return newBuyNowPrice;\n102         }\n103     }\n\n104     function buyNow() public payable {\n105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n108         require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n109         uint256 currentBuyPrice = getBuyNowPrice();\n110         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n        \n111         highestBid = currentBuyPrice;\n112         highestBidder = _msgSender();\n\n113         uint256 tokenId = _tokenIdCounter.current();\n114         _tokenIdCounter.increment();\n115         _mint(_msgSender(), tokenId);\n116         boughtNow = true;\n117         auctionEnded =  true;\n118         totalSupply = 1;\n119     }\n\n120     function endAuction() public {\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n124         uint256 tokenId = _tokenIdCounter.current();\n125         _tokenIdCounter.increment();\n        \n126         if (highestBidder != address(0)){\n127             _safeMint(highestBidder, tokenId);\n128         } else {\n129             _safeMint(owner(), tokenId);\n130         }\n131         totalSupply = 1;\n132         auctionEnded = true;\n133     }\n\n134     function refundBids() public {\n135         require(auctionEnded, \"Please end the auction firstly\");\n136         for (uint256 i = 0; i < totalBidAddresses; i++){\n137             uint256 addressTotalBid = bids[bidAdresses[i]];\n138             if ((addressTotalBid > 0) && (bidAdresses[i] != highestBidder)){\n139                 (bool success, ) = bidAdresses[i].call{value: addressTotalBid}(\"\");\n140                 bids[bidAdresses[i]] = 0;\n141             }\n142         }\n143     }\n\n144     function burn(uint256 tokenId) public { \n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n146         _burn(tokenId);\n147     }\n\n148     function ownerWithdraw() public  {\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n150         (bool success, ) = owner().call{value: highestBid}(\"\");\n151         require(success, \"Failed to withdraw funds.\");\n152     }\n\n153     function ownerWithdrawTo(address toAddress) public  {\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n155         (bool success, ) = toAddress.call{value: highestBid}(\"\");\n156         require(success, \"Failed to withdraw funds.\");\n157     }\n\n158     function ownerWithdrawAll() public  {\n159         (bool success, ) = owner().call{value: address(this).balance}(\"\");\n160         require(success, \"Failed to withdraw funds.\");\n161     }\n\n162     function ownerWithdrawAllTo(address toAddress) public  {\n163         (bool success, ) = toAddress.call{value: address(this).balance}(\"\");\n164         require(success, \"Failed to withdraw funds.\");\n165     }\n\n166     function bidderWithdraw() public  {\n167         uint256 totalBid = getBidderPaidAmount(_msgSender());\n168         require(totalBid > 0, \"Nothing to withdraw\");\n169         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n170         (bool success, ) = _msgSender().call{value: totalBid}(\"\");\n171         require(success, \"Failed to withdraw funds.\");\n172         bids[_msgSender()] = 0;\n173     }\n\n174     function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n175         super._burn(tokenId);\n176     }\n\n177     function tokenURI(uint256 tokenId)\n178         public\n179         view\n180         override(ERC721, ERC721URIStorage)\n181         returns (string memory)\n182     {\n183         require(_exists(tokenId), \"Token does not exist\");\n184         return _baseURI();\n185     }\n\n186     function isApprovedForAll(address _owner, address operator) public view override(ERC721) returns (bool) {\n187         OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(proxyRegistryAddress);\n188         if (address(proxyRegistry.proxies(_owner)) == operator || projectProxy[operator]) return true;\n189         return super.isApprovedForAll(_owner, operator);\n190     }\n191 }\n183\n",
    "transaction-context": " require(_exists(tokenId), \"Token does not exist\");",
    "Critical-points": " require(auctionStarted, \"Auction has not yet started\");\n require(!auctionEnded, \"Auction has been finished\");\n require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");",
    "invariants": " require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");",
    "critical-invariants": " require(auctionStarted, \"Auction has not yet started\");\n require(!auctionEnded, \"You cannot end the action again\");\n require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       ",
    "ranks": " require(auctionEnded, \"Please end the auction firstly\");",
    "vulnerabilities": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n5 import \"./Swapper.sol\";\n\n6 /**\n7  * @title Generic Swap Facet\n8  * @author Li.Finance (https://li.finance)\n9  * @notice Provides functionality for swapping through ANY DEX\n10  * @dev Uses calldata to execute arbitrary methods on DEXs\n11  */\n12 contract GenericSwapFacet is ILiFi, Swapper {\n13     /* ========== Public Functions ========== */\n\n14     /**\n15      * @notice Performs a swap and that's it\n16      * @param _lifiData data used purely for tracking and analytics\n17      * @param _swapData an array of swap related data for performing swaps before bridging\n18      */\n19     function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n20         uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n21         // Swap\n22         _executeSwaps(_lifiData, _swapData);\n\n23         uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n24         LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n25         emit LiFiTransferStarted(\n26             _lifiData.transactionId,\n27             _lifiData.integrator,\n28             _lifiData.referrer,\n29             _lifiData.sendingAssetId,\n30             _lifiData.receivingAssetId,\n31             _lifiData.receiver,\n32             _lifiData.amount,\n33             _lifiData.destinationChainId,\n34             block.timestamp\n35         );\n36     }\n37 }\n",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 20+ ",
    "invariants": "20+ require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");",
    "critical-invariants": "20+ require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");",
    "ranks": "20+ require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");",
    "vulnerabilities": "ether leakage;\nbusiness logic flaw; "
  },
  {
    "code": "1 pragma solidity ^0.6.0;\n2 pragma experimental ABIEncoderV2;\n\n3 import \"./BondingCurve.sol\";\n4 import \"../pcv/IPCVDeposit.sol\";\n\n5 /// @title a square root growth bonding curve for purchasing FEI with ETH\n6 /// @author Fei Protocol\n7 contract EthBondingCurve is BondingCurve {\n8     // solhint-disable-next-line var-name-mixedcase\n9     uint256 internal immutable SHIFT; // k shift\n\n10     constructor(\n11         uint256 scale,\n12         address core,\n13         address[] memory pcvDeposits,\n14         uint256[] memory ratios,\n15         address oracle,\n16         uint256 duration,\n17         uint256 incentive\n18     )\n19         public\n20         BondingCurve(\n21             scale,\n22             core,\n23             pcvDeposits,\n24             ratios,\n25             oracle,\n26             duration,\n27             incentive\n28         )\n29     {\n30         SHIFT = scale / 3; // Enforces a .50c starting price per bonding curve formula\n31     }\n\n32     /// @notice purchase FEI for underlying tokens\n33     /// @param to address to receive FEI\n34     /// @param amountIn amount of underlying tokens input\n35     /// @return amountOut amount of FEI received\n36     function purchase(address to, uint256 amountIn)\n37         external\n38         payable\n39         override\n40         postGenesis\n41         whenNotPaused\n42         returns (uint256 amountOut)\n43     {\n44         require(\n45             msg.value == amountIn,\n46             \"Bonding Curve: Sent value does not equal input\"\n47         );\n48         return _purchase(amountIn, to);\n49     }\n\n50     function getTotalPCVHeld() public view override returns (uint256) {\n51         return address(this).balance;\n52     }\n\n53     // Represents the integral solved for upper bound of P(x) = ((k+X)/(k+S))^1/2 * O. Subtracting starting point C\n54     function _getBondingCurveAmountOut(uint256 adjustedAmountIn)\n55         internal\n56         view\n57         override\n58         returns (uint256 amountOut)\n59     {\n60         uint256 shiftTotal = _shift(totalPurchased); // k + C\n61         uint256 shiftTotalCubed = shiftTotal.mul(shiftTotal.mul(shiftTotal));\n62         uint256 radicand =\n63             (adjustedAmountIn.mul(3).mul(_shift(scale).sqrt()) / 2).add(\n64                 shiftTotalCubed.sqrt()\n65             );\n66         return (radicand.cubeRoot() ** 2).sub(shiftTotal); // result - (k + C)\n67     }\n\n68     // Bonding curve formula is sqrt(k+x)/sqrt(k+S)\n69     function _getBondingCurvePriceMultiplier()\n70         internal\n71         view\n72         override\n73         returns (Decimal.D256 memory)\n74     {\n75         return\n76             Decimal.ratio(_shift(totalPurchased).sqrt(), _shift(scale).sqrt());\n77     }\n\n78     function _allocateSingle(uint256 amount, address pcvDeposit)\n79         internal\n80         override\n81     {\n82         IPCVDeposit(pcvDeposit).deposit{value: amount}(amount);\n83     }\n\n84     function _shift(uint256 x) internal view returns (uint256) {\n85         return SHIFT.add(x);\n86     }\n87 }\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 44",
    "invariants": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "critical-invariants": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "ranks": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "vulnerabilities": "healthy"
  },
  {
    "code": "\n1 pragma solidity ^0.4.2;\n2 contract owned {\n3     address public owner;\n\n4     function owned() {\n5         owner = msg.sender;\n6     }\n\n7     modifier onlyOwner {\n\n8         if (msg.sender != owner) throw;\n9         _;\n10     }\n\n11     function transferOwnership(address newOwner) onlyOwner {\n12         owner = newOwner;\n13     }\n14 }\n\n15 contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n16 contract token {\n17     /* Public variables of the token */\n18     string public standard = 'Token 0.1';\n19     string public name;\n20     string public symbol;\n21     uint8 public decimals;\n22     uint256 public totalSupply;\n\n23     /* This creates an array with all balances */\n24     mapping (address => uint256) public balanceOf;\n25     mapping (address => mapping (address => uint256)) public allowance;\n\n26     /* This generates a public event on the blockchain that will notify clients */\n27     event Transfer(address indexed from, address indexed to, uint256 value);\n\n28     /* Initializes contract with initial supply tokens to the creator of the contract */\n29     function token(\n30         uint256 initialSupply,\n31         string tokenName,\n32         uint8 decimalUnits,\n33         string tokenSymbol\n34         ) {\n35         balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n36         totalSupply = initialSupply;                        // Update total supply\n37         name = tokenName;                                   // Set the name for display purposes\n38         symbol = tokenSymbol;                               // Set the symbol for display purposes\n39         decimals = decimalUnits;                            // Amount of decimals for display purposes\n40     }\n\n41     function transfer(address _to, uint256 _value) {\n42         if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n43         if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n44         balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n45         balanceOf[_to] += _value;                            // Add the same to the recipient\n46         Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n47     }\n\n48     /* Allow another contract to spend some tokens in your behalf */\n49     function approve(address _spender, uint256 _value)\n50         returns (bool success) {\n51         allowance[msg.sender][_spender] = _value;\n52         return true;\n53     }\n\n\n54     function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n55         returns (bool success) {    \n56         tokenRecipient spender = tokenRecipient(_spender);\n57         if (approve(_spender, _value)) {\n58             spender.receiveApproval(msg.sender, _value, this, _extraData);\n59             return true;\n60         }\n61     }\n\n62     /* A contract attempts to get the coins */\n63     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n64         if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n65         if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n66         if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\n67         balanceOf[_from] -= _value;                          // Subtract from the sender\n68         balanceOf[_to] += _value;                            // Add the same to the recipient\n69         allowance[_from][msg.sender] -= _value;\n70         Transfer(_from, _to, _value);\n71         return true;\n72     }\n\n73     /* This unnamed function is called whenever someone tries to send ether to it */\n74     function () {\n75         throw;     // Prevents accidental sending of ether\n76     }\n77 }\n\n78 contract SwftCoin is owned, token {\n\n79     uint256 public sellPrice;\n80     uint256 public buyPrice;\n\n81     mapping (address => bool) public frozenAccount;\n\n\n82     event FrozenFunds(address target, bool frozen);\n\n83     /* Initializes contract with initial supply tokens to the creator of the contract */\n84     function SwftCoin(\n85         uint256 initialSupply,\n86         string tokenName,\n87         uint8 decimalUnits,\n88         string tokenSymbol\n89     ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}\n\n90     /* Send coins */\n91     function transfer(address _to, uint256 _value) {\n92         if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n93         if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n94         if (frozenAccount[msg.sender]) throw;                // Check if frozen\n95         balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n96         balanceOf[_to] += _value;                            // Add the same to the recipient\n97         Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n98     }\n\n99     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n100         if (frozenAccount[_from]) throw;                        // Check if frozen            \n101         if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n102         if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n103         if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\n104         balanceOf[_from] -= _value;                          // Subtract from the sender\n105         balanceOf[_to] += _value;                            // Add the same to the recipient\n106         allowance[_from][msg.sender] -= _value;\n107         Transfer(_from, _to, _value);\n108         return true;\n109     }\n\n110     function mintToken(address target, uint256 mintedAmount) onlyOwner {\n111         balanceOf[target] += mintedAmount;\n112         totalSupply += mintedAmount;\n113         Transfer(0, this, mintedAmount);\n114         Transfer(this, target, mintedAmount);\n115     }\n\n116     function freezeAccount(address target, bool freeze) onlyOwner {\n117         frozenAccount[target] = freeze;\n118         FrozenFunds(target, freeze);\n119     }\n\n120     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\n121         sellPrice = newSellPrice;\n122         buyPrice = newBuyPrice;\n123     }\n\n124     function buy() payable {\n125         uint amount = msg.value / buyPrice;                // calculates the amount\n126         if (balanceOf[this] < amount) throw;               // checks if it has enough to sell\n127         balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance\n128         balanceOf[this] -= amount;                         // subtracts amount from seller's balance\n129         Transfer(this, msg.sender, amount);                // execute an event reflecting the change\n130     }\n\n131     function sell(uint256 amount) {\n132         if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\n133         balanceOf[this] += amount;                         // adds the amount to owner's balance\n134         balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance\n135         if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important\n136             throw;                                         // to do this last to avoid recursion attacks\n137         } else {\n138             Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\n139         }               \n140     }\n141 }\n125+\n",
    "transaction-context": "assert(balanceOf[this] >= amount)",
    "Critical-points": "assert(balanceOf[msg.sender] >= amount );",
    "invariants": "assert(!disabled);",
    "critical-invariants": "assert(!disabled);  \nassert(balances[_from] >= _value);\nassert(allowed[_from][msg.sender] >= _value && _value > 0);",
    "ranks": "assert(msg.sender == owner);",
    "vulnerabilities": "assert(msg.sender == owner);"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n9 import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n10 import \"./interfaces/IPancakePair.sol\";\n11 import \"./interfaces/IPancakeFactory.sol\";\n12 import \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\n13 import \"./interfaces/IGymLevelPool.sol\";\n14 import \"./interfaces/IGymSinglePool.sol\";\n15 /* preserved Line */\n16 /* preserved Line */\n17 /* preserved Line */\n18 /* preserved Line */\n19 /* preserved Line */\n\n20 /**\n21  * @notice GymSinglePool contract:\n22  * - Users can:\n23  *   # Deposit GYMNET\n24  *   # Withdraw assets\n25  */\n\n26 contract GymSinglePool is ReentrancyGuardUpgradeable, OwnableUpgradeable {\n27     using SafeERC20Upgradeable for IERC20Upgradeable;\n\n28    /**\n29      * @notice Info of each user\n30      * One Address can have many Deposits with different periods. Unlimited Amount.\n31      * Total Depsit Tokens = Total amount of user active stake in all.\n32      * Total Depsit Dollar Value = Total Dollar Value over all staking single pools. Calculated when user deposits tokens, and dollar value is for that exact moment rate.\n33      * level = level qualification for this pool. Used internally, for global qualification please check MLM Contract.\n34      * depositId = incremental ID of deposits, eg. if user has 3 stakings then this value will be 2;\n35      * totalClaimt = Total amount of tokens user claimt. \n36      */\n37     struct UserInfo {\n38         uint256 totalDepositTokens;\n39         uint256 totalDepositDollarValue;\n40         uint256 level;\n41         uint256 depositId;\n42         uint256 totalClaimt;\n43     }\n\n44    /** \n45      * @notice Info for each staking by ID\n46      * One Address can have many Deposits with different periods. Unlimited Amount.\n47      * depositTokens = amount of tokens for exact deposit.\n48      * depositDollarValue = Dollar value of deposit.\n49      * stakePeriod = Locking Period - from 3 months to 30 months. value is integer\n50      * depositTimestamp = timestamp of deposit\n51      * withdrawalTimestamp = Timestamp when user can withdraw his locked tokens\n52      * rewardsGained = amount of rewards user has gained during the process\n53      * is_finished = checks if user has already withdrawn tokens\n54      */\n55     struct UserDeposits {\n56         uint256 depositTokens;\n57         uint256 depositDollarValue;\n58         uint256 stakePeriod;\n59         uint256 depositTimestamp;\n60         uint256 withdrawalTimestamp;\n61         uint256 rewardsGained;\n62         uint256 rewardsClaimt;\n63         uint256 rewardDebt;\n64         bool is_finished;\n65     }\n66     /**\n67      * @notice Info of Pool\n68      * @param lastRewardBlock: Last block number that reward distribution occurs\n69      * @param accUTacoPerShare: Accumulated rewardPool per share, times 1e18\n70      * @param rewardPerBlock: How many reward tokens will user get per block\n71      */\n72     struct PoolInfo {\n73         uint256 lastRewardBlock;\n74         uint256 accRewardPerShare;\n75         uint256 rewardPerBlock;\n76     }\n\n77     /// Startblock number\n78     uint256 public startBlock;\n79     uint256 public withdrawFee;\n\n80      // MLM Contract - RelationShip address\n81     address public relationship;\n82     /// Treasury address where will be sent all unused assets\n83     address public treasuryAddress;\n84     /// Info of pool.\n85     PoolInfo public poolInfo;\n86     /// Info of each user that staked tokens.\n87     mapping(address => UserInfo) public userInfo;\n\n88     /// accepts user address and id of element to select - returns information about selected staking by id\n89     mapping (address=>UserDeposits[]) public user_deposits;\n\n90     uint256 private lastChangeBlock;\n\n91     /// GYMNET token contract address\n92     address public tokenAddress;\n\n93     /// address of pancake Router\n94     address public pancakeRouterAddress;\n95     /// WBNB and BUSD Token Pair address, element 0 = Address of WBNB Token, element 1= Address of GYMNET \n96     address[] public wbnbAndUSDTTokenArray;\n97     /// GYMNET and WBNB Token Pair address, element 0 = Address of GYMNET, element 1 = Address of WBNB Token, \n98     address[] public GymWBNBPair;\n\n99     /// Level Qualifications for the pool\n100     uint256[16] public levels;\n101     /// Locking Periods \n102     uint256[6] public months;\n\n103     /// Amount of Total GYMNET Locked in the pool\n104     uint256 public totalGymnetLocked;\n\n105     /// Amount of GYMNET all users has claimt over time.\n106     uint256 public totalClaimtInPool;\n\n107     /// Percent that will be sent to MLM Contract for comission distribution\n108     uint256 public RELATIONSHIP_REWARD;\n\n109     /// 6% comissions\n110     uint256 public poolRewardsAmount;\n\n111     address public holderRewardContractAddress;\n\n112     address public runnerScriptAddress;\n113     uint256 public totalBurntInSinglePool;\n114     bool public isPoolActive;\n115     bool public isInMigrationToVTwo;\n116     uint256 public totalGymnetUnlocked;\n117     uint256 public unlockedTimestampQualification;\n118     address public vaultContractAddress;\n119     address public farmingContractAddress;\n\n120     address public levelPoolContractAddress;\n121     address public newSinglePoolAddress;\n\n122     /* ========== EVENTS ========== */\n\n123     event Initialized(address indexed executor, uint256 at);\n124     event Deposit(address indexed user, uint256 amount,uint indexed period);\n125     event Withdraw(address indexed user, uint256 amount,uint indexed period);\n126     event RewardPaid(address indexed token, address indexed user, uint256 amount);\n127     event ClaimUserReward(address indexed user, uint256 amount);\n\n\n128     modifier onlyRunnerScript() {\n129         require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n130         _;\n131     }\n132     modifier onlyBank() {\n133         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n134         _;\n135     }\n136     receive() external payable {}\n\n137     fallback() external payable {}\n\n138 // all initialize parameters are mandatory\n139     function initialize(\n140         uint256 _startBlock,\n141         address _gym,\n142         address _mlm,\n143         uint256 _gymRewardRate,\n144         address _pancakeRouterAddress,\n145         address[] memory _wbnbAndUSDTTokenArray,\n146         address[] memory _GymWBNBPair\n147     ) external initializer {\n148         require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n\n149         startBlock = _startBlock; // Number of Upcoming Block\n150         relationship = _mlm;  // address of MLM contract\n151         tokenAddress = _gym; // address of GYMNET Contract\n152         pancakeRouterAddress = _pancakeRouterAddress; // Address of Pancake Router\n153         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray; // WBNB And USDT Token Addresses [WBNB,USDT]\n154         GymWBNBPair = _GymWBNBPair; // GYMNET And WBNB Token Addresses [GYMNET,WBNB]\n155         runnerScriptAddress = msg.sender;\n156         isPoolActive = false;\n157         isInMigrationToVTwo = false;\n158         RELATIONSHIP_REWARD = 39; // Relationship commission amount\n159         levels = [0, 0, 200, 200, 2000, 4000, 10000, 20000, 40000, 45000, 50000, 60000, 65000, 70000, 75000, 80000]; // Internal Pool Levels\n160         months = [3, 6, 12, 18, 24, 30]; // Locking Periods\n\n161         poolInfo = PoolInfo({\n162                 lastRewardBlock: _startBlock,\n163                 rewardPerBlock: _gymRewardRate,\n164                 accRewardPerShare: 0\n165             });\n\n166         lastChangeBlock = _startBlock;\n\n167         __Ownable_init();\n168         __ReentrancyGuard_init();\n        \n169         emit Initialized(msg.sender, block.number);\n170     }\n\n\n171     function setPoolInfo(uint256 lastRewardBlock,uint256 accRewardPerShare, uint256 rewardPerBlock) external onlyOwner {\n172         poolInfo = PoolInfo({\n173                 lastRewardBlock: lastRewardBlock,\n174                 accRewardPerShare: accRewardPerShare,\n175                 rewardPerBlock: rewardPerBlock\n176             });\n177     }\n\n178     function updateStartBlock(uint256 _startBlock) external onlyOwner {\n179         startBlock = _startBlock;\n180     }\n\n181     function setMLMAddress(address _relationship) external onlyOwner {\n182         relationship = _relationship;\n183     }\n\n184     function setTokenAddress(address _tokenAddress) external onlyOwner {\n185         tokenAddress = _tokenAddress;\n186     }\n187     function setVaultContractAddress(address _vaultContractAddress) external onlyOwner {\n188         vaultContractAddress = _vaultContractAddress;\n189     }\n190     function setFarmingContractAddress(address _farmingContractAddress) external onlyOwner {\n191         farmingContractAddress = _farmingContractAddress;\n192     }\n\n193     function setLevelPoolContractAddress(address _levelPoolContractAddress) external onlyOwner {\n194         levelPoolContractAddress = _levelPoolContractAddress;\n195     }\n\n196     function setRelationshipReward(uint256 _amount) external onlyOwner {\n197         RELATIONSHIP_REWARD = _amount;\n198     }\n199     function setOnlyRunnerScript(address _onlyRunnerScript) external onlyOwner {\n200         runnerScriptAddress = _onlyRunnerScript;\n201     }\n202     function setNewSinglePoolAddress(address _newSinglePoolAddress) external onlyOwner {\n203         newSinglePoolAddress = _newSinglePoolAddress;\n204     }\n\n205     function setGymWBNBPair(address[] memory  _GymWBNBPair) external onlyOwner {\n206         GymWBNBPair = _GymWBNBPair;\n207     }\n208     function setPancakeRouterAddress(address _pancakeRouterAddress) external onlyOwner {\n209         pancakeRouterAddress = _pancakeRouterAddress;\n210     }\n\n211     function setIsPoolActive(bool _isPoolActive) external onlyOwner {\n212         isPoolActive = _isPoolActive;\n213     }\n214     function setIsInMigrationToVTwo(bool _isInMigrationToVTwo) external onlyOwner {\n215         isInMigrationToVTwo = _isInMigrationToVTwo;\n216     }\n\n217     function setHolderRewardContractAddress(address _holderRewardContractAddress) external onlyOwner {\n218         holderRewardContractAddress = _holderRewardContractAddress;\n219     }\n\n\n220     function setWbnbAndUSDTTokenArray(address[] memory _wbnbAndUSDTTokenArray) external onlyOwner {\n221         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray;\n222     }\n223     function setUnlockedTimestampQualification(uint256 _unlockedTimestampQualification) external onlyOwner {\n224         unlockedTimestampQualification = _unlockedTimestampQualification;\n225     }\n226     function setLevels(uint256[16] calldata _levels) external onlyOwner {\n227         levels = _levels;\n228     }\n\n229      /**\n230      * @notice  Function to set Treasury address\n231      * @param _treasuryAddress Address of treasury address\n232      */\n233     function setTreasuryAddress(address _treasuryAddress) external nonReentrant onlyOwner {\n234         treasuryAddress = _treasuryAddress;\n235     }\n\n236     /**\n237      * @notice Deposit in given pool\n238      * @param _depositAmount: Amount of want token that user wants to deposit\n239      */\n240     function deposit(\n241         uint256 _depositAmount,\n242         uint8 _periodId,\n243         uint256 _referrerId,\n244         bool isUnlocked\n245     ) external  {\n246         require(isPoolActive,'Contract is not running yet');\n247         IGymMLM(relationship).addGymMLM(msg.sender, _referrerId);\n248         _deposit(_depositAmount,_periodId,isUnlocked);\n249     }\n250     /**\n251      * @notice Deposit in given pool\n252      * @param _depositAmount: Amount of want token that user wants to deposit\n253      */\n254     function depositFromOtherContract(\n255         uint256 _depositAmount,\n256         uint8 _periodId,\n257         bool isUnlocked,\n258         address _from\n259     ) external onlyBank {\n260         require(isPoolActive,'Contract is not running yet');\n261         _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n\n262         _updateLevelPoolQualification(_from);\n263     }\n\n264     /**\n265      * @notice To get User level in other contract for single pool.\n266      * @param _user: User address\n267      */\n268     function getUserLevelInSinglePool(address _user) external view returns (uint32) {\n269         uint256 _totalDepositDollarValue = userInfo[_user].totalDepositDollarValue;\n270         uint32 level = 0;\n271         for (uint32 i = 0; i<levels.length ; i++) {\n272             if(_totalDepositDollarValue >= levels[i]) {\n273                 level=i;\n274             }\n275         }\n276         return level;\n277     }\n\n278     /**\n279     Should approve allowance before initiating\n280     accepts depositAmount in WEI\n281     periodID - id of months array accordingly\n282     */\n283     function _deposit(\n284         uint256 _depositAmount,\n285         uint8 _periodId,\n286         bool _isUnlocked\n287     ) private {\n288         UserInfo storage user = userInfo[msg.sender];\n289         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n290         PoolInfo storage pool = poolInfo;\n291         updatePool();\n\n292         uint256 period = months[_periodId];\n293         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n294         uint256 burnTokensAmount = 0;\n\n295         if(!_isUnlocked) {\n296             burnTokensAmount = (_depositAmount * 4) / 100;\n297             totalBurntInSinglePool += burnTokensAmount;\n298             IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n299         }\n\n        \n300         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n\n301         token.safeTransferFrom(msg.sender, address(this), amountToDeposit);\n302         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n303         user.totalDepositTokens += amountToDeposit;\n304         user.totalDepositDollarValue += UsdValueOfGym;\n305         totalGymnetLocked += amountToDeposit;\n306         if(_isUnlocked) {\n307             totalGymnetUnlocked += amountToDeposit;\n308             period = 0; \n309             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n310         }\n\n311         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n312         UserDeposits memory depositDetails = UserDeposits(\n313             {\n314                 depositTokens: amountToDeposit, \n315                 depositDollarValue: UsdValueOfGym,\n316                 stakePeriod: period,\n317                 depositTimestamp: block.timestamp,\n318                 withdrawalTimestamp: lockTimesamp,\n319                 rewardsGained: 0,\n320                 is_finished: false,\n321                 rewardsClaimt: 0,\n322                 rewardDebt: rewardDebt\n323             }\n324         );\n\n325         user_deposits[msg.sender].push(depositDetails);\n326         user.depositId = user_deposits[msg.sender].length;\n        \n\n327        for (uint i = 0; i<levels.length ; i++) {\n328             if(user.totalDepositDollarValue >= levels[i]) {\n329                 user.level=i;\n330             }\n331         }\n332         _updateLevelPoolQualification(msg.sender);\n333         emit Deposit(msg.sender, _depositAmount,_periodId);\n334     }\n\n335      /**\n336     Should approve allowance before initiating\n337     accepts depositAmount in WEI\n338     periodID - id of months array accordingly\n339     */\n340     function _autoDeposit(\n341         uint256 _depositAmount,\n342         uint8 _periodId,\n343         bool _isUnlocked,\n344         address _from\n345     ) private {\n346         UserInfo storage user = userInfo[_from];\n347         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n348         PoolInfo storage pool = poolInfo;\n349         token.approve(address(this), _depositAmount);\n350         updatePool();\n351         uint256 period = months[_periodId];\n352         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n353         uint256 burnTokensAmount = 0;\n354         // if(!_isUnlocked) {\n355         //     uint256 burnTokensAmount = (_depositAmount * 4) / 100;\n356         //     totalBurntInSinglePool += burnTokensAmount;\n357         //     IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n358         // }\n359         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n360         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n361         user.totalDepositTokens += amountToDeposit;\n362         user.totalDepositDollarValue += UsdValueOfGym;\n363         totalGymnetLocked += amountToDeposit;\n364         if(_isUnlocked) {\n365             totalGymnetUnlocked += amountToDeposit;\n366             period = 0; \n367             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n368         }\n\n369         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n370         UserDeposits memory depositDetails = UserDeposits(\n371             {\n372                 depositTokens: amountToDeposit, \n373                 depositDollarValue: UsdValueOfGym,\n374                 stakePeriod: period,\n375                 depositTimestamp: block.timestamp,\n376                 withdrawalTimestamp: lockTimesamp,\n377                 rewardsGained: 0,\n378                 is_finished: false,\n379                 rewardsClaimt: 0,\n380                 rewardDebt: rewardDebt\n381             }\n382         );\n383         user_deposits[_from].push(depositDetails);\n384         user.depositId = user_deposits[_from].length;\n \n385         emit Deposit(_from, amountToDeposit,_periodId);\n386     }\n\n387      /**\n388      * Returns the latest price\n389      */\n390     function getPrice () public view returns (uint) {\n391         uint256[] memory gymPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1000000000000000000,GymWBNBPair);\n392         uint256[] memory BNBPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1, wbnbAndUSDTTokenArray);\n393         return gymPriceInUSD[1] * BNBPriceInUSD[1];\n394     }\n\n\n395     /**\n396      * @notice withdraw one claim\n397      * @param _depositId: is the id of user element. \n398      */\n399     function withdraw(\n400         uint256 _depositId\n401     ) external  {\n402         require(_depositId >= 0, \"Value is not specified\");\n403         updatePool();\n404         _withdraw(_depositId);\n\n405         _updateLevelPoolQualification(msg.sender);\n406     }\n\n407     /**\n408     Should approve allowance before initiating\n409     accepts _depositId - is the id of user element. \n410     */\n411     function _withdraw(\n412             uint256 _depositId\n413         ) private {\n414             UserInfo storage user = userInfo[msg.sender];\n415             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n416             PoolInfo storage pool = poolInfo;\n417             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n418             if(!isInMigrationToVTwo) {\n419                 require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n420             }\n421             require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n\n422             _claim(_depositId,1);\n423             depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n\n424             user.totalDepositTokens -=  depositDetails.depositTokens;\n425             user.totalDepositDollarValue -=  depositDetails.depositDollarValue;\n426             totalGymnetLocked -= depositDetails.depositTokens;\n427             if(depositDetails.stakePeriod == 0) {\n428                 totalGymnetUnlocked -= depositDetails.depositTokens;\n429             }\n            \n430             token.safeTransferFrom(address(this),msg.sender, depositDetails.depositTokens);\n\n431             for (uint i = 0; i<levels.length ; i++) {\n432                 if(user.totalDepositDollarValue >= levels[i]) {\n433                     user.level=i;\n434                 }\n435             }\n436             depositDetails.is_finished = true;\n437             emit Withdraw(msg.sender,  depositDetails.depositTokens,depositDetails.stakePeriod);\n\n\n438         }\n\n\n439     /**\n440      * @notice Claim rewards you gained over period\n441      * @param _depositId: is the id of user element. \n442      */\n443     function claim(\n444         uint256 _depositId\n445     ) external  {\n446         require(_depositId >= 0, \"Value is not specified\");\n447         updatePool();\n448         refreshMyLevel(msg.sender);\n449         _claim(_depositId,0);\n450     }\n\n451    /*\n452     Should approve allowance before initiating\n453     accepts _depositId - is the id of user element. \n454     */\n455     function _claim(\n456             uint256 _depositId,\n457             uint256 fromWithdraw\n458         ) private {\n459             UserInfo storage user = userInfo[msg.sender];\n460             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n461             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n462             PoolInfo storage pool = poolInfo;\n\n463             uint256 pending = pendingReward(_depositId,msg.sender);\n\n464             if(fromWithdraw == 0) {\n465                 require(pending > 0 ,\"No rewards to claim.\");\n466             }\n\n\n467             if (pending > 0) {\n468                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n469                 token.safeTransfer(relationship, distributeRewardTokenAmt);\n470                 IGymMLM(relationship).distributeRewards(pending, address(tokenAddress), msg.sender, 3);\n\n471                 // 6% distribution \n472                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n473                 poolRewardsAmount += calculateDistrubutionReward; \n                \n474                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n475                 safeRewardTransfer(tokenAddress, msg.sender, calcUserRewards);\n\n476                 user.totalClaimt += calcUserRewards;\n477                 totalClaimtInPool += pending;\n478                 depositDetails.rewardsClaimt += pending;\n479                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n480                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n481                  depositDetails.rewardsGained = 0;\n482             }\n            \n483             // token.safeTransferFrom(address(this),msg.sender, depositDetails.rewardsGained);\n\n484         }\n\n\n      \n485    /*\n486     transfers pool commisions to management\n487     */\n488     function transferPoolRewards() public onlyRunnerScript {\n489             require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n490             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n491             token.safeTransfer(holderRewardContractAddress, poolRewardsAmount);\n492             // token.safeTransfer(relationship, poolRewardsAmount/2);\n493             poolRewardsAmount = 0;\n494         }  \n\n\n495     /**\n496      * @notice  Safe transfer function for reward tokens\n497      * @param _rewardToken Address of reward token contract\n498      * @param _to Address of reciever\n499      * @param _amount Amount of reward tokens to transfer\n500      */\n501     function safeRewardTransfer(\n502         address _rewardToken,\n503         address _to,\n504         uint256 _amount\n505     ) internal {\n506         uint256 _bal = IERC20Upgradeable(_rewardToken).balanceOf(address(this));\n507         if (_amount > _bal) {\n508             require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n509         } else {\n510             require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n511         }\n512     }\n513     /**\n514      * @notice To get User Info in other contract.\n515      */\n516     function getUserInfo(address _user) external view returns (UserInfo memory) {\n517         return userInfo[_user];\n518     }\n\n519         /**\n520      * @notice View function to see pending reward on frontend.\n521      * @param _depositId: Staking pool id\n522      * @param _user: User address\n523      */\n524     function pendingReward(uint256 _depositId, address _user) public view returns (uint256) {\n525         UserDeposits storage depositDetails = user_deposits[_user][_depositId];\n526         UserInfo storage user = userInfo[_user];\n527         PoolInfo storage pool = poolInfo;\n528         if(depositDetails.is_finished == true || depositDetails.stakePeriod == 0){\n529             return 0;\n530         }\n      \n531         uint256 _accRewardPerShare = pool.accRewardPerShare;\n532         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n\n533         if (block.number > pool.lastRewardBlock && sharesTotal != 0) {\n534             uint256 _multiplier = block.number - pool.lastRewardBlock;\n535             uint256 _reward = (_multiplier * pool.rewardPerBlock);\n536              _accRewardPerShare = _accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n537         }\n\n538         return (depositDetails.depositTokens * _accRewardPerShare) / (1e18) - (depositDetails.rewardDebt);\n539     }\n\n\n540     /**\n541      * @notice Update reward variables of the given pool to be up-to-date.\n542      */\n543     function updatePool() public {\n544         PoolInfo storage pool = poolInfo;\n545         if (block.number <= pool.lastRewardBlock) {\n546             return;\n547         }\n548         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n549         if (sharesTotal == 0) {\n550             pool.lastRewardBlock = block.number;\n551             return;\n552         }\n553         uint256 multiplier = block.number - pool.lastRewardBlock;\n554         if (multiplier <= 0) {\n555             return;\n556         }\n557         uint256 _rewardPerBlock = pool.rewardPerBlock;\n558         uint256 _reward = (multiplier * _rewardPerBlock);\n559         pool.accRewardPerShare = pool.accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n560         pool.lastRewardBlock = block.number;\n561     }\n562     /**\n563      * @notice Claim All Rewards in one Transaction Internat Function.\n564      * If reinvest = true, Rewards will be reinvested as a new Staking\n565      * Reinvest Period Id is the id of months element\n566      */\n567     function _claimAll(bool reinvest,uint8 reinvestPeriodId) private {\n568         UserInfo storage user = userInfo[msg.sender];\n569         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n570         PoolInfo storage pool = poolInfo;\n571          updatePool();\n572          uint256 distributeRewardTokenAmtTotal = 0;\n573          uint256 calcUserRewardsTotal = 0;\n574          uint256 totalDistribute = 0;\n575         for (uint256 i = 0; i<user.depositId ; i++) {\n576             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n577             uint256 pending = pendingReward(i,msg.sender);\n578             totalDistribute += pending;\n579             if (pending > 0) {\n580                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n581                  distributeRewardTokenAmtTotal += distributeRewardTokenAmt;\n582                 // 6% distribution \n583                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n584                 poolRewardsAmount += calculateDistrubutionReward; \n                \n585                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n586                 calcUserRewardsTotal += calcUserRewards;\n\n587                 user.totalClaimt += calcUserRewards;\n588                 totalClaimtInPool += pending;\n589                 depositDetails.rewardsClaimt += pending;\n590                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n591                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n592                  depositDetails.rewardsGained = 0;\n593             }\n            \n594         }\n595         token.safeTransfer(relationship, distributeRewardTokenAmtTotal);\n596         IGymMLM(relationship).distributeRewards(totalDistribute, address(tokenAddress), msg.sender, 3);\n597         safeRewardTransfer(tokenAddress, msg.sender, calcUserRewardsTotal);\n598         if(reinvest == true) {\n599           _deposit(calcUserRewardsTotal,reinvestPeriodId,false);\n600         }\n601     }\n602     /**\n603      * @notice Claim All Rewards in one Transaction.\n604      */\n605     function claimAll() public {\n606          refreshMyLevel(msg.sender);\n607         _claimAll(false,0);\n608     }\n609     /**\n610      * @notice Claim and Reinvest all rewards public function to trigger internal _claimAll function.\n611      */\n612     function claimAndReinvest(bool reinvest,uint8 periodId) public {\n613         require(isPoolActive,'Contract is not running yet');\n614         _claimAll(reinvest,periodId);\n615     }\n\n616     function refreshMyLevel(address _user) public {\n617         UserInfo storage user = userInfo[_user];\n618         for (uint i = 0; i<levels.length ; i++) {\n619             if(user.totalDepositDollarValue >= levels[i]) {\n620                 user.level=i;\n621             }\n622         }\n623     }\n624     function totalLockedTokens(address _user) public view returns (uint256) {\n625         UserInfo storage user = userInfo[_user];\n626         uint256 totalDepositLocked = 0;\n627         for (uint256 i = 0; i<user.depositId ; i++) {\n628             UserDeposits storage depositDetails = user_deposits[_user][i];\n629             if(depositDetails.stakePeriod != 0 && !depositDetails.is_finished) {\n630                 totalDepositLocked += depositDetails.depositTokens;\n631             } \n632         }\n633         return totalDepositLocked;\n634     }\n\n635     function switchToUnlocked(uint256 _depositId) public {\n636         UserInfo storage user = userInfo[msg.sender];\n637         UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n639         _claim(_depositId,1);\n640         uint256 lockTimesamp = DateTime.addSeconds(block.timestamp,1);\n\n641         depositDetails.stakePeriod = 0;\n642         depositDetails.withdrawalTimestamp = lockTimesamp;\n643         totalGymnetUnlocked += depositDetails.depositTokens;\n\n644     }\n\n645     function _updateLevelPoolQualification(address wallet) internal {\n646         uint256 userLevel = IGymMLM(relationship).getUserCurrentLevel(wallet);\n647         IGymLevelPool(levelPoolContractAddress).updateUserQualification(wallet, userLevel);\n648     }\n\n649     function transferToV2(uint8 _periodId,bool isUnlocked) public {\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n651         UserInfo storage user = userInfo[msg.sender];\n652          require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');\n653          if(isUnlocked) {\n654             _periodId = 0;\n655          }\n656         _claimAll(false,0);\n657         uint256 dollarValueOfDeposits = user.totalDepositDollarValue * 1e18;\n658         IGymSinglePool(newSinglePoolAddress).transferFromOldVersion(\n659              user.totalDepositTokens,\n660              _periodId,\n661              isUnlocked,\n662              msg.sender,\n663              dollarValueOfDeposits\n664         );\n665         for (uint32 i = 0; i<user.depositId ; i++) {\n666             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n667             depositDetails.depositTokens = 0;\n668             depositDetails.is_finished = true;\n669             totalGymnetLocked -= depositDetails.depositTokens;\n670             if(depositDetails.stakePeriod == 0) {\n671                 totalGymnetUnlocked -= depositDetails.depositTokens;\n672             }\n673         }\n\n674         user.totalDepositDollarValue = 0;\n675         user.totalDepositTokens = 0;\n\n676     }\n677     function burnOldTokens() public onlyOwner {\n678         uint256 _bal = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n679         IERC20Burnable(tokenAddress).burnFrom(address(this),_bal);\n680     }\n681 }\n217\n",
    "transaction-context": "onlyOwner",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": "onlyOwner",
    "ranks": "onlyOwner",
    "vulnerabilities": " require(isPoolActive,'Contract is not running yet');"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 \n10 import \"\"./lib/FullMath.sol\"\";\n11 \n12 import \"\"./lib/NoDelegateCall.sol\"\";\n13 \n14 import \"\"./Orchestrator.sol\"\";\n15 \n16 import \"\"./ProportionalLiquidity.sol\"\";\n17 \n18 import \"\"./Swaps.sol\"\";\n19 \n20 import \"\"./ViewLiquidity.sol\"\";\n21 \n22 import \"\"./Storage.sol\"\";\n23 \n24 import \"\"./MerkleProver.sol\"\";\n25 \n26 import \"\"./interfaces/IFreeFromUpTo.sol\"\";\n27 \n28 import \"\"./interfaces/ICurveFactory.sol\"\";\n29 \n30 import \"\"./Structs.sol\"\";\n31 \n32 library Curves {\n33     using ABDKMath64x64 for int128;\n34 \n35     event Approval(address indexed _owner, address indexed spender, uint256 value);\n36     event Transfer(address indexed from, address indexed to, uint256 value);\n37 \n38     function add(\n39         uint256 x,\n40         uint256 y,\n41         string memory errorMessage\n42     ) private pure returns (uint256 z) {\n43         require((z = x + y) >= x, errorMessage);\n44     }\n45 \n46     function sub(\n47         uint256 x,\n48         uint256 y,\n49         string memory errorMessage\n50     ) private pure returns (uint256 z) {\n51         require((z = x - y) <= x, errorMessage);\n52     }\n53 \n54     /**\n55      * @dev See {IERC20-transfer}.\n56      *\n57      * Requirements:\n58      *\n59      * - `recipient` cannot be the zero address.\n60      * - the caller must have a balance of at least `amount`.\n61      */\n62     function transfer(\n63         Storage.Curve storage curve,\n64         address recipient,\n65         uint256 amount\n66     ) external returns (bool) {\n67         _transfer(curve, msg.sender, recipient, amount);\n68         return true;\n69     }\n70 \n71     /**\n72      * @dev See {IERC20-approve}.\n73      *\n74      * Requirements:\n75      *\n76      * - `spender` cannot be the zero address.\n77      */\n78     function approve(\n79         Storage.Curve storage curve,\n80         address spender,\n81         uint256 amount\n82     ) external returns (bool) {\n83         _approve(curve, msg.sender, spender, amount);\n84         return true;\n85     }\n86 \n87     /**\n88      * @dev See {IERC20-transferFrom}.\n89      *\n90      * Emits an {Approval} event indicating the updated allowance. This is not\n91      * required by the EIP. See the note at the beginning of {ERC20};\n92      *\n93      * Requirements:\n94      * - `sender` and `recipient` cannot be the zero address.\n95      * - `sender` must have a balance of at least `amount`.\n96      * - the caller must have allowance for `sender`'s tokens of at least\n97      * `amount`\n98      */\n99     function transferFrom(\n100         Storage.Curve storage curve,\n101         address sender,\n102         address recipient,\n103         uint256 amount\n104     ) external returns (bool) {\n105         _transfer(curve, sender, recipient, amount);\n106         _approve(\n107             curve,\n108             sender,\n109             msg.sender,\n110             sub(curve.allowances[sender][msg.sender], amount, \"\"Curve/insufficient-allowance\"\")\n111         );\n112         return true;\n113     }\n114 \n115     /**\n116      * @dev Atomically increases the allowance granted to `spender` by the caller.\n117      *\n118      * This is an alternative to {approve} that can be used as a mitigation for\n119      * problems described in {IERC20-approve}.\n120      *\n121      * Emits an {Approval} event indicating the updated allowance.\n122      *\n123      * Requirements:\n124      *\n125      * - `spender` cannot be the zero address.\n126      */\n127     function increaseAllowance(\n128         Storage.Curve storage curve,\n129         address spender,\n130         uint256 addedValue\n131     ) external returns (bool) {\n132         _approve(\n133             curve,\n134             msg.sender,\n135             spender,\n136             add(curve.allowances[msg.sender][spender], addedValue, \"\"Curve/approval-overflow\"\")\n137         );\n138         return true;\n139     }\n140 \n141     /**\n142      * @dev Atomically decreases the allowance granted to `spender` by the caller.\n143      *\n144      * This is an alternative to {approve} that can be used as a mitigation for\n145      * problems described in {IERC20-approve}.\n146      *\n147      * Emits an {Approval} event indicating the updated allowance.\n148      *\n149      * Requirements:\n150      *\n151      * - `spender` cannot be the zero address.\n152      * - `spender` must have allowance for the caller of at least\n153      * `subtractedValue`.\n154      */\n155     function decreaseAllowance(\n156         Storage.Curve storage curve,\n157         address spender,\n158         uint256 subtractedValue\n159     ) external returns (bool) {\n160         _approve(\n161             curve,\n162             msg.sender,\n163             spender,\n164             sub(curve.allowances[msg.sender][spender], subtractedValue, \"\"Curve/allowance-decrease-underflow\"\")\n165         );\n166         return true;\n167     }\n168 \n169     /**\n170      * @dev Moves tokens `amount` from `sender` to `recipient`.\n171      *\n172      * This is public function is equivalent to {transfer}, and can be used to\n173      * e.g. implement automatic token fees, slashing mechanisms, etc.\n174      *\n175      * Emits a {Transfer} event.\n176      *\n177      * Requirements:\n178      *\n179      * - `sender` cannot be the zero address.\n180      * - `recipient` cannot be the zero address.\n181      * - `sender` must have a balance of at least `amount`.\n182      */\n183     function _transfer(\n184         Storage.Curve storage curve,\n185         address sender,\n186         address recipient,\n187         uint256 amount\n188     ) private {\n189         require(sender != address(0), \"\"ERC20: transfer from the zero address\"\");\n190         require(recipient != address(0), \"\"ERC20: transfer to the zero address\"\");\n191 \n192         curve.balances[sender] = sub(curve.balances[sender], amount, \"\"Curve/insufficient-balance\"\");\n193         curve.balances[recipient] = add(curve.balances[recipient], amount, \"\"Curve/transfer-overflow\"\");\n194         emit Transfer(sender, recipient, amount);\n195     }\n196 \n197     /**\n198      * @dev Sets `amount` as the allowance of `spender` over the `_owner`s tokens.\n199      *\n200      * This is public function is equivalent to `approve`, and can be used to\n201      * e.g. set automatic allowances for certain subsystems, etc.\n202      *\n203      * Emits an {Approval} event.\n204      *\n205      * Requirements:\n206      *\n207      * - `_owner` cannot be the zero address.\n208      * - `spender` cannot be the zero address.\n209      */\n210     function _approve(\n211         Storage.Curve storage curve,\n212         address _owner,\n213         address spender,\n214         uint256 amount\n215     ) private {\n216         require(_owner != address(0), \"\"ERC20: approve from the zero address\"\");\n217         require(spender != address(0), \"\"ERC20: approve to the zero address\"\");\n218 \n219         curve.allowances[_owner][spender] = amount;\n220         emit Approval(_owner, spender, amount);\n221     }\n222 }\n223 \n224 contract Curve is Storage, MerkleProver, NoDelegateCall {\n225     using SafeMath for uint256;\n226     using ABDKMath64x64 for int128;\n227     using SafeERC20 for IERC20;\n228 \n229     address private curveFactory;\n230 \n231     event Approval(address indexed _owner, address indexed spender, uint256 value);\n232 \n233     event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\n234 \n235     event AssetIncluded(address indexed numeraire, address indexed reserve, uint256 weight);\n236 \n237     event AssimilatorIncluded(\n238         address indexed derivative,\n239         address indexed numeraire,\n240         address indexed reserve,\n241         address assimilator\n242     );\n243 \n244     event PartitionRedeemed(address indexed token, address indexed redeemer, uint256 value);\n245 \n246     event OwnershipTransfered(address indexed previousOwner, address indexed newOwner);\n247 \n248     event FrozenSet(bool isFrozen);\n249 \n250     event EmergencyAlarm(bool isEmergency);\n251 \n252     event WhitelistingStopped();\n253 \n254     event Trade(\n255         address indexed trader,\n256         address indexed origin,\n257         address indexed target,\n258         uint256 originAmount,\n259         uint256 targetAmount\n260     );\n261 \n262     event Transfer(address indexed from, address indexed to, uint256 value);\n263 \n264     event Flash(address indexed from, address indexed to, uint256 value0, uint256 value1, uint256 paid0, uint256 paid1);\n265 \n266     modifier onlyOwner() {\n267         require(msg.sender == owner, \"\"Curve/caller-is-not-owner\"\");\n268         _;\n269     }\n270 \n271     modifier nonReentrant() {\n272         require(notEntered, \"\"Curve/re-entered\"\");\n273         notEntered = false;\n274         _;\n275         notEntered = true;\n276     }\n277 \n278     modifier transactable() {\n279         require(!frozen, \"\"Curve/frozen-only-allowing-proportional-withdraw\"\");\n280         _;\n281     }\n282 \n283     modifier isEmergency() {\n284         require(emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n285         _;\n286     }\n287 \n288     modifier isNotEmergency() {\n289         require(!emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n290         _;\n291     }\n292 \n293     modifier deadline(uint256 _deadline) {\n294         require(block.timestamp < _deadline, \"\"Curve/tx-deadline-passed\"\");\n295         _;\n296     }\n297 \n298     modifier inWhitelistingStage() {\n299         require(whitelistingStage, \"\"Curve/whitelist-stage-stopped\"\");\n300         _;\n301     }\n302 \n303     modifier notInWhitelistingStage() {\n304         require(!whitelistingStage, \"\"Curve/whitelist-stage-on-going\"\");\n305         _;\n306     }\n307 \n308     modifier globallyTransactable() {\n309         require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"\"Curve/frozen-globally-only-allowing-proportional-withdraw\"\");\n310         _;\n311     }\n312     \n313     modifier isFlashable() {\n314         require(ICurveFactory(address(curveFactory)).getFlashableState(), \"\"Curve/flashloans-paused\"\");\n315         _;\n316     }\n317 \n318     constructor(\n319         string memory _name,\n320         string memory _symbol,\n321         address[] memory _assets,\n322         uint256[] memory _assetWeights,\n323         address _factory\n324     ) {\n325         owner = msg.sender;\n326         name = _name;\n327         symbol = _symbol;\n328         curveFactory = _factory;\n329         emit OwnershipTransfered(address(0), msg.sender);\n330 \n331         Orchestrator.initialize(curve, numeraires, reserves, derivatives, _assets, _assetWeights);\n332     }\n333 \n334     /// @notice sets the parameters for the pool\n335     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n336     /// @param _beta the value for beta must be less than alpha and greater than 0\n337     /// @param _feeAtHalt the maximum value for the fee at the halt point\n338     /// @param _epsilon the base fee for the pool\n339     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n340     function setParams(\n341         uint256 _alpha,\n342         uint256 _beta,\n343         uint256 _feeAtHalt,\n344         uint256 _epsilon,\n345         uint256 _lambda\n346     ) external onlyOwner {\n347         Orchestrator.setParams(curve, _alpha, _beta, _feeAtHalt, _epsilon, _lambda);\n348     }\n349 \n350     /// @notice excludes an assimilator from the curve\n351     /// @param _derivative the address of the assimilator to exclude\n352     function excludeDerivative(address _derivative) external onlyOwner {\n353         for (uint256 i = 0; i < numeraires.length; i++) {\n354             if (_derivative == numeraires[i]) revert(\"\"Curve/cannot-delete-numeraire\"\");\n355             if (_derivative == reserves[i]) revert(\"\"Curve/cannot-delete-reserve\"\");\n356         }\n357 \n358         delete curve.assimilators[_derivative];\n359     }\n360 \n361     /// @notice view the current parameters of the curve\n362     /// @return alpha_ the current alpha value\n363     ///  beta_ the current beta value\n364     ///  delta_ the current delta value\n365     ///  epsilon_ the current epsilon value\n366     ///  lambda_ the current lambda value\n367     ///  omega_ the current omega value\n368     function viewCurve()\n369         external\n370         view\n371         returns (\n372             uint256 alpha_,\n373             uint256 beta_,\n374             uint256 delta_,\n375             uint256 epsilon_,\n376             uint256 lambda_\n377         )\n378     {\n379         return Orchestrator.viewCurve(curve);\n380     }\n381 \n382     function turnOffWhitelisting() external onlyOwner {\n383         emit WhitelistingStopped();\n384 \n385         whitelistingStage = false;\n386     }\n387 \n388     function setEmergency(bool _emergency) external onlyOwner {\n389         emit EmergencyAlarm(_emergency);\n390 \n391         emergency = _emergency;\n392     }\n393 \n394     function setFrozen(bool _toFreezeOrNotToFreeze) external onlyOwner {\n395         emit FrozenSet(_toFreezeOrNotToFreeze);\n396 \n397         frozen = _toFreezeOrNotToFreeze;\n398     }\n399 \n400     function transferOwnership(address _newOwner) external onlyOwner {\n401         require(_newOwner != address(0), \"\"Curve/new-owner-cannot-be-zeroth-address\"\");\n402 \n403         emit OwnershipTransfered(owner, _newOwner);\n404 \n405         owner = _newOwner;\n406     }\n407 \n408     /// @notice swap a dynamic origin amount for a fixed target amount\n409     /// @param _origin the address of the origin\n410     /// @param _target the address of the target\n411     /// @param _originAmount the origin amount\n412     /// @param _minTargetAmount the minimum target amount\n413     /// @param _deadline deadline in block number after which the trade will not execute\n414     /// @return targetAmount_ the amount of target that has been swapped for the origin amount\n415     function originSwap(\n416         address _origin,\n417         address _target,\n418         uint256 _originAmount,\n419         uint256 _minTargetAmount,\n420         uint256 _deadline\n421     ) external deadline(_deadline) globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant returns (uint256 targetAmount_) {\n422         OriginSwapData memory _swapData;\n423         _swapData._origin = _origin;\n424         _swapData._target = _target;\n425         _swapData._originAmount = _originAmount;\n426         _swapData._recipient = msg.sender;\n427         _swapData._curveFactory = curveFactory;\n428         targetAmount_ = Swaps.originSwap(curve, _swapData);\n429         // targetAmount_ = Swaps.originSwap(curve, _origin, _target, _originAmount, msg.sender,curveFactory);\n430 \n431         require(targetAmount_ >= _minTargetAmount, \"\"Curve/below-min-target-amount\"\");\n432     }\n433 \n434     /// @notice view how much target amount a fixed origin amount will swap for\n435     /// @param _origin the address of the origin\n436     /// @param _target the address of the target\n437     /// @param _originAmount the origin amount\n438     /// @return targetAmount_ the target amount that would have been swapped for the origin amount\n439     function viewOriginSwap(\n440         address _origin,\n441         address _target,\n442         uint256 _originAmount\n443     ) external view globallyTransactable transactable returns (uint256 targetAmount_) {\n444         targetAmount_ = Swaps.viewOriginSwap(curve, _origin, _target, _originAmount);\n445     }\n446 \n447     /// @notice swap a dynamic origin amount for a fixed target amount\n448     /// @param _origin the address of the origin\n449     /// @param _target the address of the target\n450     /// @param _maxOriginAmount the maximum origin amount\n451     /// @param _targetAmount the target amount\n452     /// @param _deadline deadline in block number after which the trade will not execute\n453     /// @return originAmount_ the amount of origin that has been swapped for the target\n454     function targetSwap(\n455         address _origin,\n456         address _target,\n457         uint256 _maxOriginAmount,\n458         uint256 _targetAmount,\n459         uint256 _deadline\n460     ) external deadline(_deadline) globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant returns (uint256 originAmount_) {\n461         TargetSwapData memory _swapData;\n462         _swapData._origin = _origin;\n463         _swapData._target = _target;\n464         _swapData._targetAmount = _targetAmount;\n465         _swapData._recipient = msg.sender;\n466         _swapData._curveFactory = curveFactory;\n467         originAmount_ = Swaps.targetSwap(curve, _swapData);\n468         // originAmount_ = Swaps.targetSwap(curve, _origin, _target, _targetAmount, msg.sender,curveFactory);\n469 \n470         require(originAmount_ <= _maxOriginAmount, \"\"Curve/above-max-origin-amount\"\");\n471     }\n472 \n473     /// @notice view how much of the origin currency the target currency will take\n474     /// @param _origin the address of the origin\n475     /// @param _target the address of the target\n476     /// @param _targetAmount the target amount\n477     /// @return originAmount_ the amount of target that has been swapped for the origin\n478     function viewTargetSwap(\n479         address _origin,\n480         address _target,\n481         uint256 _targetAmount\n482     ) external view globallyTransactable transactable returns (uint256 originAmount_) {\n483         originAmount_ = Swaps.viewTargetSwap(curve, _origin, _target, _targetAmount);\n484     }\n485 \n486     /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n487     /// @param  index Index corresponding to the merkleProof\n488     /// @param  account Address coorresponding to the merkleProof\n489     /// @param  amount Amount coorresponding to the merkleProof, should always be 1\n490     /// @param  merkleProof Merkle proof\n491     /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n492     ///                  the numeraire assets of the pool\n493     /// @return (the amount of curves you receive in return for your deposit,\n494     ///          the amount deposited for each numeraire)\n495     function depositWithWhitelist(\n496         uint256 index,\n497         address account,\n498         uint256 amount,\n499         bytes32[] calldata merkleProof,\n500         uint256 _deposit,\n501         uint256 _deadline\n502     ) external deadline(_deadline) globallyTransactable transactable nonReentrant noDelegateCall inWhitelistingStage returns (uint256, uint256[] memory) {\n503         require(amount == 1, \"\"Curve/invalid-amount\"\");\n504         require(index <= 473, \"\"Curve/index-out-of-range\"\" );\n505         require(isWhitelisted(index, account, amount, merkleProof), \"\"Curve/not-whitelisted\"\");\n506         require(msg.sender == account, \"\"Curve/not-approved-user\"\");\n507 \n508         (uint256 curvesMinted_, uint256[] memory deposits_) =\n509             ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n510 \n511         whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].add(curvesMinted_);\n512 \n513         // 10k max deposit\n514         if (whitelistedDeposited[msg.sender] > 10000e18) {\n515             revert(\"\"Curve/exceed-whitelist-maximum-deposit\"\");\n516         }\n517 \n518         return (curvesMinted_, deposits_);\n519     }\n520 \n521     /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n522     /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n523     ///                  the numeraire assets of the pool\n524     /// @return (the amount of curves you receive in return for your deposit,\n525     ///          the amount deposited for each numeraire)\n526     function deposit(uint256 _deposit, uint256 _deadline)\n527         external\n528         deadline(_deadline)\n529         globallyTransactable\n530         transactable\n531         nonReentrant\n532         noDelegateCall\n533         notInWhitelistingStage\n534         isNotEmergency\n535         returns (uint256, uint256[] memory)\n536     {\n537         // (curvesMinted_,  deposits_)\n538         return ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n539     }\n540 \n541     /// @notice view deposits and curves minted a given deposit would return\n542     /// @param _deposit the full amount of stablecoins you want to deposit. Divided evenly according to the\n543     ///                 prevailing proportions of the numeraire assets of the pool\n544     /// @return (the amount of curves you receive in return for your deposit,\n545     ///          the amount deposited for each numeraire)\n546     function viewDeposit(uint256 _deposit) external view globallyTransactable transactable returns (uint256, uint256[] memory) {\n547         // curvesToMint_, depositsToMake_\n548         return ProportionalLiquidity.viewProportionalDeposit(curve, _deposit);\n549     }\n550 \n551     /// @notice  Emergency withdraw tokens in the event that the oracle somehow bugs out\n552     ///          and no one is able to withdraw due to the invariant check\n553     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n554     ///                        numeraire assets of the pool\n555     /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n556     function emergencyWithdraw(uint256 _curvesToBurn, uint256 _deadline)\n557         external\n558         isEmergency\n559         deadline(_deadline)\n560         nonReentrant\n561         noDelegateCall\n562         returns (uint256[] memory withdrawals_)\n563     {\n564         return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n565     }\n566 \n567     /// @notice  withdrawas amount of curve tokens from the the pool equally from the numeraire assets of the pool with no slippage\n568     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n569     ///                        numeraire assets of the pool\n570     /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n571     function withdraw(uint256 _curvesToBurn, uint256 _deadline)\n572         external\n573         deadline(_deadline)\n574         nonReentrant\n575         noDelegateCall\n576         isNotEmergency\n577         returns (uint256[] memory withdrawals_)\n578     {\n579         if (whitelistingStage) {\n580             whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].sub(_curvesToBurn);\n581         }\n582 \n583         return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n584     }\n585 \n586     /// @notice  views the withdrawal information from the pool\n587     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n588     ///                        numeraire assets of the pool\n589     /// @return the amonnts of numeraire assets withdrawn from the pool\n590     function viewWithdraw(uint256 _curvesToBurn) external view globallyTransactable transactable returns (uint256[] memory) {\n591         return ProportionalLiquidity.viewProportionalWithdraw(curve, _curvesToBurn);\n592     }\n593 \n594     function supportsInterface(bytes4 _interface) public pure returns (bool supports_) {\n595         supports_ =\n596             this.supportsInterface.selector == _interface || // erc165\n597             bytes4(0x7f5828d0) == _interface || // eip173\n598             bytes4(0x36372b07) == _interface; // erc20\n599     }\n600 \n601     /// @notice transfers curve tokens\n602     /// @param _recipient the address of where to send the curve tokens\n603     /// @param _amount the amount of curve tokens to send\n604     /// @return success_ the success bool of the call\n605     function transfer(address _recipient, uint256 _amount) public nonReentrant noDelegateCall isNotEmergency returns (bool success_) {\n606         success_ = Curves.transfer(curve, _recipient, _amount);\n607     }\n608 \n609     /// @notice transfers curve tokens from one address to another address\n610     /// @param _sender the account from which the curve tokens will be sent\n611     /// @param _recipient the account to which the curve tokens will be sent\n612     /// @param _amount the amount of curve tokens to transfer\n613     /// @return success_ the success bool of the call\n614     function transferFrom(\n615         address _sender,\n616         address _recipient,\n617         uint256 _amount\n618     ) public nonReentrant noDelegateCall isNotEmergency returns (bool success_) {\n619         success_ = Curves.transferFrom(curve, _sender, _recipient, _amount);\n620     }\n621 \n622     /// @notice approves a user to spend curve tokens on their behalf\n623     /// @param _spender the account to allow to spend from msg.sender\n624     /// @param _amount the amount to specify the spender can spend\n625     /// @return success_ the success bool of this call\n626     function approve(address _spender, uint256 _amount) public nonReentrant noDelegateCall returns (bool success_) {\n627         success_ = Curves.approve(curve, _spender, _amount);\n628     }\n629     \n630     function flash(\n631         address recipient,\n632         uint256 amount0,\n633         uint256 amount1,\n634         bytes calldata data\n635     ) external isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency {\n636         uint256 fee = curve.epsilon.mulu(1e18);\n637 \n638         require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639         require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n640         \n641         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n642         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n643 \n644         uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n645         uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n646 \n647         if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n648         if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n649 \n650         IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n651 \n652         uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n653         uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n654 \n655         require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656         require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\n657 \n658         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n659         uint256 paid0 = balance0After - balance0Before;\n660         uint256 paid1 = balance1After - balance1Before;\n661 \n662         IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n663         IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n664 \n665         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n666     }    \n667 \n668     /// @notice view the curve token balance of a given account\n669     /// @param _account the account to view the balance of\n670     /// @return balance_ the curve token ballance of the given account\n671     function balanceOf(address _account) public view returns (uint256 balance_) {\n672         balance_ = curve.balances[_account];\n673     }\n674 \n675     /// @notice views the total curve supply of the pool\n676     /// @return totalSupply_ the total supply of curve tokens\n677     function totalSupply() public view returns (uint256 totalSupply_) {\n678         totalSupply_ = curve.totalSupply;\n679     }\n680 \n681     /// @notice views the total allowance one address has to spend from another address\n682     /// @param _owner the address of the owner\n683     /// @param _spender the address of the spender\n684     /// @return allowance_ the amount the owner has allotted the spender\n685     function allowance(address _owner, address _spender) public view returns (uint256 allowance_) {\n686         allowance_ = curve.allowances[_owner][_spender];\n687     }\n688 \n689     /// @notice views the total amount of liquidity in the curve in numeraire value and format - 18 decimals\n690     /// @return total_ the total value in the curve\n691     /// @return individual_ the individual values in the curve\n692     function liquidity() public view returns (uint256 total_, uint256[] memory individual_) {\n693         return ViewLiquidity.viewLiquidity(curve);\n694     }\n695 \n696     /// @notice view the assimilator address for a derivative\n697     /// @return assimilator_ the assimilator address\n698     function assimilator(address _derivative) public view returns (address assimilator_) {\n699         assimilator_ = curve.assimilators[_derivative].addr;\n700     }\n701 }\"\t\"189 require(sender != address(0), \"\"ERC20: transfer from the zero address\"\");\n190 require(recipient != address(0), \"\"ERC20: transfer to the zero address\"\");\n216 require(_owner != address(0), \"\"ERC20: approve from the zero address\"\");\n217 require(spender != address(0), \"\"ERC20: approve to the zero address\"\");\n266     modifier onlyOwner() {\n           require(msg.sender == owner, \"\"Curve/caller-is-not-owner\"\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"\"Curve/re-entered\"\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"\"Curve/frozen-only-allowing-proportional-withdraw\"\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"\"Curve/tx-deadline-passed\"\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"\"Curve/whitelist-stage-stopped\"\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"\"Curve/whitelist-stage-on-going\"\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"\"Curve/frozen-globally-only-allowing-proportional-withdraw\"\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"\"Curve/flashloans-paused\"\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n401 require(_newOwner != address(0), \"\"Curve/new-owner-cannot-be-zeroth-address\"\");\n421  noDelegateCall isNotEmergency nonReentrant\n431  require(targetAmount_ >= _minTargetAmount, \"\"Curve/below-min-target-amount\"\");\n443 globallyTransactable transactable\n460 globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant \n470 require(originAmount_ <= _maxOriginAmount, \"\"Curve/above-max-origin-amount\"\");\n482 globallyTransactable transactable\n502     ) external deadline(_deadline) globallyTransactable transactable nonReentrant noDelegateCall inWhitelistingStage returns (uint256, uint256[] memory) {\n503 require(amount == 1, \"\"Curve/invalid-amount\"\");\n504 require(index <= 473, \"\"Curve/index-out-of-range\"\" );\n505 require(isWhitelisted(index, account, amount, merkleProof), \"\"Curve/not-whitelisted\"\");\n506 require(msg.sender == account, \"\"Curve/not-approved-user\"\");\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall\n635 isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency \n638 require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639 require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n655 require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656 require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\"\n303\n",
    "transaction-context": "modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"\"Curve/whitelist-stage-on-going\"\");\n        }",
    "Critical-points": "modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"\"Curve/frozen-globally-only-allowing-proportional-withdraw\"\");\n              _;\n     }",
    "invariants": "modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"\"Curve/flashloans-paused\"\");\n            _;\n   }",
    "critical-invariants": "onlyOwner\n",
    "ranks": "onlyOwner",
    "vulnerabilities": "onlyOwner "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n\n7 // Example of the trace:\n8 // D(x) is called, where x is 716\n9 // B(x+3) called, where x is 716, B's arg is 719\n10 // A(x+1) called, where x is 720. A's arg is 720\n11 // ctor A {a = x} , where a is 720\n12 // ctor B  {b = x+1 } , where x is 719, b is 720\n13 // C(x+4) is called, where x is 716, C's arg is 720\n14 // ctor C   { c = x + 2}, where x is 720, c is 722\n\n15 contract A {\n16     uint a;\n17     constructor (uint x) public {\n18         a = x;\n19     }\n20 }\n\n21 contract B is A {\n22     uint b;\n23     constructor (uint x) A(x+1) public {  \n24         b = x + 1;\n25                 assert(a == x + 1);\n26     }\n27 }\n\n28 contract C is A {\n29     uint c;\n30     //constructor (uint x) A(x+2) public {          // no A with ANY args here, otherwise, solc error:\n31                                                                                                         // \"Base constr args given twice\"\n32         constructor (uint x) public {\n33         c = x + 2;\n34                 assert(a == x);       // passes, but proved to only 4 transactions        \n35     }\n36 }\n\n37 contract D is B, C {\n38     constructor (uint x) B(x+3) C(x+4) public\n39     {        \n40         assert (a == x + 4);  //after calling B(x+3); calling C(x+4) does not affect this assert\n41         assert (b == x + 4);  //after calling B(x+3)\n42         assert (c == x + 6);    // after calling C(x+4)\n43     }\n44 }\n",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 25+  \n34+  \n40+ \n41+    \n42+",
    "invariants": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "critical-invariants": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "ranks": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../ERC1967/ERC1967Proxy.sol\";\n\n5 interface ITransparentUpgradeableProxy {\n6     event Upgraded(address indexed implementation);\n7     event AdminChanged(address previousAdmin, address newAdmin);\n8     function admin() external view returns (address);\n9     function implementation() external view returns (address);\n10     function changeAdmin(address) external;\n11     function upgradeTo(address) external;\n12     function upgradeToAndCall(address, bytes memory) payable external;\n13 }\n\n14 /**\n15  * @dev This contract implements a proxy that is upgradeable by an admin.\n16  *\n17  * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n18  * clashing], which can potentially be used in an attack, this contract uses the\n19  * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n20  * things that go hand in hand:\n21  *\n22  * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n23  * that call matches one of the admin functions exposed by the proxy itself.\n24  * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n25  * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n26  * \"admin cannot fallback to proxy target\".\n27  *\n28  * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n29  * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n30  * to sudden errors when trying to call a function from the proxy implementation.\n31  *\n32  * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n33  * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n34  */\n35 contract Proxy is ERC1967Proxy {\n36     /**\n37      * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n38      * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n39      */\n40     constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n41         _changeAdmin(admin_);\n42     }\n\n43     /**\n44      * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n45      */\n46     function _fallback() internal virtual override {\n47         if (msg.sender == _getAdmin()) {\n48             bytes memory ret;\n49             bytes4 selector = msg.sig;\n50             if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n51                 ret = _dispatchUpgradeTo();\n52             } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n53                 ret = _dispatchUpgradeToAndCall();\n54             } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n55                 ret = _dispatchChangeAdmin();\n56             } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n57                 ret = _dispatchAdmin();\n58             } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n59                 ret = _dispatchImplementation();\n60             } else {\n61                 revert('TransparentUpgradeableProxy: admin cannot fallback to proxy target');\n62             }\n63             assembly {\n64                 return(add(ret, 0x20), mload(ret))\n65             }\n66         } else {\n67             super._fallback();\n68         }\n69     }\n\n70     /**\n71      * @dev Returns the current admin.\n72      *\n73      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n74      * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n75      * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n76      */\n77     function _dispatchAdmin() private returns (bytes memory) {\n78         _requireZeroValue();\n\n79         address admin = _getAdmin();\n80         return abi.encode(admin);\n81     }\n\n82     /**\n83      * @dev Returns the current implementation.\n84      *\n85      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n86      * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n87      * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n88      */\n89     function _dispatchImplementation() private returns (bytes memory) {\n90         _requireZeroValue();\n\n91         address implementation = _implementation();\n92         return abi.encode(implementation);\n93     }\n\n94     /**\n95      * @dev Changes the admin of the proxy.\n96      */\n97     function _dispatchChangeAdmin() private returns (bytes memory) {\n98         _requireZeroValue();\n\n99         address newAdmin = abi.decode(msg.data[4:], (address));\n100         _changeAdmin(newAdmin);\n\n101         return \"\";\n102     }\n\n103     /**\n104      * @dev Upgrade the implementation of the proxy.\n105      */\n106     function _dispatchUpgradeTo() private returns (bytes memory) {\n107         _requireZeroValue();\n\n108         address newImplementation = abi.decode(msg.data[4:], (address));\n109         _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n110         return \"\";\n111     }\n\n112     /**\n113      * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n114      * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n115      * proxied contract.\n116      */\n117     function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n118         (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n119         _upgradeToAndCall(newImplementation, data, true);\n\n120         return \"\";\n121     }\n\n122     /**\n123      * @dev Returns the current admin.\n124      */\n125     function _admin() internal view virtual returns (address) {\n126         return _getAdmin();\n127     }\n\n128     /**\n129      * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n130      * emulate some proxy functions being non-payable while still allowing value to pass through.\n131      */\n132     function _requireZeroValue() private {\n133         require(msg.value == 0);\n134     }\n135 }\n",
    "transaction-context": "The transaction context is proxy\nprotocol",
    "Critical-points": "Critical program points are 80+ \n92+ \n99+ \n108+ \n111+",
    "invariants": "80+ assert(Old(abi.encode(admin)) == abi.encode(admin)); \n92+ assert(Old(abi.encode(implementation)) == abi.encode(implementation));\n99+ assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));\n108+ assert(Old(newImplementation) == abi.decode(msg.data[4:], (address)));\n111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); \n",
    "critical-invariants": "111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); ",
    "ranks": "111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); ",
    "vulnerabilities": "incorrect visibility/ownership\ninconsistent state update\natomicity violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: BSD-3-Clause\n2 pragma solidity ^0.8.10;\n\n3 import \"./ComptrollerInterface.sol\";\n4 import \"./CTokenInterfaces.sol\";\n5 import \"./ErrorReporter.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./InterestRateModel.sol\";\n8 import \"./ExponentialNoError.sol\";\n\n9 /**\n10  * @title Compound's CToken Contract\n11  * @notice Abstract base for CTokens\n12  * @author Compound\n13  */\n14 abstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\n15     /**\n16      * @notice Initialize the money market\n17      * @param comptroller_ The address of the Comptroller\n18      * @param interestRateModel_ The address of the interest rate model\n19      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n20      * @param name_ EIP-20 name of this token\n21      * @param symbol_ EIP-20 symbol of this token\n22      * @param decimals_ EIP-20 decimal precision of this token\n23      */\n24     function initialize(ComptrollerInterface comptroller_,\n25                         InterestRateModel interestRateModel_,\n26                         uint initialExchangeRateMantissa_,\n27                         string memory name_,\n28                         string memory symbol_,\n29                         uint8 decimals_) public {\n30         require(msg.sender == admin, \"only admin may initialize the market\");\n31         require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n32         // Set initial exchange rate\n33         initialExchangeRateMantissa = initialExchangeRateMantissa_;\n34         require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n35         // Set the comptroller\n36         uint err = _setComptroller(comptroller_);\n37         require(err == NO_ERROR, \"setting comptroller failed\");\n\n38         // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n39         accrualBlockNumber = getBlockNumber();\n40         borrowIndex = mantissaOne;\n\n41         // Set the interest rate model (depends on block number / borrow index)\n42         err = _setInterestRateModelFresh(interestRateModel_);\n43         require(err == NO_ERROR, \"setting interest rate model failed\");\n\n44         name = name_;\n45         symbol = symbol_;\n46         decimals = decimals_;\n\n47         // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n48         _notEntered = true;\n49     }\n\n50     /**\n51      * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n52      * @dev Called by both `transfer` and `transferFrom` internally\n53      * @param spender The address of the account performing the transfer\n54      * @param src The address of the source account\n55      * @param dst The address of the destination account\n56      * @param tokens The number of tokens to transfer\n57      * @return 0 if the transfer succeeded, else revert\n58      */\n59     function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n60         /* Fail if transfer not allowed */\n61         uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n62         if (allowed != 0) {\n63             revert TransferComptrollerRejection(allowed);\n64         }\n\n65         /* Do not allow self-transfers */\n66         if (src == dst) {\n67             revert TransferNotAllowed();\n68         }\n\n69         /* Get the allowance, infinite for the account owner */\n70         uint startingAllowance = 0;\n71         if (spender == src) {\n72             startingAllowance = type(uint).max;\n73         } else {\n74             startingAllowance = transferAllowances[src][spender];\n75         }\n\n76         /* Do the calculations, checking for {under,over}flow */\n77         uint allowanceNew = startingAllowance - tokens;\n78         uint srcTokensNew = accountTokens[src] - tokens;\n79         uint dstTokensNew = accountTokens[dst] + tokens;\n\n80         /////////////////////////\n81         // EFFECTS & INTERACTIONS\n82         // (No safe failures beyond this point)\n\n83         accountTokens[src] = srcTokensNew;\n84         accountTokens[dst] = dstTokensNew;\n\n85         /* Eat some of the allowance (if necessary) */\n86         if (startingAllowance != type(uint).max) {\n87             transferAllowances[src][spender] = allowanceNew;\n88         }\n\n89         /* We emit a Transfer event */\n90         emit Transfer(src, dst, tokens);\n\n91         // unused function\n92         // comptroller.transferVerify(address(this), src, dst, tokens);\n\n93         return NO_ERROR;\n94     }\n\n95     /**\n96      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n97      * @param dst The address of the destination account\n98      * @param amount The number of tokens to transfer\n99      * @return Whether or not the transfer succeeded\n100      */\n101     function transfer(address dst, uint256 amount) override external returns (bool) {\n102         return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n103     }\n\n104     /**\n105      * @notice Transfer `amount` tokens from `src` to `dst`\n106      * @param src The address of the source account\n107      * @param dst The address of the destination account\n108      * @param amount The number of tokens to transfer\n109      * @return Whether or not the transfer succeeded\n110      */\n111     function transferFrom(address src, address dst, uint256 amount) override external returns (bool) {\n112         return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n113     }\n\n114     /**\n115      * @notice Approve `spender` to transfer up to `amount` from `src`\n116      * @dev This will overwrite the approval amount for `spender`\n117      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n118      * @param spender The address of the account which may transfer tokens\n119      * @param amount The number of tokens that are approved (uint256.max means infinite)\n120      * @return Whether or not the approval succeeded\n121      */\n122     function approve(address spender, uint256 amount) override external returns (bool) {\n123         address src = msg.sender;\n124         transferAllowances[src][spender] = amount;\n125         emit Approval(src, spender, amount);\n126         return true;\n127     }\n128     /**\n129      * @notice Returns the current total borrows plus accrued interest\n130      * @return The total borrows with interest\n  \n131     /*** Safe Token ***/\n\n132     /**\n133      * @notice Gets balance of this contract in terms of the underlying\n134      * @dev This excludes the value of the current message, if any\n135      * @return The quantity of underlying owned by this contract\n136      */\n137     function getCashPrior() virtual internal view returns (uint);\n\n138     /**\n139      * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n140      *  This may revert due to insufficient balance or insufficient allowance.\n141      */\n142     function doTransferIn(address from, uint amount) virtual internal returns (uint);\n\n143     /**\n144      * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n145      *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n146      *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n147      */\n148     function doTransferOut(address payable to, uint amount) virtual internal;\n\n149 }\n",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 23+  \n29 \n59\n101 \n111 ",
    "invariants": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n29 nonReentrant\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant",
    "critical-invariants": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant\n",
    "ranks": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant\n",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "pragma solidity >=0.4.24 <0.6.0;\n\n//simple library with no internal state\n\nlibrary Lib {\n    function add(uint _a, uint _b) public view returns (uint r) {\n        address x = address(this);       \n        r = _a + _b;\n    }\n}\n\ncontract C {\n    // using Lib for uint;\n\n    function foo() public {\n        uint x = 1;\n        uint y = 2;\n        uint z = Lib.add(x, y);        \n    }\n}\n5+\n",
    "transaction-context": "assert(x == msg.sender);",
    "Critical-points": "assert (z == 3);",
    "invariants": "assert(x + y == n);",
    "critical-invariants": "assert (y == n);",
    "ranks": "assert(x + y == n);",
    "vulnerabilities": "assert (y == n);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {\n9    function funcA1() public pure returns (uint) {\n10        return 11;\n11    }\n12    function funcA2(uint x) public pure returns (uint) {\n13        return x+1;\n14    }\n15    function funcA3() public returns (B) {\n16        B retVal= new B();\n17        return retVal;\n18    }\n19    constructor() public\n20     {\n21     }\n22 }\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 20+",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";\n8 import \"../../utils/Context.sol\";\n9 import \"../../utils/Strings.sol\";\n10 import \"../../utils/introspection/ERC165.sol\";\n\n11 /**\n12  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n13  * the Metadata extension, but not including the Enumerable extension, which is available separately as\n14  * {ERC721Enumerable}.\n15  */\n16 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n17     using Address for address;\n18     using Strings for uint256;\n\n19     // Token name\n20     string private _name;\n\n21     // Token symbol\n22     string private _symbol;\n\n23     // Mapping from token ID to owner address\n24     mapping(uint256 => address) private _owners;\n\n25     // Mapping owner address to token count\n26     mapping(address => uint256) private _balances;\n\n27     // Mapping from token ID to approved address\n28     mapping(uint256 => address) private _tokenApprovals;\n\n29     // Mapping from owner to operator approvals\n30     mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n\n31     constructor(string memory name_, string memory symbol_) {\n32         _name = name_;\n33         _symbol = symbol_;\n34     }\n\n\n35     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n36         return\n37             interfaceId == type(IERC721).interfaceId ||\n38             interfaceId == type(IERC721Metadata).interfaceId ||\n39             super.supportsInterface(interfaceId);\n40     }\n\n\n41     function balanceOf(address owner) public view virtual override returns (uint256) {\n42         require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n43         return _balances[owner];\n44     }\n\n\n45     function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n46         address owner = _ownerOf(tokenId);\n47         require(owner != address(0), \"ERC721: invalid token ID\");\n48         return owner;\n49     }\n\n\n50     function name() public view virtual override returns (string memory) {\n51         return _name;\n52     }\n\n\n53     function symbol() public view virtual override returns (string memory) {\n54         return _symbol;\n55     }\n\n\n56     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n57         _requireMinted(tokenId);\n\n58         string memory baseURI = _baseURI();\n59         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n60     }\n\n\n61     function _baseURI() internal view virtual returns (string memory) {\n62         return \"\";\n63     }\n\n\n64     function approve(address to, uint256 tokenId) public virtual override {\n65         address owner = ERC721.ownerOf(tokenId);\n66         require(to != owner, \"ERC721: approval to current owner\");\n\n67         require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n\n68         _approve(to, tokenId);\n69     }\n\n\n70     function getApproved(uint256 tokenId) public view virtual override returns (address) {\n71         _requireMinted(tokenId);\n\n72         return _tokenApprovals[tokenId];\n73     }\n\n\n74     function setApprovalForAll(address operator, bool approved) public virtual override {\n75         _setApprovalForAll(_msgSender(), operator, approved);\n76     }\n\n\n77     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n78         return _operatorApprovals[owner][operator];\n79     }\n\n\n80     function transferFrom(\n81         address from,\n82         address to,\n83         uint256 tokenId\n84     ) public virtual override {\n85         //solhint-disable-next-line max-line-length\n86         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n87         _transfer(from, to, tokenId);\n88     }\n\n\n89     function safeTransferFrom(\n90         address from,\n91         address to,\n92         uint256 tokenId\n93     ) public virtual override {\n94         safeTransferFrom(from, to, tokenId, \"\");\n95     }\n\n96     function safeTransferFrom(\n97         address from,\n98         address to,\n99         uint256 tokenId,\n100         bytes memory data\n101     ) public virtual override {\n102         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n103         _safeTransfer(from, to, tokenId, data);\n104     }\n\n \n105     function _safeTransfer(\n106         address from,\n107         address to,\n108         uint256 tokenId,\n109         bytes memory data\n110     ) internal virtual {\n111         _transfer(from, to, tokenId);\n112         require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n113     }\n\n  \n114     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n115         return _owners[tokenId];\n116     }\n\n\n117     function _exists(uint256 tokenId) internal view virtual returns (bool) {\n118         return _ownerOf(tokenId) != address(0);\n119     }\n\n\n120     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n121         address owner = ERC721.ownerOf(tokenId);\n122         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n123     }\n\n\n124     function _safeMint(address to, uint256 tokenId) internal virtual {\n125         _safeMint(to, tokenId, \"\");\n126     }\n\n\n127     function _safeMint(\n128         address to,\n129         uint256 tokenId,\n130         bytes memory data\n131     ) internal virtual {\n132         _mint(to, tokenId);\n133         require(\n134             _checkOnERC721Received(address(0), to, tokenId, data),\n135             \"ERC721: transfer to non ERC721Receiver implementer\"\n136         );\n137     }\n\n\n138     function _mint(address to, uint256 tokenId) internal virtual {\n139         require(to != address(0), \"ERC721: mint to the zero address\");\n140         require(!_exists(tokenId), \"ERC721: token already minted\");\n\n141         _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n142         // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n143         require(!_exists(tokenId), \"ERC721: token already minted\");\n\n144         unchecked {\n145             // Will not overflow unless all 2**256 token ids are minted to the same owner.\n146             // Given that tokens are minted one by one, it is impossible in practice that\n147             // this ever happens. Might change if we allow batch minting.\n148             // The ERC fails to describe this case.\n149             _balances[to] += 1;\n150         }\n\n151         _owners[tokenId] = to;\n\n152         emit Transfer(address(0), to, tokenId);\n\n153         _afterTokenTransfer(address(0), to, tokenId, 1);\n154     }\n\n\n155     function _burn(uint256 tokenId) internal virtual {\n156         address owner = ERC721.ownerOf(tokenId);\n\n157         _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n158         // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n159         owner = ERC721.ownerOf(tokenId);\n\n160         // Clear approvals\n161         delete _tokenApprovals[tokenId];\n\n162         unchecked {\n163             // Cannot overflow, as that would require more tokens to be burned/transferred\n164             // out than the owner initially received through minting and transferring in.\n165             _balances[owner] -= 1;\n166         }\n167         delete _owners[tokenId];\n\n168         emit Transfer(owner, address(0), tokenId);\n\n169         _afterTokenTransfer(owner, address(0), tokenId, 1);\n170     }\n\n  \n171     function _transfer(\n172         address from,\n173         address to,\n174         uint256 tokenId\n175     ) internal virtual {\n176         require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n177         require(to != address(0), \"ERC721: transfer to the zero address\");\n\n178         _beforeTokenTransfer(from, to, tokenId, 1);\n\n179         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n180         require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n181         // Clear approvals from the previous owner\n182         delete _tokenApprovals[tokenId];\n\n183         unchecked {\n184             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n185             // `from`'s balance is the number of token held, which is at least one before the current\n186             // transfer.\n187             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n188             // all 2**256 token ids to be minted, which in practice is impossible.\n189             _balances[from] -= 1;\n190             _balances[to] += 1;\n191         }\n192         _owners[tokenId] = to;\n\n193         emit Transfer(from, to, tokenId);\n\n194         _afterTokenTransfer(from, to, tokenId, 1);\n195     }\n\n\n196     function _approve(address to, uint256 tokenId) internal virtual {\n197         _tokenApprovals[tokenId] = to;\n198         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n199     }\n\n\n200     function _setApprovalForAll(\n201         address owner,\n202         address operator,\n203         bool approved\n204     ) internal virtual {\n205         require(owner != operator, \"ERC721: approve to caller\");\n206         _operatorApprovals[owner][operator] = approved;\n207         emit ApprovalForAll(owner, operator, approved);\n208     }\n\n209     function _requireMinted(uint256 tokenId) internal view virtual {\n210         require(_exists(tokenId), \"ERC721: invalid token ID\");\n211     }\n\n\n\n212     function _checkOnERC721Received(\n213         address from,\n214         address to,\n215         uint256 tokenId,\n216         bytes memory data\n217     ) private returns (bool) {\n218         if (to.isContract()) {\n219             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n220                 return retval == IERC721Receiver.onERC721Received.selector;\n221             } catch (bytes memory reason) {\n222                 if (reason.length == 0) {\n223                     revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n224                 } else {\n225                     /// @solidity memory-safe-assembly\n226                     assembly {\n227                         revert(add(32, reason), mload(reason))\n228                     }\n229                 }\n230             }\n231         } else {\n232             return true;\n233         }\n234     }\n\n\n235     function _beforeTokenTransfer(\n236         address from,\n237         address to,\n238         uint256, /* firstTokenId */\n239         uint256 batchSize\n240     ) internal virtual {\n241         if (batchSize > 1) {\n242             if (from != address(0)) {\n243                 _balances[from] -= batchSize;\n244             }\n245             if (to != address(0)) {\n246                 _balances[to] += batchSize;\n247             }\n248         }\n249     }\n\n  \n250     function _afterTokenTransfer(\n251         address from,\n252         address to,\n253         uint256 firstTokenId,\n254         uint256 batchSize\n255     ) internal virtual {}\n256 }\n42+\n",
    "transaction-context": "require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n",
    "Critical-points": "require(owner != address(0), \"ERC721: invalid token ID\");",
    "invariants": "require(to != owner, \"ERC721: approval to current owner\");\n",
    "critical-invariants": "require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");",
    "ranks": "assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);",
    "vulnerabilities": "assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n\n3 /**\n4  * @title Compound's CErc20 Contract\n5  * @notice CTokens which wrap an EIP-20 underlying\n6  * @author Compound\n7  */\n8 contract CErc20 is CToken, CErc20Interface {\n9     /**\n10      * @notice Initialize the new money market\n11      * @param underlying_ The address of the underlying asset\n12      * @param comptroller_ The address of the Comptroller\n13      * @param interestRateModel_ The address of the interest rate model\n14      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n15      * @param name_ ERC-20 name of this token\n16      * @param symbol_ ERC-20 symbol of this token\n17      * @param decimals_ ERC-20 decimal precision of this token\n18      */\n19     function initialize(\n20         address underlying_,\n21         ComptrollerInterface comptroller_,\n22         InterestRateModel interestRateModel_,\n23         uint256 initialExchangeRateMantissa_,\n24         string memory name_,\n25         string memory symbol_,\n26         uint8 decimals_\n27     ) public {\n28         // CToken initialize does the bulk of the work\n29         super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n30         // Set underlying and sanity check it\n31         underlying = underlying_;\n32         EIP20Interface(underlying).totalSupply();\n33     }\n\n34     /*** User Interface ***/\n\n35     /**\n36      * @notice Sender supplies assets into the market and receives cTokens in exchange\n37      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n38      * @param mintAmount The amount of the underlying asset to supply\n39      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n40      */\n41     function mint(uint256 mintAmount) external returns (uint256) {\n42         (uint256 err, ) = mintInternal(mintAmount, false);\n       \n43     }\n\n44     /**\n45      * @notice Sender redeems cTokens in exchange for the underlying asset\n46      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n47      * @param redeemTokens The number of cTokens to redeem into underlying\n48      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n49      */\n50     function redeem(uint256 redeemTokens) external returns (uint256) {\n51        _;\n52     }\n\n53     /**\n54      * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n55      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n56      * @param redeemAmount The amount of underlying to redeem\n57      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n58      */\n59     function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n60             _;\n61     }\n\n62     /**\n63      * @notice Sender borrows assets from the protocol to their own address\n64      * @param borrowAmount The amount of the underlying asset to borrow\n65      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n66      */\n67     function borrow(uint256 borrowAmount) external returns (uint256) {\n68          _;\n69     }\n\n70     /**\n71      * @notice Sender repays their own borrow\n72      * @param repayAmount The amount to repay\n73      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n74      */\n75     function repayBorrow(uint256 repayAmount) external returns (uint256) {\n76         (uint256 err, ) = repayBorrowInternal(repayAmount, false);\n       \n77     }\n\n78     /**\n79      * @notice Sender repays a borrow belonging to borrower\n80      * @param borrower the account with the debt being payed off\n81      * @param repayAmount The amount to repay\n82      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n83      */\n84     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n85         (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount, false);        \n86     }\n\n87     /**\n88      * @notice The sender liquidates the borrowers collateral.\n89      *  The collateral seized is transferred to the liquidator.\n90      * @param borrower The borrower of this cToken to be liquidated\n91      * @param repayAmount The amount of the underlying borrowed asset to repay\n92      * @param cTokenCollateral The market in which to seize collateral from the borrower\n93      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n94      */\n95     function liquidateBorrow(\n96         address borrower,\n97         uint256 repayAmount,\n98         CTokenInterface cTokenCollateral\n99     ) external returns (uint256) {\n100         (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral, false);\n       \n101     }\n\n102     /**\n103      * @notice The sender adds to reserves.\n104      * @param addAmount The amount fo underlying token to add as reserves\n105      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n106      */\n107     function _addReserves(uint256 addAmount) external returns (uint256) {\n108         _;\n109     }\n\n110     /*** Safe Token ***/\n\n111     /**\n112      * @notice Gets balance of this contract in terms of the underlying\n113      * @dev This excludes the value of the current message, if any\n114      * @return The quantity of underlying tokens owned by this contract\n115      */\n116     function getCashPrior() internal view returns (uint256) {\n117         EIP20Interface token = EIP20Interface(underlying);\n118         return token.balanceOf(address(this));\n119     }\n\n120     /**\n121      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n122      *      This will revert due to insufficient balance or insufficient allowance.\n123      *      This function returns the actual amount received,\n124      *      which may be less than `amount` if there is a fee attached to the transfer.\n125      *\n126      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n127      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n128      */\n129     function doTransferIn(\n130         address from,\n131         uint256 amount,\n132         bool isNative\n133     ) internal returns (uint256) {\n134         isNative; // unused\n\n135         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n136         uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n137         token.transferFrom(from, address(this), amount);\n\n138         bool success;\n139         assembly {\n140             switch returndatasize()\n141             case 0 {\n142                 // This is a non-standard ERC-20\n143                 success := not(0) // set success to true\n144             }\n145             case 32 {\n146                 // This is a compliant ERC-20\n147                 returndatacopy(0, 0, 32)\n148                 success := mload(0) // Set `success = returndata` of external call\n149             }\n150             default {\n151                 // This is an excessively non-compliant ERC-20, revert.\n152                 revert(0, 0)\n153             }\n154         }       \n\n155         // Calculate the amount that was *actually* transferred\n156         uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n157         return sub_(balanceAfter, balanceBefore);\n158     }\n\n159     /**\n160      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n161      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n162      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n163      *      it is >= amount, this should not revert in normal conditions.\n164      *\n165      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n166      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n167      */\n168     function doTransferOut(\n169         address payable to,\n170         uint256 amount,\n171         bool isNative\n172     ) internal {\n173         isNative; // unused\n\n174         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n175         token.transfer(to, amount);\n\n176         bool success;\n177         assembly {\n178             switch returndatasize()\n179             case 0 {\n180                 // This is a non-standard ERC-20\n181                 success := not(0) // set success to true\n182             }\n183             case 32 {\n184                 // This is a complaint ERC-20\n185                 returndatacopy(0, 0, 32)\n186                 success := mload(0) // Set `success = returndata` of external call\n187             }\n188             default {\n189                 // This is an excessively non-compliant ERC-20, revert.\n190                 revert(0, 0)\n191             }\n192         }\n193     }\n\n194     /**\n195      * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n196      * @dev Called by both `transfer` and `transferFrom` internally\n197      * @param spender The address of the account performing the transfer\n198      * @param src The address of the source account\n199      * @param dst The address of the destination account\n200      * @param tokens The number of tokens to transfer\n201      * @return Whether or not the transfer succeeded\n202      */\n203     function transferTokens(\n204         address spender,\n205         address src,\n206         address dst,\n207         uint256 tokens\n208     ) internal returns (uint256) {\n209         /* Fail if transfer not allowed */\n        \n   \n210         /* Get the allowance, infinite for the account owner */\n211         uint256 startingAllowance = 0;\n212         if (spender == src) {\n213             startingAllowance = uint256(-1);\n214         } else {\n215             startingAllowance = transferAllowances[src][spender];\n216         }\n\n217         /* Do the calculations, checking for {under,over}flow */\n218         accountTokens[src] = sub_(accountTokens[src], tokens);\n219         accountTokens[dst] = add_(accountTokens[dst], tokens);\n\n220         /* Eat some of the allowance (if necessary) */\n221         if (startingAllowance != uint256(-1)) {\n222             transferAllowances[src][spender] = sub_(startingAllowance, tokens);\n223         }\n\n224         /* We emit a Transfer event */\n225         emit Transfer(src, dst, tokens);\n\n226         comptroller.transferVerify(address(this), src, dst, tokens);\n\n227         return uint256(Error.NO_ERROR);\n228     }\n\n229     /**\n230      * @notice Get the account's cToken balances\n231      * @param account The address of the account\n232      */\n233     function getCTokenBalanceInternal(address account) internal view returns (uint256) {\n234         return accountTokens[account];\n235     }\n\n236     struct MintLocalVars {\n237         uint256 exchangeRateMantissa;\n238         uint256 mintTokens;\n239         uint256 actualMintAmount;\n240     }\n\n241     /**\n242      * @notice User supplies assets into the market and receives cTokens in exchange\n243      * @dev Assumes interest has already been accrued up to the current block\n244      * @param minter The address of the account which is supplying the assets\n245      * @param mintAmount The amount of the underlying asset to supply\n246      * @param isNative The amount is in native or not\n247      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n248      */\n249     function mintFresh(\n250         address minter,\n251         uint256 mintAmount,\n252         bool isNative\n253     ) internal returns (uint256, uint256) {\n\n254         /*\n255          * Return if mintAmount is zero.\n256          * Put behind `mintAllowed` for accuring potential COMP rewards.\n257          */\n258         if (mintAmount == 0) {\n259             return (uint256(Error.NO_ERROR), 0);\n260         }\n\n      \n\n261         MintLocalVars memory vars;\n\n262         vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n263         /////////////////////////\n264         // EFFECTS & INTERACTIONS\n265         // (No safe failures beyond this point)\n\n266         /*\n267          *  We call `doTransferIn` for the minter and the mintAmount.\n268          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n269          *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n270          *  side-effects occurred. The function returns the amount actually transferred,\n271          *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n272          *  of cash.\n273          */\n274         vars.actualMintAmount = doTransferIn(minter, mintAmount, isNative);\n\n275         /*\n276          * We get the current exchange rate and calculate the number of cTokens to be minted:\n277          *  mintTokens = actualMintAmount / exchangeRate\n278          */\n279         vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n280         /*\n281          * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n282          *  totalSupply = totalSupply + mintTokens\n283          *  accountTokens[minter] = accountTokens[minter] + mintTokens\n284          */\n285         totalSupply = add_(totalSupply, vars.mintTokens);\n286         accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n287         /* We emit a Mint event, and a Transfer event */\n288         emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n289         emit Transfer(address(this), minter, vars.mintTokens);\n\n290         /* We call the defense hook */\n291         comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n292         return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n293     }\n\n294     struct RedeemLocalVars {\n295         uint256 exchangeRateMantissa;\n296         uint256 redeemTokens;\n297         uint256 redeemAmount;\n298         uint256 totalSupplyNew;\n299         uint256 accountTokensNew;\n300     }\n\n301     /**\n302      * @notice User redeems cTokens in exchange for the underlying asset\n303      * @dev Assumes interest has already been accrued up to the current block. Only one of redeemTokensIn or redeemAmountIn may be non-zero and it would do nothing if both are zero.\n304      * @param redeemer The address of the account which is redeeming the tokens\n305      * @param redeemTokensIn The number of cTokens to redeem into underlying\n306      * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens\n307      * @param isNative The amount is in native or not\n308      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n309      */\n310     function redeemFresh(\n311         address payable redeemer,\n312         uint256 redeemTokensIn,\n313         uint256 redeemAmountIn,\n314         bool isNative\n315     ) internal returns (uint256) {\n       \n316         RedeemLocalVars memory vars;\n\n317         /* exchangeRate = invoke Exchange Rate Stored() */\n318         vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n319         /* If redeemTokensIn > 0: */\n320         if (redeemTokensIn > 0) {\n321             /*\n322              * We calculate the exchange rate and the amount of underlying to be redeemed:\n323              *  redeemTokens = redeemTokensIn\n324              *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n325              */\n326             vars.redeemTokens = redeemTokensIn;\n327             vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n328         } else {\n329             /*\n330              * We get the current exchange rate and calculate the amount to be redeemed:\n331              *  redeemTokens = redeemAmountIn / exchangeRate\n332              *  redeemAmount = redeemAmountIn\n333              */\n334             vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n335             vars.redeemAmount = redeemAmountIn;\n336         }\n\n \n337         /*\n338          * Return if redeemTokensIn and redeemAmountIn are zero.\n339          * Put behind `redeemAllowed` for accuring potential COMP rewards.\n340          */\n341         if (redeemTokensIn == 0 && redeemAmountIn == 0) {\n342             return uint256(Error.NO_ERROR);\n343         }\n\n344         /*\n345          * We calculate the new total supply and redeemer balance, checking for underflow:\n346          *  totalSupplyNew = totalSupply - redeemTokens\n347          *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n348          */\n349         vars.totalSupplyNew = sub_(totalSupply, vars.redeemTokens);\n350         vars.accountTokensNew = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n         \n351         /////////////////////////\n352         // EFFECTS & INTERACTIONS\n353         // (No safe failures beyond this point)\n\n354         /* We write previously calculated values into storage */\n355         totalSupply = vars.totalSupplyNew;\n356         accountTokens[redeemer] = vars.accountTokensNew;\n\n357         /*\n358          * We invoke doTransferOut for the redeemer and the redeemAmount.\n359          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n360          *  On success, the cToken has redeemAmount less of cash.\n361          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n362          */\n363         doTransferOut(redeemer, vars.redeemAmount, isNative);\n\n364         /* We emit a Transfer event, and a Redeem event */\n365         emit Transfer(redeemer, address(this), vars.redeemTokens);\n366         emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n367         /* We call the defense hook */\n368         comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n369         return uint256(Error.NO_ERROR);\n370     }\n\n371     /**\n372      * @notice Transfers collateral tokens (this market) to the liquidator.\n373      * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n374      *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n375      * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n376      * @param liquidator The account receiving seized collateral\n377      * @param borrower The account having collateral seized\n378      * @param seizeTokens The number of cTokens to seize\n379      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n380      */\n381     function seizeInternal(\n382         address seizerToken,\n383         address liquidator,\n384         address borrower,\n385         uint256 seizeTokens\n386     ) internal returns (uint256) {\n\n387        /*\n388          * Return if seizeTokens is zero.\n389          * Put behind `seizeAllowed` for accuring potential COMP rewards.\n390          */\n391         if (seizeTokens == 0) {\n392             return uint256(Error.NO_ERROR);\n393         }\n394               /*\n395          * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n396          *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n397          *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n398          */\n399         accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n400         accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n\n401         /* Emit a Transfer event */\n402         emit Transfer(borrower, liquidator, seizeTokens);\n\n403         /* We call the defense hook */\n404         comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n405         return uint256(Error.NO_ERROR);\n406     }\n407 }\n253+ \n",
    "transaction-context": "require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");",
    "Critical-points": "require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");",
    "invariants": "require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");",
    "critical-invariants": "require(comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens) == 0, \"comptroller rejection\");",
    "ranks": "require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");",
    "vulnerabilities": "require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");"
  },
  {
    "code": "1 contract PausableToken is StandardToken, Pausable {\n2 \n3   function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n4     return super.transfer(_to, _value);\n5   }\n6 \n7   function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n8     return super.transferFrom(_from, _to, _value);\n9   }\n10 \n11   function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n12     return super.approve(_spender, _value);\n13   }\n14   \n15   function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n16     uint cnt = _receivers.length;\n17     uint256 amount = uint256(cnt) * _value;\n18     require(cnt > 0 && cnt <= 20);\n19     require(_value > 0 && balances[msg.sender] >= amount);\n20 \n21     balances[msg.sender] = balances[msg.sender].sub(amount);\n22     for (uint i = 0; i < cnt; i++) {\n23         balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n24         Transfer(msg.sender, _receivers[i], _value);\n25     }\n26     return true;\n27   }\n28 }\n",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 18 \n19 \n19+ ",
    "invariants": "18 require(cnt > 0 && cnt <= 20);\n19 require(_value > 0 && balances[msg.sender] >= amount);\n19+ assert(amount >0);",
    "critical-invariants": "19+ assert(amount >0);",
    "ranks": "19+ assert(amount >0);",
    "vulnerabilities": "integer overflow"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n4 import { LibAsset } from \"../Libraries/LibAsset.sol\";\n5 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n6 import { LibSwap } from \"../Libraries/LibSwap.sol\";\n7 import { ICBridge } from \"../Interfaces/ICBridge.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n9 /**\n10  * @title CBridge Facet\n11  * @author Li.Finance (https://li.finance)\n12  * @notice Provides functionality for bridging through CBridge\n13  */\n14 contract CBridgeFacet is ILiFi {\n15     /* ========== Storage ========== */\n\n16     bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.cbridge2\");\n17     invokeSwap bool; \n18     struct Storage {\n19         address cBridge;\n20         uint64 cBridgeChainId;\n21     }\n\n22     /* ========== Types ========== */\n\n23     struct CBridgeData {\n24         address receiver;\n25         address token;\n26         uint256 amount;\n27         uint64 dstChainId;\n28         uint64 nonce;\n29         uint32 maxSlippage;\n30     }\n\n31     /* ========== Init ========== */\n\n32     /**\n33      * @notice Initializes local variables for the CBridge facet\n34      * @param _cBridge address of the canonical CBridge router contract\n35      * @param _chainId chainId of this deployed contract\n36      */\n37     function initCbridge(address _cBridge, uint64 _chainId) external {\n38         Storage storage s = getStorage();\n39         LibDiamond.enforceIsContractOwner();\n40         s.cBridge = _cBridge;\n41         s.cBridgeChainId = _chainId;\n42         emit Inited(s.cBridge, s.cBridgeChainId);\n43     }\n\n44     /* ========== Public Bridge Functions ========== */\n\n45     /**\n46      * @notice Bridges tokens via CBridge\n47      * @param _lifiData data used purely for tracking and analytics\n48      * @param _cBridgeData data specific to CBridge\n49      */\n50     function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {\n51         if (_cBridgeData.token != address(0)) {\n52             uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n53             LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);\n\n54             require(\n55                 LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,\n56                 \"ERR_INVALID_AMOUNT\"\n57             );\n58         } else {\n59             _;\n\n60         }\n\n61         _startBridge(_cBridgeData);\n\n62         emit LiFiTransferStarted(\n63             _lifiData.transactionId,\n64             _lifiData.integrator,\n65             _lifiData.referrer,\n66             _lifiData.sendingAssetId,\n67             _lifiData.receivingAssetId,\n68             _lifiData.receiver,\n69             _lifiData.amount,\n70             _lifiData.destinationChainId,\n71             block.timestamp\n72         );\n73     }\n\n74     /**\n75      * @notice Performs a swap before bridging via CBridge\n76      * @param _lifiData data used purely for tracking and analytics\n77      * @param _swapData an array of swap related data for performing swaps before bridging\n78      * @param _cBridgeData data specific to CBridge\n79      */\n80     function swapAndStartBridgeTokensViaCBridge(\n81         LiFiData memory _lifiData,\n82         LibSwap.SwapData[] calldata _swapData,\n83         CBridgeData memory _cBridgeData\n84     ) public payable {\n85         if (_cBridgeData.token != address(0)) {\n86             uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n87             // Swap\n88             for (uint8 i; i < _swapData.length; i++) {\n89                 invokeSwap = true; \n90                 LibSwap.swap(_lifiData.transactionId, _swapData[i], invokeSwap);\n91             }\n\n92             uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;          \n\n93             _cBridgeData.amount = _postSwapBalance;\n94         } else {\n95             uint256 _fromBalance = address(this).balance;\n\n96             // Swap\n97             for (uint8 i; i < _swapData.length; i++) {\n98                 invokeSwap = true; \n99                 LibSwap.swap(_lifiData.transactionId, _swapData[i],  invokeSwap);\n100             }\n\n101             uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n102             _cBridgeData.amount = _postSwapBalance;\n103         }\n\n104         _startBridge(_cBridgeData);\n\n105         emit LiFiTransferStarted(\n106             _lifiData.transactionId,\n107             _lifiData.integrator,\n108             _lifiData.referrer,\n109             _lifiData.sendingAssetId,\n110             _lifiData.receivingAssetId,\n111             _lifiData.receiver,\n112             _lifiData.amount,\n113             _lifiData.destinationChainId,\n114             block.timestamp\n115         );\n116     }\n\n117     /* ========== Internal Functions ========== */\n\n118     /*\n119      * @dev Conatains the business logic for the bridge via CBridge\n120      * @param _cBridgeData data specific to CBridge\n121      */\n122     function _startBridge(CBridgeData memory _cBridgeData) internal {\n123         Storage storage s = getStorage();\n124         address bridge = _bridge();\n\n125         // Do CBridge stuff      \n126         if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n127             ICBridge(bridge).sendNative(\n128                 _cBridgeData.receiver,\n129                 _cBridgeData.amount,\n130                 _cBridgeData.dstChainId,\n131                 _cBridgeData.nonce,\n132                 _cBridgeData.maxSlippage\n133             );\n134         } else {\n135             // Give CBridge approval to bridge tokens\n136             LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n137             // solhint-disable check-send-result\n138             ICBridge(bridge).send(\n139                 _cBridgeData.receiver,\n140                 _cBridgeData.token,\n141                 _cBridgeData.amount,\n142                 _cBridgeData.dstChainId,\n143                 _cBridgeData.nonce,\n144                 _cBridgeData.maxSlippage\n145             );\n146         }\n147     }\n\n148     /*\n149      * @dev Public view function for the CBridge router address\n150      * @returns the router address\n151      */\n152     function _bridge() internal view returns (address) {\n153         Storage storage s = getStorage();\n154         return s.cBridge;\n155     }\n\n156     /**\n157      * @dev fetch local storage\n158      */\n159     function getStorage() internal pure returns (Storage storage s) {\n160         bytes32 namespace = NAMESPACE;\n161         // solhint-disable-next-line no-inline-assembly\n162         assembly {\n163             s.slot := namespace\n164         }\n165     }\n166 }\n167 // SPDX-License-Identifier: MIT\n168 pragma solidity ^0.8.7;\n\n169 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n170 import { LibAsset } from \"./LibAsset.sol\";\n171 import { LibUtil } from \"./LibUtil.sol\";\n\n172 library LibSwap {\n173     uint256 private constant MAX_INT = 2**256 - 1;\n\n174     struct SwapData {\n175         address callTo;\n176         address approveTo;\n177         address sendingAssetId;\n178         address receivingAssetId;\n179         uint256 fromAmount;\n180         bytes callData;\n181     }\n\n182     event AssetSwapped(\n183         bytes32 transactionId,\n184         address dex,\n185         address fromAssetId,\n186         address toAssetId,\n187         uint256 fromAmount,\n188         uint256 toAmount,\n189         uint256 timestamp\n190     );\n\n191     function swap(bytes32 transactionId, SwapData calldata _swapData, bool invokeSwap) internal {       \n192         uint256 fromAmount = _swapData.fromAmount;\n193         uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n194         address fromAssetId = _swapData.sendingAssetId;\n195         if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n196             LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);\n197         }\n\n198         if (!LibAsset.isNativeAsset(fromAssetId)) {\n199             LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n200         }\n\n201         // solhint-disable-next-line avoid-low-level-calls\n202         (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n203         if (!success) {\n204             string memory reason = LibUtil.getRevertMsg(res);\n205             revert(reason);\n206         }\n\n207         toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n208         emit AssetSwapped(\n209             transactionId,\n210             _swapData.callTo,\n211             _swapData.sendingAssetId,\n212             _swapData.receivingAssetId,\n213             fromAmount,\n214             toAmount,\n215             block.timestamp\n216         );\n217     }\n218 }\n",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 58+ \n92+  \n101+\n125+  \n191+  ",
    "invariants": "58+ require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n92+  require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n101+ require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n125+  require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n191+  assert(!invokeSwap);",
    "critical-invariants": "191+  assert(!invokeSwap);",
    "ranks": "191+  assert(!invokeSwap);",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }\n\n8 contract ERC20 is ERC20Basic {\n9     function allowance(address owner, address spender) public view returns (uint256);\n10     function transferFrom(address from, address to, uint256 value) public returns (bool);\n11     function approve(address spender, uint256 value) public returns (bool); \n12     event Approval(address indexed owner, address indexed spender, uint256 value);\n13 }\n\n14 contract BasicToken is ERC20Basic {\n15     using SafeMath for uint256;\n\n16     mapping(address => uint256) balances;\n\n17     uint256 totalSupply_;\n\n18     function totalSupply() public view returns (uint256) {\n19         return totalSupply_;\n20     }\n\n21     function transfer(address _to, uint256 _value) public returns (bool) {\n\n22         balances[msg.sender] = balances[msg.sender].sub(_value);\n23         balances[_to] = balances[_to].add(_value);\n    \n24         emit Transfer(msg.sender, _to, _value);\n25         return true;\n26     }\n\n27     function balanceOf(address _owner) public view returns (uint256) {\n28         return balances[_owner];\n29     }\n30 }\n\n31 contract Ownable {\n\n32     address public owner;\n33     address public operator;\n\n34     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n35     event OperatorTransferred(address indexed previousOperator, address indexed newOperator);\n\n36     constructor() public {\n37         owner    = msg.sender;\n38         operator = msg.sender;\n39     }\n\n40     modifier onlyOwner() { \n41          _; }\n42     modifier onlyOwnerOrOperator() {      \n43            _; }\n\n44     function transferOwnership(address _newOwner) external onlyOwner {      \n45         emit OwnershipTransferred(owner, _newOwner);\n46         owner = _newOwner;\n47     }\n  \n48     function transferOperator(address _newOperator) external onlyOwner { \n49         emit OperatorTransferred(operator, _newOperator);\n50         operator = _newOperator;\n51     }\n52 }\n\n53 contract BlackList is Ownable {\n\n54     event Lock(address indexed LockedAddress);\n55     event Unlock(address indexed UnLockedAddress);\n\n56     mapping( address => bool ) public blackList;\n\n57     modifier CheckBlackList {    \n58         _; }\n\n59     function SetLockAddress(address _lockAddress) external onlyOwnerOrOperator returns (bool) { \n        \n60         blackList[_lockAddress] = true;\n        \n61         emit Lock(_lockAddress);\n\n62         return true;\n63     }\n\n64     function UnLockAddress(address _unlockAddress) external onlyOwner returns (bool) {      \n        \n65         blackList[_unlockAddress] = false;\n        \n66         emit Unlock(_unlockAddress);\n\n67         return true;\n68     }\n69 }\n\n70 contract Pausable is Ownable {\n71     event Pause();\n72     event Unpause();\n\n73     bool public paused = false;\n\n74     modifier whenNotPaused() { require(!paused); _; }\n75     modifier whenPaused() { require(paused); _; }\n\n76     function pause() onlyOwnerOrOperator whenNotPaused public {\n77         paused = true;\n78         emit Pause();\n79     }\n\n80     function unpause() onlyOwner whenPaused public {\n81         paused = false;\n82         emit Unpause();\n83     }\n84 }\n\n85 contract StandardToken is ERC20, BasicToken {\n  \n86     mapping (address => mapping (address => uint256)) internal allowed;\n\n87     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        \n88         balances[_from] = balances[_from].sub(_value);\n89         balances[_to] = balances[_to].add(_value);\n90         allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    \n91         emit Transfer(_from, _to, _value);\n92         emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n    \n93         return true;\n94     }\n\n95     function approve(address _spender, uint256 _value) public returns (bool) {\n96         allowed[msg.sender][_spender] = _value;\n    \n97         emit Approval(msg.sender, _spender, _value);\n    \n98         return true;\n99     }\n\n100     function allowance(address _owner, address _spender) public view returns (uint256) {\n101         return allowed[_owner][_spender];\n102     }\n\n103     function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n104         allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n    \n105         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    \n106         return true;\n107     }\n\n108     function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n109         uint256 oldValue = allowed[msg.sender][_spender];\n    \n110         if (_subtractedValue > oldValue) {\n111             allowed[msg.sender][_spender] = 0;\n112         } else {\n113             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n114         }\n    \n115         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n116         return true;\n117     }\n118 }\n\n119 contract MultiTransferToken is StandardToken, Ownable {\n\n120     function MultiTransfer(address[] _to, uint256[] _amount) onlyOwner public returns (bool) {\n        \n121         uint256 ui;\n122         uint256 amountSum = 0;\n    \n123         for (ui = 0; ui < _to.length; ui++) {          \n\n124             amountSum = amountSum.add(_amount[ui]);\n125         }       \n\n126         for (ui = 0; ui < _to.length; ui++) {\n127             balances[msg.sender] = balances[msg.sender].sub(_amount[ui]);\n128             balances[_to[ui]] = balances[_to[ui]].add(_amount[ui]);\n        \n129             emit Transfer(msg.sender, _to[ui], _amount[ui]);\n130         }\n    \n131         return true;\n132     }\n133 }\n\n134 contract BurnableToken is StandardToken, Ownable {\n\n135     event BurnAdminAmount(address indexed burner, uint256 value);\n\n136     function burnAdminAmount(uint256 _value) onlyOwner public {      \n\n137         balances[msg.sender] = balances[msg.sender].sub(_value);\n138         totalSupply_ = totalSupply_.sub(_value);\n    \n139         emit BurnAdminAmount(msg.sender, _value);\n140         emit Transfer(msg.sender, address(0), _value);\n141     }\n142 }\n\n143 contract MintableToken is StandardToken, Ownable {\n144     event Mint(address indexed to, uint256 amount);\n145     event MintFinished();\n\n146     bool public mintingFinished = false;\n\n147     modifier canMint() { require(!mintingFinished); _; }\n\n148     function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n149         totalSupply_ = totalSupply_.add(_amount);\n150         balances[_to] = balances[_to].add(_amount);\n    \n151         emit Mint(_to, _amount);\n152         emit Transfer(address(0), _to, _amount);\n    \n153         return true;\n154     }\n\n155     function finishMinting() onlyOwner canMint public returns (bool) {\n156         mintingFinished = true;\n157         emit MintFinished();\n158         return true;\n159     }\n160 }\n\n161 contract PausableToken is StandardToken, Pausable, BlackList {\n\n162     function transfer(address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {\n163         return super.transfer(_to, _value);\n164     }\n\n165     function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {      \n\n166         return super.transferFrom(_from, _to, _value);\n167     }\n\n168     function approve(address _spender, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {\n169         return super.approve(_spender, _value);\n170     }\n\n171     function increaseApproval(address _spender, uint _addedValue) public whenNotPaused CheckBlackList returns (bool success) {\n172         return super.increaseApproval(_spender, _addedValue);\n173     }\n\n174     function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused CheckBlackList returns (bool success) {\n175         return super.decreaseApproval(_spender, _subtractedValue);\n176     }\n177 }\n44+\n",
    "transaction-context": "require(_newOwner != address(0));",
    "Critical-points": "require(_newOperator != address(0));",
    "invariants": "require(blackList[msg.sender] != true);",
    "critical-invariants": "require(_lockAddress != address(0));\nrequire(_lockAddress != owner);\nrequire(blackList[_lockAddress] != true);",
    "ranks": "require(blackList[_unlockAddress] != false);",
    "vulnerabilities": "require(_to != address(0));\nrequire(_value <= balances[_from]);\nrequire(_value <= allowed[_from][msg.sender]);"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n\n5 /**\n6  * A highly simplified Token to express basic specifications\n7  * \n8  * - totalSupply() equals the Sum({balanceOf(a) | a is an address })\n9  * \n10  */\n11 contract ERC20 is IERC20 {\n\n12     mapping (address => uint256) private _balances;\n13     uint256 private _totalSupply;\n\n\n14     /**\n15      * A dummy constructor\n16      */\n17     constructor (uint256 totalSupply) public {       \n18        _totalSupply = totalSupply;\n19        _balances[msg.sender] = totalSupply;\n20     }\n\n21     /**\n22      * @dev See {IERC20-totalSupply}.\n23      */\n24     function totalSupply() public view returns (uint256) {\n25         return _totalSupply;\n26     }\n\n27     /**\n28      * @dev See {IERC20-balanceOf}.\n29      */\n30     function balanceOf(address account) public view returns (uint256) {\n31         return _balances[account];\n32     }\n\n33     /**\n34      * @dev See {IERC20-transfer}.\n35      *\n36      * Requirements:\n37      *\n38      * - `recipient` cannot be the zero address.\n39      * - the caller must have a balance of at least `amount`.\n40      */\n41     function transfer(address recipient, uint256 amount) public returns (bool) {\n42         uint oldBalanceSender = _balances[msg.sender];\n\n43         _transfer(msg.sender, recipient, amount); \n\n44         //assert (/* msg.sender == recipient ||  */ _balances[msg.sender] == oldBalanceSender - amount);\n45         // the following assertion will fail due to overflow when not using safemath\n46         //   to detect it,  run with /modularArith flag\n47         //   to prove it, run ERC20 with /modularArith flag       \n48         return true;\n49     }\n\n50     /**\n51      * @dev Moves tokens `amount` from `sender` to `recipient`.\n52      *\n53      * This is internal function is equivalent to {transfer}, and can be used to\n54      * e.g. implement automatic token fees, slashing mechanisms, etc.\n55      *\n56      * Emits a {Transfer} event.\n57      *\n58      * Requirements:\n59      *\n60      * - `sender` cannot be the zero address.\n61      * - `recipient` cannot be the zero address.\n62      * - `sender` must have a balance of at least `amount`.\n63      */\n64     function _transfer(address sender, address recipient, uint256 amount) internal {\n65         require(sender != address(0), \"ERC20: transfer from the zero address\");\n66         require(recipient != address(0), \"ERC20: transfer to the zero address\");      \n67         _balances[sender] = SafeMath.sub(_balances[sender], amount);\n                        \n68                 _balances[recipient] = _balances[recipient] + amount; // nosafemath //_balances[recipient] = _balances[recipient].add(amount);\n69     }\n70 }\n",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 17+ \n47+ \n66+ ",
    "invariants": "17+ require(msg.sender != address(0));\n47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); \n66+ require(_balances[sender] >= amount);",
    "critical-invariants": "47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "ranks": "47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "vulnerabilities": "incorrect visibility/ownership\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {\n6         owner = msg.sender;\n7     }\n\n8     modifier onlyOwner {\n9         require(msg.sender == owner);\n10         _;\n11     }\n\n12     function transferOwnership(address newOwner) onlyOwner {\n13         owner = newOwner;\n14     }\n15 }\n\n16 contract PylonToken is owned {\n17     // Public variables of the token\n18     string public standard = \"Pylon Token - The first decentralized energy exchange platform powered by renewable energy\";\n19     string public name = 'Pylon Token';\n20     string public symbol = 'PYLNT';\n21     uint8 public decimals = 18;\n22     uint256 public totalSupply = 3750000000000000000000000;\n\n23     // This creates an array with all balances\n24     mapping (address => uint256) public balanceOf;\n25     mapping (address => bool) public frozenAccount;\n\n26     // This notifies about accounts locked\n27     event FrozenFunds(address target, bool frozen);\n\n28     // This generates a public event on the blockchain that will notify clients\n29     event Transfer(address indexed from, address indexed to, uint256 value);\n\n30     // This notifies clients about the amount burnt\n31     event Burn(address indexed from, uint256 value);\n\n32     using SafeMath for uint256;\n\n33     address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535;  //Chip-chap Klenergy Address of ether beneficiary account\n34     uint256 public fundingGoal = 21230434782608700000000;     // Foundig goal in weis = 21230,434782608700000000 Ethers\n35     uint256 public amountRaised;    // Quantity of weis investeds\n36     uint256 public deadline; // durationInMinutes * 60 / 17 + 5000;        // Last moment to invest\n37     uint256 public price = 6608695652173910;           // Ether cost of each token in weis 0,006608695652173910 ethers\n\n38     uint256 public totalTokensToSend = 3250000000000000000000000; // Total tokens offered in the total ICO\n\n39     uint256 public maxEtherInvestment = 826086956521739000000; //Ethers. To mofify the day when starts crowdsale, equivalent to 190.000\u20ac = 826,086956521739000000 ether\n40     uint256 public maxTokens = 297619047619048000000000; // 297,619.047619048000000000 PYLNT = 190.000 \u20ac + 56% bonus\n\n41     uint256 public bonusCap = 750000000000000000000000; // 750,000.000000000000000000 PYLNT last day before Crowdsale as 1,52\u20ac/token\n42     uint256 public pylonSelled = 0;\n\n43     uint256 public startBlockBonus;\n\n44     uint256 public endBlockBonus1;\n\n45     uint256 public endBlockBonus2;\n\n46     uint256 public endBlockBonus3;\n\n47     uint256 public qnt10k = 6578947368421050000000; // 6,578.947368421050000000 PYLNT = 10.000 \u20ac\n\n48     bool fundingGoalReached = false; // If founding goal is reached or not\n49     bool crowdsaleClosed = false;    // If crowdsale is closed or open\n\n50     event GoalReached(address deposit, uint256 amountDeposited);\n51     event FundTransfer(address backer, uint256 amount, bool isContribution);\n52     event LogQuantity(uint256 _amount, string _message);\n\n53     // Chequear\n54     uint256 public startBlock = getBlockNumber();\n\n55     bool public paused = false;\n\n56     //uint256 public balanceInvestor;\n57     //uint256 public ultimosTokensEntregados;\n\n58     modifier contributionOpen() {\n59         require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline);\n60         _;\n61     }\n\n62     modifier notPaused() {\n63         require(!paused);\n64         _;\n65     }\n\n66     function crowdsale() onlyOwner{\n67         paused = false;\n68     }\n\n69     event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value, uint256 amount);\n\n\n70     function PylonToken(\n71         uint256 initialSupply,\n72         string tokenName,\n73         uint8 decimalUnits,\n74         string tokenSymbol,\n75         address centralMinter,\n76         address ifSuccessfulSendTo,\n77         uint256 fundingGoalInWeis,\n78         uint256 durationInMinutes,\n79         uint256 weisCostOfEachToken\n80     ) {\n81         if (centralMinter != 0) owner = centralMinter;\n\n82         balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n83         totalSupply = initialSupply;                        // Update total supply\n84         name = tokenName;                                   // Set the name for display purposes\n85         symbol = tokenSymbol;                               // Set the symbol for display purposes\n86         decimals = decimalUnits;                            // Amount of decimals for display purposes\n\n87         beneficiary = ifSuccessfulSendTo;\n88         fundingGoal = fundingGoalInWeis;\n89         startBlock = getBlockNumber();\n90         startBlockBonus = getBlockNumber();\n91         endBlockBonus1 = getBlockNumber() + 15246 + 12600 + 500;    // 3 days + 35,5h + margen error = 15246 + 12600 + 500\n92         endBlockBonus2 = getBlockNumber() + 30492 + 12600 + 800;    // 6 days + 35,5h + margen error = 30492 + 12600 + 800\n93         endBlockBonus3 = getBlockNumber() + 45738 + 12600 + 1100;   // 9 days + 35,5h + margen error = 45738 + 12600 + 1100\n94         deadline = getBlockNumber() + (durationInMinutes * 60 / 17) + 5000; // durationInMinutes * 60 / 17 + 12600 + 5000 = Calculo bloques + margen error\n95         price = weisCostOfEachToken;\n96     }\n\n\n97     function _transfer(address _from, address _to, uint _value) internal {\n98         require(_to != 0x0);                             \n99         require(balanceOf[_from] >= _value);                \n100         require(balanceOf[_to] + _value > balanceOf[_to]);  \n101         require(!frozenAccount[_from]);                     \n102         require(!frozenAccount[_to]);                      \n103         balanceOf[_from] -= _value;                         \n104         balanceOf[_to] += _value;                          \n105         Transfer(_from, _to, _value);\n106     }\n\n\n107     function transfer(address _to, uint256 _value) {\n108         _transfer(msg.sender, _to, _value);\n109     }\n\n\n110     function burn(uint256 _value) onlyOwner returns (bool success) {\n111         require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n112         balanceOf[msg.sender] -= _value;            // Subtract from the sender\n113         totalSupply -= _value;                      // Updates totalSupply\n114         Burn(msg.sender, _value);\n115         return true;\n116     }\n\n  \n117     function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n118         require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n119         balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n120         totalSupply -= _value;                              // Update totalSupply\n121         Burn(_from, _value);\n122         return true;\n123     }\n\n\n124     function mintToken(address target, uint256 mintedAmount) onlyOwner {\n125         balanceOf[target] += mintedAmount;\n126         totalSupply += mintedAmount;\n127         Transfer(0, owner, mintedAmount);\n128         Transfer(owner, target, mintedAmount);\n129     }\n\n\n130     function freezeAccount(address target, bool freeze) onlyOwner {\n131         frozenAccount[target] = freeze;\n132         FrozenFunds(target, freeze);\n133     }\n\n\n134     function () payable notPaused{\n135         buyTokens(msg.sender);\n136     }\n\n137     // low level token purchase function\n138     function buyTokens(address investor) payable notPaused {\n139         require (!crowdsaleClosed); // Check if crowdsale is open or not\n140         require(investor != 0x0);  \n141         require(validPurchase()); \n142         require(maxEtherInvestment >= msg.value); \n143         require(balanceOf[investor] <= maxTokens); \n144         require(amountRaised <= fundingGoal); \n145         require(pylonSelled <= totalTokensToSend); \n\n\n146         //Check if It's time for pre ICO or ICO\n147         if(startBlockBonus <= getBlockNumber() && startBlock <= getBlockNumber() && endBlockBonus3 >= getBlockNumber() && pylonSelled <= bonusCap){\n148           buyPreIco(investor);\n149         } else if(deadline >= getBlockNumber()){\n150           buyIco(investor);\n151         }\n\n152     }\n\n153     function buyIco(address investor) internal{\n154       uint256 weiAmount = msg.value;\n\n155       // calculate token amount to be sent\n156       uint256 tokens = weiAmount.mul(10**18).div(price);\n\n157       require((balanceOf[investor] + tokens) <= maxTokens);    \n158       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n160      balanceOf[this] -= tokens;\n161       balanceOf[investor] += tokens;\n162       amountRaised += weiAmount; // update state amount raised\n163       pylonSelled += tokens; // Total tokens selled\n\n164       beneficiary.transfer(weiAmount); //Transfer ethers to beneficiary\n\n165       frozenAccount[investor] = true;\n166       FrozenFunds(investor, true);\n\n167       TokenPurchase(msg.sender, investor, weiAmount, tokens);\n168     }\n\n169     function buyPreIco(address investor) internal{\n170       uint256 weiAmount = msg.value;\n\n171       uint256 bonusPrice = 0;\n172       uint256 tokens = weiAmount.mul(10**18).div(price);\n\n173       if(endBlockBonus1 >= getBlockNumber()){\n174         if(tokens == qnt10k.mul(19) ){\n175           bonusPrice = 2775652173913040;\n176         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n177           bonusPrice = 2907826086956520;\n178         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n179           bonusPrice = 3040000000000000;\n180         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n181           bonusPrice = 3172173913043480;\n182         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n183           bonusPrice = 3304347826086960;\n184         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n185           bonusPrice = 3436521739130430;\n186         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n187           bonusPrice = 3568695652173910;\n188         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n189           bonusPrice = 3700869565217390;\n190         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n191           bonusPrice = 3833043478260870;\n192         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n193           bonusPrice = 3965217391304350;\n194         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n195           bonusPrice = 4097391304347830;\n196         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n197           bonusPrice = 4229565217391300;\n198         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n199           bonusPrice = 4361739130434780;\n200         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n201           bonusPrice = 4493913043478260;\n202         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n203           bonusPrice = 4626086956521740;\n204         }else{\n205           bonusPrice = 5286956521739130;\n206         }\n207       }else if(endBlockBonus2 >= getBlockNumber()){\n208         if(tokens == qnt10k.mul(19) ){\n209           bonusPrice = 3436521739130430;\n210         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n211           bonusPrice = 3568695652173910;\n212         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n213           bonusPrice = 3700869565217390;\n214         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n215           bonusPrice = 3833043478260870;\n216         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n217           bonusPrice = 3965217391304350;\n218         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n219           bonusPrice = 4097391304347830;\n220         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n221           bonusPrice = 4229565217391300;\n222         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n223           bonusPrice = 4361739130434780;\n224         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n225           bonusPrice = 4493913043478260;\n226         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n227           bonusPrice = 4626086956521740;\n228         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n229           bonusPrice = 4758260869565220;\n230         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n231           bonusPrice = 4890434782608700;\n232         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n233           bonusPrice = 5022608695652170;\n234         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n235           bonusPrice = 5154782608695650;\n236         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n237           bonusPrice = 5286956521739130;\n238         }else{\n239           bonusPrice = 5947826086956520;\n240         }\n241       }else{\n242         if(tokens == qnt10k.mul(19) ){\n243           bonusPrice = 3766956521739130;\n244         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n245           bonusPrice = 3899130434782610;\n246         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n247           bonusPrice = 4031304347826090;\n248         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n249           bonusPrice = 4163478260869570;\n250         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n251           bonusPrice = 4295652173913040;\n252         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n253           bonusPrice = 4427826086956520;\n254         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n255           bonusPrice = 4560000000000000;\n256         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n257           bonusPrice = 4692173913043480;\n258         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n259           bonusPrice = 4824347826086960;\n260         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n261           bonusPrice = 4956521739130430;\n262         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n263           bonusPrice = 5088695652173910;\n264         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n265           bonusPrice = 5220869565217390;\n266         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n267           bonusPrice = 5353043478260870;\n268         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n269           bonusPrice = 5485217391304350;\n270         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n271           bonusPrice = 5617391304347830;\n272         }else{\n273           bonusPrice = 6278260869565220;\n274         }\n275       }\n\n276       tokens = weiAmount.mul(10**18).div(bonusPrice);\n\n277       require(pylonSelled + tokens <= bonusCap); // Check if want to sell more than total tokens for pre-ico\n278       require(balanceOf[investor] + tokens <= maxTokens); // Check if the investor has more tokens than 5% of total supply\n279       require(balanceOf[this] >= tokens);             // checks if it has enough to sell\n\n280       balanceOf[this] -= tokens;\n281       balanceOf[investor] += tokens;\n282       amountRaised += weiAmount; // update state amount raised\n283       pylonSelled += tokens; // Total tokens selled\n\n284       beneficiary.transfer(weiAmount); //Transfer ethers to beneficiary\n\n285       frozenAccount[investor] = true;\n286       FrozenFunds(investor, true);\n\n287       TokenPurchase(msg.sender, investor, weiAmount, tokens);\n\n288     }\n\n289     modifier afterDeadline() { if (now >= deadline) _; }\n\n290     /**\n291      * Check if goal was reached\n292      *\n293      * Checks if the goal or time limit has been reached and ends the campaign\n294      */\n295     function checkGoalReached() afterDeadline onlyOwner {\n296         if (amountRaised >= fundingGoal){\n297             fundingGoalReached = true;\n298             GoalReached(beneficiary, amountRaised);\n299         }\n300         crowdsaleClosed = true;\n301     }\n\n\n302     // @return true if the transaction can buy tokens\n303     function validPurchase() internal constant returns (bool) {\n304         uint256 current = getBlockNumber();\n305         bool withinPeriod = current >= startBlock && current <= deadline;\n306         bool nonZeroPurchase = msg.value != 0;\n307         return withinPeriod && nonZeroPurchase;\n308     }\n\n309     //////////\n310     // Testing specific methods\n311     //////////\n\n312     /// @notice This function is overridden by the test Mocks.\n313     function getBlockNumber() internal constant returns (uint256) {\n314         return block.number;\n315     }\n\n316     /// @notice Pauses the contribution if there is any issue\n317     function pauseContribution() onlyOwner {\n318         paused = true;\n319     }\n\n320     /// @notice Resumes the contribution\n321     function resumeContribution() onlyOwner {\n322         paused = false;\n323     }\n324 }\n325 /**\n326  * @title SafeMath\n327  * @dev Math operations with safety checks that throw on error\n328  */\n329 library SafeMath {\n330   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n331     uint256 c = a * b;\n332     assert(a == 0 || c / a == b);\n333     return c;\n334   }\n\n335   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n336     // assert(b > 0); // Solidity automatically throws when dividing by 0\n337     uint256 c = a / b;\n338     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n339     return c;\n340   }\n\n341   function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n342     assert(b <= a);\n343     return a - b;\n344   }\n\n345   function add(uint256 a, uint256 b) internal constant returns (uint256) {\n346     uint256 c = a + b;\n347     assert(c >= a);\n348     return c;\n349   }\n350 }\n103+\n",
    "transaction-context": "require(balanceOf[_to] + _value > balanceOf[_to]);  ",
    "Critical-points": " require(!frozenAccount[_from]);                     ",
    "invariants": "require(!frozenAccount[_to]);   ",
    "critical-invariants": " require(investor != 0x0);  ",
    "ranks": "require(validPurchase()); ",
    "vulnerabilities": "require(maxEtherInvestment >= msg.value); "
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error\n8  */\n9 library SafeMath {\n10   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n11     uint256 c = a * b;\n12     return c;\n13   }\n\n14   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n15     // assert(b > 0); // Solidity automatically throws when dividing by 0\n16     uint256 c = a / b;\n17     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n18     return c;\n19   }\n\n20   function sub(uint256 a, uint256 b) internal constant returns (uint256) {    \n21     return a - b;\n22   }\n\n23   function add(uint256 a, uint256 b) internal constant returns (uint256) {\n24     uint256 c = a + b;    \n25     return c;\n26   }\n27 }\n\n28 /**\n29  * @title ERC20Basic\n30  * @dev Simpler version of ERC20 interface\n31  * @dev see https://github.com/ethereum/EIPs/issues/179\n32  */\n33 contract ERC20Basic {\n34   uint256 public totalSupply;\n35   function balanceOf(address who) public constant returns (uint256);\n36   function transfer(address to, uint256 value) public returns (bool);\n37   event Transfer(address indexed from, address indexed to, uint256 value);\n38 }\n\n39 /**\n40  * @title Basic token\n41  * @dev Basic version of StandardToken, with no allowances.\n42  */\n43 contract BasicToken is ERC20Basic {\n44   using SafeMath for uint256;\n\n45   mapping(address => uint256) balances;\n\n46   /**\n47   * @dev transfer token for a specified address\n48   * @param _to The address to transfer to.\n49   * @param _value The amount to be transferred.\n50   */\n51   function transfer(address _to, uint256 _value) public returns (bool) {  \n\n52     // SafeMath.sub will throw if there is not enough balance.\n53     balances[msg.sender] = balances[msg.sender].sub(_value);\n54     balances[_to] = balances[_to].add(_value);\n55     Transfer(msg.sender, _to, _value);\n56     return true;\n57   }\n\n58   /**\n59   * @dev Gets the balance of the specified address.\n60   * @param _owner The address to query the the balance of.\n61   * @return An uint256 representing the amount owned by the passed address.\n62   */\n63   function balanceOf(address _owner) public constant returns (uint256 balance) {\n64     return balances[_owner];\n65   }\n66 }\n\n67 /**\n68  * @title ERC20 interface\n69  * @dev see https://github.com/ethereum/EIPs/issues/20\n70  */\n71 contract ERC20 is ERC20Basic {\n72   function allowance(address owner, address spender) public constant returns (uint256);\n73   function transferFrom(address from, address to, uint256 value) public returns (bool);\n74   function approve(address spender, uint256 value) public returns (bool);\n75   event Approval(address indexed owner, address indexed spender, uint256 value);\n76 }\n\n\n77 /**\n78  * @title Standard ERC20 token\n79  *\n80  * @dev Implementation of the basic standard token.\n81  * @dev https://github.com/ethereum/EIPs/issues/20\n82  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n83  */\n84 contract StandardToken is ERC20, BasicToken {\n\n85   mapping (address => mapping (address => uint256)) internal allowed;\n\n\n86   /**\n87    * @dev Transfer tokens from one address to another\n88    * @param _from address The address which you want to send tokens from\n89    * @param _to address The address which you want to transfer to\n90    * @param _value uint256 the amount of tokens to be transferred\n91    */\n92   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n93     require(_to != address(0));\n94     require(_value > 0 && _value <= balances[_from]);\n95     require(_value <= allowed[_from][msg.sender]);\n\n96     balances[_from] = balances[_from].sub(_value);\n97     balances[_to] = balances[_to].add(_value);\n98     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n99     Transfer(_from, _to, _value);\n100     return true;\n101   }\n\n102   /**\n103    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n104    *\n105    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n106    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n107    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n108    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n109    * @param _spender The address which will spend the funds.\n110    * @param _value The amount of tokens to be spent.\n111    */\n112   function approve(address _spender, uint256 _value) public returns (bool) {\n113     allowed[msg.sender][_spender] = _value;\n114     Approval(msg.sender, _spender, _value);\n115     return true;\n116   }\n\n117   /**\n118    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n119    * @param _owner address The address which owns the funds.\n120    * @param _spender address The address which will spend the funds.\n121    * @return A uint256 specifying the amount of tokens still available for the spender.\n122    */\n123   function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n124     return allowed[_owner][_spender];\n125   }\n126 }\n\n127 /**\n128  * @title Ownable\n129  * @dev The Ownable contract has an owner address, and provides basic authorization control\n130  * functions, this simplifies the implementation of \"user permissions\".\n131  */\n132 contract Ownable {\n133   address public owner;\n\n\n134   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n135   /**\n136    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n137    * account.\n138    */\n139   function Ownable() {\n140     owner = msg.sender;\n141   }\n\n\n142   /**\n143    * @dev Throws if called by any account other than the owner.\n144    */\n145   modifier onlyOwner() {   \n146     _;\n147   }\n\n\n148   /**\n149    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n150    * @param newOwner The address to transfer ownership to.\n151    */\n152   function transferOwnership(address newOwner) onlyOwner public {  \n153     OwnershipTransferred(owner, newOwner);\n154     owner = newOwner;\n155   }\n\n156 }\n\n157 /**\n158  * @title Pausable\n159  * @dev Base contract which allows children to implement an emergency stop mechanism.\n160  */\n161 contract Pausable is Ownable {\n162   event Pause();\n163   event Unpause();\n\n164   bool public paused = false;\n\n\n165   /**\n166    * @dev Modifier to make a function callable only when the contract is not paused.\n167    */\n168   modifier whenNotPaused() {   \n169     _;\n170   }\n\n171   /**\n172    * @dev Modifier to make a function callable only when the contract is paused.\n173    */\n174   modifier whenPaused() {   \n175     _;\n176   }\n\n177   /**\n178    * @dev called by the owner to pause, triggers stopped state\n179    */\n180   function pause() onlyOwner whenNotPaused public {\n181     paused = true;\n182     Pause();\n183   }\n\n184   /**\n185    * @dev called by the owner to unpause, returns to normal state\n186    */\n187   function unpause() onlyOwner whenPaused public {\n188     paused = false;\n189     Unpause();\n190   }\n191 }\n\n192 /**\n193  * @title Pausable token\n194  *\n195  * @dev StandardToken modified with pausable transfers.\n196  **/\n\n197 contract PausableToken is StandardToken, Pausable {\n\n198   function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n199     return super.transfer(_to, _value);\n200   }\n\n201   function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n202     return super.transferFrom(_from, _to, _value);\n203   }\n\n204   function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n205     return super.approve(_spender, _value);\n206   }\n  \n207   function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n208     uint cnt = _receivers.length;\n209     uint256 amount = uint256(cnt) * _value;\n210     require(cnt > 0 && cnt <= 20);\n211     require(_value > 0 && balances[msg.sender] >= amount);\n\n212     balances[msg.sender] = balances[msg.sender].sub(amount);\n213     for (uint i = 0; i < cnt; i++) {\n214         balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n215         Transfer(msg.sender, _receivers[i], _value);\n216     }\n217     return true;\n218   }\n219 }\n\n220 /**\n221  * @title Bec Token\n222  *\n223  * @dev Implementation of Bec Token based on the basic standard token.\n224  */\n225 contract BecToken is PausableToken {\n226     /**\n227     * Public variables of the token\n228     * The following variables are OPTIONAL vanities. One does not have to include them.\n229     * They allow one to customise the token contract & in no way influences the core functionality.\n230     * Some wallets/interfaces might not even bother to look at this information.\n231     */\n232     string public name = \"BeautyChain\";\n233     string public symbol = \"BEC\";\n234     string public version = '1.0.0';\n235     uint8 public decimals = 18;\n\n236     /**\n237      * @dev Function to check the amount of tokens that an owner allowed to a spender.\n238      */\n239     function BecToken() {\n240       totalSupply = 7000000000 * (10**(uint256(decimals)));\n241       balances[msg.sender] = totalSupply;    // Give the creator all initial tokens\n242     }\n\n243     function () {\n244         //if ether is sent to this address, send it back.\n245         revert();\n246     }\n247 }\n168+\n",
    "transaction-context": "require(!paused);",
    "Critical-points": "require(paused);",
    "invariants": "require(id < nextPositionID, \"bad position id\");\nrequire(positions[id].goblin == goblin, \"bad position goblin\");\nrequire(positions[id].owner == msg.sender, \"not position owner\");",
    "critical-invariants": " require(config.isGoblin(goblin), \"not a goblin\");\n require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");",
    "ranks": "require(debt >= config.minDebtSize(), \"too small debt size\");",
    "vulnerabilities": "require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {\n8 x++;\n9 }\n10 }\n\n11 contract C is A, B {\n12 }\n \n13 }\n",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 8+",
    "invariants": "8+  assert (x == a + 1);",
    "critical-invariants": "8+  assert (x == a + 1);",
    "ranks": "8+  assert (x == a + 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma experimental ABIEncoderV2;\n3 pragma solidity 0.6.12;\n\n4 import \"./ParaToken.sol\";\n5 import \"./interfaces/IERC20.sol\";\n6 import \"./libraries/SafeERC20.sol\";\n7 import \"./libraries/EnumerableSet.sol\";\n8 import \"./libraries/SafeMath_para.sol\";\n9 import \"./interfaces/IWETH.sol\";\n10 import './interfaces/IParaRouter02.sol';\n11 import './interfaces/IParaPair.sol';\n12 import './libraries/TransferHelper.sol';\n13 import './interfaces/IFeeDistributor.sol';\n14 import './ParaProxy.sol';\n\n15 interface IParaTicket {\n16     function level() external pure returns (uint256);\n17     function tokensOfOwner(address owner) external view returns (uint256[] memory);\n18     function setApprovalForAll(address to, bool approved) external;\n19     function safeTransferFrom(address from, address to, uint256 tokenId) external;\n20     function setUsed(uint256 tokenId) external;\n21     function _used(uint256 tokenId) external view returns(bool);\n22 }\n\n23 interface IMigratorChef {\n24     function migrate(IERC20 token) external returns (IERC20);\n25 }\n\n26 contract MasterChef is ParaProxyAdminStorage {\n27     using SafeMath for uint256;\n28     using SafeERC20 for IERC20;\n29     // Info of each user.\n30     struct UserInfo {\n31         uint256 amount; // How many LP tokens the user has provided.\n32         uint256 rewardDebt; // Reward debt. See explanation below.\n33         //\n34         // We do some fancy math here. Basically, any point in time, the amount of T42s\n35         // entitled to a user but is pending to be distributed is:\n36         //\n37         //   pending reward = (user.amount * pool.accT42PerShare) - user.rewardDebt\n38         //\n39         // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n40         //   1. The pool's `accT42PerShare` (and `lastRewardBlock`) gets updated.\n41         //   2. User receives the pending reward sent to his/her address.\n42         //   3. User's `amount` gets updated.\n43         //   4. User's `rewardDebt` gets updated.\n44     }\n45     // Info of each pool.\n46     struct PoolInfo {\n47         IERC20 lpToken; // Address of LP token contract.\n48         uint256 allocPoint; // How many allocation points assigned to this pool. T42s to distribute per block.\n49         uint256 lastRewardBlock; // Last block number that T42s distribution occurs.\n50         uint256 accT42PerShare; // Accumulated T42s per share, times 1e12. See below.\n51         IParaTicket ticket; // if VIP pool, NFT ticket contract, else 0\n52         uint256 pooltype;\n53     }\n54     // every farm's percent of T42 issue\n55     uint8[10] public farmPercent;\n56     // The T42 TOKEN!\n57     ParaToken public t42;\n58     // Dev address.\n59     address public devaddr;\n60     // Treasury address\n61     address public treasury;\n62     // Fee Distritution contract address\n63     address public feeDistributor;\n64     // Mining income commission rate, default 5%\n65     uint256 public claimFeeRate;\n66     // Mining pool withdrawal fee rate, the default is 1.3%\n67     uint256 public withdrawFeeRate;\n68     // Block number when bonus T42 period ends.\n69     uint256 public bonusEndBlock;\n70     // Bonus muliplier for early t42 makers.\n71     uint256 public constant BONUS_MULTIPLIER = 1;\n72     // The migrator contract. It has a lot of power. Can only be set through governance (owner).\n73     IMigratorChef public migrator;\n74     // Info of each pool.\n75     PoolInfo[] public poolInfo;\n76     // Info of each user that stakes LP tokens.\n77     mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n78     // Total allocation poitns. Must be the sum of all allocation points in all pools.\n79     uint256 public totalAllocPoint;\n80     // The block number when T42 mining starts.\n81     uint256 public startBlock;\n    \n82     // the address of WETH\n83     address public WETH;\n84     // the address of Router\n85     IParaRouter02 public paraRouter;\n86     // Change returned after adding liquidity\n87     mapping(address => mapping(address => uint)) public userChange;\n88     // record who staked which NFT ticket into this contract\n89     mapping(address => mapping(address => uint[])) public ticket_stakes;\n90     // record total claimed T42 for per user & per PoolType\n91     mapping(address => mapping(uint256 => uint256)) public _totalClaimed;\n92     mapping(address => address) public _whitelist;\n93     // TOTAL Deposit pid => uint\n94     mapping(uint => uint) public poolsTotalDeposit;\n\n95     event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n96     event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n97     event EmergencyWithdraw(\n98         address indexed user,\n99         uint256 indexed pid,\n100         uint256 amount\n101     );\n102     event WithdrawChange(\n103         address indexed user,\n104         address indexed token,\n105         uint256 change);\n106     /**\n107      * @dev Throws if called by any account other than the owner.\n108      */\n109     modifier onlyOwner() {       \n110         _;\n111     }\n112     constructor() public {\n113         admin = msg.sender;\n114     }\n    \n115     function initialize(\n116         ParaToken _t42,\n117         address _treasury,\n118         address _feeDistributor,\n119         address _devaddr,\n120         uint256 _bonusEndBlock,\n121         address _WETH,\n122         IParaRouter02 _paraRouter\n123     ) external onlyOwner {\n124         t42 = _t42;\n125         treasury = _treasury;\n126         feeDistributor = _feeDistributor;\n127         devaddr = _devaddr;\n128         bonusEndBlock = _bonusEndBlock;\n129         startBlock = _t42.startBlock();\n130         WETH = _WETH;\n131         paraRouter = _paraRouter;\n132         claimFeeRate = 500;\n133         withdrawFeeRate = 130;\n134     }\n135 //the beginning of reentrancy bug:\n136     function depositSingle(uint256 _pid, address _token, uint256 _amount, address[][2] memory paths, uint _minTokens) payable external{\n137         depositSingleInternal(msg.sender, msg.sender, _pid, _token, _amount, paths, _minTokens);\n138     }\n\n139     //uint256 _minPoolTokens,\n140     function depositSingleTo(address _user, uint256 _pid, address _token, uint256 _amount, address[][2] memory paths, uint _minTokens) payable external{\n141         //Msg.sender is on the white list       \n142         IFeeDistributor(feeDistributor).setReferalByChef(_user, _whitelist[msg.sender]);\n143         depositSingleInternal(msg.sender, _user, _pid, _token, _amount, paths, _minTokens);\n144     }\n\n145     struct DepositVars{\n146         uint oldBalance;\n147         uint newBalance;\n148         uint amountA;\n149         uint amountB;\n150         uint liquidity;\n151     }\n\n152     //During the reentrancy process, the UBT contract deposits 222 genuine LP tokens, which are credited to ParaProxy\u2019s ledger. \n153     //After the reentrancy is completed, 222 LP tokens are added to the ParaProxy contract address, \n154     //which the ParaProxy contract treats as LPs added by the attack contract and credits to the ledger. \n155     function depositSingleInternal(address payer, address _user, uint256 _pid, address _token, uint256 _amount, address[][2] memory paths, uint _minTokens) internal {\n156         //Stack too deep, try removing local variables\n157         DepositVars memory vars;\n158         (_token, _amount) = _doTransferIn(payer, _token, _amount);\n159         //swap by path\n160         (address[2] memory tokens, uint[2] memory amounts) = depositSwapForTokens(_token, _amount, paths);\n161         //Go approve\n162         approveIfNeeded(tokens[0], address(paraRouter), amounts[0]);\n163         approveIfNeeded(tokens[1], address(paraRouter), amounts[1]);\n164         PoolInfo memory pool = poolInfo[_pid];\n165         //Non-VIP pool\n166         //lp balance check\n167         vars.oldBalance = pool.lpToken.balanceOf(address(this));\n168         (vars.amountA, vars.amountB, vars.liquidity) = paraRouter.addLiquidity(tokens[0], tokens[1], amounts[0], amounts[1], 1, 1, address(this), block.timestamp + 600);\n169         vars.newBalance = pool.lpToken.balanceOf(address(this));\n170         //----------------- TODO \n171         vars.liquidity = vars.newBalance.sub(vars.oldBalance);     \n172         addChange(_user, tokens[0], amounts[0].sub(vars.amountA));\n173         addChange(_user, tokens[1], amounts[1].sub(vars.amountB));\n174         //_deposit\n175         _deposit(_pid, vars.liquidity, _user);\n176     }\n\n\n\n177     // Deposit LP tokens to MasterChef for T42 allocation.\n178     function depositInternal(uint256 _pid, uint256 _amount, address _user, address payer) internal {\n179         PoolInfo storage pool = poolInfo[_pid];\n180         pool.lpToken.safeTransferFrom(\n181             address(payer),\n182             address(this),\n183             _amount\n184         );\n185         if (address(pool.ticket) != address(0)) {\n186             UserInfo storage user = userInfo[_pid][_user];\n187             uint256 new_amount = user.amount.add(_amount);\n188             uint256 user_ticket_count = pool.ticket.tokensOfOwner(_user).length;\n189             uint256 staked_ticket_count = ticket_staked_count(_user, address(pool.ticket));\n190             uint256 ticket_level = pool.ticket.level();\n191             (, uint overflow) = check_vip_limit(ticket_level, user_ticket_count + staked_ticket_count, new_amount);\n\n192            deposit_all_tickets(pool.ticket);\n193         }\n194         _deposit(_pid, _amount, _user);\n195     }\n\n196     // Deposit LP tokens to MasterChef for para allocation.\n197     function _deposit(uint256 _pid, uint256 _amount, address _user) internal {\n198         PoolInfo storage pool = poolInfo[_pid];\n199         UserInfo storage user = userInfo[_pid][_user];\n200         //add total of pool before updatePool\n201         poolsTotalDeposit[_pid] = poolsTotalDeposit[_pid].add(_amount);\n202         updatePool(_pid);\n203         if (user.amount > 0) {\n204             uint256 pending =\n205                 user.amount.mul(pool.accT42PerShare).div(1e12).sub(\n206                     user.rewardDebt\n207                 );\n208             //TODO\n209             _claim(pool.pooltype, pending);\n210         }\n211         user.amount = user.amount.add(_amount);\n212         user.rewardDebt = user.amount.mul(pool.accT42PerShare).div(1e12);\n213         emit Deposit(_user, _pid, _amount);\n214     }\n\n215     function withdraw_tickets(uint256 _pid, uint256 tokenId) public {\n216         //use memory for reduce gas\n217         PoolInfo memory pool = poolInfo[_pid];\n218         UserInfo memory user = userInfo[_pid][msg.sender];\n219         //use storage because of updating value\n220         uint256[] storage idlist = ticket_stakes[msg.sender][address(pool.ticket)];\n221         for (uint i; i< idlist.length; i++) {\n222             if (idlist[i] == tokenId) {\n223                 (, uint overflow) = check_vip_limit(pool.ticket.level(), idlist.length - 1, user.amount);\n              \n224                 pool.ticket.safeTransferFrom(address(this), msg.sender, tokenId);\n225                 idlist[i] = idlist[idlist.length - 1];\n226                 idlist.pop();\n227                 return;\n228             }\n229         }\n230     }\n\n231     // Withdraw LP tokens from MasterChef.\n232     function withdraw(uint256 _pid, uint256 _amount) public {\n233         _withdrawInternal(_pid, _amount, msg.sender);\n234         emit Withdraw(msg.sender, _pid, _amount);\n235     }\n\n236     function _withdrawInternal(uint256 _pid, uint256 _amount, address _operator) internal{\n237         (address lpToken,uint actual_amount) = _withdrawWithoutTransfer(_pid, _amount, _operator);\n238         IERC20(lpToken).safeTransfer(_operator, actual_amount);\n239     }\n\n240     function _withdrawWithoutTransfer(uint256 _pid, uint256 _amount, address _operator) internal returns (address lpToken, uint actual_amount){\n241         PoolInfo storage pool = poolInfo[_pid];\n242         UserInfo storage user = userInfo[_pid][_operator];    \n243         updatePool(_pid);\n244         uint256 pending =\n245             user.amount.mul(pool.accT42PerShare).div(1e12).sub(\n246                 user.rewardDebt\n247             );\n248         _claim(pool.pooltype, pending);\n249         user.amount = user.amount.sub(_amount);\n250         user.rewardDebt = user.amount.mul(pool.accT42PerShare).div(1e12);\n251         //sub total of pool\n252         poolsTotalDeposit[_pid] = poolsTotalDeposit[_pid].sub(_amount);\n253         lpToken = address(pool.lpToken);\n254         uint fee = _amount.mul(withdrawFeeRate).div(10000);\n255         IERC20(lpToken).approve(feeDistributor, fee);\n256         IFeeDistributor(feeDistributor).incomeWithdrawFee(_operator, lpToken, fee, _amount);\n257         actual_amount = _amount.sub(fee);\n258     }\n\n259     function withdrawSingle(address tokenOut, uint256 _pid, uint256 _amount, address[][2] memory paths) external{       \n260         //doWithraw Lp\n261         (address lpToken, uint actual_amount) = _withdrawWithoutTransfer(_pid, _amount, msg.sender);\n262         //remove liquidity\n263         address[2] memory tokens;\n264         uint[2] memory amounts;\n265         tokens[0] = IParaPair(lpToken).token0();\n266         tokens[1] = IParaPair(lpToken).token1();\n267         //Go approve\n268         approveIfNeeded(lpToken, address(paraRouter), actual_amount);\n269         (amounts[0], amounts[1]) = paraRouter.removeLiquidity(\n270             tokens[0], tokens[1], actual_amount, 0, 0, address(this), block.timestamp.add(600));\n271         //swap to tokenOut\n272         for (uint i = 0; i < 2; i++){\n273             address[] memory path = paths[i];           \n274             //Consider the same currency situation\n275             if(path[0] == tokens[0]){\n276                 swapTokensOut(amounts[0], tokenOut, path);\n277             }else{\n278                 swapTokensOut(amounts[1], tokenOut, path);    \n279             }\n280         }\n281         emit Withdraw(msg.sender, _pid, _amount);\n282     }\n\n283     function approveIfNeeded(address _token, address spender, uint _amount) private{\n284         if (IERC20(_token).allowance(address(this), spender) < _amount) {\n285              IERC20(_token).approve(spender, _amount);\n286         }\n287     }\n273+\n",
    "transaction-context": "require(path[0] == tokens[0] || path[0] == tokens[1], \"invalid path_0\");",
    "Critical-points": " assert (y == x + 2);",
    "invariants": "assert(funcA2(funcA1())==12);\nassert(funcA3().funcB()==42);",
    "critical-invariants": "assert(a == x + 1);\n",
    "ranks": " assert(a == x);",
    "vulnerabilities": "assert (a == x + 4);  \nassert (b == x + 4);  \nassert (c == x + 6);"
  }
]