{
  "doc-193bdf9d6446039ba5bbf9b8f3370775": {
    "status": "processed",
    "chunks_count": 20,
    "content": "[\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract ExternalFunctionCall {\\n\\n3     function foo(uint x) public returns (uint ret) {\\n4         ret = x + 2;\\n5     }\\n\\n6     function testExternalFunctionCall(uint x) public {\",\n    \"transaction-context\": \"The transaction context is cross-function\",\n    \"Critical-points\": \"Critical program points are 7+\",\n    \"invariants\": \"7+ assert (y == x + 2);\",\n    \"critical-invariants\": \"7+ assert (y == x + 2);\",\n    \"ranks\": \"7+ assert (y == x + 2);\",\n    \"vulnerabilities\": \"healthy\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n2 contract B {\\n3    function funcB() public pure returns (uint) {\\n4        return 42;\\n5    }\\n6    constructor() public {}\\n7 }\\n\\n8 contract A {\",\n    \"transaction-context\": \"The transaction context is cross-function\\narithmetics\",\n    \"Critical-points\": \"Critical program points are 20+\",\n    \"invariants\": \"20+ assert(funcA2(funcA1())==12);\\n20+ assert(funcA3().funcB()==42);\",\n    \"critical-invariants\": \"20+ assert(funcA2(funcA1())==12);\\n20+ assert(funcA3().funcB()==42);\",\n    \"ranks\": \"20+ assert(funcA2(funcA1())==12);\\n20+ assert(funcA3().funcB()==42);\",\n    \"vulnerabilities\": \"healthy\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 // This test passes, but assertion on line 35 is only proved\\n3 // up to 4 transactions\\n4 // This result means that ctor A is only called once, for B, as A(x+1)\\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \\n\\n\",\n    \"transaction-context\": \"The transaction context is cross-function\\narithmetics\",\n    \"Critical-points\": \"Critical program points are 24+\\n32+\\n37+\",\n    \"invariants\": \"24+ assert(a == x + 1);\\n32+ assert(a == x);\\n37+  assert (a == x + 4);  \\n37+  assert (b == x + 4);  \\n37+  assert (c == x + 6);\",\n    \"critical-invariants\": \"24+ assert(a == x + 1);\\n32+ assert(a == x);\\n37+  assert (a == x + 4);  \\n37+  assert (b == x + 4);  \\n37+  assert (c == x + 6);\",\n    \"ranks\": \"24+ assert(a == x + 1);\\n32+ assert(a == x);\\n37+  assert (a == x + 4);  \\n37+  assert (b == x + 4);  \\n37+  assert (c == x + 6);\",\n    \"vulnerabilities\": \"healthy\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n2 contract B {\\n3    function funcB() public pure returns (uint) {\\n4        return 42;\\n5    }\\n6    constructor() public {}\\n7 }\\n\\n8 contract A {\",\n    \"transaction-context\": \"The transaction context is cross-function\\narithmetics\",\n    \"Critical-points\": \"Critical program points are 20+\",\n    \"invariants\": \"20+ assert(funcA2(funcA1())==12);\\n20+ assert(funcA3().funcB()==42);\",\n    \"critical-invariants\": \"20+ assert(funcA2(funcA1())==12);\\n20+ assert(funcA3().funcB()==42);\",\n    \"ranks\": \"20+ assert(funcA2(funcA1())==12);\\n20+ assert(funcA3().funcB()==42);\",\n    \"vulnerabilities\": \"healthy\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 // This test passes, but assertion on line 35 is only proved\\n3 // up to 4 transactions\\n4 // This result means that ctor A is only called once, for B, as A(x+1)\\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \\n\\n\",\n    \"transaction-context\": \"The transaction context is cross-function\\narithmetics\",\n    \"Critical-points\": \"Critical program points are 24+\\n32+\\n38+\",\n    \"invariants\": \"24+ assert(a == x + 1);\\n32+ assert(a == x);   \\n38+ assert (a == x + 4);  \\n38+  assert (b == x + 4);  \\n38+  assert (c == x + 6);\",\n    \"critical-invariants\": \"24+ assert(a == x + 1);\\n32+ assert(a == x);   \\n38+ assert (a == x + 4);  \\n38+  assert (b == x + 4);  \\n38+  assert (c == x + 6);\",\n    \"ranks\": \"24+ assert(a == x + 1);\\n32+ assert(a == x);   \\n38+ assert (a == x + 4);  \\n38+  assert (b == x + 4);  \\n38+  assert (c == x + 6);\",\n    \"vulnerabilities\": \"healthy\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24<0.6.0;\\n2 import \\\"./Libraries/VeriSolContracts.sol\\\";\\n\\n\\n3 contract LoopFor {\\n\\n4     int x;\\n5     int y;\\n\",\n    \"transaction-context\": \"The transaction context is loop\\narithmetics\",\n    \"Critical-points\": \"Critical program points are 6+\\n6+\\n19+\",\n    \"invariants\": \"6+ assert(x == y);\\n6+  assert(y >= 0);\\n19+  assert (y >= 0); \",\n    \"critical-invariants\": \"6+ assert(x == y);\\n6+  assert(y >= 0);\\n19+  assert (y >= 0);\",\n    \"ranks\": \"6+ assert(x == y);\\n6+  assert(y >= 0);\\n19+  assert (y >= 0);\",\n    \"vulnerabilities\": \"healthy\"\n  },\n  {\n    \"code\": \"pragma solidity >=0.4.24 <0.6.0;\\n\\n//simple library with no internal state\\n\\nlibrary Lib {\\n    function add(uint _a, uint _b) public view returns (uint r) {\\n        address x = address(this);       \\n        r = _a + _b;\\n    }\",\n    \"transaction-context\": \"The transaction context is cross-function\\narithmetics\",\n    \"Critical-points\": \"Critical program points are 5+\\n14+\",\n    \"invariants\": \"5+ assert(x == msg.sender);\\n14+ assert (z == 3);\",\n    \"critical-invariants\": \"14+ assert (z == 3);\",\n    \"ranks\": \"14+ assert (z == 3);\",\n    \"vulnerabilities\": \"healthy\"\n  },\n  {\n    \"code\": \"1 pragma solidity ^0.4.24;\\n2 import \\\"./../../Libraries/VeriSolContracts.sol\\\";\\n3 //import \\\"./VeriSolContracts.sol\\\";\\n4 //import \\\"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\\\";\\n\\n5 contract LoopFor {\\n\\n6     // test Loop invariant with for loop\\n7     constructor(uint n) public {\",\n    \"transaction-context\": \"The transaction context is loop\\narithmetics\",\n    \"Critical-points\": \"Critical program points are 10+ \\n12+ \\n19+  \\n22+  \\n29+ \\n32+\",\n    \"invariants\": \"10+  assert(x + y == n);\\n12+  assert (y == n);\\n19+  assert(x + y == n);\\n22+  assert (y == n);\\n29+  assert(x + y == n);\\n32+ assert (y == n);\",\n    \"critical-invariants\": \"10+  assert(x + y == n);\\n12+  assert (y == n);\\n19+  assert(x + y == n);\\n22+  assert (y == n);\\n29+  assert(x + y == n);\\n32+ assert (y == n);\",\n    \"ranks\": \"10+  assert(x + y == n);\\n12+  assert (y == n);\\n19+  assert(x + y == n);\\n22+  assert (y == n);\\n29+  assert(x + y == n);\\n32+ assert (y == n);\",\n    \"vulnerabilities\": \"healthy\"\n  },\n  {\n    \"code\": \"1 pragma solidity ^0.5.0;\\n\\n2 import \\\"./IERC20.sol\\\";\\n3 import \\\"./SafeMath.sol\\\";\\n4 import \\\"./Libraries/VeriSolContracts.sol\\\"; //change \\n\\n\\n5 /**\\n6  * A highly simplified Token to express basic specifications\",\n    \"transaction-context\": \"The transaction context is ERC\",\n    \"Critical-points\": \"Critical program points are 17+ \\n47+ \\n66+ \",\n    \"invariants\": \"17+ require(msg.sender != address(0));\\n47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); \\n66+ require(_balances[sender] >= amount);\",\n    \"critical-invariants\": \"47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); \",\n    \"ranks\": \"47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); \",\n    \"vulnerabilities\": \"incorrect visibility/ownership\\nbusiness logic flaw\\ninteger overflow/underflow\"\n  },\n  {\n    \"code\": \"1 //SPDX-License-Identifier: MIT\\n2 pragma solidity 0.7.5;\\n\\n3 contract contrived{\\n4  function withdraw(uint256 amount) override public nonReentrant updateReward(msg.sender) {  \\n5     _totalSupply = _totalSupply - amount;\\n6     _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n7     stakingToken.safeTransfer(msg.sender, amount);\\n\",\n    \"transaction-context\": \"The transaction context is asset swapping\",\n    \"Critical-points\": \"Critical program points are 4+\",\n    \"invariants\": \"4+   require(amount > 0, \\\"Cannot withdraw 0\\\");\",\n    \"critical-invariants\": \"4+   require(amount > 0, \\\"Cannot withdraw 0\\\");\",\n    \"ranks\": \"4+   require(amount > 0, \\\"Cannot withdraw 0\\\");\",\n    \"vulnerabilities\": \"integer over/underflow\"\n  },\n  {\n    \"code\": \"1 /**\\n2  *Submitted for verification at Etherscan.io on 2018-02-09\\n3 */\\n\\n4 pragma solidity ^0.4.16;\\n\\n5 /**\\n6  * @title SafeMath\\n7  * @dev Math operations with safety checks that throw on error\",\n    \"transaction-context\": \"The transaction context is ERC\\ntokenSale\",\n    \"Critical-points\": \"Critical program points are 11+  \\n20+ \\n24+ \\n51+   \\n51+ \\n145+ \\n152+  \\n168+ \\n174+ \",\n    \"invariants\": \"11+  assert(a == 0 || c / a == b);\\n20+ assert(b <= a);\\n24+ assert(c >= a);\\n51+   require(_to != address(0));\\n51+ require(_value > 0 && _value <= balances[msg.sender]);\\n145+ require(msg.sender == owner);\\n152+  require(newOwner != address(0));\\n168+ require(!paused);\\n174+ require(paused);\\n\",\n    \"critical-invariants\": \"11+  assert(a == 0 || c / a == b);\\n20+ assert(b <= a);\\n24+ assert(c >= a);\\n51+   require(_to != address(0));\\n51+ require(_value > 0 && _value <= balances[msg.sender]);\\n145+ require(msg.sender == owner);\\n152+  require(newOwner != address(0));\\n168+ require(!paused);\\n174+ require(paused);\",\n    \"ranks\": \"11+  assert(a == 0 || c / a == b);\\n20+ assert(b <= a);\\n24+ assert(c >= a);\\n51+   require(_to != address(0));\\n51+ require(_value > 0 && _value <= balances[msg.sender]);\\n145+ require(msg.sender == owner);\\n152+  require(newOwner != address(0));\\n168+ require(!paused);\\n174+ require(paused);\",\n    \"vulnerabilities\": \"integer over/underflow\\natomicity violation\\nincorrect visibility/ownership\"\n  },\n  {\n    \"code\": \"1 /**\\n2  *Submitted for verification at Etherscan.io on 2020-10-07\\n3 */\\n\\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\\n\\n5 pragma solidity ^0.5.0;\\n\\n6 contract Bank{\",\n    \"transaction-context\": \"The transaction context is asset swapping\\n\",\n    \"Critical-points\": \"Critical program points are 17+ \\n21+  \\n35+ \\n37+\",\n    \"invariants\": \"17+ require(id < nextPositionID, \\\"bad position id\\\");\\n17+ require(positions[id].goblin == goblin, \\\"bad position goblin\\\");\\n17+ require(positions[id].owner == msg.sender, \\\"not position owner\\\");\\n21+  require(config.isGoblin(goblin), \\\"not a goblin\\\");\\n21+  require(loan == 0 || config.acceptDebt(goblin), \\\"goblin not accept more debt\\\");\\n35+ require(debt >= config.minDebtSize(), \\\"too small debt size\\\");\\n37+  require(health.mul(workFactor) >= debt.mul(10000), \\\"bad work factor\\\");\\n\",\n    \"critical-invariants\": \"17+ require(id < nextPositionID, \\\"bad position id\\\");\",\n    \"ranks\": \"17+ require(id < nextPositionID, \\\"bad position id\\\");\",\n    \"vulnerabilities\": \"reentrancy\"\n  },\n  {\n    \"code\": \"1 /**\\n2  *Submitted for verification at BscScan.com on 2021-07-30\\n3 */\\n\\n4 //SPDX-License-Identifier: MIT\\n5 pragma solidity ^0.8.0;\\n\\n\\n6 abstract contract ReentrancyGuard {\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 13+\\n44+\",\n    \"invariants\": \"13+  require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');\",\n    \"critical-invariants\": \"44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');\",\n    \"ranks\": \"44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');\",\n    \"vulnerabilities\": \"reentrancy\\nbusiness logic flaw\"\n  },\n  {\n    \"code\": \"1 /**\\n2  *Submitted for verification at BscScan.com on 2021-07-30\\n3 */\\n\\n4 //SPDX-License-Identifier: MIT\\n5 pragma solidity ^0.8.0;\\n\\n\\n6 /**\",\n    \"transaction-context\": \"The transaction context is money market\",\n    \"Critical-points\": \"Critical program points are 124+ \\n137+ \\n150+  \\n171+ \\n201+\\n233+ \\n284+ \\n286+\\n338+ \\n341+\\n544+ \\n559+  \\n576+\\n655+ \\n678+  \\n715+ \\n733+\\n757+ \\n797+ \",\n    \"invariants\": \"124+  require(c >= a, \\\"SafeMath: addition overflow\\\");\\n137+  return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n150+  require(b <= a, errorMessage);\\n171+ require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n201+ require(b > 0, errorMessage);\\n233+ require(b != 0, errorMessage);\\n284+ require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n286+ require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n338+ require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n341+ require(isContract(target), \\\"Address: call to non-contract\\\");\\n544+ require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n544+ require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n559+  require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n576+  require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n595+  require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n595+  require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n655+ require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n678+   require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n715+ require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n733+ require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n757+ require(localCounter == _guardCounter);\\n797+ assert(token != address(this)); \\n797+ assert(token != user); \\n\\n\",\n    \"critical-invariants\": \"124+  require(c >= a, \\\"SafeMath: addition overflow\\\");\\n150+  require(b <= a, errorMessage);\\n171+ require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n186+ return div(a, b, \\\"SafeMath: division by zero\\\");\\n201+ require(b > 0, errorMessage);\\n233+ require(b != 0, errorMessage);\\n284+ require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n286+ require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n338+ require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n341+ require(isContract(target), \\\"Address: call to non-contract\\\");\\n544+ require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n544+ require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n559+  require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n797+ assert(token != address(this)); \\n797+ assert(token != user); \",\n    \"ranks\": \"124+  require(c >= a, \\\"SafeMath: addition overflow\\\");\\n150+  require(b <= a, errorMessage);\\n171+ require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n186+ return div(a, b, \\\"SafeMath: division by zero\\\");\\n201+ require(b > 0, errorMessage);\\n233+ require(b != 0, errorMessage);\\n284+ require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n286+ require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n338+ require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n341+ require(isContract(target), \\\"Address: call to non-contract\\\");\\n544+ require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n544+ require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n559+  require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n797+ assert(token != address(this)); \\n797+ assert(token != user); \",\n    \"vulnerabilities\": \"integer over/underflow\\nincorrect visibility/ownership\"\n  },\n  {\n    \"code\": \"1 /**\\n2  *Submitted for verification at BscScan.com on 2021-07-30\\n3 */\\n\\n4 //SPDX-License-Identifier: MIT\\n5 pragma solidity ^0.8.0;\\n\\n\\n6 abstract contract ReentrancyGuard {\",\n    \"transaction-context\": \"The transaction context is tokenSale\",\n    \"Critical-points\": \"Critical program points are 13+\\n23+\\n42+\",\n    \"invariants\": \"13+ require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\\n       \",\n    \"critical-invariants\": \"23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\\n       \",\n    \"ranks\": \"23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\\n       \",\n    \"vulnerabilities\": \"reentrancy \\ninteger over/underflow\"\n  },\n  {\n    \"code\": \"1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\\n\\n2 // File contracts/v0.4/token/linkERC20Basic.sol\\n\\n3 pragma solidity ^0.4.11;\\n\\n\\n4 /**\\n5  * @title ERC20Basic\",\n    \"transaction-context\": \"The transaction context is tokenSale\",\n    \"Critical-points\": \"Critical program points are 88+  \\n97+\\n101+  \",\n    \"invariants\": \"88+  assert(a == 0 || c / a == b);\\n97+ assert(b <= a);\\n101+  assert(c >= a);\\n\",\n    \"critical-invariants\": \"88+  assert(a == 0 || c / a == b);\\n97+ assert(b <= a);\\n101+  assert(c >= a);\",\n    \"ranks\": \"88+  assert(a == 0 || c / a == b);\\n97+ assert(b <= a);\\n101+  assert(c >= a);\",\n    \"vulnerabilities\": \"arithmetic flaw\\nreentrancy\"\n  },\n  {\n    \"code\": \"1 // SPDX-License-Identifier: BUSL-1.1\\n\\n2 pragma solidity 0.7.6;\\n\\n3 import \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n4 import \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n5 import \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n6 import \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n7 import \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\",\n    \"transaction-context\": \"The transaction context is cross-function\\nmoney market\",\n    \"Critical-points\": \"Critical program points are 18+  \\n33+ \\n44+  \\n45+  \\n61+  \\n63+\",\n    \"invariants\": \"18+  require(msg.sender == owner, \\\"only owner\\\");\\n33+  require(visrDeposit > 0, \\\"deposits must be nonzero\\\");\\n33+  require(to != address(0) && to != address(this), \\\"to\\\");\\n33+ require(from != address(0) && from != address(this), \\\"from\\\");\\n44+  require(IVisor(from).owner() == msg.sender); \\n45+  assert( IVisor(from) !=  address(this)); \\n61+  require(shares > 0, \\\"shares\\\");\\n61+  require(to != address(0), \\\"to\\\");\\n61+  require(from != address(0), \\\"from\\\");\\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \\\"Sender must own the tokens\\\");\\n\",\n    \"critical-invariants\": \"18+  require(msg.sender == owner, \\\"only owner\\\");\\n33+  require(visrDeposit > 0, \\\"deposits must be nonzero\\\");\\n33+  require(to != address(0) && to != address(this), \\\"to\\\");\\n33+ require(from != address(0) && from != address(this), \\\"from\\\");\\n44+  require(IVisor(from).owner() == msg.sender); \\n45+  assert( IVisor(from) !=  address(this)); \\n61+  require(shares > 0, \\\"shares\\\");\\n61+  require(to != address(0), \\\"to\\\");\\n61+  require(from != address(0), \\\"from\\\");\\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \\\"Sender must own the tokens\\\");\",\n    \"ranks\": \"18+  require(msg.sender == owner, \\\"only owner\\\");\\n33+  require(visrDeposit > 0, \\\"deposits must be nonzero\\\");\\n33+  require(to != address(0) && to != address(this), \\\"to\\\");\\n33+ require(from != address(0) && from != address(this), \\\"from\\\");\\n44+  require(IVisor(from).owner() == msg.sender); \\n45+  assert( IVisor(from) !=  address(this)); \\n61+  require(shares > 0, \\\"shares\\\");\\n61+  require(to != address(0), \\\"to\\\");\\n61+  require(from != address(0), \\\"from\\\");\\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \\\"Sender must own the tokens\\\");\",\n    \"vulnerabilities\": \"reentrancy\"\n  },\n  {\n    \"code\": \"1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\n2 pragma solidity ^0.8.0;\\n\\n3 import \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n4 import \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n5 import \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\n6 import \\\"./interfaces/IRevest.sol\\\";\\n7 import \\\"./interfaces/IAddressRegistry.sol\\\";\",\n    \"transaction-context\": \"The transaction context is money market\",\n    \"Critical-points\": \"Critical program points are 32+  \\n89+ \",\n    \"invariants\": \"32+  require(amount > 0, \\\"Invalid amount\\\");\\n32+  require(supply[id] == 0, \\\"Repeated mint for the same FNFT\\\");\\n89+  require(canTransfer, \\\"E046\\\");\\n\",\n    \"critical-invariants\": \"32+  require(amount > 0, \\\"Invalid amount\\\");\\n32+  require(supply[id] == 0, \\\"Repeated mint for the same FNFT\\\");\\n\",\n    \"ranks\": \"32+  require(amount > 0, \\\"Invalid amount\\\");\\n32+  require(supply[id] == 0, \\\"Repeated mint for the same FNFT\\\");\\n\",\n    \"vulnerabilities\": \"nan\"\n  },\n  {\n    \"code\": \"1 // SPDX-License-Identifier: MIT\\n2 pragma solidity ^0.8.7;\\n\\n3 import \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n4 import { LibAsset } from \\\"../Libraries/LibAsset.sol\\\";\\n5 import { ILiFi } from \\\"../Interfaces/ILiFi.sol\\\";\\n6 import { LibSwap } from \\\"../Libraries/LibSwap.sol\\\";\\n7 import { ICBridge } from \\\"../Interfaces/ICBridge.sol\\\";\\n8 import { LibDiamond } from \\\"../Libraries/LibDiamond.sol\\\";\",\n    \"transaction-context\": \"The transaction context is cross bridge\",\n    \"Critical-points\": \"Critical program points are 58+ \\n92+  \\n101+\\n125+  \\n191+  \",\n    \"invariants\": \"58+ require(msg.value >= _cBridgeData.amount, \\\"ERR_INVALID_AMOUNT\\\");\\n92+  require(_postSwapBalance > 0, \\\"ERR_INVALID_AMOUNT\\\");\\n101+ require(_postSwapBalance > 0, \\\"ERR_INVALID_AMOUNT\\\");\\n125+  require(s.cBridgeChainId != _cBridgeData.dstChainId, \\\"Cannot bridge to the same network.\\\");\\n191+  assert(!invokeSwap);\",\n    \"critical-invariants\": \"191+  assert(!invokeSwap);\",\n    \"ranks\": \"191+  assert(!invokeSwap);\",\n    \"vulnerabilities\": \"atomicity violation\\nbusiness logic flaw\\ninteger overflow/underflow\"\n  },\n  {\n    \"code\": \"1 // SPDX-License-Identifier: MIT OR Apache-2.0\\n2 pragma solidity >=0.6.11;\\n\\n3  */\\n4 contract Replica {\\n \\n5     /**\\n6      * @notice Emitted when message is processed\\n7      * @param messageHash Hash of message that failed to process\",\n    \"transaction-context\": \"The transaction context is cross bridge\",\n    \"Critical-points\": \"Critical program points are 26+\",\n    \"invariants\": \"26+   assert(_committedRoot != 0); \",\n    \"critical-invariants\": \"26+   assert(_committedRoot != 0); \",\n    \"ranks\": \"26+   assert(_committedRoot != 0); \",\n    \"vulnerabilities\": \"ID uniqueness violation\\ninconsistent state update\"\n  },\n  {\n    \"code\": \"1 pragma solidity ^0.5.0;\\n\\n2 import \\\"./../../../libs/math/SafeMath.sol\\\";\\n3 import \\\"./../../../libs/common/ZeroCopySource.sol\\\";\\n4 import \\\"./../../../libs/common/ZeroCopySink.sol\\\";\\n5 import \\\"./../../../libs/utils/Utils.sol\\\";\\n6 import \\\"./../upgrade/UpgradableECCM.sol\\\";\\n7 import \\\"./../libs/EthCrossChainUtils.sol\\\";\\n8 import \\\"./../interface/IEthCrossChainManager.sol\\\";\",\n    \"transaction-context\": \"The transaction context is cross bridge\",\n    \"Critical-points\": \"Critical program points are 29+  \\n30+  \\n48+  \\n51+  \\n54+ \\n55+ \\n83+ \\n106+  \\n108+\\n112+ \\n117+  \\n118+ \\n121+ \\n139+ \\n143+ \\n145+\",\n    \"invariants\": \"29+  require(header.nextBookkeeper == nextBookKeeper, \\\"NextBookers illegal\\\");\\n30+  require(eccd.putCurEpochStartHeight(header.height), \\\"Save Poly chain current epoch start height to Data contract failed!\\\");\\n30+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \\\"Save Poly chain current epoch book keepers to Data contract failed!\\\");\\n48+  require(header.nextBookkeeper != bytes20(0), \\\"The nextBookKeeper of header is empty\\\");\\n51+  require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \\\"Verify signature failed!\\\");\\n54+ require(header.nextBookkeeper == nextBookKeeper, \\\"NextBookers illegal\\\");\\n55+ require(eccd.putCurEpochStartHeight(header.height), \\\"Save MC LatestHeight to Data contract failed!\\\");\\n55+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \\\"Save Poly chain book keepers bytes to Data contract failed!\\\");\\n83+ require(eccd.putEthTxHash(keccak256(rawParam)), \\\"Save ethTxHash by index to Data contract failed!\\\");\\n106+  require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \\\"Verify poly chain header signature failed!\\\");\\n108+  require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \\\"Verify poly chain current epoch header signature failed!\\\");\\n112+  require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \\\"verify header proof failed!\\\");\\n117+  require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \\\"the transaction has been executed!\\\");\\n117+ require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \\\"Save crosschain tx exist failed!\\\");\\n118+  require(toMerkleValue.makeTxParam.toChainId == uint64(2), \\\"This Tx is not aiming at Ethereum network!\\\");\\n121+  require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \\\"Execute CrossChain Tx failed!\\\");\\n139+ assert(_method != “f1121318093”); \\n143+ require(success == true, \\\"EthCrossChain call business contract failed\\\");\\n145+  require(res == true, \\\"EthCrossChain call business contract return is not true\\\");\",\n    \"critical-invariants\": \"139+ assert(_method != “f1121318093”); \\n\",\n    \"ranks\": \"139+ assert(_method != “f1121318093”); \\n\",\n    \"vulnerabilities\": \"incorrect visibility/ownership\\nID uniqueness violation\\nbusiness logic flaw\\ninconsistent state update\"\n  },\n  {\n    \"code\": \"1 // SPDX-License-Identifier: LGPL-3.0-only\\n2 pragma solidity 0.6.12;\\n3 pragma experimental ABIEncoderV2;\\n\\n4 import \\\"../interfaces/IDepositExecute.sol\\\";\\n5 import \\\"./HandlerHelpers.sol\\\";\\n6 import \\\"../ERC721Safe.sol\\\";\\n7 import \\\"@openzeppelin/contracts/introspection/ERC165Checker.sol\\\";\\n8 import \\\"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\\\";\",\n    \"transaction-context\": \"The transaction context is cross bridge\",\n    \"Critical-points\": \"Critical program points are 43+    \\n83+  \",\n    \"invariants\": \"43+    require(_contractWhitelist[tokenAddress], \\\"provided tokenAddress is not whitelisted\\\");\\n83+   require(_contractWhitelist[address(tokenAddress)], \\\"provided tokenAddress is not whitelisted\\\");\\n\",\n    \"critical-invariants\": \"43+   require(_contractWhitelist[tokenAddress], \\\"provided tokenAddress is not whitelisted\\\");\\n83+   require(_contractWhitelist[address(tokenAddress)], \\\"provided tokenAddress is not whitelisted\\\");\\n\",\n    \"ranks\": \"43+   require(_contractWhitelist[tokenAddress], \\\"provided tokenAddress is not whitelisted\\\");\\n83+   require(_contractWhitelist[address(tokenAddress)], \\\"provided tokenAddress is not whitelisted\\\");\\n\",\n    \"vulnerabilities\": \"ID uniqueness violation\\ninconsistent state update\"\n  },\n  {\n    \"code\": \"1 // SPDX-License-Identifier: LGPL-3.0-only\\n2 pragma solidity 0.6.12;\\n3 pragma experimental ABIEncoderV2;\\n\\n4 import \\\"../interfaces/IDepositExecute.sol\\\";\\n5 import \\\"./HandlerHelpers.sol\\\";\\n6 import \\\"../ERC721Safe.sol\\\";\\n7 import \\\"@openzeppelin/contracts/introspection/ERC165Checker.sol\\\";\\n8 import \\\"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\\\";\",\n    \"transaction-context\": \"The transaction context is nan\",\n    \"Critical-points\": \"Critical program points are nan\",\n    \"invariants\": \"43+  require(_contractWhitelist[tokenAddress], \\\"provided tokenAddress is not whitelisted\\\");\\n83+  require(_contractWhitelist[address(tokenAddress)], \\\"provided tokenAddress is not whitelisted\\\");\\n\",\n    \"critical-invariants\": \"nan\",\n    \"ranks\": \"nan\",\n    \"vulnerabilities\": \"nan\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract A {\\n3     uint x;\\n4     constructor (uint a) public {x= a;}\\n5 }\\n\\n6 contract B is A {\\n7     constructor (uint a) A(a) public {x++;}\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 7+\",\n    \"invariants\": \"7+ assert (x == a + 1);\",\n    \"critical-invariants\": \"7+ assert (x == a + 1);\",\n    \"ranks\": \"7+ assert (x == a + 1);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 // Possible bug:\\n3 // In this test, ctor D is NOT called twice -\\n4 // Only ctor C is called\\n5 // compare with ConstructorChaining2_fail.sol\\n\\n6 contract D {\\n7         uint a;\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 14+\",\n    \"invariants\": \"14+ assert (a == x + 2);\",\n    \"critical-invariants\": \"14+ assert (a == x + 2);\",\n    \"ranks\": \"14+ assert (a == x + 2);\",\n    \"vulnerabilities\": \"arithmetic flaw\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 // This test shows an order in which base constructors for C are called:\\n3 // B(a) calls base ctor A(a) {x = a};\\n4 // ctor B is called {x++};\\n5 // ctor C is called {x++}\\n\\n\\n6 contract A {\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 13+\",\n    \"invariants\": \"13+ assert (x == a + 2);\",\n    \"critical-invariants\": \"13+ assert (x == a + 2);\",\n    \"ranks\": \"13+ assert (x == a + 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract Foo {\\n\\n3     uint a;\\n\\n4     constructor () public {\\n5         a = 1;\\n6     }\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+\",\n    \"invariants\": \"7+  assert (a == 1);\",\n    \"critical-invariants\": \"7+  assert (a == 1);\",\n    \"ranks\": \"7+  assert (a == 1);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 contract ArrayNestedFixedSize {\\n\\n2     // NOTE: the number of columns comes first in the declaration!\\n3     uint[3][2] a;\\n4     bool[2][2] aa;\\n\\n5     constructor() {\\n6       _;\\n\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 20+ \\n\",\n    \"invariants\": \"20+ assert (a[0][0] == 0 || a[0][0] == 3);\\n20+  assert (a[0][1] == 1);\\n20+  assert (a[0][2] == 2);\\n20+  assert (a[1][0] == 3);\\n20+  assert (a[1][1] == 4);\\n20+  assert (a[1][2] == 5);\",\n    \"critical-invariants\": \"20+ assert (a[0][0] == 0 || a[0][0] == 3);\\n20+  assert (a[0][1] == 1);\\n20+  assert (a[0][2] == 2);\\n20+  assert (a[1][0] == 3);\\n20+  assert (a[1][1] == 4);\\n20+  assert (a[1][2] == 5);\",\n    \"ranks\": \"20+ assert (a[0][0] == 0 || a[0][0] == 3);\\n20+  assert (a[0][1] == 1);\\n20+  assert (a[0][2] == 2);\\n20+  assert (a[1][0] == 3);\\n20+  assert (a[1][1] == 4);\\n20+  assert (a[1][2] == 5);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract ArrayFixedSize {\\n\\n3     uint[2] a;\\n\\n4     constructor() public {}\\n\\n5     function test() public {\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+\",\n    \"invariants\": \"7+  assert(a[0] == 1);    \\n7+  assert(a[1] == 2);\",\n    \"critical-invariants\": \"7+  assert(a[0] == 1);    \\n7+  assert(a[1] == 2);\",\n    \"ranks\": \"7+  assert(a[0] == 1);    \\n7+  assert(a[1] == 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract ArrayDynamicStorage {\\n\\n3     uint[] sa;\\n\\n4     function ArrayDynamicStorage() {\\n5        assert (sa.length == 0);\\n6     }\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 9+\",\n    \"invariants\": \"9+ assert (sa[0] == 10);\\n9+  assert (sa[1] == 11);\\n9+ assert (sa.length == 2);\",\n    \"critical-invariants\": \"9+ assert (sa[0] == 10);\\n9+  assert (sa[1] == 11);\",\n    \"ranks\": \"9+ assert (sa[0] == 10);\\n9+  assert (sa[1] == 11);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract LoopFor {\\n\\n3     uint[2] a;\\n\\n4     function testBoundedForLoop() public {\\n5         for (uint i = 0; i < 2; i += 1) {\\n6             a[i] = i;\",\n    \"transaction-context\": \"The transaction context is loop\",\n    \"Critical-points\": \"Critical program points are 7+  \\n15+\",\n    \"invariants\": \"7+  assert (a[0] == 0);\\n7+ assert (a[1] == 1);\\n15+ assert (b[j] == j);\\n\",\n    \"critical-invariants\": \"7+  assert (a[0] == 0);\\n7+ assert (a[1] == 1);\\n15+ assert (b[j] == j);\",\n    \"ranks\": \"7+  assert (a[0] == 0);\\n7+ assert (a[1] == 1);\\n15+ assert (b[j] == j);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract A {\\n3    function testTuple() public pure{\\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\\n5       uint a;\\n6       uint b;\\n7       /* only support function returns as tuples\\n8       (a,  b) = (1, 3);\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 8+ \\n10+  \\n11+ \\n\",\n    \"invariants\": \"8+ assert (a == 1);\\n8+ assert (b == 3);\\n10+  assert (a == 4);\\n10+. assert (b == 40);\\n11+  assert (a == 5);\\n11+  assert (b == 55);\\n\",\n    \"critical-invariants\": \"8+ assert (a == 1);\\n8+ assert (b == 3);\\n10+  assert (a == 4);\\n10+. assert (b == 40);\\n11+  assert (a == 5);\\n11+  assert (b == 55);\",\n    \"ranks\": \"8+ assert (a == 1);\\n8+ assert (b == 3);\\n10+  assert (a == 4);\\n10+. assert (b == 40);\\n11+  assert (a == 5);\\n11+  assert (b == 55);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract A {\\n3     uint x;\\n4     constructor (uint a) public {x= a;}\\n5 }\\n\\n6 contract B is A {\\n7     constructor (uint a) A(a) public {\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 8+\",\n    \"invariants\": \"8+  assert (x == a + 1);\",\n    \"critical-invariants\": \"8+  assert (x == a + 1);\",\n    \"ranks\": \"8+  assert (x == a + 1);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 // This test shows an order in which base constructors for C are called:\\n3 // B(a) calls base ctor A(a) {x = a};\\n4 // ctor B is called {x++};\\n5 // ctor C is called {x++}\\n\\n\\n6 contract A {\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 13+ \",\n    \"invariants\": \"13+ assert (x == a + 2);\",\n    \"critical-invariants\": \"13+ assert (x == a + 2);\",\n    \"ranks\": \"13+ assert (x == a + 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract Foo {\\n\\n3     uint a;\\n\\n4     constructor () public {\\n5         a = 1;\\n6     }\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+   \",\n    \"invariants\": \"7+   assert (a == 1);\",\n    \"critical-invariants\": \"7+   assert (a == 1);\",\n    \"ranks\": \"7+   assert (a == 1);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 // This test shows an order in which base constructors for C are called:\\n3 // B(a) calls base ctor A(a) {x = a};\\n4 // ctor B is called {x++};\\n5 // ctor C is called {x++}\\n\\n\\n6 contract A {\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 13+\",\n    \"invariants\": \"13+ assert (x == a + 2);\",\n    \"critical-invariants\": \"13+ assert (x == a + 2);\",\n    \"ranks\": \"13+ assert (x == a + 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n2 pragma solidity >=0.4.24 <0.6.0;\\n\\n3 contract Consts {\\n\\n4     constructor () public {\\n5         uint a;\\n6         address b;\\n7         address c;\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 10+\",\n    \"invariants\": \"10+ assert(b != c);\",\n    \"critical-invariants\": \"10+ assert(b != c);\",\n    \"ranks\": \"10+ assert(b != c);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract Branch {\\n\\n3     function testIf(bool b) public returns (uint a) {\\n4         if (b) {\\n5             a = 1;\\n6         } else {\\n7             a = 2;\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 8+\\n11+\",\n    \"invariants\": \"8+  assert (a == 1 || a == 2);\\n11+ assert (a == 1 || a == 2);\",\n    \"critical-invariants\": \"11+ assert (a == 1 || a == 2);\",\n    \"ranks\": \"11+ assert (a == 1 || a == 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract DoWhileLoop {\\n\\n3     function testDoWhileLoop() public {\\n4         uint i = 1;\\n5         uint sum = 0;\\n6         do {\\n7             sum += i;\",\n    \"transaction-context\": \"The transaction context is loop\\n\",\n    \"Critical-points\": \"Critical program points are 9+\",\n    \"invariants\": \"9+   assert (sum == 1);\",\n    \"critical-invariants\": \"9+   assert (sum == 1);\",\n    \"ranks\": \"9+   assert (sum == 1);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract Arithmetics {\\n\\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\\n4         c = _a + _b;\\n      \\n5     }\\n\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 4+ \\n7+ \\n10+ \\n13+ \",\n    \"invariants\": \"4+ assert (c == _a + _b);\\n7+ assert (c == _a - _b);\\n10+ assert (c == _a * _b);\\n13+  assert (c == _a / _b);\",\n    \"critical-invariants\": \"4+ assert (c == _a + _b);\\n7+ assert (c == _a - _b);\\n10+ assert (c == _a * _b);\\n13+  assert (c == _a / _b);\",\n    \"ranks\": \"4+ assert (c == _a + _b);\\n7+ assert (c == _a - _b);\\n10+ assert (c == _a * _b);\\n13+  assert (c == _a / _b);\",\n    \"vulnerabilities\": \"arithmetic flaw \\ninteger overflow/underflow\\n\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24<0.6.0; contract Crowdsale {\\n2     uint raised;\\n3     uint goal;\\n4     uint deadline;\\n\\n5     bool finished; // Instrumented.\\n6     bool canceled; // Instrumented.\\n\\n7     constructor(uint _goal) public {\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 16+ \\n19+ \\n22+ \",\n    \"invariants\": \"16+ assert(finished = true);\\n19+ assert(canceled = true); \\n22+ assert(!(finished && canceled)); \",\n    \"critical-invariants\": \"16+ assert(finished = true);\\n19+ assert(canceled = true); \\n22+ assert(!(finished && canceled)); \",\n    \"ranks\": \"16+ assert(finished = true);\\n19+ assert(canceled = true); \\n22+ assert(!(finished && canceled)); \",\n    \"vulnerabilities\": \"atomicity violation \\n\"\n  },\n  {\n    \"code\": \"1 contract JAY is ERC20, Ownable {\\n2     using SafeMath for uint256;\\n3     AggregatorV3Interface internal priceFeed;\\n\\n4     address private dev;\\n5     uint256 public constant MIN = 1000;\\n6     bool private start = false;\\n7     bool private lockDev = false;\\n\",\n    \"transaction-context\": \"The transaction context is money market\",\n    \"Critical-points\": \"Critical program points are 24+  \\n46+       \\n47+   \\n100+       \\n102+  \\n104+ \\n140+  \\n143+   \\n144+ \\n148+    \\n150+ \",\n    \"invariants\": \"24+   require(lockDev == false);\\n46+        require(\\n            msg.value >= (total).mul(buyNftFeeEth),\\n            \\\"You need to pay ETH more\\\"\\n        );\\n47+   require(success, \\\"ETH Transfer failed.\\\");\\n100+         require(\\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\\n                \\\"You need to pay ETH more\\\"\\n            );\\n102+  require(\\n                msg.value >= (total).mul(sellNftFeeEth),\\n                \\\"You need to pay ETH more\\\"\\n            );\\n104+ require(success, \\\"ETH Transfer failed.\\\");\\n140+   require(value > MIN, \\\"Dude tf\\\");\\n143+   require(success, \\\"ETH Transfer failed.\\\");\\n144+   require(success2, \\\"ETH Transfer failed.\\\");\\n148+   require(msg.value > MIN, \\\"must trade over min\\\");\\n148+   require(start, \\\"Not started!\\\");\\n150+ require(success, \\\"ETH Transfer failed.\\\");\",\n    \"critical-invariants\": \"24+   require(lockDev == false);\\n46+        require(\\n            msg.value >= (total).mul(buyNftFeeEth),\\n            \\\"You need to pay ETH more\\\"\\n        );\\n47+   require(success, \\\"ETH Transfer failed.\\\");\\n100+         require(\\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\\n                \\\"You need to pay ETH more\\\"\\n            );\\n102+  require(\\n                msg.value >= (total).mul(sellNftFeeEth),\\n                \\\"You need to pay ETH more\\\"\\n            );\\n104+ require(success, \\\"ETH Transfer failed.\\\");\",\n    \"ranks\": \"24+   require(lockDev == false);\\n46+        require(\\n            msg.value >= (total).mul(buyNftFeeEth),\\n            \\\"You need to pay ETH more\\\"\\n        );\\n47+   require(success, \\\"ETH Transfer failed.\\\");\\n100+         require(\\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\\n                \\\"You need to pay ETH more\\\"\\n            );\\n102+  require(\\n                msg.value >= (total).mul(sellNftFeeEth),\\n                \\\"You need to pay ETH more\\\"\\n            );\\n104+ require(success, \\\"ETH Transfer failed.\\\");\",\n    \"vulnerabilities\": \"atomicity violation \\narithmetic flaw\\nintefer overflow/underflow\\ninconsistent state update\\nbusiness logic flaw\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.6.0 <0.8.0;\\n\\n2 import \\\"./openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\n3 import \\\"./openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n4 import \\\"./openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n5 import \\\"./openzeppelin/contracts/math/SafeMath.sol\\\";\\n6 import \\\"./openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n7 import \\\"./openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n8 // import \\\"hardhat/consolse.sol\\\";\",\n    \"transaction-context\": \"The transaction context is asset swapping\",\n    \"Critical-points\": \"Critical program points are 19+ \\n76+\",\n    \"invariants\": \"19+ require (liquidity>0, \\\"MonoX:BAD_AMOUNT\\\");\\n76+ assert(to != address(0)); \",\n    \"critical-invariants\": \"19+ require (liquidity>0, \\\"MonoX:BAD_AMOUNT\\\");\\n76+ assert(to != address(0)); \",\n    \"ranks\": \"19+ require (liquidity>0, \\\"MonoX:BAD_AMOUNT\\\");\\n76+ assert(to != address(0)); \",\n    \"vulnerabilities\": \"incorrect visibility/ownership\\narithmetic flaw\"\n  },\n  {\n    \"code\": \"1 pragma solidity ^0.5.16;\\n\\n2 import \\\"./ComptrollerInterface.sol\\\";\\n3 import \\\"./CTokenInterfaces.sol\\\";\\n4 import \\\"./ErrorReporter.sol\\\";\\n5 import \\\"./Exponential.sol\\\";\\n6 import \\\"./EIP20Interface.sol\\\";\\n7 import \\\"./EIP20NonStandardInterface.sol\\\";\\n8 import \\\"./InterestRateModel.sol\\\";\",\n    \"transaction-context\": \"The transaction context is tokenSale\",\n    \"Critical-points\": \"Critical program points are 16+ \\n17+   \\n20+  \\n24+ \\n104+\\n107+  \\n133+\\n195+ \\n774+  \\n828+  \",\n    \"invariants\": \"16+   require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n17+   require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n20+  require(err == uint(Error.NO_ERROR), \\\"setting comptroller failed\\\");\\n24+  require(err == uint(Error.NO_ERROR), \\\"setting interest rate model failed\\\");\\n104+ require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n107+   require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n133+ require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\n774+  require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\\n828+  require(_notEntered, \\\"re-entered\\\");\",\n    \"critical-invariants\": \"16+   require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n17+   require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\n774+  require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\",\n    \"ranks\": \"16+   require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n17+   require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\n774+  require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\",\n    \"vulnerabilities\": \"reentrancy\\ninconsistent state update \\nID uniqueness violation\\narithmetic flaw\\nincorrect visibility/ownership \"\n  },\n  {\n    \"code\": \"1 pragma solidity ^0.5.16;\\n\\n2 import \\\"./CToken.sol\\\";\\n3 import \\\"./ERC3156FlashLenderInterface.sol\\\";\\n4 import \\\"./ERC3156FlashBorrowerInterface.sol\\\";\\n\\n5 /**\\n6  * @title Cream's CCollateralCapErc20 Contract\\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap\",\n    \"transaction-context\": \"The transaction context is tokenSale\",\n    \"Critical-points\": \"Critical program points are 44+   \\n190+  \\n194+ \\n206+ \\n217+ \\n491+ \\n552+  \\n584+  \\n586+  \",\n    \"invariants\": \"44+   require(err == 0, \\\"mint failed\\\");\\n190+  require(\\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\\n                keccak256(\\\"ERC3156FlashBorrowerInterface.onFlashLoan\\\"),\\n            \\\"IERC3156: Callback failed\\\"\\n        );\\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \\\"BALANCE_INCONSISTENT\\\");\\n206+ require(msg.sender == address(comptroller), \\\"comptroller only\\\");\\n217+ require(msg.sender == address(comptroller), \\\"comptroller only\\\");\\n491+ require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"bad input\\\");\\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \\\"comptroller rejection\\\");\\n586+  require(getCashPrior() >= vars.redeemAmount, \\\"insufficient cash\\\");\\n\",\n    \"critical-invariants\": \"44+   require(err == 0, \\\"mint failed\\\");\\n190+  require(\\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\\n                keccak256(\\\"ERC3156FlashBorrowerInterface.onFlashLoan\\\"),\\n            \\\"IERC3156: Callback failed\\\"\\n        );\\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \\\"BALANCE_INCONSISTENT\\\");\\n491+ require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"bad input\\\");\\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \\\"comptroller rejection\\\");\\n586+  require(getCashPrior() >= vars.redeemAmount, \\\"insufficient cash\\\");\",\n    \"ranks\": \"44+   require(err == 0, \\\"mint failed\\\");\\n190+  require(\\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\\n                keccak256(\\\"ERC3156FlashBorrowerInterface.onFlashLoan\\\"),\\n            \\\"IERC3156: Callback failed\\\"\\n        );\\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \\\"BALANCE_INCONSISTENT\\\");\\n491+ require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"bad input\\\");\\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \\\"comptroller rejection\\\");\\n586+  require(getCashPrior() >= vars.redeemAmount, \\\"insufficient cash\\\");\",\n    \"vulnerabilities\": \"cross bridge\\ninconsistent state update \\nID uniqueness violation\\narithmetic flaw\"\n  },\n  {\n    \"code\": \"1 pragma solidity ^0.5.16;\\n\\n2 import \\\"./CToken.sol\\\";\\n\\n3 /**\\n4  * @title Compound's CErc20 Contract\\n5  * @notice CTokens which wrap an EIP-20 underlying\\n6  * @author Compound\\n7  */\",\n    \"transaction-context\": \"The transaction context is tokenSale\",\n    \"Critical-points\": \"Critical program points are 42+  \\n50+ \\n59+  \\n67+ \\n76+\\n85+ \\n100+\\n154+\\n192+\\n209+\\n210+ \\n253+  \\n260+   \\n315+ \\n336+  \\n343+  \\n352+  \\n390+  \\n402+  \",\n    \"invariants\": \"42+  require(err == 0, \\\"mint failed\\\");\\n50+  require(redeemInternal(redeemTokens, false) == 0, \\\"redeem failed\\\");\\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \\\"redeem underlying failed\\\");\\n67+  require(borrowInternal(borrowAmount, false) == 0, \\\"borrow failed\\\");\\n76+  require(err == 0, \\\"repay failed\\\");\\n85+  require(err == 0, \\\"repay behalf failed\\\");\\n100+ require(err == 0, \\\"liquidate borrow failed\\\");\\n154+ require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\n192+  require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \\\"comptroller rejection\\\");\\n210+ require(src != dst, \\\"bad input\\\");\\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \\\"comptroller rejection\\\");\\n260+   require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"bad input\\\");\\n336+  require(comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens) == 0, \\\"comptroller rejection\\\");\\n343+  require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n352+  require(getCashPrior() >= vars.redeemAmount, \\\"insufficient cash\\\");\\n390+  require(\\n            comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\\n            \\\"comptroller rejection\\\"\\n        );\\n402+   require(borrower != liquidator, \\\"invalid account pair\\\");\",\n    \"critical-invariants\": \"42+  require(err == 0, \\\"mint failed\\\");\\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \\\"redeem underlying failed\\\");\\n67+  require(borrowInternal(borrowAmount, false) == 0, \\\"borrow failed\\\");\\n76+  require(err == 0, \\\"repay failed\\\");\\n192+  require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \\\"comptroller rejection\\\");\\n210+ require(src != dst, \\\"bad input\\\");\\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \\\"comptroller rejection\\\");\\n260+   require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"bad input\\\");\\n\\n343+  require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n352+  require(getCashPrior() >= vars.redeemAmount, \\\"insufficient cash\\\");\\n390+  require(  comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\\\"comptroller rejection\\\");\\n402+   require(borrower != liquidator, \\\"invalid account pair\\\");\",\n    \"ranks\": \"42+  require(err == 0, \\\"mint failed\\\");\\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \\\"redeem underlying failed\\\");\\n67+  require(borrowInternal(borrowAmount, false) == 0, \\\"borrow failed\\\");\\n76+  require(err == 0, \\\"repay failed\\\");\\n192+  require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \\\"comptroller rejection\\\");\\n210+ require(src != dst, \\\"bad input\\\");\\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \\\"comptroller rejection\\\");\\n260+   require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"bad input\\\");\\n\\n343+  require(accrualBlockNumber == getBlockNumber(), \\\"market not fresh\\\");\\n352+  require(getCashPrior() >= vars.redeemAmount, \\\"insufficient cash\\\");\\n390+  require(  comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\\\"comptroller rejection\\\");\\n402+   require(borrower != liquidator, \\\"invalid account pair\\\");\",\n    \"vulnerabilities\": \"cross bridge\\ninconsistent state update \\nID uniqueness violation\\narithmetic flaw\"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract A {\\n3    function testTuple() public pure{\\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\\n5       uint a;\\n6       uint b;\\n7       (a,  b) = (1, 3);\\n  \",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+ \\n8+ \\n9+ \\n\\n\",\n    \"invariants\": \"7+ assert (a == 1);\\n7+ assert (b == 3);\\n8+  assert (a == 4);\\n8+ assert (b == 40);\\n9+  assert (a == 5);\\n9+  assert (b == 55);\\n\",\n    \"critical-invariants\": \"7+ assert (a == 1);\\n7+ assert (b == 3);\\n8+  assert (a == 4);\\n8+ assert (b == 40);\\n9+  assert (a == 5);\\n9+  assert (b == 55);\",\n    \"ranks\": \"7+ assert (a == 1);\\n7+ assert (b == 3);\\n8+  assert (a == 4);\\n8+ assert (b == 40);\\n9+  assert (a == 5);\\n9+  assert (b == 55);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 /**\\n2  *Submitted for verification at Etherscan.io on 2018-05-09\\n3 */\\n\\n4 pragma solidity ^0.4.21;\\n\\n\\n5 /**\\n6  * @title SafeMath\",\n    \"transaction-context\": \"The transaction context is ERC\",\n    \"Critical-points\": \"Critical program points are 17+  \\n32+ \\n39+ \\n84+ \\n85+ \",\n    \"invariants\": \"17+  assert(c / a == b);\\n32+ assert(b <= a);\\n39+  assert(c >= a);\\n84+  require(_to != address(0));\\n85+ require(_value <= balances[msg.sender]);\",\n    \"critical-invariants\": \"17+  assert(c / a == b);\\n32+ assert(b <= a);\\n39+  assert(c >= a);\\n84+  require(_to != address(0));\\n85+ require(_value <= balances[msg.sender]);\",\n    \"ranks\": \"17+  assert(c / a == b);\\n32+ assert(b <= a);\\n39+  assert(c >= a);\\n84+  require(_to != address(0));\\n85+ require(_value <= balances[msg.sender]);\",\n    \"vulnerabilities\": \"arithmetic flaw \\ninteger overflow/underflow\\nincorrect visibility/ownership\"\n  },\n  {\n    \"code\": \"1 pragma solidity ^0.4.16;\\n \\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\\n \\n3 contract TokenERC20 {\\n4     string public name;\\n5     string public symbol;\\n6     uint8 public decimals = 18;  // 18 \\n7     uint256 public totalSupply;\",\n    \"transaction-context\": \"The transaction context is tokenSale\",\n    \"Critical-points\": \"Critical program points are 51+ \\n58+  \\n59+ \",\n    \"invariants\": \"51+  require(balanceOf[msg.sender] >= _value);\\n58+  require(balanceOf[_from] >= _value);\\n59+  require(_value <= allowance[_from][msg.sender]);\",\n    \"critical-invariants\": \"51+  require(balanceOf[msg.sender] >= _value);\\n58+  require(balanceOf[_from] >= _value);\\n59+  require(_value <= allowance[_from][msg.sender]);\",\n    \"ranks\": \"51+  require(balanceOf[msg.sender] >= _value);\\n58+  require(balanceOf[_from] >= _value);\\n59+  require(_value <= allowance[_from][msg.sender]);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 contract SafeMath {\\n\\n2     function safeAdd(uint a, uint b) public pure returns (uint c) {\\n3         c = a + b;\\n4         require(c >= a);\\n5     }\\n\\n6     function safeSub(uint a, uint b) public pure returns (uint c) {\\n7         require(b <= a);\",\n    \"transaction-context\": \"The transaction context is ERC\",\n    \"Critical-points\": \"Critical program points are 4+ \\n7+ \\n12+ \\n15+ \",\n    \"invariants\": \"4+ require(c >= a);\\n7+ require(b <= a);\\n12+ require(a == 0 || c / a == b);\\n15+ require(b > 0);\",\n    \"critical-invariants\": \"4+ require(c >= a);\\n7+ require(b <= a);\\n12+ require(a == 0 || c / a == b);\\n15+ require(b > 0);\",\n    \"ranks\": \"4+ require(c >= a);\\n7+ require(b <= a);\\n12+ require(a == 0 || c / a == b);\\n15+ require(b > 0);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 // array variable copy breaks\\n\\n2 contract ArrayLength {\\n3     uint[12] a;\\n\\n4     constructor (uint[12] memory d) public\\n5     {\\n6         require (d[1] == 5);\\n7         a = d;       \",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 6+ \\n8+  \",\n    \"invariants\": \"6+ require (d[1] == 5);\\n8+  assert (d[1] == 5);\",\n    \"critical-invariants\": \"8+  assert (d[1] == 5);\",\n    \"ranks\": \"8+  assert (d[1] == 5);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract ArrayNestedFixedSize {\\n\\n3     // NOTE: the number of columns comes first in the declaration!\\n4     uint[3][2] a;\\n5     bool[2][2] aa;\\n\\n6     constructor() {\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+ \\n8+ \\n22+  \\n23+  \\n24+\\n25+ \\n26+  \\n27+ \",\n    \"invariants\": \"7+ assert (a[0][1] == 0);\\n8+  assert (!aa[0][1]);\\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\\n23+  assert (a[0][1] == 1);\\n24+ assert (a[0][2] == 2);\\n25+ assert (a[1][0] == 3);\\n26+  assert (a[1][1] == 4);\\n27+ assert (a[1][2] == 5);\\n\",\n    \"critical-invariants\": \"7+ assert (a[0][1] == 0);\\n8+  assert (!aa[0][1]);\\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\\n23+  assert (a[0][1] == 1);\\n24+ assert (a[0][2] == 2);\\n25+ assert (a[1][0] == 3);\\n26+  assert (a[1][1] == 4);\\n27+ assert (a[1][2] == 5);\",\n    \"ranks\": \"7+ assert (a[0][1] == 0);\\n8+  assert (!aa[0][1]);\\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\\n23+  assert (a[0][1] == 1);\\n24+ assert (a[0][2] == 2);\\n25+ assert (a[1][0] == 3);\\n26+  assert (a[1][1] == 4);\\n27+ assert (a[1][2] == 5);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 contract ArrayInit {\\n\\n2     uint[2] a;\\n3     uint[2] b;\\n    \\n4     constructor() public {\\n5        b[1] = 22;\\n6        a[1] = 33;\\n7        assert (b[1] == 22);\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+ \",\n    \"invariants\": \"7+ assert (b[1] == 22);\",\n    \"critical-invariants\": \"7+ assert (b[1] == 22);\",\n    \"ranks\": \"7+ assert (b[1] == 22);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity ^0.5.2;\\n\\n2 // Tests that function with inline assembly generates non-det result\\n3 contract AssemblyTest\\n4 {\\n5         bool b;\\n6         int x;\\n7     constructor () public {\\n8   }\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 12+ \",\n    \"invariants\": \"12+ assert(false);\",\n    \"critical-invariants\": \"12+ assert(false);\",\n    \"ranks\": \"12+ assert(false);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract Branch {\\n\\n3     function testIf(bool b) public returns (uint a) {\\n4         if (b) {\\n5             a = 1;\\n6         } else {\\n7             a = 2;\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 9+ \\n13+ \",\n    \"invariants\": \"9+ assert (a == 1 || a == 2);\\n13+ assert (a == 1 || a == 2);\",\n    \"critical-invariants\": \"13+ assert (a == 1 || a == 2);\",\n    \"ranks\": \"13+ assert (a == 1 || a == 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract Consts {\\n\\n3     constructor () public {\\n4         uint a;\\n5         address b;\\n6         address c;\\n\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 10+ \",\n    \"invariants\": \"10+ assert(b != c);\",\n    \"critical-invariants\": \"10+ assert(b != c);\",\n    \"ranks\": \"10+ assert(b != c);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract Foo {\\n\\n3     uint a;\\n\\n4     constructor () public {\\n5         a = 1;\\n6     }\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 8+ \",\n    \"invariants\": \"8+ assert (a == 1);\",\n    \"critical-invariants\": \"8+ assert (a == 1);\",\n    \"ranks\": \"8+ assert (a == 1);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 // This test shows an order in which base constructors for C are called:\\n3 // B(a) calls base ctor A(a) {x = a};\\n4 // ctor B is called {x++};\\n5 // ctor C is called {x++}\\n\\n\\n6 contract A {\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 15+\",\n    \"invariants\": \"15+ assert (x == a + 2);\",\n    \"critical-invariants\": \"15+ assert (x == a + 2);\",\n    \"ranks\": \"15+ assert (x == a + 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 // Shows that constructor chaining still has a bug\\n2 // D constructor is called twice - see trace in corral.txt:\\n3 // ctor D {x = 1}\\n4 // ctor D {x = 1}\\n5 // ctor B\\n6 // ctor C\\n\\n7 contract D {\\n8         uint x;\",\n    \"transaction-context\": \"The transaction context is arithmetics\",\n    \"Critical-points\": \"Critical program points are 16+ \",\n    \"invariants\": \"16+ assert (x != 1); \",\n    \"critical-invariants\": \"16+ assert (x != 1); \",\n    \"ranks\": \"16+ assert (x != 1); \",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract A {\\n3    function testTuple() public pure{\\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\\n5       uint a;\\n6       uint b;\\n7       /* only support function returns as tuples\\n8       (a,  b) = (1, 3);\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 9+   \\n10+      \\n13+    \\n14+     \\n16+     \\n17+      \",\n    \"invariants\": \"9+       assert (a == 1);\\n10+       assert (b == 3);\\n13+       assert (a == 4);\\n14+       assert (b == 40);\\n16+       assert (a == 5);\\n17+       assert (b == 55);\\n\",\n    \"critical-invariants\": \"9+       assert (a == 1);\\n10+       assert (b == 3);\\n13+       assert (a == 4);\\n14+       assert (b == 40);\\n16+       assert (a == 5);\\n17+       assert (b == 55);\",\n    \"ranks\": \"9+       assert (a == 1);\\n10+       assert (b == 3);\\n13+       assert (a == 4);\\n14+       assert (b == 40);\\n16+       assert (a == 5);\\n17+       assert (b == 55);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract LoopFor {\\n\\n3     uint[2] a;\\n\\n4     function testBoundedForLoop() public {\\n5         for (uint i = 0; i < 2; i += 1) {\\n6             a[i] = i;\",\n    \"transaction-context\": \"The transaction context is loop\\ncross function\",\n    \"Critical-points\": \"Critical program points are 8+ \\n9+\\n18+ \\n\",\n    \"invariants\": \"8+ assert (a[0] == 0);\\n9+ assert (a[1] == 1);\\n18+ assert (b[j] == j);\\n\",\n    \"critical-invariants\": \"8+ assert (a[0] == 0);\\n9+ assert (a[1] == 1);\\n18+ assert (b[j] == j);\",\n    \"ranks\": \"8+ assert (a[0] == 0);\\n9+ assert (a[1] == 1);\\n18+ assert (b[j] == j);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract ArrayDynamicStorage {\\n\\n3     uint[] sa;\\n\\n4     function ArrayDynamicStorage() {\\n5        assert (sa.length == 0);\\n6     }\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 5+ \\n10+ \\n11+ \\n12+  \",\n    \"invariants\": \"5+ assert (sa.length == 0);\\n10+ assert (sa[0] == 10);\\n11+ assert (sa[1] == 11);\\n12+  assert (sa.length == 2);\",\n    \"critical-invariants\": \"5+ assert (sa.length == 0);\\n10+ assert (sa[0] == 10);\\n11+ assert (sa[1] == 11);\\n12+  assert (sa.length == 2);\",\n    \"ranks\": \"5+ assert (sa.length == 0);\\n10+ assert (sa[0] == 10);\\n11+ assert (sa[1] == 11);\\n12+  assert (sa.length == 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract ArrayFixedSize {\\n\\n3     uint[2] a;\\n\\n4     constructor() public {}\\n\\n5     function test() public {\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 8+ \\n9+ \",\n    \"invariants\": \"8+ assert(a[0] == 1);\\n9+ assert(a[1] == 2);\",\n    \"critical-invariants\": \"8+ assert(a[0] == 1);\\n9+ assert(a[1] == 2);\",\n    \"ranks\": \"8+ assert(a[0] == 1);\\n9+ assert(a[1] == 2);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1  contract ArrayInit {\\n\\n2     uint[2] a;\\n3     uint[2] b;\\n    \\n4     constructor() public {\\n5        b[1] = 22;\\n6        a[1] = 33;\\n7        assert (b[1] == 22);\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+ \",\n    \"invariants\": \"7+ assert (b[1] == 22);\",\n    \"critical-invariants\": \"7+ assert (b[1] == 22);\",\n    \"ranks\": \"7+ assert (b[1] == 22);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract ArrayNestedFixedSize {\\n\\n3     // NOTE: the number of columns comes first in the declaration!\\n4     uint[3][2] a;\\n5     bool[2][2] aa;\\n\\n6     constructor() {\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+ \\n8+ \\n22+ \\n23+ \\n24+\\n25+ \\n26+ \\n27+ \",\n    \"invariants\": \"7+ assert (a[0][1] == 0);\\n8+  assert (!aa[0][1]);\\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\\n23+ assert (a[0][1] == 1);\\n24+ assert (a[0][2] == 2);\\n25+ assert (a[1][0] == 3);\\n26+ assert (a[1][1] == 4);\\n27+ assert (a[1][2] == 5);\",\n    \"critical-invariants\": \"7+ assert (a[0][1] == 0);\\n8+  assert (!aa[0][1]);\\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\\n23+ assert (a[0][1] == 1);\\n24+ assert (a[0][2] == 2);\\n25+ assert (a[1][0] == 3);\\n26+ assert (a[1][1] == 4);\\n27+ assert (a[1][2] == 5);\",\n    \"ranks\": \"7+ assert (a[0][1] == 0);\\n8+  assert (!aa[0][1]);\\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\\n23+ assert (a[0][1] == 1);\\n24+ assert (a[0][2] == 2);\\n25+ assert (a[1][0] == 3);\\n26+ assert (a[1][1] == 4);\\n27+ assert (a[1][2] == 5);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 contract ArrayInit {\\n\\n2     uint[2] a;\\n3     uint[2] b;\\n    \\n4     constructor() public {\\n5        b[1] = 22;\\n6        a[1] = 33;\\n7        assert (b[1] == 22);\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 7+\",\n    \"invariants\": \"7+ assert (b[1] == 22);\",\n    \"critical-invariants\": \"7+ assert (b[1] == 22);\",\n    \"ranks\": \"7+ assert (b[1] == 22);\",\n    \"vulnerabilities\": \"healthy \"\n  },\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract Consts {\\n\\n3     constructor () public {\\n4         uint a;\\n5         address b;\\n6         address c;\\n\",\n    \"transaction-context\": \"The transaction context is simple\",\n    \"Critical-points\": \"Critical program points are 10+  \",\n    \"invariants\": \"10+  assert(b != c);\",\n    \"critical-invariants\": \"10+  assert(b != c);\",\n    \"ranks\": \"10+  assert(b != c);\",\n    \"vulnerabilities\": \"healthy \"\n  }\n]",
    "content_summary": "[\n  {\n    \"code\": \"1 pragma solidity >=0.4.24 <0.6.0;\\n\\n2 contract ExternalFunctionCall {\\n\\n3     function foo(uint x) public returns (uint ret) {\\n4         ret = x + 2;\\n5     }\\n\\n6     function testExternalFunctionCall(uint x) public {\",\n    \"t...",
    "content_length": 67001,
    "created_at": "2025-05-09T17:27:14.152524",
    "updated_at": "2025-05-09T17:36:52.174269",
    "file_path": "unknown_source"
  }
}