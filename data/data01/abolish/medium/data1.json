[
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ExternalFunctionCall {\n\n3     function foo(uint x) public returns (uint ret) {\n4         ret = x + 2;\n5     }\n\n6     function testExternalFunctionCall(uint x) public {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (y == x + 2);",
    "critical-invariants": "7+ assert (y == x + 2);",
    "ranks": "7+ assert (y == x + 2);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 20+",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 24+\n32+\n37+",
    "invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "critical-invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "ranks": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 20+",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 24+\n32+\n38+",
    "invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "critical-invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "ranks": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0;\n2 import \"./Libraries/VeriSolContracts.sol\";\n\n\n3 contract LoopFor {\n\n4     int x;\n5     int y;\n",
    "transaction-context": "The transaction context is loop\narithmetics",
    "Critical-points": "Critical program points are 6+\n6+\n19+",
    "invariants": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0); ",
    "critical-invariants": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0);",
    "ranks": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "pragma solidity >=0.4.24 <0.6.0;\n\n//simple library with no internal state\n\nlibrary Lib {\n    function add(uint _a, uint _b) public view returns (uint r) {\n        address x = address(this);       \n        r = _a + _b;\n    }",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 5+\n14+",
    "invariants": "5+ assert(x == msg.sender);\n14+ assert (z == 3);",
    "critical-invariants": "14+ assert (z == 3);",
    "ranks": "14+ assert (z == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n2 import \"./../../Libraries/VeriSolContracts.sol\";\n3 //import \"./VeriSolContracts.sol\";\n4 //import \"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\";\n\n5 contract LoopFor {\n\n6     // test Loop invariant with for loop\n7     constructor(uint n) public {",
    "transaction-context": "The transaction context is loop\narithmetics",
    "Critical-points": "Critical program points are 10+ \n12+ \n19+  \n22+  \n29+ \n32+",
    "invariants": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "critical-invariants": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "ranks": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n\n5 /**\n6  * A highly simplified Token to express basic specifications",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 17+ \n47+ \n66+ ",
    "invariants": "17+ require(msg.sender != address(0));\n47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); \n66+ require(_balances[sender] >= amount);",
    "critical-invariants": "47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "ranks": "47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "vulnerabilities": "incorrect visibility/ownership\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 //SPDX-License-Identifier: MIT\n2 pragma solidity 0.7.5;\n\n3 contract contrived{\n4  function withdraw(uint256 amount) override public nonReentrant updateReward(msg.sender) {  \n5     _totalSupply = _totalSupply - amount;\n6     _balances[msg.sender] = _balances[msg.sender].sub(amount);\n7     stakingToken.safeTransfer(msg.sender, amount);\n",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 4+",
    "invariants": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "critical-invariants": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "ranks": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "vulnerabilities": "integer over/underflow"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error",
    "transaction-context": "The transaction context is ERC\ntokenSale",
    "Critical-points": "Critical program points are 11+  \n20+ \n24+ \n51+   \n51+ \n145+ \n152+  \n168+ \n174+ ",
    "invariants": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);\n",
    "critical-invariants": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);",
    "ranks": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);",
    "vulnerabilities": "integer over/underflow\natomicity violation\nincorrect visibility/ownership"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "The transaction context is asset swapping\n",
    "Critical-points": "Critical program points are 17+ \n21+  \n35+ \n37+",
    "invariants": "17+ require(id < nextPositionID, \"bad position id\");\n17+ require(positions[id].goblin == goblin, \"bad position goblin\");\n17+ require(positions[id].owner == msg.sender, \"not position owner\");\n21+  require(config.isGoblin(goblin), \"not a goblin\");\n21+  require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n35+ require(debt >= config.minDebtSize(), \"too small debt size\");\n37+  require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n",
    "critical-invariants": "17+ require(id < nextPositionID, \"bad position id\");",
    "ranks": "17+ require(id < nextPositionID, \"bad position id\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+\n44+",
    "invariants": "13+  require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "critical-invariants": "44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "ranks": "44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "vulnerabilities": "reentrancy\nbusiness logic flaw"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 124+ \n137+ \n150+  \n171+ \n201+\n233+ \n284+ \n286+\n338+ \n341+\n544+ \n559+  \n576+\n655+ \n678+  \n715+ \n733+\n757+ \n797+ ",
    "invariants": "124+  require(c >= a, \"SafeMath: addition overflow\");\n137+  return sub(a, b, \"SafeMath: subtraction overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n576+  require(account != address(0), \"ERC20: burn from the zero address\");\n595+  require(owner != address(0), \"ERC20: approve from the zero address\");\n595+  require(spender != address(0), \"ERC20: approve to the zero address\");\n655+ require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n678+   require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n715+ require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n733+ require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n757+ require(localCounter == _guardCounter);\n797+ assert(token != address(this)); \n797+ assert(token != user); \n\n",
    "critical-invariants": "124+  require(c >= a, \"SafeMath: addition overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n186+ return div(a, b, \"SafeMath: division by zero\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n797+ assert(token != address(this)); \n797+ assert(token != user); ",
    "ranks": "124+  require(c >= a, \"SafeMath: addition overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n186+ return div(a, b, \"SafeMath: division by zero\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n797+ assert(token != address(this)); \n797+ assert(token != user); ",
    "vulnerabilities": "integer over/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 13+\n23+\n42+",
    "invariants": "13+ require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "critical-invariants": "23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "ranks": "23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "vulnerabilities": "reentrancy \ninteger over/underflow"
  },
  {
    "code": "1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\n\n2 // File contracts/v0.4/token/linkERC20Basic.sol\n\n3 pragma solidity ^0.4.11;\n\n\n4 /**\n5  * @title ERC20Basic",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 88+  \n97+\n101+  ",
    "invariants": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);\n",
    "critical-invariants": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);",
    "ranks": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);",
    "vulnerabilities": "arithmetic flaw\nreentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "The transaction context is cross-function\nmoney market",
    "Critical-points": "Critical program points are 18+  \n33+ \n44+  \n45+  \n61+  \n63+",
    "invariants": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n",
    "critical-invariants": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");",
    "ranks": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 32+  \n89+ ",
    "invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n89+  require(canTransfer, \"E046\");\n",
    "critical-invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "ranks": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n4 import { LibAsset } from \"../Libraries/LibAsset.sol\";\n5 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n6 import { LibSwap } from \"../Libraries/LibSwap.sol\";\n7 import { ICBridge } from \"../Interfaces/ICBridge.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 58+ \n92+  \n101+\n125+  \n191+  ",
    "invariants": "58+ require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n92+  require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n101+ require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n125+  require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n191+  assert(!invokeSwap);",
    "critical-invariants": "191+  assert(!invokeSwap);",
    "ranks": "191+  assert(!invokeSwap);",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 26+",
    "invariants": "26+   assert(_committedRoot != 0); ",
    "critical-invariants": "26+   assert(_committedRoot != 0); ",
    "ranks": "26+   assert(_committedRoot != 0); ",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 29+  \n30+  \n48+  \n51+  \n54+ \n55+ \n83+ \n106+  \n108+\n112+ \n117+  \n118+ \n121+ \n139+ \n143+ \n145+",
    "invariants": "29+  require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n30+  require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\n30+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");\n48+  require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");\n51+  require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");\n54+ require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n55+ require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\n55+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");\n83+ require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\");\n106+  require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n108+  require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n112+  require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n117+  require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n117+ require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n118+  require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n121+  require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n139+ assert(_method != “f1121318093”); \n143+ require(success == true, \"EthCrossChain call business contract failed\");\n145+  require(res == true, \"EthCrossChain call business contract return is not true\");",
    "critical-invariants": "139+ assert(_method != “f1121318093”); \n",
    "ranks": "139+ assert(_method != “f1121318093”); \n",
    "vulnerabilities": "incorrect visibility/ownership\nID uniqueness violation\nbusiness logic flaw\ninconsistent state update"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 43+    \n83+  ",
    "invariants": "43+    require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "critical-invariants": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "ranks": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are nan",
    "invariants": "43+  require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+  require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {x++;}",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (x == a + 1);",
    "critical-invariants": "7+ assert (x == a + 1);",
    "ranks": "7+ assert (x == a + 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // Possible bug:\n3 // In this test, ctor D is NOT called twice -\n4 // Only ctor C is called\n5 // compare with ConstructorChaining2_fail.sol\n\n6 contract D {\n7         uint a;",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 14+",
    "invariants": "14+ assert (a == x + 2);",
    "critical-invariants": "14+ assert (a == x + 2);",
    "ranks": "14+ assert (a == x + 2);",
    "vulnerabilities": "arithmetic flaw"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+  assert (a == 1);",
    "critical-invariants": "7+  assert (a == 1);",
    "ranks": "7+  assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract ArrayNestedFixedSize {\n\n2     // NOTE: the number of columns comes first in the declaration!\n3     uint[3][2] a;\n4     bool[2][2] aa;\n\n5     constructor() {\n6       _;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 20+ \n",
    "invariants": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "critical-invariants": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "ranks": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayFixedSize {\n\n3     uint[2] a;\n\n4     constructor() public {}\n\n5     function test() public {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "critical-invariants": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "ranks": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+",
    "invariants": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);\n9+ assert (sa.length == 2);",
    "critical-invariants": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);",
    "ranks": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);",
    "vulnerabilities": "healthy "
  }
]