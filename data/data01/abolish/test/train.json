[
  {
    "code": "1     function getYvTokenPrice(address token) internal view returns (uint256) {\n2         YvTokenInfo memory yvTokenInfo = yvTokens[token];\n3         require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n4  \n5         uint256 pricePerShare;\n6         address underlying;\n7         if (yvTokenInfo.version == YvTokenVersion.V1) {\n8             pricePerShare = YVaultV1Interface(token).getPricePerFullShare();\n9             underlying = YVaultV1Interface(token).token();",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 3\n11+ ",
    "invariants": "3  require(yvTokenInfo.isYvToken, \"not a Yvault token\"); \n11+ assert(pricePerShare <= k*Old(pricePerShare));",
    "critical-invariants": "11+ assert(pricePerShare <= k*Old(pricePerShare));",
    "ranks": "11+ assert(pricePerShare <= k*Old(pricePerShare));",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (b[1] == 22);",
    "critical-invariants": "7+ assert (b[1] == 22);",
    "ranks": "7+ assert (b[1] == 22);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.12;\n3 pragma experimental ABIEncoderV2;\n4 \n5 \n6 \n7 contract PancakeSwap is IStrategy, RewardsDistributionRecipient, ReentrancyGuard, Pausable {\n8     using SafeMath for uint256;\n9     using SafeBEP20 for IBEP20;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 47+\n181+ \n",
    "invariants": "47+ assert(Old(stakingToken.balanceOf(msg.sender)) == stakingToken.balanceOf(msg.sender));\n181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");",
    "ranks": "181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+",
    "invariants": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);\n9+ assert (sa.length == 2);",
    "critical-invariants": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);",
    "ranks": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "onlyOwner",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": "require(_newOwner != address(0), \"\"Curve/new-owner-cannot-be-zeroth-address\"\");",
    "ranks": "noDelegateCall isNotEmergency nonReentrant",
    "vulnerabilities": "require(targetAmount_ >= _minTargetAmount, \"\"Curve/below-min-target-amount\"\");"
  },
  {
    "code": "1 pragma solidity 0.6.9;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import {Types} from \"./lib/Types.sol\";\n5 import {IERC20} from \"./intf/IERC20.sol\";\n6 import {Storage} from \"./impl/Storage.sol\";\n7 import {Trader} from \"./impl/Trader.sol\";\n8 import {LiquidityProvider} from \"./impl/LiquidityProvider.sol\";\n9 import {Admin} from \"./impl/Admin.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 32",
    "invariants": "32 require(!_INITIALIZED_, \"DODO_INITIALIZED\");",
    "critical-invariants": "32 require(!_INITIALIZED_, \"DODO_INITIALIZED\");",
    "ranks": "32 require(!_INITIALIZED_, \"DODO_INITIALIZED\");",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n6 import \"./interfaces/IStakingBank.sol\";\n7 import \"./BaseChain.sol\";\n",
    "transaction-context": "The transaction context is cross bridge\nfunds transfer",
    "Critical-points": "Critical program points are 74+ \n76+ \n94+",
    "invariants": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp + padding < block.timestamp, \"do not spam\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "critical-invariants": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "ranks": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "vulnerabilities": "integer over/underflow\nincorrect visibility/ownership\narithmetic flaw"
  },
  {
    "code": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);",
    "transaction-context": "assert(Old(reserve0) == reserve0 + amount0);\nassert(Old(reserve1) == reserve1+ amount1);",
    "Critical-points": "assert(msg.sender != 0);",
    "invariants": " assert(Old(abi.encode(admin)) == abi.encode(admin)); ",
    "critical-invariants": "assert(Old(abi.encode(implementation)) == abi.encode(implementation));",
    "ranks": "assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));",
    "vulnerabilities": "assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));"
  },
  {
    "code": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "assert (b[1] == 22);",
    "Critical-points": " assert(b != c);",
    "invariants": "assert (a == 1);",
    "critical-invariants": "require(amount > 0, \"Invalid amount\");",
    "ranks": "require(supply[id] == 0, \"Repeated mint for the same FNFT\");",
    "vulnerabilities": "require(canTransfer, \"E046\");"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 226\n231+\n254\n322\n323\n360\n361\n379\n380\n406\n407\n416\n429 \n439",
    "invariants": "226 require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n231+ assert(pricePerShare <= k*Old(pricePerShare));\n254 require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n322 require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323 require(tokenAddresses.length == quotes.length, \"mismatched data\");\n329 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n360 require(msg.sender == admin, \"only the admin may set LPs\");\n361 require(tokenAddresses.length == isLP.length, \"mismatched data\");\n379 require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n380 require(tokenAddresses.length == version.length, \"mismatched data\");\n406 require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n407  require(\n               tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\"         );\n416 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");\n429 require(msg.sender == admin, \"only the admin may set new guardian\");\n439 require(msg.sender == admin, \"only the admin may set new admin\");",
    "critical-invariants": "231+ assert(pricePerShare <= k*Old(pricePerShare));\n254 require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n322 require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323 require(tokenAddresses.length == quotes.length, \"mismatched data\");\n329 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n360 require(msg.sender == admin, \"only the admin may set LPs\");\n379 require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n406 require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n429 require(msg.sender == admin, \"only the admin may set new guardian\");\n439 require(msg.sender == admin, \"only the admin may set new admin\");\n407  require(\n               tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\"         );\n416 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");",
    "ranks": "231+ assert(pricePerShare <= k*Old(pricePerShare));\n254 require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n322 require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323 require(tokenAddresses.length == quotes.length, \"mismatched data\");\n329 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n360 require(msg.sender == admin, \"only the admin may set LPs\");\n379 require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n406 require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n429 require(msg.sender == admin, \"only the admin may set new guardian\");\n439 require(msg.sender == admin, \"only the admin may set new admin\");\n407  require(\n               tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\"         );\n416 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 8+ \n10+  \n11+ \n",
    "invariants": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);\n",
    "critical-invariants": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);",
    "ranks": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4 contract testlock {\n5             \n6          function test_lock(\n7                  uint lock,\n8                  uint newLock,\n9                  uint amount",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 12+ \n",
    "invariants": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "critical-invariants": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "ranks": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract overflow{\n5     function transferProxy (address from, address to, uint\n6     value, uint fee) {  \n7         if (balance[from] < fee + value) revert();\n8 \n9         if (balance[to] + value < balance[to] ||",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 6+",
    "invariants": "6+  assert(fee + value != 0);\n",
    "critical-invariants": "6+  assert(fee + value != 0);",
    "ranks": "6+  assert(fee + value != 0);",
    "vulnerabilities": "integer overflow/underflow"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "assert (c == x + 6); ",
    "Critical-points": "assert(funcA2(funcA1())==12);",
    "invariants": " assert(funcA3().funcB()==42);",
    "critical-invariants": "require(msg.sender != address(0));",
    "ranks": " _transfer(msg.sender, recipient, amount);",
    "vulnerabilities": "assert (_balances[msg.sender] + _balances[recipient]) == _balances[msg.sender] + _balances[recipient];"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3   contract Swap {\n4           IERC20 public WEI;\n5           IERC20 public USD;\n6           IUniswapV2Pair public pair; \n7           mapping(address => uint) public debt;\n8           mapping(address => uint) public collateral;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 8+ \n16+\n",
    "invariants": "8+ assert(Old(getPrice())==getPrice());\n16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "ranks": "16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "vulnerabilities": "price manipulation\ninconsistent state update"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../ERC1967/ERC1967Proxy.sol\";\n\n5 interface ITransparentUpgradeableProxy {\n6     event Upgraded(address indexed implementation);",
    "transaction-context": "assert(Old(newImplementation) == abi.decode(msg.data[4:], (address)));",
    "Critical-points": "assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\nassert(Old(newAdmin) != Old(newImplementation)); ",
    "invariants": "assert(signatures.length ==calldatas.length);\n",
    "critical-invariants": "assert(signatures.length ==calldatas.length);\n",
    "ranks": "assert(signatures.length ==calldatas.length);\n",
    "vulnerabilities": "assert(signatures.length ==calldatas.length);"
  },
  {
    "code": "1 pragma solidity ^0.5.2;\n\n2 // Tests that function with inline assembly generates non-det result\n3 contract AssemblyTest\n4 {\n5         bool b;\n6         int x;\n7     constructor () public {\n8   }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 12+ ",
    "invariants": "12+ assert(false);",
    "critical-invariants": "12+ assert(false);",
    "ranks": "12+ assert(false);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "assert (sa.length == 2);",
    "Critical-points": "assert(a[0] == 1);",
    "invariants": "assert(a[1] == 2);",
    "critical-invariants": "assert (b[1] == 22);",
    "ranks": "assert (a[0][1] == 0);",
    "vulnerabilities": "assert (!aa[0][1]);"
  },
  {
    "code": "1 // SPDX-License-Identifier: UNLICENSED\n2 pragma solidity =0.8.7;\n\n3 import \"./interfaces/ICollateral.sol\";\n4 import \"./interfaces/IStrategyController.sol\";\n5 import \"./interfaces/IHook.sol\";\n6 import \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n7 import \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";",
    "transaction-context": "The transaction context is liquidity pool",
    "Critical-points": "Critical program points are 286+ ",
    "invariants": "286+ assert(totalAssets != 0);",
    "critical-invariants": "286+ assert(totalAssets != 0);",
    "ranks": "286+ assert(totalAssets != 0);",
    "vulnerabilities": "business logic flaw;\nether leakage; "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {x++;}",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (x == a + 1);",
    "critical-invariants": "7+ assert (x == a + 1);",
    "ranks": "7+ assert (x == a + 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');",
    "Critical-points": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');",
    "invariants": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');",
    "critical-invariants": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');",
    "ranks": "require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');",
    "vulnerabilities": "modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );",
    "Critical-points": "require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");",
    "invariants": "require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");",
    "critical-invariants": "require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");",
    "ranks": " require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");",
    "vulnerabilities": " require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");"
  },
  {
    "code": "1 pragma solidity ^0.4.25;\n\n2 library SafeMath {\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     uint256 c = a * b;\n5     return c;\n6   }\n\n7   function div(uint256 a, uint256 b) internal pure returns (uint256) {",
    "transaction-context": "require(_to != address(0));",
    "Critical-points": "require(_value <= balances[msg.sender]);",
    "invariants": "require(_to != address(0));",
    "critical-invariants": "require(_value <= balances[_from]);",
    "ranks": "require(_value <= allowed[_from][msg.sender]);",
    "vulnerabilities": "require((_value == 0) || (allowed[msg.sender][_spender] == 0));"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n2 import \"./../../Libraries/VeriSolContracts.sol\";\n3 //import \"./VeriSolContracts.sol\";\n4 //import \"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\";\n\n5 contract LoopFor {\n\n6     // test Loop invariant with for loop\n7     constructor(uint n) public {",
    "transaction-context": "The transaction context is loop\narithmetics",
    "Critical-points": "Critical program points are 10+ \n12+ \n19+  \n22+  \n29+ \n32+",
    "invariants": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "critical-invariants": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "ranks": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n2 import \"./../../Libraries/VeriSolContracts.sol\";\n3 //import \"./VeriSolContracts.sol\";\n4 //import \"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\";\n\n5 contract LoopFor {\n\n6     // test Loop invariant with for loop\n7     constructor(uint n) public {",
    "transaction-context": "assert(x + y == n);",
    "Critical-points": "assert (y == n);",
    "invariants": " require(msg.sender != address(0));",
    "critical-invariants": "assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "ranks": "require(_balances[sender] >= amount);",
    "vulnerabilities": "require(amount > 0, \"Cannot withdraw 0\");"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 library Math {\n    \n3     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4         if (a == 0) {\n5             return 0;\n6         }",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 8+\n15+\n20+",
    "invariants": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "critical-invariants": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "ranks": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "assert (a[0][0] == 0 || a[0][0] == 3);",
    "Critical-points": "assert (a[0][1] == 1);",
    "invariants": "assert (a[0][2] == 2);",
    "critical-invariants": "assert (a[1][0] == 3);",
    "ranks": "assert (a[1][1] == 4);",
    "vulnerabilities": "assert (a[1][2] == 5);"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3 contract etherleakge{\n4    function payout(address[] recipients,\n5                 uint256[] amounts) {\n6       require(recipients.length==amounts.length);\n7       for (uint i = 0; i < recipients.length; i++) {\n",
    "transaction-context": "The transaction context is payment ",
    "Critical-points": "Critical program points are 6+ ",
    "invariants": "6+ assert(msg.sender != 0);",
    "critical-invariants": "assert(msg.sender != 0);",
    "ranks": "assert(msg.sender != 0);",
    "vulnerabilities": "ether leakage"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 43+    \n83+  ",
    "invariants": "43+    require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "critical-invariants": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "ranks": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 9+  \n17+ \n18+ ",
    "invariants": "9+  assert(_merkleRoot != 0);\n17+ assert(_msgHash != 0);\n18+ assert(_root != 0);",
    "critical-invariants": "17+ assert(_msgHash != 0);\n",
    "ranks": "9+ assert(_merkleRoot != 0); \n17+ assert(_msgHash != 0); ",
    "vulnerabilities": "cross bridge\nID Uniqueness violation"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-05-09\n3 */\n\n4 pragma solidity ^0.4.21;\n\n\n5 /**\n6  * @title SafeMath",
    "transaction-context": "assert(b <= a);",
    "Critical-points": "assert(c >= a);",
    "invariants": "require(_to != address(0));",
    "critical-invariants": "require(_value <= balances[msg.sender]);",
    "ranks": "require(balanceOf[msg.sender] >= _value);\n",
    "vulnerabilities": "require(balanceOf[_from] >= _value);"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": " require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": " onlyOwner",
    "ranks": "onlyOwner",
    "vulnerabilities": "onlyOwner"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4  contract Lottery {\n5 \n6          mapping (address => mapping(uint64 => uint))\n7          public tickets;\n8          uint64 winningId; \n9          bool drawingPhase; ",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 17+ \n35+ \n",
    "invariants": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "critical-invariants": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "ranks": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "vulnerabilities": "atomicity violation"
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0;\n2 import \"./Libraries/VeriSolContracts.sol\";\n\n\n3 contract LoopFor {\n\n4     int x;\n5     int y;\n",
    "transaction-context": "The transaction context is loop\narithmetics",
    "Critical-points": "Critical program points are 6+\n6+\n19+",
    "invariants": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0); ",
    "critical-invariants": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0);",
    "ranks": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.6.0;\n2 pragma experimental ABIEncoderV2;\n\n3 import \"@openzeppelin/contracts/utils/Address.sol\";\n4 import \"./UniswapPCVDeposit.sol\";\n\n5 /// @title implementation for an ETH Uniswap LP PCV Deposit\n6 /// @author Fei Protocol\n7 contract EthUniswapPCVDeposit is UniswapPCVDeposit {",
    "transaction-context": " require(\n             ethAmount == msg.value,\n             \"Bonding Curve: Sent value does not equal input\"\n         );\n",
    "Critical-points": "assert(ethAmount <= k*Old(ethAmount)); ",
    "invariants": "assert(feiAmount <= k*Old(feiAmount)); ",
    "critical-invariants": "require(auctionStarted, \"Auction has not yet started\");",
    "ranks": " require(!auctionEnded, \"Auction has been finished\");",
    "vulnerabilities": "require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "require(auctionEnded, \"Please end the auction firstly\");",
    "Critical-points": "require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");",
    "invariants": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "critical-invariants": " require(success, \"Failed to withdraw funds.\");",
    "ranks": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "vulnerabilities": "require(success, \"Failed to withdraw funds.\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "The transaction context is asset swapping\n",
    "Critical-points": "Critical program points are 17+ \n21+  \n35+ \n37+",
    "invariants": "17+ require(id < nextPositionID, \"bad position id\");\n17+ require(positions[id].goblin == goblin, \"bad position goblin\");\n17+ require(positions[id].owner == msg.sender, \"not position owner\");\n21+  require(config.isGoblin(goblin), \"not a goblin\");\n21+  require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n35+ require(debt >= config.minDebtSize(), \"too small debt size\");\n37+  require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n",
    "critical-invariants": "17+ require(id < nextPositionID, \"bad position id\");",
    "ranks": "17+ require(id < nextPositionID, \"bad position id\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.0;\n3 \n4 contract WUSDMaster is Ownable, Withdrawable, ReentrancyGuard {\n5     using SafeERC20 for IERC20;\n6     \n7     IWUSD public immutable wusd;\n8     IERC20 public usdt;\n9     IERC20 public wex;",
    "transaction-context": "assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n",
    "Critical-points": "assert(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *2);\n",
    "invariants": "assert(Old(stakingToken.balanceOf(msg.sender)) == stakingToken.balanceOf(msg.sender));",
    "critical-invariants": "assert(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *2);\n\n",
    "ranks": "require(!drawingPhase, \"drawing\");\n",
    "vulnerabilities": "require(!drawingPhase, \"drawing\");\n"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "The transaction context is bidding",
    "Critical-points": "Critical program points are 104+ \n104+  \n104+  \n104+  \n106   \n116+  \n116+  \n116+  \n127+ \n140+  \n144+ \n146    \n150 \n152   \n154   \n158    \n159   \n161  ",
    "invariants": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n106    require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n146    require(success, \"Failed to withdraw funds.\");\n150    require(success, \"Failed to withdraw funds.\");\n152    onlyOwner \n154    require(success, \"Failed to withdraw funds.\");\n158    require(totalBid > 0, \"Nothing to withdraw\");\n159   require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n161  require(success, \"Failed to withdraw funds.\");\n",
    "critical-invariants": "152    onlyOwner \n104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n",
    "ranks": "152    onlyOwner \n104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n",
    "vulnerabilities": "atomicity violation\nincorrect ownership/visibility"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": " require(success, \"Failed to withdraw funds.\");",
    "Critical-points": "onlyOwner",
    "invariants": "require(success, \"Failed to withdraw funds.\");",
    "critical-invariants": "require(totalBid > 0, \"Nothing to withdraw\");",
    "ranks": " require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");",
    "vulnerabilities": " require(success, \"Failed to withdraw funds.\");"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n3 \n4  contract Swap {\n5          IERC20 public WEI;\n6          IERC20 public USD;\n7          IUniswapV2Pair public pair; \n8          mapping(address => uint) public debt;\n9          mapping(address => uint) public collateral;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 13+\n23+\n",
    "invariants": "13+ assert(Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair))) == USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)));\n23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n",
    "critical-invariants": "23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n",
    "ranks": "23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "assert(msg.sender == wNATIVE);",
    "Critical-points": "modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }",
    "invariants": "onlyMPC",
    "critical-invariants": "require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");",
    "ranks": " onlyMPC",
    "vulnerabilities": "require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 25+  \n34+  \n40+ \n41+    \n42+",
    "invariants": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "critical-invariants": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "ranks": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;",
    "transaction-context": "assert (a[0] == 0);",
    "Critical-points": "assert (a[1] == 1);",
    "invariants": "assert (b[j] == j);",
    "critical-invariants": "assert (sa.length == 0);",
    "ranks": "assert (sa[0] == 10);",
    "vulnerabilities": " assert (sa[1] == 11);"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 \n4 import \"./token/ERC677.sol\";\n5 import \"./token/ERC677Receiver.sol\";\n6 \n7 \n8 contract ERC677Token is ERC677 {\n9 ",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 44+ \n50+ \n\n",
    "invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "critical-invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "ranks": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "vulnerabilities": "atomicity violation "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "onlyOwner",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": "onlyOwner",
    "ranks": "onlyOwner",
    "vulnerabilities": " require(isPoolActive,'Contract is not running yet');"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "require(shares > 0, \"shares\");",
    "Critical-points": "require(to != address(0), \"to\");",
    "invariants": "require(from != address(0), \"from\");",
    "critical-invariants": "assert(a == 0 || c / a == b);",
    "ranks": "assert(b <= a);",
    "vulnerabilities": "assert(c >= a);"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n\n2 contract ERC20Interface {\n3     function totalSupply() public view returns (uint);\n4     function balanceOf(address tokenOwner) public view returns (uint balance);\n5     function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n6     function transfer(address to, uint tokens) public returns (bool success);\n7     function approve(address spender, uint tokens) public returns (bool success);",
    "transaction-context": "require(b <= a);",
    "Critical-points": " require(a == 0 || c / a == b);",
    "invariants": "assert(balances[msg.sender] >= _value);\n assert( _value > 0); ",
    "critical-invariants": "require(_to != address(0));\nrequire(_value <= balances[msg.sender]);",
    "ranks": "require(msg.sender == owner);",
    "vulnerabilities": "require(msg.sender == owner || msg.sender == operator); "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Arithmetics {\n\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\n4         c = _a + _b;\n      \n5     }\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 4+ \n7+ \n10+ \n13+ ",
    "invariants": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "critical-invariants": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "ranks": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "vulnerabilities": "arithmetic flaw \ninteger overflow/underflow\n"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"\"Curve/whitelist-stage-on-going\"\");\n        }",
    "Critical-points": "modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"\"Curve/frozen-globally-only-allowing-proportional-withdraw\"\");\n              _;\n     }",
    "invariants": "modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"\"Curve/flashloans-paused\"\");\n            _;\n   }",
    "critical-invariants": "onlyOwner\n",
    "ranks": "onlyOwner",
    "vulnerabilities": "onlyOwner "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Arithmetics {\n\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\n4         c = _a + _b;\n      \n5     }\n",
    "transaction-context": "assert (c == _a * _b);",
    "Critical-points": "assert (c == _a / _b);",
    "invariants": "assert(finished = true);",
    "critical-invariants": "assert(canceled = true); ",
    "ranks": " assert(!(finished && canceled)); ",
    "vulnerabilities": "require(lockDev == false);"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n3 import \"./ERC3156FlashLenderInterface.sol\";\n4 import \"./ERC3156FlashBorrowerInterface.sol\";\n\n5 /**\n6  * @title Cream's CCollateralCapErc20 Contract\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap",
    "transaction-context": " require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");",
    "Critical-points": "require(err == 0, \"mint failed\");",
    "invariants": "require(redeemInternal(redeemTokens, false) == 0, \"redeem failed\");",
    "critical-invariants": "require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");",
    "ranks": "require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");",
    "vulnerabilities": "require(err == 0, \"repay failed\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../../utils/math/SafeCast.sol\";\n5 import \"../extensions/IGovernorTimelock.sol\";\n6 import \"../Governor.sol\";\n7 import \"./IGovernorCompatibilityBravo.sol\";",
    "transaction-context": "The transaction context is protocol\nvoting ",
    "Critical-points": "Critical program points are 36+ ",
    "invariants": "36+ assert(signatures.length ==calldatas.length);",
    "critical-invariants": "assert(signatures.length ==calldatas.length);",
    "ranks": "assert(signatures.length ==calldatas.length);",
    "vulnerabilities": "insufficient gas"
  },
  {
    "code": "1 // SPDX-License-Identifier: BSD-3-Clause\n2 pragma solidity ^0.8.10;\n\n3 import \"./ComptrollerInterface.sol\";\n4 import \"./CTokenInterfaces.sol\";\n5 import \"./ErrorReporter.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./InterestRateModel.sol\";\n8 import \"./ExponentialNoError.sol\";",
    "transaction-context": "nonReentrant",
    "Critical-points": "nonReentrant ",
    "invariants": "nonReentrant",
    "critical-invariants": "assert(totalAssets != 0);",
    "ranks": "require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");",
    "vulnerabilities": "assert(usdcAmount <= Old(usdcAmount)*k));"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 contract ModifierEntrancy {\n\n3   mapping (address => uint) public tokenBalance;\n4   string constant name = \"Nu Token\";\n5   Bank bank;\n  \n6   constructor() public{",
    "transaction-context": "require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "Critical-points": "require(tokenBalance[msg.sender] == 0);",
    "invariants": "require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
    "critical-invariants": "require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');",
    "ranks": "require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "vulnerabilities": "require(id < nextPositionID, \"bad position id\");"
  },
  {
    "code": "1 pragma solidity ^0.4.16;\n \n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n \n3 contract TokenERC20 {\n4     string public name;\n5     string public symbol;\n6     uint8 public decimals = 18;  // 18 \n7     uint256 public totalSupply;",
    "transaction-context": "require(_value <= allowance[_from][msg.sender]);",
    "Critical-points": "require(c >= a);",
    "invariants": "require(b <= a);",
    "critical-invariants": "require(a == 0 || c / a == b);",
    "ranks": "require(b > 0);",
    "vulnerabilities": "require (d[1] == 5);\n"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;",
    "transaction-context": "The transaction context is loop\ncross function",
    "Critical-points": "Critical program points are 8+ \n9+\n18+ \n",
    "invariants": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);\n",
    "critical-invariants": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);",
    "ranks": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\n\n2 // File contracts/v0.4/token/linkERC20Basic.sol\n\n3 pragma solidity ^0.4.11;\n\n\n4 /**\n5  * @title ERC20Basic",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 88+  \n97+\n101+  ",
    "invariants": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);\n",
    "critical-invariants": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);",
    "ranks": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);",
    "vulnerabilities": "arithmetic flaw\nreentrancy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n22+  \n23+  \n24+\n25+ \n26+  \n27+ ",
    "invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);\n",
    "critical-invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "ranks": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+ \n13+ ",
    "invariants": "9+ assert (a == 1 || a == 2);\n13+ assert (a == 1 || a == 2);",
    "critical-invariants": "13+ assert (a == 1 || a == 2);",
    "ranks": "13+ assert (a == 1 || a == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 //simple library with no internal state\n\n3 library Lib {\n4     function add(uint _a, uint _b) public view returns (uint r) {\n5         address x = address(this);\n6         assert(x == msg.sender);\n7         r = _a + _b;",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 6+\n16+",
    "invariants": "6+ assert(x == msg.sender);\n16+ assert (z == 3);",
    "critical-invariants": "16+ assert (z == 3);",
    "ranks": "16+ assert (z == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 124+ \n137+ \n150+  \n171+ \n201+\n233+ \n284+ \n286+\n338+ \n341+\n544+ \n559+  \n576+\n655+ \n678+  \n715+ \n733+\n757+ \n797+ ",
    "invariants": "124+  require(c >= a, \"SafeMath: addition overflow\");\n137+  return sub(a, b, \"SafeMath: subtraction overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n576+  require(account != address(0), \"ERC20: burn from the zero address\");\n595+  require(owner != address(0), \"ERC20: approve from the zero address\");\n595+  require(spender != address(0), \"ERC20: approve to the zero address\");\n655+ require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n678+   require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n715+ require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n733+ require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n757+ require(localCounter == _guardCounter);\n797+ assert(token != address(this)); \n797+ assert(token != user); \n\n",
    "critical-invariants": "124+  require(c >= a, \"SafeMath: addition overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n186+ return div(a, b, \"SafeMath: division by zero\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n797+ assert(token != address(this)); \n797+ assert(token != user); ",
    "ranks": "124+  require(c >= a, \"SafeMath: addition overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n186+ return div(a, b, \"SafeMath: division by zero\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n797+ assert(token != address(this)); \n797+ assert(token != user); ",
    "vulnerabilities": "integer over/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "1 pragma solidity ^0.4.25;\n\n2 library SafeMath {\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     uint256 c = a * b;\n5     return c;\n6   }\n\n7   function div(uint256 a, uint256 b) internal pure returns (uint256) {",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 4+ \n7+ \n11+  \n15+ \n19+  \n27+ \n47+ \n48+ \n72+ \n73+\n74+\n82+",
    "invariants": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n19+  assert(uint112(a) == a);\n27+ assert(uint128(a) == a);\n47+ require(_to != address(0));\n48+ require(_value <= balances[msg.sender]);\n72+ require(_to != address(0));\n73+ require(_value <= balances[_from]);\n74+ require(_value <= allowed[_from][msg.sender]);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "critical-invariants": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "ranks": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "vulnerabilities": "arithmetic flaw\ninteger over/underflow"
  },
  {
    "code": "1  contract PoolCurve{\n2 \n3    /// @notice sets the parameters for the pool\n4     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n5     /// @param _beta the value for beta must be less than alpha and greater than 0\n6     /// @param _feeAtHalt the maximum value for the fee at the halt point\n7     /// @param _epsilon the base fee for the pool\n8     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n9     function setParams(",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 1+ \n9 \n21 \n30 \n36 \n42 \n48 ",
    "invariants": "1+ modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n9 onlyOwner\n21 onlyOwner\n30 onlyOwner\n36 onlyOwner\n42 onlyOwner\n48 onlyOwner",
    "critical-invariants": "1+ modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n9 onlyOwner\n21 onlyOwner\n30 onlyOwner\n36 onlyOwner\n42 onlyOwner\n48 onlyOwner",
    "ranks": "1+ modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n9 onlyOwner\n21 onlyOwner\n30 onlyOwner\n36 onlyOwner\n42 onlyOwner\n48 onlyOwner",
    "vulnerabilities": "incorrect visibility/ownership"
  },
  {
    "code": "1 contract Example {\n2     function flash(\n3         address recipient,\n4         uint256 amount0,\n5         uint256 amount1,\n6         bytes calldata data\n7     ) external isFlashable globallyTransactable transactable isNotEmergency {\n8         uint256 fee = curve.epsilon.mulu(1e18);\n9         ",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are 1+ \n7 \n8+\n9+ \n22+ \n23+ ",
    "invariants": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "critical-invariants": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "ranks": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "vulnerabilities": "money market"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4 contract testlock {\n5             \n6          function test_lock(\n7                  uint lock,\n8                  uint newLock,\n9                  uint amount",
    "transaction-context": "require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "Critical-points": "assert(Old(reserve0) == reserve0);\nassert(Old(reserve1) == reserve1);",
    "invariants": "assert(Old(reserve0) == reserve0 + amount0);\n assert(Old(reserve1) == reserve1+ amount1);",
    "critical-invariants": "require(proposal.sTime == 0, \"on-going proposal\");\n",
    "ranks": " require(proposal.sTime + 2 days > block.timestamp,\n \"voting has ended\");\n",
    "vulnerabilities": " assert(Old(votingToken.balanceOf(address(this))) ==votingToken.balanceOf(address(this)));\n"
  },
  {
    "code": "1 // array variable copy breaks\n\n2 contract ArrayLength {\n3     uint[12] a;\n\n4     constructor (uint[12] memory d) public\n5     {\n6         require (d[1] == 5);\n7         a = d;       ",
    "transaction-context": "assert (d[1] == 5);",
    "Critical-points": "assert (a[0][1] == 0);",
    "invariants": "assert (!aa[0][1]);",
    "critical-invariants": "assert (a[0][0] == 0 || a[0][0] == 3);",
    "ranks": "assert (a[0][1] == 1);",
    "vulnerabilities": "assert (a[0][2] == 2);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 8+",
    "invariants": "8+  assert (x == a + 1);",
    "critical-invariants": "8+  assert (x == a + 1);",
    "ranks": "8+  assert (x == a + 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n\n6 import \"./interfaces/IStakingBank.sol\";\n",
    "transaction-context": "require(uint224(_values[i]) == _values[i], \"FCD overflow\");",
    "Critical-points": "require(prevSigner < signer, \"validator included more than once\");",
    "invariants": "require(i >= requiredSignatures, \"not enough signatures\");",
    "critical-invariants": "modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}",
    "ranks": " require(_amount > 0, \"!deposit zero\");",
    "vulnerabilities": "require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");"
  },
  {
    "code": "1 pragma solidity ^0.4.21;\n\n2 library SafeMath {\n\n\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     if (a == 0) {\n5       return 0;\n6     }",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 8+    \n15+    \n20+    \n44+     \n45+    ",
    "invariants": "8+     assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n44+    require(_to != address(0));\n45+     require(_value <= balances[msg.sender]);",
    "critical-invariants": "8+    assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n",
    "ranks": "8+    assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract SafeMath {\n\n2     function safeAdd(uint a, uint b) public pure returns (uint c) {\n3         c = a + b;\n4         require(c >= a);\n5     }\n\n6     function safeSub(uint a, uint b) public pure returns (uint c) {\n7         require(b <= a);",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 4+ \n7+ \n12+ \n15+ ",
    "invariants": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "critical-invariants": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "ranks": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "require(_depositId >= 0, \"Value is not specified\");",
    "Critical-points": "require(pending > 0 ,\"No rewards to claim.\");",
    "invariants": "onlyRunnerScript",
    "critical-invariants": " require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");",
    "ranks": "require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");",
    "vulnerabilities": "require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       (a,  b) = (1, 3);\n  ",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n9+ \n\n",
    "invariants": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);\n",
    "critical-invariants": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);",
    "ranks": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma experimental ABIEncoderV2;\n3 pragma solidity 0.6.12;\n\n4 import \"./ParaToken.sol\";\n5 import \"./interfaces/IERC20.sol\";\n6 import \"./libraries/SafeERC20.sol\";\n7 import \"./libraries/EnumerableSet.sol\";\n8 import \"./libraries/SafeMath_para.sol\";",
    "transaction-context": "require(path[0] == tokens[0] || path[0] == tokens[1], \"invalid path_0\");",
    "Critical-points": " assert (y == x + 2);",
    "invariants": "assert(funcA2(funcA1())==12);\nassert(funcA3().funcB()==42);",
    "critical-invariants": "assert(a == x + 1);\n",
    "ranks": " assert(a == x);",
    "vulnerabilities": "assert (a == x + 4);  \nassert (b == x + 4);  \nassert (c == x + 6);"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 26+",
    "invariants": "26+   assert(_committedRoot != 0); ",
    "critical-invariants": "26+   assert(_committedRoot != 0); ",
    "ranks": "26+   assert(_committedRoot != 0); ",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 contract DODO {\n2     function init(\n3         address maintainer,\n4         address baseTokenAddress,\n5         address quoteTokenAddress,\n6         uint256 lpFeeRate,\n7         uint256 mtFeeRate,\n8         uint256 k,\n9         uint256 i,",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 1+\n11\n12\n16 \n19 ",
    "invariants": "1+ modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n11 nonReentrant\n12 require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n16 require(i > 0 && i <= 10**36);      \n19 require(k <= 10**18); ",
    "critical-invariants": "1+ modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n11 nonReentrant\n12 require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");",
    "ranks": "1+ modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n11 nonReentrant\n12 require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");",
    "vulnerabilities": "reeentrancy\nprice manipulation\nbusiness logic flaw"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": " assert (a == 4);\n assert (b == 40);",
    "Critical-points": "assert (a == 5);\nassert (b == 55);",
    "invariants": "assert (x == a + 1);",
    "critical-invariants": "assert (x == a + 2);",
    "ranks": "  assert (a == 1);",
    "vulnerabilities": "assert (x == a + 2);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract MappingNested {\n\n3     mapping (uint => mapping (uint => uint)) m;\n4     mapping (uint => uint[]) n;\n5     uint[] p;\n  \n",
    "transaction-context": "assert (m[10][20] == 11); ",
    "Critical-points": "assert (m[20][10] == 21);",
    "invariants": "assert (n[0].length == 0);",
    "critical-invariants": "assert (n[0].length == 2);",
    "ranks": " assert (n[1].length == 0); ",
    "vulnerabilities": "assert (p.length == 0);"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "The transaction context is bidding",
    "Critical-points": "Critical program points are 104+ \n104+  \n104+  \n104+  \n106   \n116+  \n116+  \n116+  \n127+ \n140+  \n144+ \n146    \n150    \n154   \n158    \n159   \n161  ",
    "invariants": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n106    require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n146    require(success, \"Failed to withdraw funds.\");\n150    require(success, \"Failed to withdraw funds.\");\n154    require(success, \"Failed to withdraw funds.\");\n158    require(totalBid > 0, \"Nothing to withdraw\");\n159   require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n161  require(success, \"Failed to withdraw funds.\");\n",
    "critical-invariants": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n\n",
    "ranks": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n\n",
    "vulnerabilities": "atomicity violation"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n\n3 /**\n4  * @title Compound's CErc20 Contract\n5  * @notice CTokens which wrap an EIP-20 underlying\n6  * @author Compound\n7  */",
    "transaction-context": "require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");",
    "Critical-points": "require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");",
    "invariants": "require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");",
    "critical-invariants": "require(comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens) == 0, \"comptroller rejection\");",
    "ranks": "require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");",
    "vulnerabilities": "require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");"
  },
  {
    "code": "\n1 pragma solidity ^0.4.2;\n2 contract owned {\n3     address public owner;\n\n4     function owned() {\n5         owner = msg.sender;\n6     }\n",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 7+\n125+ \n131+",
    "invariants": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount );",
    "critical-invariants": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount ) ",
    "ranks": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount ) ",
    "vulnerabilities": "integer overflow/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "noDelegateCall",
    "Critical-points": "notInWhitelistingStage",
    "invariants": " isNotEmergency\n",
    "critical-invariants": "globallyTransactable transactable",
    "ranks": "nonReentrant",
    "vulnerabilities": "noDelegateCall"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 5+ \n10+ \n11+ \n12+  ",
    "invariants": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "critical-invariants": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "ranks": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+ ",
    "invariants": "10+ assert(b != c);",
    "critical-invariants": "10+ assert(b != c);",
    "ranks": "10+ assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 13+\n23+\n42+",
    "invariants": "13+ require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "critical-invariants": "23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "ranks": "23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "vulnerabilities": "reentrancy \ninteger over/underflow"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 20+",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n3 import \"./ERC3156FlashLenderInterface.sol\";\n4 import \"./ERC3156FlashBorrowerInterface.sol\";\n\n5 /**\n6  * @title Cream's CCollateralCapErc20 Contract\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap",
    "transaction-context": "require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");",
    "Critical-points": "require(msg.sender == address(comptroller), \"comptroller only\");",
    "invariants": "require(msg.sender == address(comptroller), \"comptroller only\");",
    "critical-invariants": "require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");",
    "ranks": "require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");",
    "vulnerabilities": "require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+  ",
    "invariants": "10+  assert(b != c);",
    "critical-invariants": "10+  assert(b != c);",
    "ranks": "10+  assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract Vote {\n2    struct Proposal {\n3       uint160 sTime; address newOwner;\n4  }\n5   IERC20 votingToken;\n6   IERC20 LockedToken;\n7   address owner;\n8   Proposal proposal;\n",
    "transaction-context": "require(proposal.sTime != 0, \"no proposal\");",
    "Critical-points": "require(proposal.sTime + 2 days < block.timestamp, \"voting has not ended\");",
    "invariants": "require(votingToken.balanceOf(address(this))*2 >votingToken.totalSupply(), \"vote failed\");\n",
    "critical-invariants": "assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "require(winningId == 0, \"already drawn\");\n",
    "vulnerabilities": "require(!drawingPhase, \"drawing\")"
  },
  {
    "code": "1 contract ArrayNestedFixedSize {\n\n2     // NOTE: the number of columns comes first in the declaration!\n3     uint[3][2] a;\n4     bool[2][2] aa;\n\n5     constructor() {\n6       _;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 20+ \n",
    "invariants": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "critical-invariants": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "ranks": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;",
    "transaction-context": "The transaction context is loop",
    "Critical-points": "Critical program points are 9+ ",
    "invariants": "9+ assert (sum == 1);",
    "critical-invariants": "9+ assert (sum == 1);",
    "ranks": "9+ assert (sum == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract DODO {\n2     function init(\n3         address maintainer,\n4         address baseTokenAddress,\n5         address quoteTokenAddress,\n6         uint256 lpFeeRate,\n7         uint256 mtFeeRate,\n8         uint256 k,\n9         uint256 i,",
    "transaction-context": "modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n",
    "Critical-points": "nonReentrant",
    "invariants": "require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");",
    "critical-invariants": "require(i > 0 && i <= 10**36);      ",
    "ranks": "require(k <= 10**18); ",
    "vulnerabilities": "require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );"
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0; contract Crowdsale {\n2     uint raised;\n3     uint goal;\n4     uint deadline;\n\n5     bool finished; // Instrumented.\n6     bool canceled; // Instrumented.\n\n7     constructor(uint _goal) public {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 16+ \n19+ \n22+ ",
    "invariants": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "critical-invariants": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "ranks": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "vulnerabilities": "atomicity violation \n"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "ensure(deadline)",
    "Critical-points": "ensure(deadline)",
    "invariants": "require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "ensure(deadline)",
    "ranks": "ensure(deadline)",
    "vulnerabilities": "ensure(deadline)"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 21+ \n40+ \n42+ \n44+ \n48+ \n57+ \n59+ \n64+\n87+\n120+\n123+ \n125+ \n136+  \n165+ ",
    "invariants": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);\n",
    "critical-invariants": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);",
    "ranks": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);",
    "vulnerabilities": "incorrect invisibility/ownership\nariithmetic flaw"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+   ",
    "invariants": "7+   assert (a == 1);",
    "critical-invariants": "7+   assert (a == 1);",
    "ranks": "7+   assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\");",
    "Critical-points": "require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");",
    "invariants": "require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");",
    "critical-invariants": "require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");",
    "ranks": " require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\nrequire(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");",
    "vulnerabilities": "require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 contract ModifierEntrancy {\n\n3   mapping (address => uint) public tokenBalance;\n4   string constant name = \"Nu Token\";\n5   Bank bank;\n  \n6   constructor() public{",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 15+ \n20+  ",
    "invariants": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());\n20+  require(tokenBalance[msg.sender] == 0);\n\n",
    "critical-invariants": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "ranks": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 33+ \n34+ \n92+  ",
    "invariants": "33+ require(amount > 0, \"Invalid amount\");\n34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n92+  require(canTransfer, \"E046\");\n",
    "critical-invariants": "34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");",
    "ranks": "34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1     function _stETHTransferFrom(address from, address to, uint256 amount) internal returns () {      \n2         _asset.safeTransferFrom(from, to, amount);\n3       }\n4     }\n\n5     function _beforeWithdraw(uint256 shares) internal {\n6         lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n      \n7     }",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 1+ \n6+ ",
    "invariants": "1+ require(amount > 0);\n6+ assert(lastRoundAssets > 0);",
    "critical-invariants": "1+ require(amount > 0);\n6+ assert(lastRoundAssets > 0);",
    "ranks": "1+ require(amount > 0);\n6+  assert(lastRoundAssets > 0);",
    "vulnerabilities": "integer overflow/underflow"
  },
  {
    "code": "1 abstract contract BaseVault is IVault, ERC20Permit, Capped {\n\n2      function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n3          if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n4          uint256 _totalAssets = totalAssets();\n5          for (uint256 i = startIndex; i < endIndex; i++) {\n6              uint256 currentAssets = _totalAssets + processedDeposits;\n7              DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);",
    "transaction-context": "The transaction context is vault \nasset swapping",
    "Critical-points": "Critical program points are 10+",
    "invariants": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "critical-invariants": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "ranks": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "vulnerabilities": "insufficient gas"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "Critical-points": "assert(a == 0 || c / a == b);",
    "invariants": "assert(b <= a);",
    "critical-invariants": "assert(c >= a);",
    "ranks": "require(msg.sender == owner, \"only owner\");\n",
    "vulnerabilities": "require(visrDeposit > 0, \"deposits must be nonzero\");\nrequire(to != address(0) && to != address(this), \"to\");\nrequire(from != address(0) && from != address(this), \"from\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");",
    "Critical-points": "require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "invariants": "assert (x == a + 1);",
    "critical-invariants": "assert (a == x + 2);",
    "ranks": "assert (x == a + 2);",
    "vulnerabilities": " assert (a == 1);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 24+\n32+\n37+",
    "invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "critical-invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "ranks": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../ERC1967/ERC1967Proxy.sol\";\n\n5 interface ITransparentUpgradeableProxy {\n6     event Upgraded(address indexed implementation);",
    "transaction-context": "The transaction context is proxy\nprotocol",
    "Critical-points": "Critical program points are 80+ \n92+ \n99+ \n108+ \n111+",
    "invariants": "80+ assert(Old(abi.encode(admin)) == abi.encode(admin)); \n92+ assert(Old(abi.encode(implementation)) == abi.encode(implementation));\n99+ assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));\n108+ assert(Old(newImplementation) == abi.decode(msg.data[4:], (address)));\n111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); \n",
    "critical-invariants": "111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); ",
    "ranks": "111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); ",
    "vulnerabilities": "incorrect visibility/ownership\ninconsistent state update\natomicity violation"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "require((z = x + y) >= x, 'ds-math-add-overflow');",
    "Critical-points": "require((z = x - y) <= x, 'ds-math-sub-underflow');",
    "invariants": "require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');",
    "critical-invariants": " require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');",
    "ranks": "require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');",
    "vulnerabilities": "require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 9+  \n17+ \n18+ ",
    "invariants": "9+  assert(_merkleRoot != 0);\n17+ assert(_msgHash != 0);\n18+ assert(_root != 0);",
    "critical-invariants": "17+ assert(_msgHash != 0);\n",
    "ranks": "9+ assert(_merkleRoot != 0); \n17+ assert(_msgHash != 0); ",
    "vulnerabilities": "cross bridge\nID Uniqueness violation"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./ComptrollerInterface.sol\";\n3 import \"./CTokenInterfaces.sol\";\n4 import \"./ErrorReporter.sol\";\n5 import \"./Exponential.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./EIP20NonStandardInterface.sol\";\n8 import \"./InterestRateModel.sol\";",
    "transaction-context": "require(msg.sender == admin, \"only admin may initialize the market\");\nrequire(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");",
    "Critical-points": " require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");",
    "invariants": "require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");",
    "critical-invariants": "require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");",
    "ranks": "require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");",
    "vulnerabilities": "require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; ",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 19+  ",
    "invariants": "19+   require(!drawingPhase, \"drawing\");",
    "critical-invariants": "19+   require(!drawingPhase, \"drawing\");",
    "ranks": "19+   require(!drawingPhase, \"drawing\");",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract SafeMath {\n\n3     function safeAdd(uint a, uint b) public pure returns (uint c) {\n4         c = a + b;\n\n5     }",
    "transaction-context": "The transaction context is ERC \nfunds transfer",
    "Critical-points": "Critical program points are 4+ \n6+ \n10+\n12+\n71+",
    "invariants": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "critical-invariants": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "ranks": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "vulnerabilities": "arithmetic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 abstract contract BaseVault {\n\n2     DepositQueueLib DepositQueue;\n\n3     function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n4         uint256 _totalAssets = totalAssets();\n5         for (uint256 i = startIndex; i < endIndex; i++){\n6             uint256 currentAssets = _totalAssets + processedDeposits;\n7             depositEntry = depositQueue.get(i);",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 9+ ",
    "invariants": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");\n",
    "critical-invariants": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");",
    "ranks": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");",
    "vulnerabilities": "gas leakage"
  },
  {
    "code": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 32+  \n89+ ",
    "invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n89+  require(canTransfer, \"E046\");\n",
    "critical-invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "ranks": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 contract Example {\n2     function flash(\n3         address recipient,\n4         uint256 amount0,\n5         uint256 amount1,\n6         bytes calldata data\n7     ) external isFlashable globallyTransactable transactable isNotEmergency {\n8         uint256 fee = curve.epsilon.mulu(1e18);\n9         ",
    "transaction-context": "assert(balance0Before.add(fee0) <= balance0After);",
    "Critical-points": "assert(balance1Before.add(fee1) <= balance1After);",
    "invariants": "nan",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 \n3 pragma solidity 0.6.12;\n4 \n5 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"../LPToken.sol\";\n8 import \"../interfaces/ISwap.sol\";\n9 import \"../MathUtils.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 110+ \n186+\n",
    "invariants": "110+ assert(Old(CalculateSwapUnderlyingInfo.dy) == dy);\n186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));\n",
    "critical-invariants": "186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));",
    "ranks": "186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "require(index <= 473, \"\"Curve/index-out-of-range\"\" );",
    "Critical-points": " require(isWhitelisted(index, account, amount, merkleProof), \"\"Curve/not-whitelisted\"\");",
    "invariants": "require(msg.sender == account, \"\"Curve/not-approved-user\"\");",
    "critical-invariants": "globallyTransactable",
    "ranks": "transactable",
    "vulnerabilities": "nonReentrant"
  },
  {
    "code": "1 / SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract ether{\n5         function payout(address[] recipients,\n6                         uint256[] amounts) {\n7         require(recipients.length==amounts.length);\n8         for (uint i = 0; i < recipients.length; i++) {\n9         recipients[i].send(amounts[i]);",
    "transaction-context": "assert(address(this)==msg.sender);",
    "Critical-points": "assert(msg.sender == _contractRegistry);\nassert(msg.sender == _contractRegistry);",
    "invariants": "assert (sum == 1);",
    "critical-invariants": "assert(funcA2(funcA1())==12);\nassert(funcA3().funcB()!=42);",
    "ranks": "assert(c / a == b);",
    "vulnerabilities": "assert(b <= a);"
  },
  {
    "code": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {",
    "transaction-context": "require(balanceOf[_to] + _value > balanceOf[_to]);  ",
    "Critical-points": " require(!frozenAccount[_from]);                     ",
    "invariants": "require(!frozenAccount[_to]);   ",
    "critical-invariants": " require(investor != 0x0);  ",
    "ranks": "require(validPurchase()); ",
    "vulnerabilities": "require(maxEtherInvestment >= msg.value); "
  },
  {
    "code": "1 // SPDX-License-Identifier: BSD-3-Clause\n2 pragma solidity ^0.8.10;\n\n3 import \"./ComptrollerInterface.sol\";\n4 import \"./CTokenInterfaces.sol\";\n5 import \"./ErrorReporter.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./InterestRateModel.sol\";\n8 import \"./ExponentialNoError.sol\";",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 23+  \n29 \n59\n101 \n111 ",
    "invariants": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n29 nonReentrant\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant",
    "critical-invariants": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant\n",
    "ranks": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant\n",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "nan\nWhat's the transaction context of the contract?\n",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are nan",
    "invariants": "nan",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract MappingNested {\n\n3     mapping (uint => mapping (uint => uint)) m;\n4     mapping (uint => uint[]) n;\n5     uint[] p;\n  \n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+         \n11+      \n12+        \n15+        \n16+\n17+         ",
    "invariants": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);\n12+         assert (n[0].length == 0);\n15+         assert (n[0].length == 2);\n16+         assert (n[1].length == 0); \n17+         assert (p.length == 0); ",
    "critical-invariants": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);",
    "ranks": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 ragma solidity ^0.5.0;\n2 \n3 import \"./IERC20.sol\";\n4 import \"./SafeMath.sol\";\n5 import \"./Libraries/VeriSolContracts.sol\"; //change \n6 \n7 \n8 contract ERC20 is IERC20 {\n9 ",
    "transaction-context": "The transaction context is funds transfer\nERC",
    "Critical-points": "Critical program points are 31+ ",
    "invariants": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "critical-invariants": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "ranks": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at FtmScan.com on 2021-08-31\n3 */\n\n4 // SPDX-License-Identifier: MIT\n5 // File: @openzeppelin/contracts/GSN/Context.sol\n\n\n6 pragma solidity ^0.6.0;",
    "transaction-context": "require(stratCandidate.implementation != address(0), \"There is no candidate\");",
    "Critical-points": "require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");",
    "invariants": " require(_token != address(want()), \"!token\");",
    "critical-invariants": "nonReentrant",
    "ranks": "modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }",
    "vulnerabilities": " modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract testSuicide{\n5         function initMultiowned(address[] _owners,\n6                             uint _required){\n7         if (m_numOwners > 0) throw;\n8         m_numOwners = _owners.length + 1;\n9         m_owners[1] = uint(msg.sender);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 15+",
    "invariants": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "critical-invariants": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "ranks": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "vulnerabilities": "suicidal contracts"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "globallyTransactable transactable",
    "Critical-points": "globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant ",
    "invariants": " require(originAmount_ <= _maxOriginAmount, \"\"Curve/above-max-origin-amount\"\");",
    "critical-invariants": "globallyTransactable transactable\n",
    "ranks": "globallyTransactable transactable nonReentrant noDelegateCall ",
    "vulnerabilities": "require(amount == 1, \"\"Curve/invalid-amount\"\");"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "assert (a[1][0] == 3);",
    "Critical-points": "assert (a[1][1] == 4);",
    "invariants": "assert (a[1][2] == 5);",
    "critical-invariants": "assert (b[1] == 22);",
    "ranks": "assert(false);",
    "vulnerabilities": "assert (a == 1 || a == 2);"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");",
    "Critical-points": "assert (y == 2*x + 4); ",
    "invariants": "assert (a[0][0] == 0);\n",
    "critical-invariants": " assert (a[0][1] == 1);",
    "ranks": "assert (a[1][0] == 2);",
    "vulnerabilities": "assert (a[1][1] == 3);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ExternalFunctionCall {\n\n3     function foo(uint x) public returns (uint ret) {\n4         ret = x + 2;\n5     }\n\n6     function testExternalFunctionCall(uint x) public {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (y == x + 2);",
    "critical-invariants": "7+ assert (y == x + 2);",
    "ranks": "7+ assert (y == x + 2);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 42+\n151+ \n",
    "invariants": "42+ assert(Old(reserve0) == reserve0);\n42+ assert(Old(reserve1) == reserve1);\n152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "critical-invariants": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "ranks": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**",
    "transaction-context": "require(_owner == _msgSender(), \"Ownable: caller is not the owner\");",
    "Critical-points": "require(newOwner != address(0), \"Ownable: new owner is the zero address\");",
    "invariants": "require(localCounter == _guardCounter);",
    "critical-invariants": "assert(token != address(this)); \nassert(token != user); ",
    "ranks": "require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
    "vulnerabilities": "require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; ",
    "transaction-context": "require(!drawingPhase, \"drawing\");",
    "Critical-points": "assert(bal == oldBal || bal == (oldBal - amount));",
    "invariants": " assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "critical-invariants": "assert (!false);",
    "ranks": " assert(fee + value != 0);",
    "vulnerabilities": "assert(_required > 0); \nassert(m_numOwners > 0);"
  },
  {
    "code": "1  contract Lottery {\n2  // user address -> lottery id -> count\n3  mapping (address => mapping(uint64 => uint))\n4  public tickets;\n5  uint64 winningId; // the winning id\n6  bool drawingPhase; // whether the owner is drawing\n\n7  // invoked every day to reset a round\n8  function reset() external onlyOwner {",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 13+  \n14+ \n23+  \n24+ \n25+  \n34+  \n",
    "invariants": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "critical-invariants": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "ranks": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 42+ \n47+ \n66+ \n67+ \n87+ \n112+ \n141+ \n141+  \n177+ \n177+ \n210+ ",
    "invariants": "42+ require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n47+ require(owner != address(0), \"ERC721: invalid token ID\");\n66+ require(to != owner, \"ERC721: approval to current owner\");\n67+ require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n112+ require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n141+ require(to != address(0), \"ERC721: mint to the zero address\");\n141+  require(!_exists(tokenId), \"ERC721: token already minted\");\n177+  require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n177+ require(to != address(0), \"ERC721: transfer to the zero address\");\n210+ require(_exists(tokenId), \"ERC721: invalid token ID\");\n",
    "critical-invariants": "87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n",
    "ranks": "87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "onlyMPC",
    "Critical-points": "require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');",
    "invariants": " require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "require(cnt > 0 && cnt <= 20);\n",
    "ranks": "require(_value > 0 && balances[msg.sender] >= amount);\n",
    "vulnerabilities": "assert(amount >0);"
  },
  {
    "code": "1  contract PoolCurve{\n2 \n3    /// @notice sets the parameters for the pool\n4     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n5     /// @param _beta the value for beta must be less than alpha and greater than 0\n6     /// @param _feeAtHalt the maximum value for the fee at the halt point\n7     /// @param _epsilon the base fee for the pool\n8     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n9     function setParams(",
    "transaction-context": "onlyOwner",
    "Critical-points": "require(sender != address(0), \"\"ERC20: transfer from the zero address\"\");",
    "invariants": "require(recipient != address(0), \"\"ERC20: transfer to the zero address\"\");",
    "critical-invariants": "require(_owner != address(0), \"\"ERC20: approve from the zero address\"\");",
    "ranks": " require(spender != address(0), \"\"ERC20: approve to the zero address\"\");",
    "vulnerabilities": "modifier onlyOwner() {\n           require(msg.sender == owner, \"\"Curve/caller-is-not-owner\"\");        \n            _;\n     }"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 \n4 contract Ctoken{\n5     function transfer(address _to, uint256 _value) public returns (bool) {\n6         require(superTransfer(_to, _value));\n7         callAfterTransfer(msg.sender, _to, _value);\n8         return true;\n9     }",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 5+ \n11+\n",
    "invariants": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "critical-invariants": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "ranks": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": "assert (a == 1);",
    "Critical-points": "assert (b == 3);",
    "invariants": "assert (a == 4);",
    "critical-invariants": "assert (b == 40);",
    "ranks": "assert (a == 5);",
    "vulnerabilities": " assert (b == 55);"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": " modifier nonReentrant() {\n               require(notEntered, \"\"Curve/re-entered\"\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }",
    "Critical-points": "modifier transactable() {\n              require(!frozen, \"\"Curve/frozen-only-allowing-proportional-withdraw\"\");\n               _;\n         }",
    "invariants": "modifier isEmergency() {\n             require(emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n             _;\n        }",
    "critical-invariants": "modifier isNotEmergency() {\n              require(!emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n             _;\n     }",
    "ranks": " modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"\"Curve/tx-deadline-passed\"\");\n              _;\n         }",
    "vulnerabilities": "modifier inWhitelistingStage() {\n              require(whitelistingStage, \"\"Curve/whitelist-stage-stopped\"\");\n                _;\n           }"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n22+ \n23+ \n24+\n25+ \n26+ \n27+ ",
    "invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "critical-invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "ranks": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n4 import { LibAsset } from \"../Libraries/LibAsset.sol\";\n5 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n6 import { LibSwap } from \"../Libraries/LibSwap.sol\";\n7 import { ICBridge } from \"../Interfaces/ICBridge.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 58+ \n92+  \n101+\n125+  \n191+  ",
    "invariants": "58+ require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n92+  require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n101+ require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n125+  require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n191+  assert(!invokeSwap);",
    "critical-invariants": "191+  assert(!invokeSwap);",
    "ranks": "191+  assert(!invokeSwap);",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "onlyBank",
    "Critical-points": " onlyBank",
    "invariants": "require(isPoolActive,'Contract is not running yet');",
    "critical-invariants": "require(_depositId >= 0, \"Value is not specified\");",
    "ranks": "require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");",
    "vulnerabilities": "require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+  assert (a == 1);",
    "critical-invariants": "7+  assert (a == 1);",
    "ranks": "7+  assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "\"1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\"\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;",
    "transaction-context": "onlyFactory \n",
    "Critical-points": "modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }",
    "invariants": " require(signatories.length == increments.length, 'two array lenth not equal');",
    "critical-invariants": " require(signatories.length == decrements.length, 'two array lenth not equal');",
    "ranks": " require(received[fromChainId][to][nonce] == 0, 'withdrawn already');",
    "vulnerabilities": " require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 15+",
    "invariants": "15+ assert (x == a + 2);",
    "critical-invariants": "15+ assert (x == a + 2);",
    "ranks": "15+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 26+ ",
    "invariants": "26+ assert(_committedRoot !=0); ",
    "critical-invariants": "26+ assert(_committedRoot !=0); ",
    "ranks": "26+ assert(_committedRoot !=0); ",
    "vulnerabilities": "cross bridge\nID Uniqueness violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";",
    "transaction-context": "require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
    "Critical-points": " require(to != address(0), \"ERC721: mint to the zero address\");\n require(!_exists(tokenId), \"ERC721: token already minted\");",
    "invariants": "require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\nrequire(to != address(0), \"ERC721: transfer to the zero address\");",
    "critical-invariants": "require(_exists(tokenId), \"ERC721: invalid token ID\");",
    "ranks": "assert(Old(pirce) == token0.balanceOf(address(this))/token1.balanceOf(address(this)));\n",
    "vulnerabilities": "assert(price <= 1.2 * Old(pirce)); "
  },
  {
    "code": "1 contract ArrayNestedFixedSize {\n\n2     // NOTE: the number of columns comes first in the declaration!\n3     uint[3][2] a;\n4     bool[2][2] aa;\n\n5     constructor() {\n6       _;\n",
    "transaction-context": "assert (a[0][0] == 0 || a[0][0] == 3);\nassert (a[0][1] == 1);\nassert (a[0][2] == 2);\nassert (a[1][0] == 3);\nassert (a[1][1] == 4);\nassert (a[1][2] == 5);",
    "Critical-points": "assert(a[0] == 1);    \nassert(a[1] == 2);",
    "invariants": "assert (sa[0] == 10);\nassert (sa[1] == 11);\nassert (sa.length == 2);",
    "critical-invariants": "assert (a[0] == 0);\nassert (a[1] == 1);\n",
    "ranks": "assert (b[j] == j);",
    "vulnerabilities": "assert (a == 1);\nassert (b == 3);"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "Critical-points": " require(success, \"Failed to withdraw funds.\");",
    "invariants": "require(success, \"Failed to withdraw funds.\");",
    "critical-invariants": "require(success, \"Failed to withdraw funds.\");",
    "ranks": "require(totalBid > 0, \"Nothing to withdraw\");",
    "vulnerabilities": "require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
    "Critical-points": "require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "invariants": "require(c >= a, \"SafeMath: addition overflow\");",
    "critical-invariants": " return sub(a, b, \"SafeMath: subtraction overflow\");",
    "ranks": "require(b <= a, errorMessage);",
    "vulnerabilities": "require(c / a == b, \"SafeMath: multiplication overflow\");"
  },
  {
    "code": "1 //SPDX-License-Identifier: GPL-3.0\n2 pragma solidity 0.8.4;\n3 \n4 import \"../libraries/MathLib.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n7 import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n8 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n9 import \"../interfaces/IExchangeFactory.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 147+\n194+\n",
    "invariants": "147+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "critical-invariants": "194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "ranks": "194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // array variable copy breaks\n\n2 contract ArrayLength {\n3     uint[12] a;\n\n4     constructor (uint[12] memory d) public\n5     {\n6         require (d[1] == 5);\n7         a = d;       ",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 6+ \n8+  ",
    "invariants": "6+ require (d[1] == 5);\n8+  assert (d[1] == 5);",
    "critical-invariants": "8+  assert (d[1] == 5);",
    "ranks": "8+  assert (d[1] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;",
    "transaction-context": "assert (a == 1 || a == 2);",
    "Critical-points": "assert(b != c);",
    "invariants": "assert (a == 1);",
    "critical-invariants": "assert (x == a + 2);",
    "ranks": "assert (x != 1); ",
    "vulnerabilities": "assert (a == 1);"
  },
  {
    "code": "1 contract Vote {\n2    struct Proposal {\n3       uint160 sTime; address newOwner;\n4  }\n5   IERC20 votingToken;\n6   IERC20 LockedToken;\n7   address owner;\n8   Proposal proposal;\n",
    "transaction-context": "The transaction context is voting\nbidding proposal",
    "Critical-points": "Critical program points are 10+\n11+  \n14+ \n17+ \n20+ \n21+  \n23+ \n24+ \n",
    "invariants": "10+ require(proposal.sTime == 0, \"on-going proposal\");\n11+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n14+ require(proposal.sTime + 2 days > block.timestamp,\n \"voting has ended\");\n17+ assert(Old(votingToken.balanceOf(address(this))) ==votingToken.balanceOf(address(this)));\n20+ require(proposal.sTime != 0, \"no proposal\");\n21+  require(proposal.sTime + 2 days < block.timestamp,\n \"voting has not ended\");\n23+ require(votingToken.balanceOf(address(this))*2 >\nvotingToken.totalSupply(), \"vote failed\");\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n\n",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n\n",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 abstract contract BaseVault {\n\n2     DepositQueueLib DepositQueue;\n\n3     function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n4         uint256 _totalAssets = totalAssets();\n5         for (uint256 i = startIndex; i < endIndex; i++){\n6             uint256 currentAssets = _totalAssets + processedDeposits;\n7             depositEntry = depositQueue.get(i);",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 9+ ",
    "invariants": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");\n",
    "critical-invariants": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");",
    "ranks": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");",
    "vulnerabilities": "gas leakage"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 38            \n43            \n78            \n84            \n86          \n109        ",
    "invariants": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n109         require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "critical-invariants": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n\"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n109         require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "ranks": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n\"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n109         require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "The transaction context is cross-function\nmoney market",
    "Critical-points": "Critical program points are 18+  \n33+ \n44+  \n45+  \n61+  \n63+",
    "invariants": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n",
    "critical-invariants": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");",
    "ranks": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "onlyMPC",
    "Critical-points": "onlyMPC",
    "invariants": "onlyMPC",
    "critical-invariants": "onlyMPC",
    "ranks": "onlyMPC",
    "vulnerabilities": "ensure(deadline)"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n6 import \"./interfaces/IStakingBank.sol\";\n7 import \"./BaseChain.sol\";\n",
    "transaction-context": "require(msg.sender == owner, \"only owner\");\nrequire(dataTimestamp + padding < block.timestamp, \"do not spam\");\nrequire(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\nrequire(_keys.length == _values.length, \"numbers of keys and values not the same\");",
    "Critical-points": "require(uint224(_values[i]) == _values[i], \"FCD overflow\");",
    "invariants": "require(i >= requiredSignatures, \"not enough signatures\");",
    "critical-invariants": "require(winningId == 0, \"already drawn\");\nrequire(!drawingPhase, \"drawing\");",
    "ranks": "require(drawingPhase, \"not drawing\");",
    "vulnerabilities": "require(winningId == 0, \"already drawn\");\nrequire(!drawingPhase, \"drawing\");"
  },
  {
    "code": "\"1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\"\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;",
    "transaction-context": " require(signatory != address(0), \"invalid signature\");",
    "Critical-points": "require(signatory == signatures[i].signatory, \"unauthorized\");",
    "invariants": " assert(to == signatory);",
    "critical-invariants": "require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "ranks": "require(yvTokenInfo.isYvToken, \"not a Yvault token\");",
    "vulnerabilities": "assert(pricePerShare <= k*Old(pricePerShare));"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 15+  \n19+ \n23+ \n32+  \n34+\n57+ \n58+  \n64+  \n65+ \n74+  \n75+ \n83+  \n94+ \n109+ \n115+ \n121+\n126+ \n168+  \n181+ \n196+ \n212 \n213+\n221 \n222+  \n291 \n296 \n302 \n312 \n318 \n360 \n379 \n409 \n428+  \n454 \n473 \n503 \n520  \n521+ \n523+   ",
    "invariants": "15+  require((z = x + y) >= x, 'ds-math-add-overflow');\n19+  require((z = x - y) <= x, 'ds-math-sub-underflow');\n23+  require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n212 onlyMPC\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n221 onlyMPC\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "ranks": "168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 19+         \n35+        \n36+       \n37+       \n49+         \n51+        \n68+        \n69+       \n70+        ",
    "invariants": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "critical-invariants": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "ranks": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "vulnerabilities": "incorrect visibility/ownership\nreentrancy"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 29+  \n30+  \n48+  \n51+  \n54+ \n55+ \n83+ \n106+  \n108+\n112+ \n117+  \n118+ \n121+ \n139+ \n143+ \n145+",
    "invariants": "29+  require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n30+  require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\n30+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");\n48+  require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");\n51+  require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");\n54+ require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n55+ require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\n55+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");\n83+ require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\");\n106+  require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n108+  require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n112+  require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n117+  require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n117+ require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n118+  require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n121+  require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n139+ assert(_method != \u201cf1121318093\u201d); \n143+ require(success == true, \"EthCrossChain call business contract failed\");\n145+  require(res == true, \"EthCrossChain call business contract return is not true\");",
    "critical-invariants": "139+ assert(_method != \u201cf1121318093\u201d); \n",
    "ranks": "139+ assert(_method != \u201cf1121318093\u201d); \n",
    "vulnerabilities": "incorrect visibility/ownership\nID uniqueness violation\nbusiness logic flaw\ninconsistent state update"
  },
  {
    "code": "1 abstract contract BaseVault is IVault, ERC20Permit, Capped {\n\n2      function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n3          if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n4          uint256 _totalAssets = totalAssets();\n5          for (uint256 i = startIndex; i < endIndex; i++) {\n6              uint256 currentAssets = _totalAssets + processedDeposits;\n7              DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);",
    "transaction-context": "require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "Critical-points": "assert(Old(getPrice())==getPrice());",
    "invariants": "assert(Old(getPrice())<=getPrice()*2);\n",
    "critical-invariants": "require(proposal.sTime == 0, \"on-going proposal\");\n",
    "ranks": "assert(Old(votingToken.balanceOf(address(this))) == 0);",
    "vulnerabilities": "require(proposal.sTime + 2 days > block.timestamp,\n \"voting has ended\");"
  },
  {
    "code": "1 //SPDX-License-Identifier: MIT\n2 pragma solidity 0.7.5;\n\n3 contract contrived{\n4  function withdraw(uint256 amount) override public nonReentrant updateReward(msg.sender) {  \n5     _totalSupply = _totalSupply - amount;\n6     _balances[msg.sender] = _balances[msg.sender].sub(amount);\n7     stakingToken.safeTransfer(msg.sender, amount);\n",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 4+",
    "invariants": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "critical-invariants": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "ranks": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "vulnerabilities": "integer over/underflow"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error",
    "transaction-context": "require(!paused);",
    "Critical-points": "require(paused);",
    "invariants": "require(id < nextPositionID, \"bad position id\");\nrequire(positions[id].goblin == goblin, \"bad position goblin\");\nrequire(positions[id].owner == msg.sender, \"not position owner\");",
    "critical-invariants": " require(config.isGoblin(goblin), \"not a goblin\");\n require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");",
    "ranks": "require(debt >= config.minDebtSize(), \"too small debt size\");",
    "vulnerabilities": "require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n"
  },
  {
    "code": "1  contract PoolCurve{\n2 \n3    /// @notice sets the parameters for the pool\n4     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n5     /// @param _beta the value for beta must be less than alpha and greater than 0\n6     /// @param _feeAtHalt the maximum value for the fee at the halt point\n7     /// @param _epsilon the base fee for the pool\n8     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n9     function setParams(",
    "transaction-context": "modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": "onlyOwner",
    "ranks": "onlyOwner ",
    "vulnerabilities": "onlyOwner"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n\n6 import \"./interfaces/IStakingBank.sol\";\n",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 21+ \n78\n81   \n82   \n89   \n92     \n104     \n110     ",
    "invariants": "21+   modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n78 onlyOwner\n81     require(dataTimestamp + padding < block.timestamp, \"do not spam\");\n82     require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n89     require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n92       require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n104       require(prevSigner < signer, \"validator included more than once\");\n110     require(i >= requiredSignatures, \"not enough signatures\");\n",
    "critical-invariants": "21+   modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n78 onlyOwner",
    "ranks": "21+   modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n78 onlyOwner",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "//votingToken is important for tracking \n1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 contract JAY is ERC20, Ownable {\n2     using SafeMath for uint256;\n3     AggregatorV3Interface internal priceFeed;\n\n4     address private dev;\n5     uint256 public constant MIN = 1000;\n6     bool private start = false;\n7     bool private lockDev = false;\n",
    "transaction-context": "require(success, \"ETH Transfer failed.\");",
    "Critical-points": "require(success2, \"ETH Transfer failed.\");",
    "invariants": "require(msg.value > MIN, \"must trade over min\");\nrequire(start, \"Not started!\");",
    "critical-invariants": "require(success, \"ETH Transfer failed.\");",
    "ranks": "require (liquidity>0, \"MonoX:BAD_AMOUNT\");",
    "vulnerabilities": "assert(to != address(0)); "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 21+  \n22+  ",
    "invariants": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "critical-invariants": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "ranks": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 38            \n43          \n78             \n84    \n86          \n109+ ",
    "invariants": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "critical-invariants": "109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "ranks": "109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "vulnerabilities": "ID uniquness violation"
  },
  {
    "code": "1  contract Lottery {\n2  // user address -> lottery id -> count\n3  mapping (address => mapping(uint64 => uint))\n4  public tickets;\n5  uint64 winningId; // the winning id\n6  bool drawingPhase; // whether the owner is drawing\n\n7  // invoked every day to reset a round\n8  function reset() external onlyOwner {",
    "transaction-context": "require(winningId == 0, \"already drawn\");\n",
    "Critical-points": " assert(Old(votingToken.balanceOf(address(this))) == 0)",
    "invariants": "assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));",
    "critical-invariants": "assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "  assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));",
    "vulnerabilities": "assert(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *2);\n"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\"; //import \"../../math/SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n5 contract ERC20 is IERC20 {\n6     using SafeMath for uint256;\n",
    "transaction-context": "assert (msg.sender == recipient ||  _balances[msg.sender] == _balances[msg.sender] - amount);",
    "Critical-points": "assert (_balances[recipient] >= _balances[recipient]);",
    "invariants": "require(sender != address(0), \"ERC20: transfer from the zero address\");",
    "critical-invariants": "require(recipient != address(0), \"ERC20: transfer to the zero address\");",
    "ranks": "require(account != address(0), \"ERC20: burn from the zero address\");",
    "vulnerabilities": "require(owner != address(0), \"ERC20: approve from the zero address\");"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }",
    "transaction-context": "require(_to.length == _amount.length);",
    "Critical-points": "require(_to[ui] != address(0));",
    "invariants": " require(amountSum <= balances[msg.sender]);",
    "critical-invariants": " require(_value <= balances[msg.sender]);",
    "ranks": " require(blackList[_from] != true);\n require(blackList[_to] != true);",
    "vulnerabilities": "assert(i <= team_limit);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;",
    "transaction-context": "The transaction context is loop\n",
    "Critical-points": "Critical program points are 9+",
    "invariants": "9+   assert (sum == 1);",
    "critical-invariants": "9+   assert (sum == 1);",
    "ranks": "9+   assert (sum == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.6.0;\n2 pragma experimental ABIEncoderV2;\n\n3 import \"./BondingCurve.sol\";\n4 import \"../pcv/IPCVDeposit.sol\";\n\n5 /// @title a square root growth bonding curve for purchasing FEI with ETH\n6 /// @author Fei Protocol\n7 contract EthBondingCurve is BondingCurve {",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 44",
    "invariants": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "critical-invariants": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "ranks": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "vulnerabilities": "healthy"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "nonReentrant",
    "Critical-points": "noDelegateCall",
    "invariants": " isNotEmergency",
    "critical-invariants": "globallyTransactable transactable ",
    "ranks": "nonReentrant noDelegateCall isNotEmergency",
    "vulnerabilities": "nonReentrant noDelegateCall"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n4 import { LibAsset } from \"../Libraries/LibAsset.sol\";\n5 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n6 import { LibSwap } from \"../Libraries/LibSwap.sol\";\n7 import { ICBridge } from \"../Interfaces/ICBridge.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");",
    "Critical-points": "require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");",
    "invariants": "require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");",
    "critical-invariants": "require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");",
    "ranks": " assert(!invokeSwap);",
    "vulnerabilities": "  assert(_committedRoot != 0)"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "require(IVisor(from).owner() == msg.sender); \n",
    "Critical-points": "assert( IVisor(from) !=  address(this)); \n",
    "invariants": "require(shares > 0, \"shares\");\n require(from != address(0), \"from\");",
    "critical-invariants": "require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n",
    "ranks": " require(amount > 0, \"Invalid amount\");\n require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "vulnerabilities": "require(canTransfer, \"E046\");"
  },
  {
    "code": "1 contract JAY is ERC20, Ownable {\n2     using SafeMath for uint256;\n3     AggregatorV3Interface internal priceFeed;\n\n4     address private dev;\n5     uint256 public constant MIN = 1000;\n6     bool private start = false;\n7     bool private lockDev = false;\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 24+  \n46+       \n47+   \n100+       \n102+  \n104+ \n140+  \n143+   \n144+ \n148+    \n150+ ",
    "invariants": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");\n140+   require(value > MIN, \"Dude tf\");\n143+   require(success, \"ETH Transfer failed.\");\n144+   require(success2, \"ETH Transfer failed.\");\n148+   require(msg.value > MIN, \"must trade over min\");\n148+   require(start, \"Not started!\");\n150+ require(success, \"ETH Transfer failed.\");",
    "critical-invariants": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");",
    "ranks": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");",
    "vulnerabilities": "atomicity violation \narithmetic flaw\nintefer overflow/underflow\ninconsistent state update\nbusiness logic flaw"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": " require(_exists(tokenId), \"Token does not exist\");",
    "Critical-points": " require(auctionStarted, \"Auction has not yet started\");\n require(!auctionEnded, \"Auction has been finished\");\n require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");",
    "invariants": " require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");",
    "critical-invariants": " require(auctionStarted, \"Auction has not yet started\");\n require(!auctionEnded, \"You cannot end the action again\");\n require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       ",
    "ranks": " require(auctionEnded, \"Please end the auction firstly\");",
    "vulnerabilities": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error",
    "transaction-context": "The transaction context is ERC\ntokenSale",
    "Critical-points": "Critical program points are 11+  \n20+ \n24+ \n51+   \n51+ \n145+ \n152+  \n168+ \n174+ ",
    "invariants": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);\n",
    "critical-invariants": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);",
    "ranks": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);",
    "vulnerabilities": "integer over/underflow\natomicity violation\nincorrect visibility/ownership"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "require(isPoolActive,'Contract is not running yet');",
    "Critical-points": "require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');",
    "invariants": "require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');",
    "critical-invariants": " require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "ranks": "modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }",
    "vulnerabilities": "nonReentrant"
  },
  {
    "code": "pragma solidity >=0.4.24 <0.6.0;\n\n//simple library with no internal state\n\nlibrary Lib {\n    function add(uint _a, uint _b) public view returns (uint r) {\n        address x = address(this);       \n        r = _a + _b;\n    }",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 5+\n14+",
    "invariants": "5+ assert(x == msg.sender);\n14+ assert (z == 3);",
    "critical-invariants": "14+ assert (z == 3);",
    "ranks": "14+ assert (z == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "require(success, \"Failed to withdraw funds.\");",
    "Critical-points": "modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }",
    "invariants": "onlyOwner",
    "critical-invariants": " require(dataTimestamp + padding < block.timestamp, \"do not spam\");",
    "ranks": "require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");",
    "vulnerabilities": " require(_keys.length == _values.length, \"numbers of keys and values not the same\");"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": " assert(funcA2(funcA1())==12);\n assert(funcA3().funcB()==42);",
    "Critical-points": "assert(a == x + 1);\n",
    "invariants": "assert(a == x);  ",
    "critical-invariants": "assert (a == x + 4);  \nassert (b == x + 4);  \nassert (c == x + 6);",
    "ranks": " assert(x == y);\n assert(y >= 0);\n",
    "vulnerabilities": "assert (y >= 0); "
  },
  {
    "code": "1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 22  \n27  \n55 \n69 \n109 \n111 \n118 \n119 \n133 ",
    "invariants": "22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n55 require(signatories.length == increments.length, 'two array lenth not equal');\n69 require(signatories.length == decrements.length, 'two array lenth not equal');\n109 require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n111 require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "critical-invariants": "118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "ranks": "118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "vulnerabilities": "privilege escalation\ncross bridge"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract SafeMath {\n\n3     function safeAdd(uint a, uint b) public pure returns (uint c) {\n4         c = a + b;\n\n5     }",
    "transaction-context": "require(c >= a);",
    "Critical-points": "require(b <= a);",
    "invariants": "require(a == 0 || c / a == b);",
    "critical-invariants": " require(b > 0);",
    "ranks": "assert(allowed[msg.sender][spender] = tokens); ",
    "vulnerabilities": "require(c >= a);"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";",
    "transaction-context": " require(msg.sender == admin, \"only the admin may set new guardian\");",
    "Critical-points": "require(msg.sender == admin, \"only the admin may set new admin\");",
    "invariants": "modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }",
    "critical-invariants": "nonReentrant ",
    "ranks": "assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);",
    "vulnerabilities": "assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);"
  },
  {
    "code": "1 // SPDX-License-Identifier: AGPL-3.0-or-later\n\n2 pragma solidity 0.8.9;\n\n3 import \"./BaseVault.sol\";\n4 ct STETHVault is BaseVault {\n5     using SafeERC20 for IERC20Metadata;\n6     using AuxMath for uint256;\n7     using AuxMath for AuxMath.Fractional;",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are 72+ \n115+ ",
    "invariants": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "critical-invariants": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "ranks": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "vulnerabilities": "vault\nasset swapping"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.0;\n3 \n4 contract WUSDMaster is Ownable, Withdrawable, ReentrancyGuard {\n5     using SafeERC20 for IERC20;\n6     \n7     IWUSD public immutable wusd;\n8     IERC20 public usdt;\n9     IERC20 public wex;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 53+ \n59+ \n",
    "invariants": "53+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");\n",
    "critical-invariants": "59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");",
    "ranks": "59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.6.0 <0.8.0;\n\n2 import \"./openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n3 import \"./openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n4 import \"./openzeppelin/contracts/token/ERC20/IERC20.sol\";\n5 import \"./openzeppelin/contracts/math/SafeMath.sol\";\n6 import \"./openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n7 import \"./openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n8 // import \"hardhat/consolse.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 19+ \n76+",
    "invariants": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "critical-invariants": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "ranks": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "vulnerabilities": "incorrect visibility/ownership\narithmetic flaw"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+\n44+",
    "invariants": "13+  require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "critical-invariants": "44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "ranks": "44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "vulnerabilities": "reentrancy\nbusiness logic flaw"
  },
  {
    "code": "1 contract PausableToken is StandardToken, Pausable {\n2 \n3   function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n4     return super.transfer(_to, _value);\n5   }\n6 \n7   function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n8     return super.transferFrom(_from, _to, _value);\n9   }",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 18 \n19 \n19+ ",
    "invariants": "18 require(cnt > 0 && cnt <= 20);\n19 require(_value > 0 && balances[msg.sender] >= amount);\n19+ assert(amount >0);",
    "critical-invariants": "19+ assert(amount >0);",
    "ranks": "19+ assert(amount >0);",
    "vulnerabilities": "integer overflow"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency ",
    "Critical-points": "require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');",
    "invariants": "require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth'); ",
    "critical-invariants": " require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned'); ",
    "ranks": "require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\"",
    "vulnerabilities": "require(!_INITIALIZED_, \"DODO_INITIALIZED\");"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n",
    "Critical-points": "require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\nrequire(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");",
    "invariants": "require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");",
    "critical-invariants": " require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");",
    "ranks": "require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");",
    "vulnerabilities": "require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\nrequire(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "The transaction context is liquidity pool",
    "Critical-points": "Critical program points are 128    \n132  \n148   \n171    \n178    \n181     \n184   \n193    \n196    \n199   \n202    \n205  \n211    \n214   \n217    \n220  \n223    \n226 \n233  \n246       \n254       \n260         \n402        \n419      \n421       \n446        \n465      \n488    \n489       \n508          \n510         \n613        \n638       \n650      \n652     ",
    "invariants": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n148    require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n171    onlyOwner\n178    onlyOwner\n181     onlyOwner\n184    onlyOwner\n193    onlyOwner\n196    onlyOwner\n199     onlyOwner\n202    onlyOwner\n205    onlyOwner\n211    onlyOwner\n214    onlyOwner\n217    onlyOwner\n220    onlyOwner\n223    onlyOwner\n226    onlyOwner\n233    onlyOwner\n246         require(isPoolActive,'Contract is not running yet');\n254         onlyBank\n259        onlyBank\n260         require(isPoolActive,'Contract is not running yet');\n402         require(_depositId >= 0, \"Value is not specified\");\n419         require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n421        require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n446         require(_depositId >= 0, \"Value is not specified\");\n465         require(pending > 0 ,\"No rewards to claim.\");\n488         onlyRunnerScript\n\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "critical-invariants": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n488         onlyRunnerScript\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "ranks": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n488         onlyRunnerScript\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+ ",
    "invariants": "8+ assert (a == 1);",
    "critical-invariants": "8+ assert (a == 1);",
    "ranks": "8+ assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");",
    "Critical-points": "require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");",
    "invariants": "require(auctionStarted, \"Auction has not yet started\");",
    "critical-invariants": "require(!auctionEnded, \"You cannot end the action again\");",
    "ranks": "require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");",
    "vulnerabilities": " uint256 tokenId = _tokenIdCounter.current();"
  }
]