[
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ExternalFunctionCall {\n\n3     function foo(uint x) public returns (uint ret) {\n4         ret = x + 2;\n5     }\n\n6     function testExternalFunctionCall(uint x) public {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (y == x + 2);",
    "critical-invariants": "7+ assert (y == x + 2);",
    "ranks": "7+ assert (y == x + 2);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 20+",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 24+\n32+\n37+",
    "invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "critical-invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "ranks": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 20+",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 24+\n32+\n38+",
    "invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "critical-invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "ranks": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0;\n2 import \"./Libraries/VeriSolContracts.sol\";\n\n\n3 contract LoopFor {\n\n4     int x;\n5     int y;\n",
    "transaction-context": "The transaction context is loop\narithmetics",
    "Critical-points": "Critical program points are 6+\n6+\n19+",
    "invariants": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0); ",
    "critical-invariants": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0);",
    "ranks": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "pragma solidity >=0.4.24 <0.6.0;\n\n//simple library with no internal state\n\nlibrary Lib {\n    function add(uint _a, uint _b) public view returns (uint r) {\n        address x = address(this);       \n        r = _a + _b;\n    }",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 5+\n14+",
    "invariants": "5+ assert(x == msg.sender);\n14+ assert (z == 3);",
    "critical-invariants": "14+ assert (z == 3);",
    "ranks": "14+ assert (z == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n2 import \"./../../Libraries/VeriSolContracts.sol\";\n3 //import \"./VeriSolContracts.sol\";\n4 //import \"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\";\n\n5 contract LoopFor {\n\n6     // test Loop invariant with for loop\n7     constructor(uint n) public {",
    "transaction-context": "The transaction context is loop\narithmetics",
    "Critical-points": "Critical program points are 10+ \n12+ \n19+  \n22+  \n29+ \n32+",
    "invariants": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "critical-invariants": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "ranks": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n\n5 /**\n6  * A highly simplified Token to express basic specifications",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 17+ \n47+ \n66+ ",
    "invariants": "17+ require(msg.sender != address(0));\n47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); \n66+ require(_balances[sender] >= amount);",
    "critical-invariants": "47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "ranks": "47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "vulnerabilities": "incorrect visibility/ownership\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 //SPDX-License-Identifier: MIT\n2 pragma solidity 0.7.5;\n\n3 contract contrived{\n4  function withdraw(uint256 amount) override public nonReentrant updateReward(msg.sender) {  \n5     _totalSupply = _totalSupply - amount;\n6     _balances[msg.sender] = _balances[msg.sender].sub(amount);\n7     stakingToken.safeTransfer(msg.sender, amount);\n",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 4+",
    "invariants": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "critical-invariants": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "ranks": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "vulnerabilities": "integer over/underflow"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error",
    "transaction-context": "The transaction context is ERC\ntokenSale",
    "Critical-points": "Critical program points are 11+  \n20+ \n24+ \n51+   \n51+ \n145+ \n152+  \n168+ \n174+ ",
    "invariants": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);\n",
    "critical-invariants": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);",
    "ranks": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);",
    "vulnerabilities": "integer over/underflow\natomicity violation\nincorrect visibility/ownership"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "The transaction context is asset swapping\n",
    "Critical-points": "Critical program points are 17+ \n21+  \n35+ \n37+",
    "invariants": "17+ require(id < nextPositionID, \"bad position id\");\n17+ require(positions[id].goblin == goblin, \"bad position goblin\");\n17+ require(positions[id].owner == msg.sender, \"not position owner\");\n21+  require(config.isGoblin(goblin), \"not a goblin\");\n21+  require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n35+ require(debt >= config.minDebtSize(), \"too small debt size\");\n37+  require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n",
    "critical-invariants": "17+ require(id < nextPositionID, \"bad position id\");",
    "ranks": "17+ require(id < nextPositionID, \"bad position id\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+\n44+",
    "invariants": "13+  require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "critical-invariants": "44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "ranks": "44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "vulnerabilities": "reentrancy\nbusiness logic flaw"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 124+ \n137+ \n150+  \n171+ \n201+\n233+ \n284+ \n286+\n338+ \n341+\n544+ \n559+  \n576+\n655+ \n678+  \n715+ \n733+\n757+ \n797+ ",
    "invariants": "124+  require(c >= a, \"SafeMath: addition overflow\");\n137+  return sub(a, b, \"SafeMath: subtraction overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n576+  require(account != address(0), \"ERC20: burn from the zero address\");\n595+  require(owner != address(0), \"ERC20: approve from the zero address\");\n595+  require(spender != address(0), \"ERC20: approve to the zero address\");\n655+ require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n678+   require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n715+ require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n733+ require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n757+ require(localCounter == _guardCounter);\n797+ assert(token != address(this)); \n797+ assert(token != user); \n\n",
    "critical-invariants": "124+  require(c >= a, \"SafeMath: addition overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n186+ return div(a, b, \"SafeMath: division by zero\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n797+ assert(token != address(this)); \n797+ assert(token != user); ",
    "ranks": "124+  require(c >= a, \"SafeMath: addition overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n186+ return div(a, b, \"SafeMath: division by zero\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n797+ assert(token != address(this)); \n797+ assert(token != user); ",
    "vulnerabilities": "integer over/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 13+\n23+\n42+",
    "invariants": "13+ require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "critical-invariants": "23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "ranks": "23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "vulnerabilities": "reentrancy \ninteger over/underflow"
  },
  {
    "code": "1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\n\n2 // File contracts/v0.4/token/linkERC20Basic.sol\n\n3 pragma solidity ^0.4.11;\n\n\n4 /**\n5  * @title ERC20Basic",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 88+  \n97+\n101+  ",
    "invariants": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);\n",
    "critical-invariants": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);",
    "ranks": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);",
    "vulnerabilities": "arithmetic flaw\nreentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "The transaction context is cross-function\nmoney market",
    "Critical-points": "Critical program points are 18+  \n33+ \n44+  \n45+  \n61+  \n63+",
    "invariants": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n",
    "critical-invariants": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");",
    "ranks": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 32+  \n89+ ",
    "invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n89+  require(canTransfer, \"E046\");\n",
    "critical-invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "ranks": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n4 import { LibAsset } from \"../Libraries/LibAsset.sol\";\n5 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n6 import { LibSwap } from \"../Libraries/LibSwap.sol\";\n7 import { ICBridge } from \"../Interfaces/ICBridge.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 58+ \n92+  \n101+\n125+  \n191+  ",
    "invariants": "58+ require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n92+  require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n101+ require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n125+  require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n191+  assert(!invokeSwap);",
    "critical-invariants": "191+  assert(!invokeSwap);",
    "ranks": "191+  assert(!invokeSwap);",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 26+",
    "invariants": "26+   assert(_committedRoot != 0); ",
    "critical-invariants": "26+   assert(_committedRoot != 0); ",
    "ranks": "26+   assert(_committedRoot != 0); ",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 29+  \n30+  \n48+  \n51+  \n54+ \n55+ \n83+ \n106+  \n108+\n112+ \n117+  \n118+ \n121+ \n139+ \n143+ \n145+",
    "invariants": "29+  require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n30+  require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\n30+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");\n48+  require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");\n51+  require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");\n54+ require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n55+ require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\n55+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");\n83+ require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\");\n106+  require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n108+  require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n112+  require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n117+  require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n117+ require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n118+  require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n121+  require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n139+ assert(_method != “f1121318093”); \n143+ require(success == true, \"EthCrossChain call business contract failed\");\n145+  require(res == true, \"EthCrossChain call business contract return is not true\");",
    "critical-invariants": "139+ assert(_method != “f1121318093”); \n",
    "ranks": "139+ assert(_method != “f1121318093”); \n",
    "vulnerabilities": "incorrect visibility/ownership\nID uniqueness violation\nbusiness logic flaw\ninconsistent state update"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 43+    \n83+  ",
    "invariants": "43+    require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "critical-invariants": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "ranks": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are nan",
    "invariants": "43+  require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+  require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {x++;}",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (x == a + 1);",
    "critical-invariants": "7+ assert (x == a + 1);",
    "ranks": "7+ assert (x == a + 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // Possible bug:\n3 // In this test, ctor D is NOT called twice -\n4 // Only ctor C is called\n5 // compare with ConstructorChaining2_fail.sol\n\n6 contract D {\n7         uint a;",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 14+",
    "invariants": "14+ assert (a == x + 2);",
    "critical-invariants": "14+ assert (a == x + 2);",
    "ranks": "14+ assert (a == x + 2);",
    "vulnerabilities": "arithmetic flaw"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+  assert (a == 1);",
    "critical-invariants": "7+  assert (a == 1);",
    "ranks": "7+  assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract ArrayNestedFixedSize {\n\n2     // NOTE: the number of columns comes first in the declaration!\n3     uint[3][2] a;\n4     bool[2][2] aa;\n\n5     constructor() {\n6       _;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 20+ \n",
    "invariants": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "critical-invariants": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "ranks": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayFixedSize {\n\n3     uint[2] a;\n\n4     constructor() public {}\n\n5     function test() public {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "critical-invariants": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "ranks": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+",
    "invariants": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);\n9+ assert (sa.length == 2);",
    "critical-invariants": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);",
    "ranks": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;",
    "transaction-context": "The transaction context is loop",
    "Critical-points": "Critical program points are 7+  \n15+",
    "invariants": "7+  assert (a[0] == 0);\n7+ assert (a[1] == 1);\n15+ assert (b[j] == j);\n",
    "critical-invariants": "7+  assert (a[0] == 0);\n7+ assert (a[1] == 1);\n15+ assert (b[j] == j);",
    "ranks": "7+  assert (a[0] == 0);\n7+ assert (a[1] == 1);\n15+ assert (b[j] == j);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 8+ \n10+  \n11+ \n",
    "invariants": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);\n",
    "critical-invariants": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);",
    "ranks": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 8+",
    "invariants": "8+  assert (x == a + 1);",
    "critical-invariants": "8+  assert (x == a + 1);",
    "ranks": "8+  assert (x == a + 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+ ",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+   ",
    "invariants": "7+   assert (a == 1);",
    "critical-invariants": "7+   assert (a == 1);",
    "ranks": "7+   assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Consts {\n\n4     constructor () public {\n5         uint a;\n6         address b;\n7         address c;",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+",
    "invariants": "10+ assert(b != c);",
    "critical-invariants": "10+ assert(b != c);",
    "ranks": "10+ assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+\n11+",
    "invariants": "8+  assert (a == 1 || a == 2);\n11+ assert (a == 1 || a == 2);",
    "critical-invariants": "11+ assert (a == 1 || a == 2);",
    "ranks": "11+ assert (a == 1 || a == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;",
    "transaction-context": "The transaction context is loop\n",
    "Critical-points": "Critical program points are 9+",
    "invariants": "9+   assert (sum == 1);",
    "critical-invariants": "9+   assert (sum == 1);",
    "ranks": "9+   assert (sum == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Arithmetics {\n\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\n4         c = _a + _b;\n      \n5     }\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 4+ \n7+ \n10+ \n13+ ",
    "invariants": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "critical-invariants": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "ranks": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "vulnerabilities": "arithmetic flaw \ninteger overflow/underflow\n"
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0; contract Crowdsale {\n2     uint raised;\n3     uint goal;\n4     uint deadline;\n\n5     bool finished; // Instrumented.\n6     bool canceled; // Instrumented.\n\n7     constructor(uint _goal) public {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 16+ \n19+ \n22+ ",
    "invariants": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "critical-invariants": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "ranks": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "vulnerabilities": "atomicity violation \n"
  },
  {
    "code": "1 contract JAY is ERC20, Ownable {\n2     using SafeMath for uint256;\n3     AggregatorV3Interface internal priceFeed;\n\n4     address private dev;\n5     uint256 public constant MIN = 1000;\n6     bool private start = false;\n7     bool private lockDev = false;\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 24+  \n46+       \n47+   \n100+       \n102+  \n104+ \n140+  \n143+   \n144+ \n148+    \n150+ ",
    "invariants": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");\n140+   require(value > MIN, \"Dude tf\");\n143+   require(success, \"ETH Transfer failed.\");\n144+   require(success2, \"ETH Transfer failed.\");\n148+   require(msg.value > MIN, \"must trade over min\");\n148+   require(start, \"Not started!\");\n150+ require(success, \"ETH Transfer failed.\");",
    "critical-invariants": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");",
    "ranks": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");",
    "vulnerabilities": "atomicity violation \narithmetic flaw\nintefer overflow/underflow\ninconsistent state update\nbusiness logic flaw"
  },
  {
    "code": "1 pragma solidity >=0.6.0 <0.8.0;\n\n2 import \"./openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n3 import \"./openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n4 import \"./openzeppelin/contracts/token/ERC20/IERC20.sol\";\n5 import \"./openzeppelin/contracts/math/SafeMath.sol\";\n6 import \"./openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n7 import \"./openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n8 // import \"hardhat/consolse.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 19+ \n76+",
    "invariants": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "critical-invariants": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "ranks": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "vulnerabilities": "incorrect visibility/ownership\narithmetic flaw"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./ComptrollerInterface.sol\";\n3 import \"./CTokenInterfaces.sol\";\n4 import \"./ErrorReporter.sol\";\n5 import \"./Exponential.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./EIP20NonStandardInterface.sol\";\n8 import \"./InterestRateModel.sol\";",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 16+ \n17+   \n20+  \n24+ \n104+\n107+  \n133+\n195+ \n774+  \n828+  ",
    "invariants": "16+   require(msg.sender == admin, \"only admin may initialize the market\");\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n17+   require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n20+  require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n24+  require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n104+ require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n107+   require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n133+ require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n774+  require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n828+  require(_notEntered, \"re-entered\");",
    "critical-invariants": "16+   require(msg.sender == admin, \"only admin may initialize the market\");\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n17+   require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n774+  require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");",
    "ranks": "16+   require(msg.sender == admin, \"only admin may initialize the market\");\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n17+   require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n774+  require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");",
    "vulnerabilities": "reentrancy\ninconsistent state update \nID uniqueness violation\narithmetic flaw\nincorrect visibility/ownership "
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n3 import \"./ERC3156FlashLenderInterface.sol\";\n4 import \"./ERC3156FlashBorrowerInterface.sol\";\n\n5 /**\n6  * @title Cream's CCollateralCapErc20 Contract\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 44+   \n190+  \n194+ \n206+ \n217+ \n491+ \n552+  \n584+  \n586+  ",
    "invariants": "44+   require(err == 0, \"mint failed\");\n190+  require(\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\n                keccak256(\"ERC3156FlashBorrowerInterface.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n206+ require(msg.sender == address(comptroller), \"comptroller only\");\n217+ require(msg.sender == address(comptroller), \"comptroller only\");\n491+ require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");\n586+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n",
    "critical-invariants": "44+   require(err == 0, \"mint failed\");\n190+  require(\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\n                keccak256(\"ERC3156FlashBorrowerInterface.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n491+ require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");\n586+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");",
    "ranks": "44+   require(err == 0, \"mint failed\");\n190+  require(\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\n                keccak256(\"ERC3156FlashBorrowerInterface.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n491+ require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");\n586+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");",
    "vulnerabilities": "cross bridge\ninconsistent state update \nID uniqueness violation\narithmetic flaw"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n\n3 /**\n4  * @title Compound's CErc20 Contract\n5  * @notice CTokens which wrap an EIP-20 underlying\n6  * @author Compound\n7  */",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 42+  \n50+ \n59+  \n67+ \n76+\n85+ \n100+\n154+\n192+\n209+\n210+ \n253+  \n260+   \n315+ \n336+  \n343+  \n352+  \n390+  \n402+  ",
    "invariants": "42+  require(err == 0, \"mint failed\");\n50+  require(redeemInternal(redeemTokens, false) == 0, \"redeem failed\");\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n67+  require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n76+  require(err == 0, \"repay failed\");\n85+  require(err == 0, \"repay behalf failed\");\n100+ require(err == 0, \"liquidate borrow failed\");\n154+ require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n192+  require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \"comptroller rejection\");\n210+ require(src != dst, \"bad input\");\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n260+   require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n336+  require(comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens) == 0, \"comptroller rejection\");\n343+  require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n352+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n390+  require(\n            comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\n            \"comptroller rejection\"\n        );\n402+   require(borrower != liquidator, \"invalid account pair\");",
    "critical-invariants": "42+  require(err == 0, \"mint failed\");\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n67+  require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n76+  require(err == 0, \"repay failed\");\n192+  require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \"comptroller rejection\");\n210+ require(src != dst, \"bad input\");\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n260+   require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n\n343+  require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n352+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n390+  require(  comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\"comptroller rejection\");\n402+   require(borrower != liquidator, \"invalid account pair\");",
    "ranks": "42+  require(err == 0, \"mint failed\");\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n67+  require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n76+  require(err == 0, \"repay failed\");\n192+  require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \"comptroller rejection\");\n210+ require(src != dst, \"bad input\");\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n260+   require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n\n343+  require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n352+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n390+  require(  comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\"comptroller rejection\");\n402+   require(borrower != liquidator, \"invalid account pair\");",
    "vulnerabilities": "cross bridge\ninconsistent state update \nID uniqueness violation\narithmetic flaw"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       (a,  b) = (1, 3);\n  ",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n9+ \n\n",
    "invariants": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);\n",
    "critical-invariants": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);",
    "ranks": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-05-09\n3 */\n\n4 pragma solidity ^0.4.21;\n\n\n5 /**\n6  * @title SafeMath",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 17+  \n32+ \n39+ \n84+ \n85+ ",
    "invariants": "17+  assert(c / a == b);\n32+ assert(b <= a);\n39+  assert(c >= a);\n84+  require(_to != address(0));\n85+ require(_value <= balances[msg.sender]);",
    "critical-invariants": "17+  assert(c / a == b);\n32+ assert(b <= a);\n39+  assert(c >= a);\n84+  require(_to != address(0));\n85+ require(_value <= balances[msg.sender]);",
    "ranks": "17+  assert(c / a == b);\n32+ assert(b <= a);\n39+  assert(c >= a);\n84+  require(_to != address(0));\n85+ require(_value <= balances[msg.sender]);",
    "vulnerabilities": "arithmetic flaw \ninteger overflow/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "1 pragma solidity ^0.4.16;\n \n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n \n3 contract TokenERC20 {\n4     string public name;\n5     string public symbol;\n6     uint8 public decimals = 18;  // 18 \n7     uint256 public totalSupply;",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 51+ \n58+  \n59+ ",
    "invariants": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "critical-invariants": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "ranks": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract SafeMath {\n\n2     function safeAdd(uint a, uint b) public pure returns (uint c) {\n3         c = a + b;\n4         require(c >= a);\n5     }\n\n6     function safeSub(uint a, uint b) public pure returns (uint c) {\n7         require(b <= a);",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 4+ \n7+ \n12+ \n15+ ",
    "invariants": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "critical-invariants": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "ranks": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // array variable copy breaks\n\n2 contract ArrayLength {\n3     uint[12] a;\n\n4     constructor (uint[12] memory d) public\n5     {\n6         require (d[1] == 5);\n7         a = d;       ",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 6+ \n8+  ",
    "invariants": "6+ require (d[1] == 5);\n8+  assert (d[1] == 5);",
    "critical-invariants": "8+  assert (d[1] == 5);",
    "ranks": "8+  assert (d[1] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n22+  \n23+  \n24+\n25+ \n26+  \n27+ ",
    "invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);\n",
    "critical-invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "ranks": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ ",
    "invariants": "7+ assert (b[1] == 22);",
    "critical-invariants": "7+ assert (b[1] == 22);",
    "ranks": "7+ assert (b[1] == 22);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.5.2;\n\n2 // Tests that function with inline assembly generates non-det result\n3 contract AssemblyTest\n4 {\n5         bool b;\n6         int x;\n7     constructor () public {\n8   }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 12+ ",
    "invariants": "12+ assert(false);",
    "critical-invariants": "12+ assert(false);",
    "ranks": "12+ assert(false);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+ \n13+ ",
    "invariants": "9+ assert (a == 1 || a == 2);\n13+ assert (a == 1 || a == 2);",
    "critical-invariants": "13+ assert (a == 1 || a == 2);",
    "ranks": "13+ assert (a == 1 || a == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+ ",
    "invariants": "10+ assert(b != c);",
    "critical-invariants": "10+ assert(b != c);",
    "ranks": "10+ assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+ ",
    "invariants": "8+ assert (a == 1);",
    "critical-invariants": "8+ assert (a == 1);",
    "ranks": "8+ assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 15+",
    "invariants": "15+ assert (x == a + 2);",
    "critical-invariants": "15+ assert (x == a + 2);",
    "ranks": "15+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // Shows that constructor chaining still has a bug\n2 // D constructor is called twice - see trace in corral.txt:\n3 // ctor D {x = 1}\n4 // ctor D {x = 1}\n5 // ctor B\n6 // ctor C\n\n7 contract D {\n8         uint x;",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 16+ ",
    "invariants": "16+ assert (x != 1); ",
    "critical-invariants": "16+ assert (x != 1); ",
    "ranks": "16+ assert (x != 1); ",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+   \n10+      \n13+    \n14+     \n16+     \n17+      ",
    "invariants": "9+       assert (a == 1);\n10+       assert (b == 3);\n13+       assert (a == 4);\n14+       assert (b == 40);\n16+       assert (a == 5);\n17+       assert (b == 55);\n",
    "critical-invariants": "9+       assert (a == 1);\n10+       assert (b == 3);\n13+       assert (a == 4);\n14+       assert (b == 40);\n16+       assert (a == 5);\n17+       assert (b == 55);",
    "ranks": "9+       assert (a == 1);\n10+       assert (b == 3);\n13+       assert (a == 4);\n14+       assert (b == 40);\n16+       assert (a == 5);\n17+       assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;",
    "transaction-context": "The transaction context is loop\ncross function",
    "Critical-points": "Critical program points are 8+ \n9+\n18+ \n",
    "invariants": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);\n",
    "critical-invariants": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);",
    "ranks": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 5+ \n10+ \n11+ \n12+  ",
    "invariants": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "critical-invariants": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "ranks": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayFixedSize {\n\n3     uint[2] a;\n\n4     constructor() public {}\n\n5     function test() public {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+ \n9+ ",
    "invariants": "8+ assert(a[0] == 1);\n9+ assert(a[1] == 2);",
    "critical-invariants": "8+ assert(a[0] == 1);\n9+ assert(a[1] == 2);",
    "ranks": "8+ assert(a[0] == 1);\n9+ assert(a[1] == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1  contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ ",
    "invariants": "7+ assert (b[1] == 22);",
    "critical-invariants": "7+ assert (b[1] == 22);",
    "ranks": "7+ assert (b[1] == 22);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n22+ \n23+ \n24+\n25+ \n26+ \n27+ ",
    "invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "critical-invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "ranks": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (b[1] == 22);",
    "critical-invariants": "7+ assert (b[1] == 22);",
    "ranks": "7+ assert (b[1] == 22);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+  ",
    "invariants": "10+  assert(b != c);",
    "critical-invariants": "10+  assert(b != c);",
    "ranks": "10+  assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+ ",
    "invariants": "8+ assert (a == 1);",
    "critical-invariants": "8+ assert (a == 1);",
    "ranks": "8+ assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 33+ \n34+ \n92+  ",
    "invariants": "33+ require(amount > 0, \"Invalid amount\");\n34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n92+  require(canTransfer, \"E046\");\n",
    "critical-invariants": "34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");",
    "ranks": "34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 19+         \n35+        \n36+       \n37+       \n49+         \n51+        \n68+        \n69+       \n70+        ",
    "invariants": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "critical-invariants": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "ranks": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "vulnerabilities": "incorrect visibility/ownership\nreentrancy"
  },
  {
    "code": "1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\n\n2 // File contracts/v0.4/token/linkERC20Basic.sol\n\n3 pragma solidity ^0.4.11;\n\n\n4 /**\n5  * @title ERC20Basic",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are 89+    \n99+    \n104+    ",
    "invariants": "89+    assert(a == 0 || c / a == b);\n99+     assert(b <= a);\n104+    assert(c >= a);",
    "critical-invariants": "89+    assert(a == 0 || c / a == b);\n99+     assert(b <= a);\n104+    assert(c >= a);",
    "ranks": "89+    assert(a == 0 || c / a == b);\n99+     assert(b <= a);\n104+    assert(c >= a);",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 contract ModifierEntrancy {\n\n3   mapping (address => uint) public tokenBalance;\n4   string constant name = \"Nu Token\";\n5   Bank bank;\n  \n6   constructor() public{",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 15+ \n20+  ",
    "invariants": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());\n20+  require(tokenBalance[msg.sender] == 0);\n\n",
    "critical-invariants": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "ranks": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 14+\n25+\n45+",
    "invariants": "14+  require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n25+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n45+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "critical-invariants": "25+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n45+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "ranks": "25+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n45+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 18+       \n19+ \n20+     \n24+       \n25+        \n31+       \n40+         \n43+    ",
    "invariants": "18+         require(id < nextPositionID, \"bad position id\");\n19+         require(positions[id].goblin == goblin, \"bad position goblin\");\n20+         require(positions[id].owner == msg.sender, \"not position owner\");\n24+         require(config.isGoblin(goblin), \"not a goblin\");\n25+        require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n31+        require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");\n40+         require(debt >= config.minDebtSize(), \"too small debt size\");\n43+         require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");",
    "critical-invariants": "18+         require(id < nextPositionID, \"bad position id\");\n",
    "ranks": "18+         require(id < nextPositionID, \"bad position id\");\n",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n\n3    function get_a()  public returns (uint) {\n4        return 2;\n5    }\n6 }\n",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 33+",
    "invariants": "33+  assert (y == 2*x + 4); ",
    "critical-invariants": "33+  assert (y == 2*x + 4);",
    "ranks": "33+  assert (y == 2*x + 4);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopNestedWhile {\n\n3     uint[2][2] a;\n\n4     function testNestedWhileLoop() public {\n5         uint i = 0;\n6         while (i < 2) {",
    "transaction-context": "The transaction context is loop",
    "Critical-points": "Critical program points are 14+      \n15+       \n16+      \n17+       ",
    "invariants": "14+        assert (a[0][0] == 0);\n15+        assert (a[0][1] == 1);\n16+         assert (a[1][0] == 2);\n17+         assert (a[1][1] == 3);",
    "critical-invariants": "14+        assert (a[0][0] == 0);\n15+        assert (a[0][1] == 1);\n16+         assert (a[1][0] == 2);\n17+         assert (a[1][1] == 3);",
    "ranks": "14+        assert (a[0][0] == 0);\n15+        assert (a[0][1] == 1);\n16+         assert (a[1][0] == 2);\n17+         assert (a[1][1] == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract MappingNested {\n\n3     mapping (uint => mapping (uint => uint)) m;\n4     mapping (uint => uint[]) n;\n5     uint[] p;\n  \n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+         \n11+      \n12+        \n15+        \n16+\n17+         ",
    "invariants": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);\n12+         assert (n[0].length == 0);\n15+         assert (n[0].length == 2);\n16+         assert (n[1].length == 0); \n17+         assert (p.length == 0); ",
    "critical-invariants": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);",
    "ranks": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 //simple library with no internal state\n\n3 library Lib {\n4     function add(uint _a, uint _b) public view returns (uint r) {\n5         address x = address(this);\n6         assert(x == msg.sender);\n7         r = _a + _b;",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 6+\n16+",
    "invariants": "6+ assert(x == msg.sender);\n16+ assert (z == 3);",
    "critical-invariants": "16+ assert (z == 3);",
    "ranks": "16+ assert (z == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 25+  \n34+  \n40+ \n41+    \n42+",
    "invariants": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "critical-invariants": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "ranks": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 21+  \n22+  ",
    "invariants": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "critical-invariants": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "ranks": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\"; //import \"../../math/SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n5 contract ERC20 is IERC20 {\n6     using SafeMath for uint256;\n",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 11+ \n22+  \n23+  \n24+  \n25+  \n49+  \n50+  \n62+  \n81+ \n82+ \n91+",
    "invariants": "11+ require(msg.sender != address(0));\n22+  _transfer(msg.sender, recipient, amount);\n23+  assert (_balances[msg.sender] + _balances[recipient]) == _balances[msg.sender] + _balances[recipient];\n24+  assert (msg.sender == recipient ||  _balances[msg.sender] == _balances[msg.sender] - amount);\n25+  assert (_balances[recipient] >= _balances[recipient]);\n49+  require(sender != address(0), \"ERC20: transfer from the zero address\");\n50+  require(recipient != address(0), \"ERC20: transfer to the zero address\");\n62+  require(account != address(0), \"ERC20: burn from the zero address\");\n81+ require(owner != address(0), \"ERC20: approve from the zero address\");\n82+ require(spender != address(0), \"ERC20: approve to the zero address\");\n91+ assert(_totalSupply == VeriSol.SumMapping(_balances);",
    "critical-invariants": "91+ assert(_totalSupply == VeriSol.SumMapping(_balances);",
    "ranks": "91+ assert(_totalSupply == VeriSol.SumMapping(_balances);",
    "vulnerabilities": "arithmetic flaw"
  },
  {
    "code": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 12+         \n63+        \n101+                                    \n102+                 \n103+      \n104+                          \n105+      \n140+   \n141+ \n142+   \n143+     \n144+       \n145+         \n157+         \n158+           \n159+       \n277+       \n278+      \n332+     \n342+     \n347+     ",
    "invariants": "12+         require(msg.sender == owner);\n63+         require(!paused);\n101+         require(_to != 0x0);                             \n102+         require(balanceOf[_from] >= _value);                \n103+         require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+         require(!frozenAccount[_from]);                     \n105+         require(!frozenAccount[_to]);   \n140+         require(investor != 0x0);  \n141+         require(validPurchase()); \n142+         require(maxEtherInvestment >= msg.value); \n143+        require(balanceOf[investor] <= maxTokens); \n144+         require(amountRaised <= fundingGoal); \n145+         require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159+       require(pylonSelled + tokens <= totalTokensToSend);\n277+       require(pylonSelled + tokens <= bonusCap); \n278+      require(balanceOf[investor] + tokens <= maxTokens); \n332+    assert(a == 0 || c / a == b);\n342+     assert(b <= a);\n347+     assert(c >= a);",
    "critical-invariants": "63+         require(!paused);\n101+       require(_to != 0x0);                             \n102+       require(balanceOf[_from] >= _value);                \n103+       require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+       require(!frozenAccount[_from]);                     \n105+       require(!frozenAccount[_to]);   \n140+       require(investor != 0x0);  \n141+       require(validPurchase()); \n142+       require(maxEtherInvestment >= msg.value); \n143+       require(balanceOf[investor] <= maxTokens); \n144+       require(amountRaised <= fundingGoal); \n145+       require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n277       require(pylonSelled + tokens <= bonusCap); \n278       require(balanceOf[investor] + tokens <= maxTokens); ",
    "ranks": "63+         require(!paused);\n101+       require(_to != 0x0);                             \n102+       require(balanceOf[_from] >= _value);                \n103+       require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+       require(!frozenAccount[_from]);                     \n105+       require(!frozenAccount[_to]);   \n140+       require(investor != 0x0);  \n141+       require(validPurchase()); \n142+       require(maxEtherInvestment >= msg.value); \n143+       require(balanceOf[investor] <= maxTokens); \n144+       require(amountRaised <= fundingGoal); \n145+       require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n277       require(pylonSelled + tokens <= bonusCap); \n278       require(balanceOf[investor] + tokens <= maxTokens); ",
    "vulnerabilities": "incorrect visibility/ownership\ninteger overflow/underflow \narithmetic flaw \n"
  },
  {
    "code": "\n1 pragma solidity ^0.4.2;\n2 contract owned {\n3     address public owner;\n\n4     function owned() {\n5         owner = msg.sender;\n6     }\n",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 7+\n125+ \n131+",
    "invariants": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount );",
    "critical-invariants": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount ) ",
    "ranks": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount ) ",
    "vulnerabilities": "integer overflow/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n\n2 contract Token {\n3     uint256 public totalSupply;\n4     function balanceOf(address _owner) constant returns (uint256 balance);\n5     function transfer(address _to, uint256 _value) returns (bool success);\n6     function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n7     function approve(address _spender, uint256 _value) returns (bool success);\n8     function allowance(address _owner, address _spender) constant returns (uint256 remaining);",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 12+ \n22+   \n62+ \n69+",
    "invariants": "12+ assert(!disabled);\n22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n62+ assert(msg.sender == owner);\n69+ assert(msg.sender == owner);",
    "critical-invariants": "22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n69+ assert(msg.sender == owner);",
    "ranks": "22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n69+ assert(msg.sender == owner);",
    "vulnerabilities": "incorrect invisibility/ownership\natomicity violation\ninteger overflow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract SafeMath {\n\n3     function safeAdd(uint a, uint b) public pure returns (uint c) {\n4         c = a + b;\n\n5     }",
    "transaction-context": "The transaction context is ERC \nfunds transfer",
    "Critical-points": "Critical program points are 4+ \n6+ \n10+\n12+\n71+",
    "invariants": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "critical-invariants": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "ranks": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "vulnerabilities": "arithmetic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n\n2 contract ERC20Interface {\n3     function totalSupply() public view returns (uint);\n4     function balanceOf(address tokenOwner) public view returns (uint balance);\n5     function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n6     function transfer(address to, uint tokens) public returns (bool success);\n7     function approve(address spender, uint tokens) public returns (bool success);",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 15+ \n17+ \n21+ \n",
    "invariants": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);\n",
    "critical-invariants": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);",
    "ranks": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.4.4;\n\n2 contract Token {\n\n3     function totalSupply() constant returns (uint256 supply) {}\n4     function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n5     function transfer(address _to, uint256 _value) returns (bool success) {}\n",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 13+ ",
    "invariants": "13+ assert(balances[msg.sender] >= _value);\n13+ assert( _value > 0); \n",
    "critical-invariants": "13+ assert(balances[msg.sender] >= _value);\n13+ assert( _value > 0); ",
    "ranks": "13+ assert(balances[msg.sender] >= _value);\n13+ assert( _value > 0); ",
    "vulnerabilities": "integer overflow/underflow\narithmetic flaw"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 21+ \n40+ \n42+ \n44+ \n48+ \n57+ \n59+ \n64+\n87+\n120+\n123+ \n125+ \n136+  \n165+ ",
    "invariants": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);\n",
    "critical-invariants": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);",
    "ranks": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);",
    "vulnerabilities": "incorrect invisibility/ownership\nariithmetic flaw"
  },
  {
    "code": "nan\nWhat's the transaction context of the contract?\n",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are nan",
    "invariants": "nan",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n6 import \"./interfaces/IStakingBank.sol\";\n7 import \"./BaseChain.sol\";\n",
    "transaction-context": "The transaction context is cross bridge\nfunds transfer",
    "Critical-points": "Critical program points are 74+ \n76+ \n94+",
    "invariants": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp + padding < block.timestamp, \"do not spam\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "critical-invariants": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "ranks": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "vulnerabilities": "integer over/underflow\nincorrect visibility/ownership\narithmetic flaw"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; ",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 13+ \n20+  \n29+ ",
    "invariants": "13+ require(winningId == 0, \"already drawn\");\n13+ require(!drawingPhase, \"drawing\");\n20+  require(drawingPhase, \"not drawing\");\n29+  require(winningId == 0, \"already drawn\");\n29+ require(!drawingPhase, \"drawing\");",
    "critical-invariants": "13+ require(winningId == 0, \"already drawn\");\n13+ require(!drawingPhase, \"drawing\");\n20+  require(drawingPhase, \"not drawing\");\n29+  require(winningId == 0, \"already drawn\");\n29+ require(!drawingPhase, \"drawing\");",
    "ranks": "13+ require(winningId == 0, \"already drawn\");\n13+ require(!drawingPhase, \"drawing\");\n20+  require(drawingPhase, \"not drawing\");\n29+  require(winningId == 0, \"already drawn\");\n29+ require(!drawingPhase, \"drawing\");",
    "vulnerabilities": "atomicity violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; ",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 19+  ",
    "invariants": "19+   require(!drawingPhase, \"drawing\");",
    "critical-invariants": "19+   require(!drawingPhase, \"drawing\");",
    "ranks": "19+   require(!drawingPhase, \"drawing\");",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0;\n2 \n3 contract SimpleDAO {\n4     mapping (address => uint) public credit;\n5     constructor() public {\n6     }\n7     function donate(address to, uint amount) payable public {\n8         credit[to] += amount;\n9     }",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 22+ ",
    "invariants": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "critical-invariants": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "ranks": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 ragma solidity ^0.5.0;\n2 \n3 import \"./IERC20.sol\";\n4 import \"./SafeMath.sol\";\n5 import \"./Libraries/VeriSolContracts.sol\"; //change \n6 \n7 \n8 contract ERC20 is IERC20 {\n9 ",
    "transaction-context": "The transaction context is funds transfer\nERC",
    "Critical-points": "Critical program points are 31+ ",
    "invariants": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "critical-invariants": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "ranks": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 \n3 contract AssertFalse {\n4 \n5     function test1() public {\n6               _;\n7 \n8     }\n9 ",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 6+ \n",
    "invariants": "6+ assert (!false);\n",
    "critical-invariants": "6+ assert (!false);",
    "ranks": "6+ assert (!false);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract overflow{\n5     function transferProxy (address from, address to, uint\n6     value, uint fee) {  \n7         if (balance[from] < fee + value) revert();\n8 \n9         if (balance[to] + value < balance[to] ||",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 6+",
    "invariants": "6+  assert(fee + value != 0);\n",
    "critical-invariants": "6+  assert(fee + value != 0);",
    "ranks": "6+  assert(fee + value != 0);",
    "vulnerabilities": "integer overflow/underflow"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract testSuicide{\n5         function initMultiowned(address[] _owners,\n6                             uint _required){\n7         if (m_numOwners > 0) throw;\n8         m_numOwners = _owners.length + 1;\n9         m_owners[1] = uint(msg.sender);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 15+",
    "invariants": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "critical-invariants": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "ranks": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "vulnerabilities": "suicidal contracts"
  },
  {
    "code": "1 / SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract ether{\n5         function payout(address[] recipients,\n6                         uint256[] amounts) {\n7         require(recipients.length==amounts.length);\n8         for (uint i = 0; i < recipients.length; i++) {\n9         recipients[i].send(amounts[i]);",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 6+\n",
    "invariants": "6+  assert(address(this)==msg.sender);\n",
    "critical-invariants": "6+  assert(address(this)==msg.sender);\n",
    "ranks": "6+  assert(address(this)==msg.sender);\n",
    "vulnerabilities": "ether leakage"
  },
  {
    "code": "1   // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n4 \n5 \n6 contract Chain  {\n7   IStakingBank public immutable stakingBank;\n8 \n9   event LogMint(address indexed minter, uint256 blockId, uint256 staked, uint256 power);",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 30+",
    "invariants": "30+ assert(msg.sender == _contractRegistry);\n30+ assert(msg.sender == _contractRegistry);",
    "critical-invariants": "30+ assert(msg.sender == _contractRegistry);",
    "ranks": "30+ assert(msg.sender == _contractRegistry);",
    "vulnerabilities": "incorrect visibility/ownership"
  },
  {
    "code": "1 //SPDX-License-Identifier: GPL-3.0\n2 pragma solidity 0.8.4;\n3 \n4 import \"../libraries/MathLib.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n7 import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n8 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n9 import \"../interfaces/IExchangeFactory.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 147+\n194+\n",
    "invariants": "147+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "critical-invariants": "194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "ranks": "194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.5.0;\n\n3 interface IERC20 {\n4     event Approval(address indexed owner, address indexed spender, uint value);\n5     event Transfer(address indexed from, address indexed to, uint value);\n\n6     function name() external view returns (string memory);\n7     function symbol() external view returns (string memory);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 63+\n73+\n",
    "invariants": "63+ assert(Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair))) == USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)));\n73+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack!\");\n",
    "critical-invariants": "73+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack!\");",
    "ranks": "73+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack!\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n3 \n4  contract Swap {\n5          IERC20 public WEI;\n6          IERC20 public USD;\n7          IUniswapV2Pair public pair; \n8          mapping(address => uint) public debt;\n9          mapping(address => uint) public collateral;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 13+\n23+\n",
    "invariants": "13+ assert(Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair))) == USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)));\n23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n",
    "critical-invariants": "23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n",
    "ranks": "23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity 0.8.4;\n3 import \"./IOracle.sol\";\n4 \n5 \n6 interface IAggregator {\n7     function latestAnswer() external view returns (int256 answer);\n8 }\n9 ",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 24+ \n26+ \n\n\n",
    "invariants": "24+ assert(Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) == price);\n26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n",
    "critical-invariants": "26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n",
    "ranks": "26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity 0.8.4;\n3 import \"./IOracle.sol\";\n4 \n5 \n6 interface IAggregator {\n7     function latestAnswer() external view returns (int256 answer);\n8 }\n9 ",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 24+ \n26+ \n\n\n",
    "invariants": "24+ assert(Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) == price);\n26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n",
    "critical-invariants": "26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");",
    "ranks": "26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 \n3 pragma solidity 0.6.12;\n4 \n5 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"../LPToken.sol\";\n8 import \"../interfaces/ISwap.sol\";\n9 import \"../MathUtils.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 110+ \n186+\n",
    "invariants": "110+ assert(Old(CalculateSwapUnderlyingInfo.dy) == dy);\n186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));\n",
    "critical-invariants": "186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));",
    "ranks": "186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "//hundred finance hack\n1 pragma solidity ^0.4.11;\n2 \n3 \n4 import \"./token/ERC677.sol\";\n5 import \"./token/ERC677Receiver.sol\";\n6 \n7 \n8 contract ERC677Token is ERC677 {",
    "transaction-context": "The transaction context is ERC677",
    "Critical-points": "Critical program points are 44+ \n50+ \n\n",
    "invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "critical-invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "ranks": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "vulnerabilities": "reentrancy\natomicity violation"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 \n4 import \"./token/ERC677.sol\";\n5 import \"./token/ERC677Receiver.sol\";\n6 \n7 \n8 contract ERC677Token is ERC677 {\n9 ",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 44+ \n50+ \n\n",
    "invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "critical-invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "ranks": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "vulnerabilities": "atomicity violation "
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 \n4 contract Ctoken{\n5     function transfer(address _to, uint256 _value) public returns (bool) {\n6         require(superTransfer(_to, _value));\n7         callAfterTransfer(msg.sender, _to, _value);\n8         return true;\n9     }",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 5+ \n11+\n",
    "invariants": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "critical-invariants": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "ranks": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 \n3 pragma solidity ^0.8.0;\n4 \n5 contract WUSDMaster{\n6 \n7         function stake(uint256 amount) external nonReentrant {\n8         require(amount <= maxStakeAmount, 'amount too high');\n9         usdt.safeTransferFrom(msg.sender, address(this), amount);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 8+ \n14+ \n",
    "invariants": "8+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n14+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "8+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n14+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k, \"watch out for flashloan attacks!\");\n",
    "ranks": "14+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k, \"watch out for flashloan attacks!\");\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.0;\n3 \n4 contract WUSDMaster is Ownable, Withdrawable, ReentrancyGuard {\n5     using SafeERC20 for IERC20;\n6     \n7     IWUSD public immutable wusd;\n8     IERC20 public usdt;\n9     IERC20 public wex;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 53+ \n59+ \n",
    "invariants": "53+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");\n",
    "critical-invariants": "59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");",
    "ranks": "59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.12;\n3 pragma experimental ABIEncoderV2;\n4 \n5 \n6 \n7 contract PancakeSwap is IStrategy, RewardsDistributionRecipient, ReentrancyGuard, Pausable {\n8     using SafeMath for uint256;\n9     using SafeBEP20 for IBEP20;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 47+\n181+ \n",
    "invariants": "47+ assert(Old(stakingToken.balanceOf(msg.sender)) == stakingToken.balanceOf(msg.sender));\n181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");",
    "ranks": "181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4  contract Lottery {\n5 \n6          mapping (address => mapping(uint64 => uint))\n7          public tickets;\n8          uint64 winningId; \n9          bool drawingPhase; ",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 17+ \n35+ \n",
    "invariants": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "critical-invariants": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "ranks": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "vulnerabilities": "atomicity violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4 contract testlock {\n5             \n6          function test_lock(\n7                  uint lock,\n8                  uint newLock,\n9                  uint amount",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 12+ \n",
    "invariants": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "critical-invariants": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "ranks": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw"
  },
  {
    "code": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 42+\n151+ \n",
    "invariants": "42+ assert(Old(reserve0) == reserve0);\n42+ assert(Old(reserve1) == reserve1);\n152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "critical-invariants": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "ranks": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 42+\n152+ \n",
    "invariants": "42+ assert(Old(reserve0) == reserve0);\n42+ assert(Old(reserve1) == reserve1);\n152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "critical-invariants": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "ranks": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;",
    "transaction-context": "The transaction context is loop",
    "Critical-points": "Critical program points are 9+ ",
    "invariants": "9+ assert (sum == 1);",
    "critical-invariants": "9+ assert (sum == 1);",
    "ranks": "9+ assert (sum == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 20+ ",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()!=42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()!=42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()!=42);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 library Math {\n    \n3     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4         if (a == 0) {\n5             return 0;\n6         }",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 8+\n15+\n20+",
    "invariants": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "critical-invariants": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "ranks": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.21;\n\n2 library SafeMath {\n\n\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     if (a == 0) {\n5       return 0;\n6     }",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 8+    \n15+    \n20+    \n44+     \n45+    ",
    "invariants": "8+     assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n44+    require(_to != address(0));\n45+     require(_value <= balances[msg.sender]);",
    "critical-invariants": "8+    assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n",
    "ranks": "8+    assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.25;\n\n2 library SafeMath {\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     uint256 c = a * b;\n5     return c;\n6   }\n\n7   function div(uint256 a, uint256 b) internal pure returns (uint256) {",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 4+ \n7+ \n11+  \n15+ \n19+  \n27+ \n47+ \n48+ \n72+ \n73+\n74+\n82+",
    "invariants": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n19+  assert(uint112(a) == a);\n27+ assert(uint128(a) == a);\n47+ require(_to != address(0));\n48+ require(_value <= balances[msg.sender]);\n72+ require(_to != address(0));\n73+ require(_value <= balances[_from]);\n74+ require(_value <= allowed[_from][msg.sender]);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "critical-invariants": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "ranks": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "vulnerabilities": "arithmetic flaw\ninteger over/underflow"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 26+ ",
    "invariants": "26+ assert(_committedRoot !=0); ",
    "critical-invariants": "26+ assert(_committedRoot !=0); ",
    "ranks": "26+ assert(_committedRoot !=0); ",
    "vulnerabilities": "cross bridge\nID Uniqueness violation"
  },
  {
    "code": "1 contract Vote {\n2    struct Proposal {\n3       uint160 sTime; address newOwner;\n4  }\n5   IERC20 votingToken;\n6   IERC20 LockedToken;\n7   address owner;\n8   Proposal proposal;\n",
    "transaction-context": "The transaction context is voting\nbidding proposal",
    "Critical-points": "Critical program points are 10+\n11+  \n14+ \n17+ \n20+ \n21+  \n23+ \n24+ \n",
    "invariants": "10+ require(proposal.sTime == 0, \"on-going proposal\");\n11+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n14+ require(proposal.sTime + 2 days > block.timestamp,\n \"voting has ended\");\n17+ assert(Old(votingToken.balanceOf(address(this))) ==votingToken.balanceOf(address(this)));\n20+ require(proposal.sTime != 0, \"no proposal\");\n21+  require(proposal.sTime + 2 days < block.timestamp,\n \"voting has not ended\");\n23+ require(votingToken.balanceOf(address(this))*2 >\nvotingToken.totalSupply(), \"vote failed\");\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n\n",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n\n",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1  contract Lottery {\n2  // user address -> lottery id -> count\n3  mapping (address => mapping(uint64 => uint))\n4  public tickets;\n5  uint64 winningId; // the winning id\n6  bool drawingPhase; // whether the owner is drawing\n\n7  // invoked every day to reset a round\n8  function reset() external onlyOwner {",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 13+  \n14+ \n23+  \n24+ \n25+  \n34+  \n",
    "invariants": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "critical-invariants": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "ranks": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw"
  },
  {
    "code": "1 // SPDX-License-Identifier: AGPL-3.0-or-later\n\n2 pragma solidity 0.8.9;\n\n3 import \"./BaseVault.sol\";\n4 ct STETHVault is BaseVault {\n5     using SafeERC20 for IERC20Metadata;\n6     using AuxMath for uint256;\n7     using AuxMath for AuxMath.Fractional;",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are 72+ \n115+ ",
    "invariants": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "critical-invariants": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "ranks": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "vulnerabilities": "vault\nasset swapping"
  },
  {
    "code": "1 abstract contract BaseVault is IVault, ERC20Permit, Capped {\n\n2      function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n3          if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n4          uint256 _totalAssets = totalAssets();\n5          for (uint256 i = startIndex; i < endIndex; i++) {\n6              uint256 currentAssets = _totalAssets + processedDeposits;\n7              DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);",
    "transaction-context": "The transaction context is vault \nasset swapping",
    "Critical-points": "Critical program points are 10+",
    "invariants": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "critical-invariants": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "ranks": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "vulnerabilities": "insufficient gas"
  },
  {
    "code": "1/ / SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract overflow{\n5         function pay(address[] recipients,\n6                         uint256[] amounts) {\n7         require(recipients.length==amounts.length);\n8         for (uint i = 0; i < recipients.length; i++) {\n9         recipients[i].send(amounts[i]);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 7+\n8+ ",
    "invariants": "7+ require(recipients.length==amounts.length);\n8+ assert(amounts[i] >= 0); ",
    "critical-invariants": "8+ assert(amounts[i] >= 0); ",
    "ranks": "8+ assert(amounts[i] >= 0); ",
    "vulnerabilities": "integer overflow/underflow\ninsufficient gas"
  },
  {
    "code": "1 / / SPDX-License-Identifier: MIT\n2   pragma solidity >=0.4.24 <0.6.0;\n3 contract AccountingError{\n\n4 function swap(uint amount1Out, address to) external {\n5      token1.transfer(to, amount1Out);\n6      IUniswapV2Callee(to).uniswapV2Call();\n\n7      uint balance0 = token0.balanceOf(address(this));",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 10+  \n",
    "invariants": "10+  assert( balance0Adj*balance1 >= reserve0* reserve1* 10000);\n",
    "critical-invariants": "10+  assert( balance0Adj*balance1 >= reserve0* reserve1* 10000);",
    "ranks": "10+  assert( balance0Adj*balance1 >= reserve0* reserve1* 10000);",
    "vulnerabilities": "arithmetic flaw\n"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3   contract Swap {\n4           IERC20 public WEI;\n5           IERC20 public USD;\n6           IUniswapV2Pair public pair; \n7           mapping(address => uint) public debt;\n8           mapping(address => uint) public collateral;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 8+ \n16+\n",
    "invariants": "8+ assert(Old(getPrice())==getPrice());\n16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "ranks": "16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "vulnerabilities": "price manipulation\ninconsistent state update"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3 contract etherleakge{\n4    function payout(address[] recipients,\n5                 uint256[] amounts) {\n6       require(recipients.length==amounts.length);\n7       for (uint i = 0; i < recipients.length; i++) {\n",
    "transaction-context": "The transaction context is payment ",
    "Critical-points": "Critical program points are 6+ ",
    "invariants": "6+ assert(msg.sender != 0);",
    "critical-invariants": "assert(msg.sender != 0);",
    "ranks": "assert(msg.sender != 0);",
    "vulnerabilities": "ether leakage"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "//votingToken is important for tracking \n1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../ERC1967/ERC1967Proxy.sol\";\n\n5 interface ITransparentUpgradeableProxy {\n6     event Upgraded(address indexed implementation);",
    "transaction-context": "The transaction context is proxy\nprotocol",
    "Critical-points": "Critical program points are 80+ \n92+ \n99+ \n108+ \n111+",
    "invariants": "80+ assert(Old(abi.encode(admin)) == abi.encode(admin)); \n92+ assert(Old(abi.encode(implementation)) == abi.encode(implementation));\n99+ assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));\n108+ assert(Old(newImplementation) == abi.decode(msg.data[4:], (address)));\n111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); \n",
    "critical-invariants": "111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); ",
    "ranks": "111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); ",
    "vulnerabilities": "incorrect visibility/ownership\ninconsistent state update\natomicity violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../../utils/math/SafeCast.sol\";\n5 import \"../extensions/IGovernorTimelock.sol\";\n6 import \"../Governor.sol\";\n7 import \"./IGovernorCompatibilityBravo.sol\";",
    "transaction-context": "The transaction context is protocol\nvoting ",
    "Critical-points": "Critical program points are 63+\n111+ \n131+ ",
    "invariants": "63+ assert(signatures.length ==calldatas.length);\n111+ assert(signatures.length ==calldatas.length);\n131+ assert(signatures.length ==calldatas.length);",
    "critical-invariants": "63+ assert(signatures.length ==calldatas.length);",
    "ranks": "63+ assert(signatures.length ==calldatas.length);",
    "vulnerabilities": "insufficient gas"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../../utils/math/SafeCast.sol\";\n5 import \"../extensions/IGovernorTimelock.sol\";\n6 import \"../Governor.sol\";\n7 import \"./IGovernorCompatibilityBravo.sol\";",
    "transaction-context": "The transaction context is protocol\nvoting ",
    "Critical-points": "Critical program points are 36+ ",
    "invariants": "36+ assert(signatures.length ==calldatas.length);",
    "critical-invariants": "assert(signatures.length ==calldatas.length);",
    "ranks": "assert(signatures.length ==calldatas.length);",
    "vulnerabilities": "insufficient gas"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 42+ \n47+ \n66+ \n67+ \n87+ \n112+ \n141+ \n141+  \n177+ \n177+ \n210+ ",
    "invariants": "42+ require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n47+ require(owner != address(0), \"ERC721: invalid token ID\");\n66+ require(to != owner, \"ERC721: approval to current owner\");\n67+ require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n112+ require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n141+ require(to != address(0), \"ERC721: mint to the zero address\");\n141+  require(!_exists(tokenId), \"ERC721: token already minted\");\n177+  require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n177+ require(to != address(0), \"ERC721: transfer to the zero address\");\n210+ require(_exists(tokenId), \"ERC721: invalid token ID\");\n",
    "critical-invariants": "87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n",
    "ranks": "87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 15+  \n19+ \n23+ \n32+  \n34+\n57+ \n58+  \n64+  \n65+ \n74+  \n75+ \n83+  \n94+ \n109+ \n115+ \n121+\n126+ \n168+  \n181+ \n196+ \n212 \n213+\n221 \n222+  \n291 \n296 \n302 \n312 \n318 \n360 \n379 \n409 \n428+  \n454 \n473 \n503 \n520  \n521+ \n523+   ",
    "invariants": "15+  require((z = x + y) >= x, 'ds-math-add-overflow');\n19+  require((z = x - y) <= x, 'ds-math-sub-underflow');\n23+  require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n212 onlyMPC\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n221 onlyMPC\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "ranks": "168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 contract PausableToken is StandardToken, Pausable {\n2 \n3   function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n4     return super.transfer(_to, _value);\n5   }\n6 \n7   function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n8     return super.transferFrom(_from, _to, _value);\n9   }",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 18 \n19 \n19+ ",
    "invariants": "18 require(cnt > 0 && cnt <= 20);\n19 require(_value > 0 && balances[msg.sender] >= amount);\n19+ assert(amount >0);",
    "critical-invariants": "19+ assert(amount >0);",
    "ranks": "19+ assert(amount >0);",
    "vulnerabilities": "integer overflow"
  },
  {
    "code": "1 library SafeMath {\n2   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n3     uint256 c = a * b;\n4     assert(a == 0 || c / a == b);\n5     return c;\n6   }\n7 \n8   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n9     // assert(b > 0); // Solidity automatically throws when dividing by 0",
    "transaction-context": "The transaction context is safemath library",
    "Critical-points": "Critical program points are 4 \n16 \n22 ",
    "invariants": "4 assert(a == 0 || c / a == b);\n16 assert(b <= a);\n22 assert(c >= a);",
    "critical-invariants": "4 assert(a == 0 || c / a == b);\n16 assert(b <= a);\n22 assert(c >= a);",
    "ranks": "4 assert(a == 0 || c / a == b);\n16 assert(b <= a);\n22 assert(c >= a);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 22  \n27  \n55 \n69 \n109 \n111 \n118 \n119 \n133 ",
    "invariants": "22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n55 require(signatories.length == increments.length, 'two array lenth not equal');\n69 require(signatories.length == decrements.length, 'two array lenth not equal');\n109 require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n111 require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "critical-invariants": "118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "ranks": "118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "vulnerabilities": "privilege escalation\ncross bridge"
  },
  {
    "code": "1     function getYvTokenPrice(address token) internal view returns (uint256) {\n2         YvTokenInfo memory yvTokenInfo = yvTokens[token];\n3         require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n4  \n5         uint256 pricePerShare;\n6         address underlying;\n7         if (yvTokenInfo.version == YvTokenVersion.V1) {\n8             pricePerShare = YVaultV1Interface(token).getPricePerFullShare();\n9             underlying = YVaultV1Interface(token).token();",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 3\n11+ ",
    "invariants": "3  require(yvTokenInfo.isYvToken, \"not a Yvault token\"); \n11+ assert(pricePerShare <= k*Old(pricePerShare));",
    "critical-invariants": "11+ assert(pricePerShare <= k*Old(pricePerShare));",
    "ranks": "11+ assert(pricePerShare <= k*Old(pricePerShare));",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 226\n231+\n254\n322\n323\n360\n361\n379\n380\n406\n407\n416\n429 \n439",
    "invariants": "226 require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n231+ assert(pricePerShare <= k*Old(pricePerShare));\n254 require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n322 require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323 require(tokenAddresses.length == quotes.length, \"mismatched data\");\n329 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n360 require(msg.sender == admin, \"only the admin may set LPs\");\n361 require(tokenAddresses.length == isLP.length, \"mismatched data\");\n379 require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n380 require(tokenAddresses.length == version.length, \"mismatched data\");\n406 require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n407  require(\n               tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\"         );\n416 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");\n429 require(msg.sender == admin, \"only the admin may set new guardian\");\n439 require(msg.sender == admin, \"only the admin may set new admin\");",
    "critical-invariants": "231+ assert(pricePerShare <= k*Old(pricePerShare));\n254 require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n322 require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323 require(tokenAddresses.length == quotes.length, \"mismatched data\");\n329 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n360 require(msg.sender == admin, \"only the admin may set LPs\");\n379 require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n406 require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n429 require(msg.sender == admin, \"only the admin may set new guardian\");\n439 require(msg.sender == admin, \"only the admin may set new admin\");\n407  require(\n               tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\"         );\n416 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");",
    "ranks": "231+ assert(pricePerShare <= k*Old(pricePerShare));\n254 require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n322 require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323 require(tokenAddresses.length == quotes.length, \"mismatched data\");\n329 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n360 require(msg.sender == admin, \"only the admin may set LPs\");\n379 require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n406 require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n429 require(msg.sender == admin, \"only the admin may set new guardian\");\n439 require(msg.sender == admin, \"only the admin may set new admin\");\n407  require(\n               tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\"         );\n416 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 contract Example {\n2     function flash(\n3         address recipient,\n4         uint256 amount0,\n5         uint256 amount1,\n6         bytes calldata data\n7     ) external isFlashable globallyTransactable transactable isNotEmergency {\n8         uint256 fee = curve.epsilon.mulu(1e18);\n9         ",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are 1+ \n7 \n8+\n9+ \n22+ \n23+ ",
    "invariants": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "critical-invariants": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "ranks": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);",
    "vulnerabilities": "money market"
  },
  {
    "code": "1  contract PoolCurve{\n2 \n3    /// @notice sets the parameters for the pool\n4     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n5     /// @param _beta the value for beta must be less than alpha and greater than 0\n6     /// @param _feeAtHalt the maximum value for the fee at the halt point\n7     /// @param _epsilon the base fee for the pool\n8     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n9     function setParams(",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 1+ \n9 \n21 \n30 \n36 \n42 \n48 ",
    "invariants": "1+ modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n9 onlyOwner\n21 onlyOwner\n30 onlyOwner\n36 onlyOwner\n42 onlyOwner\n48 onlyOwner",
    "critical-invariants": "1+ modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n9 onlyOwner\n21 onlyOwner\n30 onlyOwner\n36 onlyOwner\n42 onlyOwner\n48 onlyOwner",
    "ranks": "1+ modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n9 onlyOwner\n21 onlyOwner\n30 onlyOwner\n36 onlyOwner\n42 onlyOwner\n48 onlyOwner",
    "vulnerabilities": "incorrect visibility/ownership"
  },
  {
    "code": "1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n7 \n8 import \"./lib/ABDKMath64x64.sol\";\n9 ",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 189 \n190 \n216\n217\n266\n271\n278\n283\n288\n293\n298\n303\n308\n313\n346\n352\n382 \n388\n394\n400\n401\n421\n431\n443\n460\n470\n482\n502\n503\n504 \n505\n506\n529 \n530\n531\n532 \n533\n534\n546 \n560\n561\n574\n575\n576 \n590\n618\n626 \n635\n638\n639 \n655 \n656 ",
    "invariants": "189 require(sender != address(0), \"ERC20: transfer from the zero address\");\n190 require(recipient != address(0), \"ERC20: transfer to the zero address\");\n216 require(_owner != address(0), \"ERC20: approve from the zero address\");\n217 require(spender != address(0), \"ERC20: approve to the zero address\");\n266     modifier onlyOwner() {\n           require(msg.sender == owner, \"Curve/caller-is-not-owner\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n401 require(_newOwner != address(0), \"Curve/new-owner-cannot-be-zeroth-address\");\n421  noDelegateCall isNotEmergency nonReentrant\n431  require(targetAmount_ >= _minTargetAmount, \"Curve/below-min-target-amount\");\n443 globallyTransactable transactable\n460 globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant \n470 require(originAmount_ <= _maxOriginAmount, \"Curve/above-max-origin-amount\");\n482 globallyTransactable transactable\n502 globallyTransactable transactable nonReentrant noDelegateCall\n503 require(amount == 1, \"Curve/invalid-amount\");\n504 require(index <= 473, \"Curve/index-out-of-range\" );\n505 require(isWhitelisted(index, account, amount, merkleProof), \"Curve/not-whitelisted\");\n506 require(msg.sender == account, \"Curve/not-approved-user\");\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall\n635 isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency \n638 require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639 require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n655 require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656 require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');",
    "critical-invariants": "266     modifier onlyOwner() {\n           require(msg.sender == owner, \"Curve/caller-is-not-owner\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall",
    "ranks": "266     modifier onlyOwner() {\n           require(msg.sender == owner, \"Curve/caller-is-not-owner\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract DODO {\n2     function init(\n3         address maintainer,\n4         address baseTokenAddress,\n5         address quoteTokenAddress,\n6         uint256 lpFeeRate,\n7         uint256 mtFeeRate,\n8         uint256 k,\n9         uint256 i,",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 1+\n11\n12\n16 \n19 ",
    "invariants": "1+ modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n11 nonReentrant\n12 require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n16 require(i > 0 && i <= 10**36);      \n19 require(k <= 10**18); ",
    "critical-invariants": "1+ modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n11 nonReentrant\n12 require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");",
    "ranks": "1+ modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n11 nonReentrant\n12 require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");",
    "vulnerabilities": "reeentrancy\nprice manipulation\nbusiness logic flaw"
  },
  {
    "code": "1 pragma solidity 0.6.9;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import {Types} from \"./lib/Types.sol\";\n5 import {IERC20} from \"./intf/IERC20.sol\";\n6 import {Storage} from \"./impl/Storage.sol\";\n7 import {Trader} from \"./impl/Trader.sol\";\n8 import {LiquidityProvider} from \"./impl/LiquidityProvider.sol\";\n9 import {Admin} from \"./impl/Admin.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 32",
    "invariants": "32 require(!_INITIALIZED_, \"DODO_INITIALIZED\");",
    "critical-invariants": "32 require(!_INITIALIZED_, \"DODO_INITIALIZED\");",
    "ranks": "32 require(!_INITIALIZED_, \"DODO_INITIALIZED\");",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.6.0;\n2 pragma experimental ABIEncoderV2;\n\n3 import \"./BondingCurve.sol\";\n4 import \"../pcv/IPCVDeposit.sol\";\n\n5 /// @title a square root growth bonding curve for purchasing FEI with ETH\n6 /// @author Fei Protocol\n7 contract EthBondingCurve is BondingCurve {",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 44",
    "invariants": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "critical-invariants": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "ranks": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.6.0;\n2 pragma experimental ABIEncoderV2;\n\n3 import \"@openzeppelin/contracts/utils/Address.sol\";\n4 import \"./UniswapPCVDeposit.sol\";\n\n5 /// @title implementation for an ETH Uniswap LP PCV Deposit\n6 /// @author Fei Protocol\n7 contract EthUniswapPCVDeposit is UniswapPCVDeposit {",
    "transaction-context": "The transaction context is asset swapping ",
    "Critical-points": "Critical program points are 24\n28+ \n29+ ",
    "invariants": "24         require(\n             ethAmount == msg.value,\n             \"Bonding Curve: Sent value does not equal input\"\n         );\n28+ assert(ethAmount <= k*Old(ethAmount)); \n29+ assert(feiAmount <= k*Old(feiAmount)); ",
    "critical-invariants": "28+ assert(ethAmount <= k*Old(ethAmount)); \n29+ assert(feiAmount <= k*Old(feiAmount)); ",
    "ranks": "28+ assert(ethAmount <= k*Old(ethAmount)); \n29+ assert(feiAmount <= k*Old(feiAmount)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "The transaction context is bidding",
    "Critical-points": "Critical program points are 105         \n106        \n107         \n108        \n110        \n121         \n122       \n123       \n124         \n135        \n145        \n149        \n151        \n154       \n156       \n160    \n162   \n164       \n168   \n169     \n171        \n183         ",
    "invariants": "105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n108         require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n110         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n124         uint256 tokenId = _tokenIdCounter.current();\n135         require(auctionEnded, \"Please end the auction firstly\");\n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n151         require(success, \"Failed to withdraw funds.\");\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n156         require(success, \"Failed to withdraw funds.\");\n160         require(success, \"Failed to withdraw funds.\");\n162         onlyOwner\n164         require(success, \"Failed to withdraw funds.\");\n168         require(totalBid > 0, \"Nothing to withdraw\");\n169         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n171         require(success, \"Failed to withdraw funds.\");\n183         require(_exists(tokenId), \"Token does not exist\");",
    "critical-invariants": "162         onlyOwner\n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "ranks": "162         onlyOwner\n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "The transaction context is bidding",
    "Critical-points": "Critical program points are 104+ \n104+  \n104+  \n104+  \n106   \n116+  \n116+  \n116+  \n127+ \n140+  \n144+ \n146    \n150    \n154   \n158    \n159   \n161  ",
    "invariants": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n106    require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n146    require(success, \"Failed to withdraw funds.\");\n150    require(success, \"Failed to withdraw funds.\");\n154    require(success, \"Failed to withdraw funds.\");\n158    require(totalBid > 0, \"Nothing to withdraw\");\n159   require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n161  require(success, \"Failed to withdraw funds.\");\n",
    "critical-invariants": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n\n",
    "ranks": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n\n",
    "vulnerabilities": "atomicity violation"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "The transaction context is bidding",
    "Critical-points": "Critical program points are 104+ \n104+  \n104+  \n104+  \n106   \n116+  \n116+  \n116+  \n127+ \n140+  \n144+ \n146    \n150 \n152   \n154   \n158    \n159   \n161  ",
    "invariants": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n106    require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n146    require(success, \"Failed to withdraw funds.\");\n150    require(success, \"Failed to withdraw funds.\");\n152    onlyOwner \n154    require(success, \"Failed to withdraw funds.\");\n158    require(totalBid > 0, \"Nothing to withdraw\");\n159   require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n161  require(success, \"Failed to withdraw funds.\");\n",
    "critical-invariants": "152    onlyOwner \n104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n",
    "ranks": "152    onlyOwner \n104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n",
    "vulnerabilities": "atomicity violation\nincorrect ownership/visibility"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n\n6 import \"./interfaces/IStakingBank.sol\";\n",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 21+ \n78\n81   \n82   \n89   \n92     \n104     \n110     ",
    "invariants": "21+   modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n78 onlyOwner\n81     require(dataTimestamp + padding < block.timestamp, \"do not spam\");\n82     require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n89     require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n92       require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n104       require(prevSigner < signer, \"validator included more than once\");\n110     require(i >= requiredSignatures, \"not enough signatures\");\n",
    "critical-invariants": "21+   modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n78 onlyOwner",
    "ranks": "21+   modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n78 onlyOwner",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at FtmScan.com on 2021-08-31\n3 */\n\n4 // SPDX-License-Identifier: MIT\n5 // File: @openzeppelin/contracts/GSN/Context.sol\n\n\n6 pragma solidity ^0.6.0;",
    "transaction-context": "The transaction context is money market\ntoken transfer",
    "Critical-points": "Critical program points are 48+ \n87         \n141        \n154       \n155         \n168       \n172 ",
    "invariants": "48+ modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}\n87         require(_amount > 0, \"!deposit zero\");\n141         require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");\n154         require(stratCandidate.implementation != address(0), \"There is no candidate\");\n155         require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n168         require(_token != address(want()), \"!token\");\n172 nonReentrant",
    "critical-invariants": "48+ modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}\n172 nonReentrant\n168 require(_token != address(want()), \"!token\");",
    "ranks": "48+ modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}\n172 nonReentrant\n168 require(_token != address(want()), \"!token\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "The transaction context is liquidity pool",
    "Critical-points": "Critical program points are 128    \n132  \n148   \n171    \n178    \n181     \n184   \n193    \n196    \n199   \n202    \n205  \n211    \n214   \n217    \n220  \n223    \n226 \n233  \n246       \n254       \n260         \n402        \n419      \n421       \n446        \n465      \n488    \n489       \n508          \n510         \n613        \n638       \n650      \n652     ",
    "invariants": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n148    require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n171    onlyOwner\n178    onlyOwner\n181     onlyOwner\n184    onlyOwner\n193    onlyOwner\n196    onlyOwner\n199     onlyOwner\n202    onlyOwner\n205    onlyOwner\n211    onlyOwner\n214    onlyOwner\n217    onlyOwner\n220    onlyOwner\n223    onlyOwner\n226    onlyOwner\n233    onlyOwner\n246         require(isPoolActive,'Contract is not running yet');\n254         onlyBank\n259        onlyBank\n260         require(isPoolActive,'Contract is not running yet');\n402         require(_depositId >= 0, \"Value is not specified\");\n419         require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n421        require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n446         require(_depositId >= 0, \"Value is not specified\");\n465         require(pending > 0 ,\"No rewards to claim.\");\n488         onlyRunnerScript\n\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "critical-invariants": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n488         onlyRunnerScript\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "ranks": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n488         onlyRunnerScript\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 pragma solidity ^0.6.0;\n\n\n2 interface IUniswapV2Pair {\n3     function swap(\n4         uint256 amount0Out,\n5         uint256 amount1Out,\n6         address to,\n7         bytes calldata data",
    "transaction-context": "The transaction context is liquidity pool",
    "Critical-points": "Critical program points are 75+ ",
    "invariants": "75+ assert(usdcAmount <= Old(usdcAmount)*k));",
    "critical-invariants": "assert(usdcAmount <= Old(usdcAmount)*k))",
    "ranks": "assert(usdcAmount <= Old(usdcAmount)*k))",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: BSD-3-Clause\n2 pragma solidity ^0.8.10;\n\n3 import \"./ComptrollerInterface.sol\";\n4 import \"./CTokenInterfaces.sol\";\n5 import \"./ErrorReporter.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./InterestRateModel.sol\";\n8 import \"./ExponentialNoError.sol\";",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 23+  \n29 \n59\n101 \n111 ",
    "invariants": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n29 nonReentrant\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant",
    "critical-invariants": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant\n",
    "ranks": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant\n",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: UNLICENSED\n2 pragma solidity =0.8.7;\n\n3 import \"./interfaces/ICollateral.sol\";\n4 import \"./interfaces/IStrategyController.sol\";\n5 import \"./interfaces/IHook.sol\";\n6 import \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n7 import \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";",
    "transaction-context": "The transaction context is liquidity pool",
    "Critical-points": "Critical program points are 286+ ",
    "invariants": "286+ assert(totalAssets != 0);",
    "critical-invariants": "286+ assert(totalAssets != 0);",
    "ranks": "286+ assert(totalAssets != 0);",
    "vulnerabilities": "business logic flaw;\nether leakage; "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n5 import \"./Swapper.sol\";\n\n6 /**\n7  * @title Generic Swap Facet",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 20+ ",
    "invariants": "20+ require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");",
    "critical-invariants": "20+ require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");",
    "ranks": "20+ require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");",
    "vulnerabilities": "ether leakage;\nbusiness logic flaw; "
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 38            \n43            \n78            \n84            \n86          \n109        ",
    "invariants": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n109         require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "critical-invariants": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n\"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n109         require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "ranks": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n\"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n109         require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 38            \n43          \n78             \n84    \n86          \n109+ ",
    "invariants": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "critical-invariants": "109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "ranks": "109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");",
    "vulnerabilities": "ID uniquness violation"
  },
  {
    "code": "1 abstract contract BaseVault {\n\n2     DepositQueueLib DepositQueue;\n\n3     function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n4         uint256 _totalAssets = totalAssets();\n5         for (uint256 i = startIndex; i < endIndex; i++){\n6             uint256 currentAssets = _totalAssets + processedDeposits;\n7             depositEntry = depositQueue.get(i);",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 9+ ",
    "invariants": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");\n",
    "critical-invariants": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");",
    "ranks": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");",
    "vulnerabilities": "gas leakage"
  },
  {
    "code": "1 abstract contract BaseVault {\n\n2     DepositQueueLib DepositQueue;\n\n3     function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n4         uint256 _totalAssets = totalAssets();\n5         for (uint256 i = startIndex; i < endIndex; i++){\n6             uint256 currentAssets = _totalAssets + processedDeposits;\n7             depositEntry = depositQueue.get(i);",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 9+ ",
    "invariants": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");\n",
    "critical-invariants": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");",
    "ranks": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");",
    "vulnerabilities": "gas leakage"
  },
  {
    "code": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 9+  \n17+ \n18+ ",
    "invariants": "9+  assert(_merkleRoot != 0);\n17+ assert(_msgHash != 0);\n18+ assert(_root != 0);",
    "critical-invariants": "17+ assert(_msgHash != 0);\n",
    "ranks": "9+ assert(_merkleRoot != 0); \n17+ assert(_msgHash != 0); ",
    "vulnerabilities": "cross bridge\nID Uniqueness violation"
  },
  {
    "code": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 9+  \n17+ \n18+ ",
    "invariants": "9+  assert(_merkleRoot != 0);\n17+ assert(_msgHash != 0);\n18+ assert(_root != 0);",
    "critical-invariants": "17+ assert(_msgHash != 0);\n",
    "ranks": "9+ assert(_merkleRoot != 0); \n17+ assert(_msgHash != 0); ",
    "vulnerabilities": "cross bridge\nID Uniqueness violation"
  },
  {
    "code": "1     function _stETHTransferFrom(address from, address to, uint256 amount) internal returns () {      \n2         _asset.safeTransferFrom(from, to, amount);\n3       }\n4     }\n\n5     function _beforeWithdraw(uint256 shares) internal {\n6         lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n      \n7     }",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 1+ \n6+ ",
    "invariants": "1+ require(amount > 0);\n6+ assert(lastRoundAssets > 0);",
    "critical-invariants": "1+ require(amount > 0);\n6+ assert(lastRoundAssets > 0);",
    "ranks": "1+ require(amount > 0);\n6+  assert(lastRoundAssets > 0);",
    "vulnerabilities": "integer overflow/underflow"
  },
  {
    "code": "1     function _stETHTransferFrom(address from, address to, uint256 amount) internal returns () {      \n2         _asset.safeTransferFrom(from, to, amount);\n3       }\n4     }\n\n5     function _beforeWithdraw(uint256 shares) internal {\n6         lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n      \n7     }",
    "transaction-context": "The transaction context is token transfer",
    "Critical-points": "Critical program points are 1+ \n6+ ",
    "invariants": "1+ require(amount > 0);\n6+ assert(lastRoundAssets > 0);",
    "critical-invariants": "1+ require(amount > 0);\n6+ assert(lastRoundAssets > 0);",
    "ranks": "1+ require(amount > 0);\n6+  assert(lastRoundAssets > 0);",
    "vulnerabilities": "integer overflow/underflow"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma experimental ABIEncoderV2;\n3 pragma solidity 0.6.12;\n\n4 import \"./ParaToken.sol\";\n5 import \"./interfaces/IERC20.sol\";\n6 import \"./libraries/SafeERC20.sol\";\n7 import \"./libraries/EnumerableSet.sol\";\n8 import \"./libraries/SafeMath_para.sol\";",
    "transaction-context": "require(admin == msg.sender, \"Ownable: caller is not the owner\");",
    "Critical-points": "require(_whitelist[msg.sender] != address(0), \"only white\");",
    "invariants": "require(paths.length == 2,\"deposit: PE\");",
    "critical-invariants": "require(_amount > 0, \"deposit: zero\");",
    "ranks": "require(paths.length == 2,\"deposit: PE\");",
    "vulnerabilities": "require(vars.newBalance > vars.oldBalance, \"B:E\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma experimental ABIEncoderV2;\n3 pragma solidity 0.6.12;\n\n4 import \"./ParaToken.sol\";\n5 import \"./interfaces/IERC20.sol\";\n6 import \"./libraries/SafeERC20.sol\";\n7 import \"./libraries/EnumerableSet.sol\";\n8 import \"./libraries/SafeMath_para.sol\";",
    "transaction-context": "require(vars.liquidity >= _minTokens, \"H:S\");",
    "Critical-points": " require(overflow == 0, \"Exceeding the ticket limit\");",
    "invariants": "require(overflow == 0, \"Please withdraw usdt in advance\");",
    "critical-invariants": "require(false, \"You never staked this ticket before\");",
    "ranks": " require(user.amount >= _amount, \"withdraw: not good\");",
    "vulnerabilities": " require(paths[0].length >= 2 && paths[1].length >= 2, \"PE:2\");\nrequire(paths[0][paths[0].length - 1] == tokenOut,\"invalid path_\");\nrequire(paths[1][paths[1].length - 1] == tokenOut,\"invalid path_\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma experimental ABIEncoderV2;\n3 pragma solidity 0.6.12;\n\n4 import \"./ParaToken.sol\";\n5 import \"./interfaces/IERC20.sol\";\n6 import \"./libraries/SafeERC20.sol\";\n7 import \"./libraries/EnumerableSet.sol\";\n8 import \"./libraries/SafeMath_para.sol\";",
    "transaction-context": "require(path[0] == tokens[0] || path[0] == tokens[1], \"invalid path_0\");",
    "Critical-points": " assert (y == x + 2);",
    "invariants": "assert(funcA2(funcA1())==12);\nassert(funcA3().funcB()==42);",
    "critical-invariants": "assert(a == x + 1);\n",
    "ranks": " assert(a == x);",
    "vulnerabilities": "assert (a == x + 4);  \nassert (b == x + 4);  \nassert (c == x + 6);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": " assert(funcA2(funcA1())==12);\n assert(funcA3().funcB()==42);",
    "Critical-points": "assert(a == x + 1);\n",
    "invariants": "assert(a == x);  ",
    "critical-invariants": "assert (a == x + 4);  \nassert (b == x + 4);  \nassert (c == x + 6);",
    "ranks": " assert(x == y);\n assert(y >= 0);\n",
    "vulnerabilities": "assert (y >= 0); "
  },
  {
    "code": "pragma solidity >=0.4.24 <0.6.0;\n\n//simple library with no internal state\n\nlibrary Lib {\n    function add(uint _a, uint _b) public view returns (uint r) {\n        address x = address(this);       \n        r = _a + _b;\n    }",
    "transaction-context": "assert(x == msg.sender);",
    "Critical-points": "assert (z == 3);",
    "invariants": "assert(x + y == n);",
    "critical-invariants": "assert (y == n);",
    "ranks": "assert(x + y == n);",
    "vulnerabilities": "assert (y == n);"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n2 import \"./../../Libraries/VeriSolContracts.sol\";\n3 //import \"./VeriSolContracts.sol\";\n4 //import \"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\";\n\n5 contract LoopFor {\n\n6     // test Loop invariant with for loop\n7     constructor(uint n) public {",
    "transaction-context": "assert(x + y == n);",
    "Critical-points": "assert (y == n);",
    "invariants": " require(msg.sender != address(0));",
    "critical-invariants": "assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "ranks": "require(_balances[sender] >= amount);",
    "vulnerabilities": "require(amount > 0, \"Cannot withdraw 0\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error",
    "transaction-context": "assert(a == 0 || c / a == b);",
    "Critical-points": "assert(b <= a);",
    "invariants": "assert(c >= a);",
    "critical-invariants": "require(_to != address(0));\nrequire(_value > 0 && _value <= balances[msg.sender]);",
    "ranks": "require(msg.sender == owner);",
    "vulnerabilities": " require(newOwner != address(0));"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error",
    "transaction-context": "require(!paused);",
    "Critical-points": "require(paused);",
    "invariants": "require(id < nextPositionID, \"bad position id\");\nrequire(positions[id].goblin == goblin, \"bad position goblin\");\nrequire(positions[id].owner == msg.sender, \"not position owner\");",
    "critical-invariants": " require(config.isGoblin(goblin), \"not a goblin\");\n require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");",
    "ranks": "require(debt >= config.minDebtSize(), \"too small debt size\");",
    "vulnerabilities": "require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
    "Critical-points": "require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "invariants": "require(c >= a, \"SafeMath: addition overflow\");",
    "critical-invariants": " return sub(a, b, \"SafeMath: subtraction overflow\");",
    "ranks": "require(b <= a, errorMessage);",
    "vulnerabilities": "require(c / a == b, \"SafeMath: multiplication overflow\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**",
    "transaction-context": "require(b > 0, errorMessage);",
    "Critical-points": "require(b != 0, errorMessage);",
    "invariants": "require(address(this).balance >= amount, \"Address: insufficient balance\");",
    "critical-invariants": "require(success, \"Address: unable to send value, recipient may have reverted\");",
    "ranks": "require(address(this).balance >= value, \"Address: insufficient balance for call\");",
    "vulnerabilities": "require(isContract(target), \"Address: call to non-contract\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**",
    "transaction-context": " require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n",
    "Critical-points": "require(account != address(0), \"ERC20: mint to the zero address\");",
    "invariants": "require(account != address(0), \"ERC20: burn from the zero address\");\n",
    "critical-invariants": "require(owner != address(0), \"ERC20: approve from the zero address\");\nrequire(spender != address(0), \"ERC20: approve to the zero address\");",
    "ranks": "require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );",
    "vulnerabilities": "require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**",
    "transaction-context": "require(_owner == _msgSender(), \"Ownable: caller is not the owner\");",
    "Critical-points": "require(newOwner != address(0), \"Ownable: new owner is the zero address\");",
    "invariants": "require(localCounter == _guardCounter);",
    "critical-invariants": "assert(token != address(this)); \nassert(token != user); ",
    "ranks": "require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
    "vulnerabilities": "require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "Critical-points": "assert(a == 0 || c / a == b);",
    "invariants": "assert(b <= a);",
    "critical-invariants": "assert(c >= a);",
    "ranks": "require(msg.sender == owner, \"only owner\");\n",
    "vulnerabilities": "require(visrDeposit > 0, \"deposits must be nonzero\");\nrequire(to != address(0) && to != address(this), \"to\");\nrequire(from != address(0) && from != address(this), \"from\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "require(IVisor(from).owner() == msg.sender); \n",
    "Critical-points": "assert( IVisor(from) !=  address(this)); \n",
    "invariants": "require(shares > 0, \"shares\");\n require(from != address(0), \"from\");",
    "critical-invariants": "require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n",
    "ranks": " require(amount > 0, \"Invalid amount\");\n require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "vulnerabilities": "require(canTransfer, \"E046\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n4 import { LibAsset } from \"../Libraries/LibAsset.sol\";\n5 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n6 import { LibSwap } from \"../Libraries/LibSwap.sol\";\n7 import { ICBridge } from \"../Interfaces/ICBridge.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");",
    "Critical-points": "require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");",
    "invariants": "require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");",
    "critical-invariants": "require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");",
    "ranks": " assert(!invokeSwap);",
    "vulnerabilities": "  assert(_committedRoot != 0)"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n",
    "Critical-points": "require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\nrequire(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");",
    "invariants": "require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");",
    "critical-invariants": " require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");",
    "ranks": "require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");",
    "vulnerabilities": "require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\nrequire(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\");",
    "Critical-points": "require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");",
    "invariants": "require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");",
    "critical-invariants": "require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");",
    "ranks": " require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\nrequire(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");",
    "vulnerabilities": "require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");",
    "Critical-points": "assert(_method != “f1121318093”); ",
    "invariants": "require(success == true, \"EthCrossChain call business contract failed\");",
    "critical-invariants": "require(res == true, \"EthCrossChain call business contract return is not true\");",
    "ranks": "require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");",
    "vulnerabilities": "require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");",
    "Critical-points": "require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "invariants": "assert (x == a + 1);",
    "critical-invariants": "assert (a == x + 2);",
    "ranks": "assert (x == a + 2);",
    "vulnerabilities": " assert (a == 1);"
  },
  {
    "code": "1 contract ArrayNestedFixedSize {\n\n2     // NOTE: the number of columns comes first in the declaration!\n3     uint[3][2] a;\n4     bool[2][2] aa;\n\n5     constructor() {\n6       _;\n",
    "transaction-context": "assert (a[0][0] == 0 || a[0][0] == 3);\nassert (a[0][1] == 1);\nassert (a[0][2] == 2);\nassert (a[1][0] == 3);\nassert (a[1][1] == 4);\nassert (a[1][2] == 5);",
    "Critical-points": "assert(a[0] == 1);    \nassert(a[1] == 2);",
    "invariants": "assert (sa[0] == 10);\nassert (sa[1] == 11);\nassert (sa.length == 2);",
    "critical-invariants": "assert (a[0] == 0);\nassert (a[1] == 1);\n",
    "ranks": "assert (b[j] == j);",
    "vulnerabilities": "assert (a == 1);\nassert (b == 3);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": " assert (a == 4);\n assert (b == 40);",
    "Critical-points": "assert (a == 5);\nassert (b == 55);",
    "invariants": "assert (x == a + 1);",
    "critical-invariants": "assert (x == a + 2);",
    "ranks": "  assert (a == 1);",
    "vulnerabilities": "assert (x == a + 2);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Consts {\n\n4     constructor () public {\n5         uint a;\n6         address b;\n7         address c;",
    "transaction-context": " assert(b != c);",
    "Critical-points": "assert (a == 1 || a == 2);\n",
    "invariants": "assert (a == 1 || a == 2);",
    "critical-invariants": " assert (sum == 1);",
    "ranks": "assert (c == _a + _b);",
    "vulnerabilities": "assert (c == _a - _b);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Arithmetics {\n\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\n4         c = _a + _b;\n      \n5     }\n",
    "transaction-context": "assert (c == _a * _b);",
    "Critical-points": "assert (c == _a / _b);",
    "invariants": "assert(finished = true);",
    "critical-invariants": "assert(canceled = true); ",
    "ranks": " assert(!(finished && canceled)); ",
    "vulnerabilities": "require(lockDev == false);"
  },
  {
    "code": "1 contract JAY is ERC20, Ownable {\n2     using SafeMath for uint256;\n3     AggregatorV3Interface internal priceFeed;\n\n4     address private dev;\n5     uint256 public constant MIN = 1000;\n6     bool private start = false;\n7     bool private lockDev = false;\n",
    "transaction-context": "require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );",
    "Critical-points": "require(success, \"ETH Transfer failed.\");",
    "invariants": "require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );",
    "critical-invariants": "require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );",
    "ranks": "require(success, \"ETH Transfer failed.\");",
    "vulnerabilities": "require(value > MIN, \"Dude tf\");"
  },
  {
    "code": "1 contract JAY is ERC20, Ownable {\n2     using SafeMath for uint256;\n3     AggregatorV3Interface internal priceFeed;\n\n4     address private dev;\n5     uint256 public constant MIN = 1000;\n6     bool private start = false;\n7     bool private lockDev = false;\n",
    "transaction-context": "require(success, \"ETH Transfer failed.\");",
    "Critical-points": "require(success2, \"ETH Transfer failed.\");",
    "invariants": "require(msg.value > MIN, \"must trade over min\");\nrequire(start, \"Not started!\");",
    "critical-invariants": "require(success, \"ETH Transfer failed.\");",
    "ranks": "require (liquidity>0, \"MonoX:BAD_AMOUNT\");",
    "vulnerabilities": "assert(to != address(0)); "
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./ComptrollerInterface.sol\";\n3 import \"./CTokenInterfaces.sol\";\n4 import \"./ErrorReporter.sol\";\n5 import \"./Exponential.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./EIP20NonStandardInterface.sol\";\n8 import \"./InterestRateModel.sol\";",
    "transaction-context": "require(msg.sender == admin, \"only admin may initialize the market\");\nrequire(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");",
    "Critical-points": " require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");",
    "invariants": "require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");",
    "critical-invariants": "require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");",
    "ranks": "require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");",
    "vulnerabilities": "require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./ComptrollerInterface.sol\";\n3 import \"./CTokenInterfaces.sol\";\n4 import \"./ErrorReporter.sol\";\n5 import \"./Exponential.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./EIP20NonStandardInterface.sol\";\n8 import \"./InterestRateModel.sol\";",
    "transaction-context": "require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");",
    "Critical-points": "require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");",
    "invariants": "require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");",
    "critical-invariants": "require(_notEntered, \"re-entered\");",
    "ranks": "require(err == 0, \"mint failed\");",
    "vulnerabilities": "  require(\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\n                keccak256(\"ERC3156FlashBorrowerInterface.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n3 import \"./ERC3156FlashLenderInterface.sol\";\n4 import \"./ERC3156FlashBorrowerInterface.sol\";\n\n5 /**\n6  * @title Cream's CCollateralCapErc20 Contract\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap",
    "transaction-context": "require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");",
    "Critical-points": "require(msg.sender == address(comptroller), \"comptroller only\");",
    "invariants": "require(msg.sender == address(comptroller), \"comptroller only\");",
    "critical-invariants": "require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");",
    "ranks": "require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");",
    "vulnerabilities": "require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n3 import \"./ERC3156FlashLenderInterface.sol\";\n4 import \"./ERC3156FlashBorrowerInterface.sol\";\n\n5 /**\n6  * @title Cream's CCollateralCapErc20 Contract\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap",
    "transaction-context": " require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");",
    "Critical-points": "require(err == 0, \"mint failed\");",
    "invariants": "require(redeemInternal(redeemTokens, false) == 0, \"redeem failed\");",
    "critical-invariants": "require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");",
    "ranks": "require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");",
    "vulnerabilities": "require(err == 0, \"repay failed\");"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n\n3 /**\n4  * @title Compound's CErc20 Contract\n5  * @notice CTokens which wrap an EIP-20 underlying\n6  * @author Compound\n7  */",
    "transaction-context": "require(err == 0, \"repay behalf failed\");",
    "Critical-points": "require(err == 0, \"liquidate borrow failed\");",
    "invariants": "require(success, \"TOKEN_TRANSFER_IN_FAILED\");",
    "critical-invariants": "require(success, \"TOKEN_TRANSFER_OUT_FAILED\");",
    "ranks": "require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \"comptroller rejection\");",
    "vulnerabilities": "require(src != dst, \"bad input\");"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n\n3 /**\n4  * @title Compound's CErc20 Contract\n5  * @notice CTokens which wrap an EIP-20 underlying\n6  * @author Compound\n7  */",
    "transaction-context": "require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");",
    "Critical-points": "require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");",
    "invariants": "require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");",
    "critical-invariants": "require(comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens) == 0, \"comptroller rejection\");",
    "ranks": "require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");",
    "vulnerabilities": "require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n\n3 /**\n4  * @title Compound's CErc20 Contract\n5  * @notice CTokens which wrap an EIP-20 underlying\n6  * @author Compound\n7  */",
    "transaction-context": " require(\n            comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\n            \"comptroller rejection\"\n        );",
    "Critical-points": "require(borrower != liquidator, \"invalid account pair\");",
    "invariants": "assert (a == 1);\nassert (b == 3);",
    "critical-invariants": "assert (a == 4);\nassert (b == 40);",
    "ranks": "assert (a == 5);\nassert (b == 55);",
    "vulnerabilities": "assert(c / a == b);"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-05-09\n3 */\n\n4 pragma solidity ^0.4.21;\n\n\n5 /**\n6  * @title SafeMath",
    "transaction-context": "assert(b <= a);",
    "Critical-points": "assert(c >= a);",
    "invariants": "require(_to != address(0));",
    "critical-invariants": "require(_value <= balances[msg.sender]);",
    "ranks": "require(balanceOf[msg.sender] >= _value);\n",
    "vulnerabilities": "require(balanceOf[_from] >= _value);"
  },
  {
    "code": "1 pragma solidity ^0.4.16;\n \n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n \n3 contract TokenERC20 {\n4     string public name;\n5     string public symbol;\n6     uint8 public decimals = 18;  // 18 \n7     uint256 public totalSupply;",
    "transaction-context": "require(_value <= allowance[_from][msg.sender]);",
    "Critical-points": "require(c >= a);",
    "invariants": "require(b <= a);",
    "critical-invariants": "require(a == 0 || c / a == b);",
    "ranks": "require(b > 0);",
    "vulnerabilities": "require (d[1] == 5);\n"
  },
  {
    "code": "1 // array variable copy breaks\n\n2 contract ArrayLength {\n3     uint[12] a;\n\n4     constructor (uint[12] memory d) public\n5     {\n6         require (d[1] == 5);\n7         a = d;       ",
    "transaction-context": "assert (d[1] == 5);",
    "Critical-points": "assert (a[0][1] == 0);",
    "invariants": "assert (!aa[0][1]);",
    "critical-invariants": "assert (a[0][0] == 0 || a[0][0] == 3);",
    "ranks": "assert (a[0][1] == 1);",
    "vulnerabilities": "assert (a[0][2] == 2);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "assert (a[1][0] == 3);",
    "Critical-points": "assert (a[1][1] == 4);",
    "invariants": "assert (a[1][2] == 5);",
    "critical-invariants": "assert (b[1] == 22);",
    "ranks": "assert(false);",
    "vulnerabilities": "assert (a == 1 || a == 2);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;",
    "transaction-context": "assert (a == 1 || a == 2);",
    "Critical-points": "assert(b != c);",
    "invariants": "assert (a == 1);",
    "critical-invariants": "assert (x == a + 2);",
    "ranks": "assert (x != 1); ",
    "vulnerabilities": "assert (a == 1);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": "assert (a == 1);",
    "Critical-points": "assert (b == 3);",
    "invariants": "assert (a == 4);",
    "critical-invariants": "assert (b == 40);",
    "ranks": "assert (a == 5);",
    "vulnerabilities": " assert (b == 55);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;",
    "transaction-context": "assert (a[0] == 0);",
    "Critical-points": "assert (a[1] == 1);",
    "invariants": "assert (b[j] == j);",
    "critical-invariants": "assert (sa.length == 0);",
    "ranks": "assert (sa[0] == 10);",
    "vulnerabilities": " assert (sa[1] == 11);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "assert (sa.length == 2);",
    "Critical-points": "assert(a[0] == 1);",
    "invariants": "assert(a[1] == 2);",
    "critical-invariants": "assert (b[1] == 22);",
    "ranks": "assert (a[0][1] == 0);",
    "vulnerabilities": "assert (!aa[0][1]);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "assert (a[0][0] == 0 || a[0][0] == 3);",
    "Critical-points": "assert (a[0][1] == 1);",
    "invariants": "assert (a[0][2] == 2);",
    "critical-invariants": "assert (a[1][0] == 3);",
    "ranks": "assert (a[1][1] == 4);",
    "vulnerabilities": "assert (a[1][2] == 5);"
  },
  {
    "code": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "assert (b[1] == 22);",
    "Critical-points": " assert(b != c);",
    "invariants": "assert (a == 1);",
    "critical-invariants": "require(amount > 0, \"Invalid amount\");",
    "ranks": "require(supply[id] == 0, \"Repeated mint for the same FNFT\");",
    "vulnerabilities": "require(canTransfer, \"E046\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "require(msg.sender == owner, \"only owner\");",
    "Critical-points": "require(visrDeposit > 0, \"deposits must be nonzero\");",
    "invariants": "require(to != address(0) && to != address(this), \"to\");",
    "critical-invariants": "require(from != address(0) && from != address(this), \"from\");",
    "ranks": "require(IVisor(from).owner() == msg.sender); ",
    "vulnerabilities": " assert( IVisor(from) !=  address(this)); "
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "require(shares > 0, \"shares\");",
    "Critical-points": "require(to != address(0), \"to\");",
    "invariants": "require(from != address(0), \"from\");",
    "critical-invariants": "assert(a == 0 || c / a == b);",
    "ranks": "assert(b <= a);",
    "vulnerabilities": "assert(c >= a);"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 contract ModifierEntrancy {\n\n3   mapping (address => uint) public tokenBalance;\n4   string constant name = \"Nu Token\";\n5   Bank bank;\n  \n6   constructor() public{",
    "transaction-context": "require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "Critical-points": "require(tokenBalance[msg.sender] == 0);",
    "invariants": "require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
    "critical-invariants": "require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');",
    "ranks": "require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "vulnerabilities": "require(id < nextPositionID, \"bad position id\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "require(positions[id].goblin == goblin, \"bad position goblin\");",
    "Critical-points": "require(positions[id].owner == msg.sender, \"not position owner\");",
    "invariants": "require(config.isGoblin(goblin), \"not a goblin\");",
    "critical-invariants": " require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");",
    "ranks": " require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");",
    "vulnerabilities": " require(debt >= config.minDebtSize(), \"too small debt size\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");",
    "Critical-points": "assert (y == 2*x + 4); ",
    "invariants": "assert (a[0][0] == 0);\n",
    "critical-invariants": " assert (a[0][1] == 1);",
    "ranks": "assert (a[1][0] == 2);",
    "vulnerabilities": "assert (a[1][1] == 3);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract MappingNested {\n\n3     mapping (uint => mapping (uint => uint)) m;\n4     mapping (uint => uint[]) n;\n5     uint[] p;\n  \n",
    "transaction-context": "assert (m[10][20] == 11); ",
    "Critical-points": "assert (m[20][10] == 21);",
    "invariants": "assert (n[0].length == 0);",
    "critical-invariants": "assert (n[0].length == 2);",
    "ranks": " assert (n[1].length == 0); ",
    "vulnerabilities": "assert (p.length == 0);"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 //simple library with no internal state\n\n3 library Lib {\n4     function add(uint _a, uint _b) public view returns (uint r) {\n5         address x = address(this);\n6         assert(x == msg.sender);\n7         r = _a + _b;",
    "transaction-context": "assert(x == msg.sender);",
    "Critical-points": "assert (z == 3);",
    "invariants": "assert(a == x + 1);",
    "critical-invariants": "assert(a == x); ",
    "ranks": "assert (a == x + 4); ",
    "vulnerabilities": "assert (b == x + 4);  "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "assert (c == x + 6); ",
    "Critical-points": "assert(funcA2(funcA1())==12);",
    "invariants": " assert(funcA3().funcB()==42);",
    "critical-invariants": "require(msg.sender != address(0));",
    "ranks": " _transfer(msg.sender, recipient, amount);",
    "vulnerabilities": "assert (_balances[msg.sender] + _balances[recipient]) == _balances[msg.sender] + _balances[recipient];"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\"; //import \"../../math/SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n5 contract ERC20 is IERC20 {\n6     using SafeMath for uint256;\n",
    "transaction-context": "assert (msg.sender == recipient ||  _balances[msg.sender] == _balances[msg.sender] - amount);",
    "Critical-points": "assert (_balances[recipient] >= _balances[recipient]);",
    "invariants": "require(sender != address(0), \"ERC20: transfer from the zero address\");",
    "critical-invariants": "require(recipient != address(0), \"ERC20: transfer to the zero address\");",
    "ranks": "require(account != address(0), \"ERC20: burn from the zero address\");",
    "vulnerabilities": "require(owner != address(0), \"ERC20: approve from the zero address\");"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\"; //import \"../../math/SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n5 contract ERC20 is IERC20 {\n6     using SafeMath for uint256;\n",
    "transaction-context": "require(spender != address(0), \"ERC20: approve to the zero address\");",
    "Critical-points": "assert(_totalSupply == VeriSol.SumMapping(_balances);",
    "invariants": "require(msg.sender == owner);",
    "critical-invariants": "require(!paused);",
    "ranks": "require(_to != 0x0);                             ",
    "vulnerabilities": "require(balanceOf[_from] >= _value);                "
  },
  {
    "code": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {",
    "transaction-context": "require(balanceOf[_to] + _value > balanceOf[_to]);  ",
    "Critical-points": " require(!frozenAccount[_from]);                     ",
    "invariants": "require(!frozenAccount[_to]);   ",
    "critical-invariants": " require(investor != 0x0);  ",
    "ranks": "require(validPurchase()); ",
    "vulnerabilities": "require(maxEtherInvestment >= msg.value); "
  },
  {
    "code": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {",
    "transaction-context": " require(balanceOf[investor] <= maxTokens); ",
    "Critical-points": " require(amountRaised <= fundingGoal); ",
    "invariants": "require(pylonSelled <= totalTokensToSend); ",
    "critical-invariants": "require((balanceOf[investor] + tokens) <= maxTokens);    ",
    "ranks": "require(balanceOf[this] >= tokens);           ",
    "vulnerabilities": " require(pylonSelled + tokens <= totalTokensToSend);"
  },
  {
    "code": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {",
    "transaction-context": "require(pylonSelled + tokens <= bonusCap); ",
    "Critical-points": "equire(balanceOf[investor] + tokens <= maxTokens); ",
    "invariants": "assert(a == 0 || c / a == b);",
    "critical-invariants": "assert(b <= a);",
    "ranks": " assert(c >= a);",
    "vulnerabilities": "assert(msg.sender == owner);"
  },
  {
    "code": "\n1 pragma solidity ^0.4.2;\n2 contract owned {\n3     address public owner;\n\n4     function owned() {\n5         owner = msg.sender;\n6     }\n",
    "transaction-context": "assert(balanceOf[this] >= amount)",
    "Critical-points": "assert(balanceOf[msg.sender] >= amount );",
    "invariants": "assert(!disabled);",
    "critical-invariants": "assert(!disabled);  \nassert(balances[_from] >= _value);\nassert(allowed[_from][msg.sender] >= _value && _value > 0);",
    "ranks": "assert(msg.sender == owner);",
    "vulnerabilities": "assert(msg.sender == owner);"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract SafeMath {\n\n3     function safeAdd(uint a, uint b) public pure returns (uint c) {\n4         c = a + b;\n\n5     }",
    "transaction-context": "require(c >= a);",
    "Critical-points": "require(b <= a);",
    "invariants": "require(a == 0 || c / a == b);",
    "critical-invariants": " require(b > 0);",
    "ranks": "assert(allowed[msg.sender][spender] = tokens); ",
    "vulnerabilities": "require(c >= a);"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n\n2 contract ERC20Interface {\n3     function totalSupply() public view returns (uint);\n4     function balanceOf(address tokenOwner) public view returns (uint balance);\n5     function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n6     function transfer(address to, uint tokens) public returns (bool success);\n7     function approve(address spender, uint tokens) public returns (bool success);",
    "transaction-context": "require(b <= a);",
    "Critical-points": " require(a == 0 || c / a == b);",
    "invariants": "assert(balances[msg.sender] >= _value);\n assert( _value > 0); ",
    "critical-invariants": "require(_to != address(0));\nrequire(_value <= balances[msg.sender]);",
    "ranks": "require(msg.sender == owner);",
    "vulnerabilities": "require(msg.sender == owner || msg.sender == operator); "
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }",
    "transaction-context": "require(_newOwner != address(0));",
    "Critical-points": "require(_newOperator != address(0));",
    "invariants": "require(blackList[msg.sender] != true);",
    "critical-invariants": "require(_lockAddress != address(0));\nrequire(_lockAddress != owner);\nrequire(blackList[_lockAddress] != true);",
    "ranks": "require(blackList[_unlockAddress] != false);",
    "vulnerabilities": "require(_to != address(0));\nrequire(_value <= balances[_from]);\nrequire(_value <= allowed[_from][msg.sender]);"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }",
    "transaction-context": "require(_to.length == _amount.length);",
    "Critical-points": "require(_to[ui] != address(0));",
    "invariants": " require(amountSum <= balances[msg.sender]);",
    "critical-invariants": " require(_value <= balances[msg.sender]);",
    "ranks": " require(blackList[_from] != true);\n require(blackList[_to] != true);",
    "vulnerabilities": "assert(i <= team_limit);"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n6 import \"./interfaces/IStakingBank.sol\";\n7 import \"./BaseChain.sol\";\n",
    "transaction-context": "require(msg.sender == owner, \"only owner\");\nrequire(dataTimestamp + padding < block.timestamp, \"do not spam\");\nrequire(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\nrequire(_keys.length == _values.length, \"numbers of keys and values not the same\");",
    "Critical-points": "require(uint224(_values[i]) == _values[i], \"FCD overflow\");",
    "invariants": "require(i >= requiredSignatures, \"not enough signatures\");",
    "critical-invariants": "require(winningId == 0, \"already drawn\");\nrequire(!drawingPhase, \"drawing\");",
    "ranks": "require(drawingPhase, \"not drawing\");",
    "vulnerabilities": "require(winningId == 0, \"already drawn\");\nrequire(!drawingPhase, \"drawing\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; ",
    "transaction-context": "require(!drawingPhase, \"drawing\");",
    "Critical-points": "assert(bal == oldBal || bal == (oldBal - amount));",
    "invariants": " assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "critical-invariants": "assert (!false);",
    "ranks": " assert(fee + value != 0);",
    "vulnerabilities": "assert(_required > 0); \nassert(m_numOwners > 0);"
  },
  {
    "code": "1 / SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract ether{\n5         function payout(address[] recipients,\n6                         uint256[] amounts) {\n7         require(recipients.length==amounts.length);\n8         for (uint i = 0; i < recipients.length; i++) {\n9         recipients[i].send(amounts[i]);",
    "transaction-context": "assert(address(this)==msg.sender);",
    "Critical-points": "assert(msg.sender == _contractRegistry);\nassert(msg.sender == _contractRegistry);",
    "invariants": "assert (sum == 1);",
    "critical-invariants": "assert(funcA2(funcA1())==12);\nassert(funcA3().funcB()!=42);",
    "ranks": "assert(c / a == b);",
    "vulnerabilities": "assert(b <= a);"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 library Math {\n    \n3     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4         if (a == 0) {\n5             return 0;\n6         }",
    "transaction-context": " assert(c >= a);",
    "Critical-points": "assert(c / a == b);",
    "invariants": "assert(b <= a);",
    "critical-invariants": "assert(c >= a);",
    "ranks": " require(_to != address(0));",
    "vulnerabilities": "require(_value <= balances[msg.sender]);"
  },
  {
    "code": "1 pragma solidity ^0.4.25;\n\n2 library SafeMath {\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     uint256 c = a * b;\n5     return c;\n6   }\n\n7   function div(uint256 a, uint256 b) internal pure returns (uint256) {",
    "transaction-context": "assert(a == 0 || c / a == b);",
    "Critical-points": "assert(b > 0); ",
    "invariants": "assert(b > 0); ",
    "critical-invariants": "assert(c >= a);",
    "ranks": "assert(uint112(a) == a);",
    "vulnerabilities": "assert(uint128(a) == a);"
  },
  {
    "code": "1 pragma solidity ^0.4.25;\n\n2 library SafeMath {\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     uint256 c = a * b;\n5     return c;\n6   }\n\n7   function div(uint256 a, uint256 b) internal pure returns (uint256) {",
    "transaction-context": "require(_to != address(0));",
    "Critical-points": "require(_value <= balances[msg.sender]);",
    "invariants": "require(_to != address(0));",
    "critical-invariants": "require(_value <= balances[_from]);",
    "ranks": "require(_value <= allowed[_from][msg.sender]);",
    "vulnerabilities": "require((_value == 0) || (allowed[msg.sender][_spender] == 0));"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process",
    "transaction-context": "assert(_committedRoot !=0); ",
    "Critical-points": "require(winningId == 0, \"already drawn\");",
    "invariants": "require(!drawingPhase, \"drawing\")",
    "critical-invariants": "require(winningId == 0, \"already drawn\");",
    "ranks": " require(drawingPhase, \"not drawing\");",
    "vulnerabilities": "require(id != 0, \"invalid winning number\");"
  },
  {
    "code": "1  contract Lottery {\n2  // user address -> lottery id -> count\n3  mapping (address => mapping(uint64 => uint))\n4  public tickets;\n5  uint64 winningId; // the winning id\n6  bool drawingPhase; // whether the owner is drawing\n\n7  // invoked every day to reset a round\n8  function reset() external onlyOwner {",
    "transaction-context": "require(winningId == 0, \"already drawn\");\n",
    "Critical-points": " assert(Old(votingToken.balanceOf(address(this))) == 0)",
    "invariants": "assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));",
    "critical-invariants": "assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "  assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));",
    "vulnerabilities": "assert(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *2);\n"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.0;\n3 \n4 contract WUSDMaster is Ownable, Withdrawable, ReentrancyGuard {\n5     using SafeERC20 for IERC20;\n6     \n7     IWUSD public immutable wusd;\n8     IERC20 public usdt;\n9     IERC20 public wex;",
    "transaction-context": "assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n",
    "Critical-points": "assert(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *2);\n",
    "invariants": "assert(Old(stakingToken.balanceOf(msg.sender)) == stakingToken.balanceOf(msg.sender));",
    "critical-invariants": "assert(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *2);\n\n",
    "ranks": "require(!drawingPhase, \"drawing\");\n",
    "vulnerabilities": "require(!drawingPhase, \"drawing\");\n"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4 contract testlock {\n5             \n6          function test_lock(\n7                  uint lock,\n8                  uint newLock,\n9                  uint amount",
    "transaction-context": "require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "Critical-points": "assert(Old(reserve0) == reserve0);\nassert(Old(reserve1) == reserve1);",
    "invariants": "assert(Old(reserve0) == reserve0 + amount0);\n assert(Old(reserve1) == reserve1+ amount1);",
    "critical-invariants": "require(proposal.sTime == 0, \"on-going proposal\");\n",
    "ranks": " require(proposal.sTime + 2 days > block.timestamp,\n \"voting has ended\");\n",
    "vulnerabilities": " assert(Old(votingToken.balanceOf(address(this))) ==votingToken.balanceOf(address(this)));\n"
  },
  {
    "code": "1 contract Vote {\n2    struct Proposal {\n3       uint160 sTime; address newOwner;\n4  }\n5   IERC20 votingToken;\n6   IERC20 LockedToken;\n7   address owner;\n8   Proposal proposal;\n",
    "transaction-context": "require(proposal.sTime != 0, \"no proposal\");",
    "Critical-points": "require(proposal.sTime + 2 days < block.timestamp, \"voting has not ended\");",
    "invariants": "require(votingToken.balanceOf(address(this))*2 >votingToken.totalSupply(), \"vote failed\");\n",
    "critical-invariants": "assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "require(winningId == 0, \"already drawn\");\n",
    "vulnerabilities": "require(!drawingPhase, \"drawing\")"
  },
  {
    "code": "1  contract Lottery {\n2  // user address -> lottery id -> count\n3  mapping (address => mapping(uint64 => uint))\n4  public tickets;\n5  uint64 winningId; // the winning id\n6  bool drawingPhase; // whether the owner is drawing\n\n7  // invoked every day to reset a round\n8  function reset() external onlyOwner {",
    "transaction-context": "require(winningId == 0, \"already drawn\");",
    "Critical-points": "require(drawingPhase, \"not drawing\");",
    "invariants": "require(id != 0, \"invalid winning number\");",
    "critical-invariants": "require(winningId == 0, \"already drawn\");\npause();",
    "ranks": "assert(lastRoundAssets > 0);",
    "vulnerabilities": "assert(amount > 0);"
  },
  {
    "code": "1 abstract contract BaseVault is IVault, ERC20Permit, Capped {\n\n2      function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n3          if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n4          uint256 _totalAssets = totalAssets();\n5          for (uint256 i = startIndex; i < endIndex; i++) {\n6              uint256 currentAssets = _totalAssets + processedDeposits;\n7              DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);",
    "transaction-context": "require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "Critical-points": "assert(Old(getPrice())==getPrice());",
    "invariants": "assert(Old(getPrice())<=getPrice()*2);\n",
    "critical-invariants": "require(proposal.sTime == 0, \"on-going proposal\");\n",
    "ranks": "assert(Old(votingToken.balanceOf(address(this))) == 0);",
    "vulnerabilities": "require(proposal.sTime + 2 days > block.timestamp,\n \"voting has ended\");"
  },
  {
    "code": "1 contract Vote {\n2    struct Proposal {\n3       uint160 sTime; address newOwner;\n4  }\n5   IERC20 votingToken;\n6   IERC20 LockedToken;\n7   address owner;\n8   Proposal proposal;\n",
    "transaction-context": "assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\nassert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "Critical-points": "require(proposal.sTime != 0, \"no proposal\");",
    "invariants": " require(proposal.sTime + 2 days < block.timestamp, \"voting has not ended\");",
    "critical-invariants": "require(votingToken.balanceOf(address(this))*2 >votingToken.totalSupply(), \"vote failed\");",
    "ranks": "assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "assert(Old(reserve0) == reserve0);\nassert(Old(reserve1) == reserve1);"
  },
  {
    "code": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);",
    "transaction-context": "assert(Old(reserve0) == reserve0 + amount0);\nassert(Old(reserve1) == reserve1+ amount1);",
    "Critical-points": "assert(msg.sender != 0);",
    "invariants": " assert(Old(abi.encode(admin)) == abi.encode(admin)); ",
    "critical-invariants": "assert(Old(abi.encode(implementation)) == abi.encode(implementation));",
    "ranks": "assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));",
    "vulnerabilities": "assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../ERC1967/ERC1967Proxy.sol\";\n\n5 interface ITransparentUpgradeableProxy {\n6     event Upgraded(address indexed implementation);",
    "transaction-context": "assert(Old(newImplementation) == abi.decode(msg.data[4:], (address)));",
    "Critical-points": "assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\nassert(Old(newAdmin) != Old(newImplementation)); ",
    "invariants": "assert(signatures.length ==calldatas.length);\n",
    "critical-invariants": "assert(signatures.length ==calldatas.length);\n",
    "ranks": "assert(signatures.length ==calldatas.length);\n",
    "vulnerabilities": "assert(signatures.length ==calldatas.length);"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";",
    "transaction-context": "require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n",
    "Critical-points": "require(owner != address(0), \"ERC721: invalid token ID\");",
    "invariants": "require(to != owner, \"ERC721: approval to current owner\");\n",
    "critical-invariants": "require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");",
    "ranks": "assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);",
    "vulnerabilities": "assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";",
    "transaction-context": "require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
    "Critical-points": " require(to != address(0), \"ERC721: mint to the zero address\");\n require(!_exists(tokenId), \"ERC721: token already minted\");",
    "invariants": "require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\nrequire(to != address(0), \"ERC721: transfer to the zero address\");",
    "critical-invariants": "require(_exists(tokenId), \"ERC721: invalid token ID\");",
    "ranks": "assert(Old(pirce) == token0.balanceOf(address(this))/token1.balanceOf(address(this)));\n",
    "vulnerabilities": "assert(price <= 1.2 * Old(pirce)); "
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "require((z = x + y) >= x, 'ds-math-add-overflow');",
    "Critical-points": "require((z = x - y) <= x, 'ds-math-sub-underflow');",
    "invariants": "require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');",
    "critical-invariants": " require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');",
    "ranks": "require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');",
    "vulnerabilities": "require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');",
    "Critical-points": "require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');",
    "invariants": "require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');",
    "critical-invariants": " require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');",
    "ranks": " require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');",
    "vulnerabilities": "require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');",
    "Critical-points": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');",
    "invariants": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');",
    "critical-invariants": "require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');",
    "ranks": "require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');",
    "vulnerabilities": "modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "assert(msg.sender == wNATIVE);",
    "Critical-points": "modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }",
    "invariants": "onlyMPC",
    "critical-invariants": "require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");",
    "ranks": " onlyMPC",
    "vulnerabilities": "require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "onlyMPC",
    "Critical-points": "onlyMPC",
    "invariants": "onlyMPC",
    "critical-invariants": "onlyMPC",
    "ranks": "onlyMPC",
    "vulnerabilities": "ensure(deadline)"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "ensure(deadline)",
    "Critical-points": "ensure(deadline)",
    "invariants": "require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "ensure(deadline)",
    "ranks": "ensure(deadline)",
    "vulnerabilities": "ensure(deadline)"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "onlyMPC",
    "Critical-points": "require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');",
    "invariants": " require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "require(cnt > 0 && cnt <= 20);\n",
    "ranks": "require(_value > 0 && balances[msg.sender] >= amount);\n",
    "vulnerabilities": "assert(amount >0);"
  },
  {
    "code": "\"1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\"\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;",
    "transaction-context": "onlyFactory \n",
    "Critical-points": "modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }",
    "invariants": " require(signatories.length == increments.length, 'two array lenth not equal');",
    "critical-invariants": " require(signatories.length == decrements.length, 'two array lenth not equal');",
    "ranks": " require(received[fromChainId][to][nonce] == 0, 'withdrawn already');",
    "vulnerabilities": " require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');"
  },
  {
    "code": "\"1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\"\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;",
    "transaction-context": " require(signatory != address(0), \"invalid signature\");",
    "Critical-points": "require(signatory == signatures[i].signatory, \"unauthorized\");",
    "invariants": " assert(to == signatory);",
    "critical-invariants": "require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "ranks": "require(yvTokenInfo.isYvToken, \"not a Yvault token\");",
    "vulnerabilities": "assert(pricePerShare <= k*Old(pricePerShare));"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";",
    "transaction-context": "require(crvTokenInfo.isCrvToken, \"not a curve pool token\");",
    "Critical-points": "require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");",
    "invariants": "require(tokenAddresses.length == quotes.length, \"mismatched data\");",
    "critical-invariants": "require(msg.sender == admin, \"guardian may only clear the aggregator\");",
    "ranks": " require(msg.sender == admin, \"only the admin may set LPs\");",
    "vulnerabilities": " require(tokenAddresses.length == isLP.length, \"mismatched data\");"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";",
    "transaction-context": "require(msg.sender == admin, \"only the admin may set Yvault tokens\");",
    "Critical-points": "require(tokenAddresses.length == version.length, \"mismatched data\");",
    "invariants": "require(msg.sender == admin, \"only the admin may set curve pool tokens\");",
    "critical-invariants": " require(tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\" );",
    "ranks": " require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";",
    "transaction-context": " require(msg.sender == admin, \"only the admin may set new guardian\");",
    "Critical-points": "require(msg.sender == admin, \"only the admin may set new admin\");",
    "invariants": "modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }",
    "critical-invariants": "nonReentrant ",
    "ranks": "assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);",
    "vulnerabilities": "assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);"
  },
  {
    "code": "1 contract Example {\n2     function flash(\n3         address recipient,\n4         uint256 amount0,\n5         uint256 amount1,\n6         bytes calldata data\n7     ) external isFlashable globallyTransactable transactable isNotEmergency {\n8         uint256 fee = curve.epsilon.mulu(1e18);\n9         ",
    "transaction-context": "assert(balance0Before.add(fee0) <= balance0After);",
    "Critical-points": "assert(balance1Before.add(fee1) <= balance1After);",
    "invariants": "nan",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1  contract PoolCurve{\n2 \n3    /// @notice sets the parameters for the pool\n4     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n5     /// @param _beta the value for beta must be less than alpha and greater than 0\n6     /// @param _feeAtHalt the maximum value for the fee at the halt point\n7     /// @param _epsilon the base fee for the pool\n8     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n9     function setParams(",
    "transaction-context": "modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": "onlyOwner",
    "ranks": "onlyOwner ",
    "vulnerabilities": "onlyOwner"
  },
  {
    "code": "1  contract PoolCurve{\n2 \n3    /// @notice sets the parameters for the pool\n4     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n5     /// @param _beta the value for beta must be less than alpha and greater than 0\n6     /// @param _feeAtHalt the maximum value for the fee at the halt point\n7     /// @param _epsilon the base fee for the pool\n8     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n9     function setParams(",
    "transaction-context": "onlyOwner",
    "Critical-points": "require(sender != address(0), \"\"ERC20: transfer from the zero address\"\");",
    "invariants": "require(recipient != address(0), \"\"ERC20: transfer to the zero address\"\");",
    "critical-invariants": "require(_owner != address(0), \"\"ERC20: approve from the zero address\"\");",
    "ranks": " require(spender != address(0), \"\"ERC20: approve to the zero address\"\");",
    "vulnerabilities": "modifier onlyOwner() {\n           require(msg.sender == owner, \"\"Curve/caller-is-not-owner\"\");        \n            _;\n     }"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": " modifier nonReentrant() {\n               require(notEntered, \"\"Curve/re-entered\"\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }",
    "Critical-points": "modifier transactable() {\n              require(!frozen, \"\"Curve/frozen-only-allowing-proportional-withdraw\"\");\n               _;\n         }",
    "invariants": "modifier isEmergency() {\n             require(emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n             _;\n        }",
    "critical-invariants": "modifier isNotEmergency() {\n              require(!emergency, \"\"Curve/emergency-only-allowing-emergency-proportional-withdraw\"\");\n             _;\n     }",
    "ranks": " modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"\"Curve/tx-deadline-passed\"\");\n              _;\n         }",
    "vulnerabilities": "modifier inWhitelistingStage() {\n              require(whitelistingStage, \"\"Curve/whitelist-stage-stopped\"\");\n                _;\n           }"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"\"Curve/whitelist-stage-on-going\"\");\n        }",
    "Critical-points": "modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"\"Curve/frozen-globally-only-allowing-proportional-withdraw\"\");\n              _;\n     }",
    "invariants": "modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"\"Curve/flashloans-paused\"\");\n            _;\n   }",
    "critical-invariants": "onlyOwner\n",
    "ranks": "onlyOwner",
    "vulnerabilities": "onlyOwner "
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "onlyOwner",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": "require(_newOwner != address(0), \"\"Curve/new-owner-cannot-be-zeroth-address\"\");",
    "ranks": "noDelegateCall isNotEmergency nonReentrant",
    "vulnerabilities": "require(targetAmount_ >= _minTargetAmount, \"\"Curve/below-min-target-amount\"\");"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "globallyTransactable transactable",
    "Critical-points": "globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant ",
    "invariants": " require(originAmount_ <= _maxOriginAmount, \"\"Curve/above-max-origin-amount\"\");",
    "critical-invariants": "globallyTransactable transactable\n",
    "ranks": "globallyTransactable transactable nonReentrant noDelegateCall ",
    "vulnerabilities": "require(amount == 1, \"\"Curve/invalid-amount\"\");"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "require(index <= 473, \"\"Curve/index-out-of-range\"\" );",
    "Critical-points": " require(isWhitelisted(index, account, amount, merkleProof), \"\"Curve/not-whitelisted\"\");",
    "invariants": "require(msg.sender == account, \"\"Curve/not-approved-user\"\");",
    "critical-invariants": "globallyTransactable",
    "ranks": "transactable",
    "vulnerabilities": "nonReentrant"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "noDelegateCall",
    "Critical-points": "notInWhitelistingStage",
    "invariants": " isNotEmergency\n",
    "critical-invariants": "globallyTransactable transactable",
    "ranks": "nonReentrant",
    "vulnerabilities": "noDelegateCall"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "nonReentrant",
    "Critical-points": "noDelegateCall",
    "invariants": " isNotEmergency",
    "critical-invariants": "globallyTransactable transactable ",
    "ranks": "nonReentrant noDelegateCall isNotEmergency",
    "vulnerabilities": "nonReentrant noDelegateCall"
  },
  {
    "code": "\"1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"\"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\"\";\n7 \n8 import \"\"./lib/ABDKMath64x64.sol\"\";\n9 ",
    "transaction-context": "isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency ",
    "Critical-points": "require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');",
    "invariants": "require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth'); ",
    "critical-invariants": " require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned'); ",
    "ranks": "require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\"",
    "vulnerabilities": "require(!_INITIALIZED_, \"DODO_INITIALIZED\");"
  },
  {
    "code": "1 contract DODO {\n2     function init(\n3         address maintainer,\n4         address baseTokenAddress,\n5         address quoteTokenAddress,\n6         uint256 lpFeeRate,\n7         uint256 mtFeeRate,\n8         uint256 k,\n9         uint256 i,",
    "transaction-context": "modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n",
    "Critical-points": "nonReentrant",
    "invariants": "require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");",
    "critical-invariants": "require(i > 0 && i <= 10**36);      ",
    "ranks": "require(k <= 10**18); ",
    "vulnerabilities": "require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );"
  },
  {
    "code": "1 pragma solidity ^0.6.0;\n2 pragma experimental ABIEncoderV2;\n\n3 import \"@openzeppelin/contracts/utils/Address.sol\";\n4 import \"./UniswapPCVDeposit.sol\";\n\n5 /// @title implementation for an ETH Uniswap LP PCV Deposit\n6 /// @author Fei Protocol\n7 contract EthUniswapPCVDeposit is UniswapPCVDeposit {",
    "transaction-context": " require(\n             ethAmount == msg.value,\n             \"Bonding Curve: Sent value does not equal input\"\n         );\n",
    "Critical-points": "assert(ethAmount <= k*Old(ethAmount)); ",
    "invariants": "assert(feiAmount <= k*Old(feiAmount)); ",
    "critical-invariants": "require(auctionStarted, \"Auction has not yet started\");",
    "ranks": " require(!auctionEnded, \"Auction has been finished\");",
    "vulnerabilities": "require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");",
    "Critical-points": "require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");",
    "invariants": "require(auctionStarted, \"Auction has not yet started\");",
    "critical-invariants": "require(!auctionEnded, \"You cannot end the action again\");",
    "ranks": "require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");",
    "vulnerabilities": " uint256 tokenId = _tokenIdCounter.current();"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "require(auctionEnded, \"Please end the auction firstly\");",
    "Critical-points": "require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");",
    "invariants": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "critical-invariants": " require(success, \"Failed to withdraw funds.\");",
    "ranks": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "vulnerabilities": "require(success, \"Failed to withdraw funds.\");"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": " require(success, \"Failed to withdraw funds.\");",
    "Critical-points": "onlyOwner",
    "invariants": "require(success, \"Failed to withdraw funds.\");",
    "critical-invariants": "require(totalBid > 0, \"Nothing to withdraw\");",
    "ranks": " require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");",
    "vulnerabilities": " require(success, \"Failed to withdraw funds.\");"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": " require(_exists(tokenId), \"Token does not exist\");",
    "Critical-points": " require(auctionStarted, \"Auction has not yet started\");\n require(!auctionEnded, \"Auction has been finished\");\n require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");",
    "invariants": " require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");",
    "critical-invariants": " require(auctionStarted, \"Auction has not yet started\");\n require(!auctionEnded, \"You cannot end the action again\");\n require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       ",
    "ranks": " require(auctionEnded, \"Please end the auction firstly\");",
    "vulnerabilities": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");",
    "Critical-points": " require(success, \"Failed to withdraw funds.\");",
    "invariants": "require(success, \"Failed to withdraw funds.\");",
    "critical-invariants": "require(success, \"Failed to withdraw funds.\");",
    "ranks": "require(totalBid > 0, \"Nothing to withdraw\");",
    "vulnerabilities": "require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");"
  },
  {
    "code": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;",
    "transaction-context": "require(success, \"Failed to withdraw funds.\");",
    "Critical-points": "modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }",
    "invariants": "onlyOwner",
    "critical-invariants": " require(dataTimestamp + padding < block.timestamp, \"do not spam\");",
    "ranks": "require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");",
    "vulnerabilities": " require(_keys.length == _values.length, \"numbers of keys and values not the same\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n\n6 import \"./interfaces/IStakingBank.sol\";\n",
    "transaction-context": "require(uint224(_values[i]) == _values[i], \"FCD overflow\");",
    "Critical-points": "require(prevSigner < signer, \"validator included more than once\");",
    "invariants": "require(i >= requiredSignatures, \"not enough signatures\");",
    "critical-invariants": "modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}",
    "ranks": " require(_amount > 0, \"!deposit zero\");",
    "vulnerabilities": "require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at FtmScan.com on 2021-08-31\n3 */\n\n4 // SPDX-License-Identifier: MIT\n5 // File: @openzeppelin/contracts/GSN/Context.sol\n\n\n6 pragma solidity ^0.6.0;",
    "transaction-context": "require(stratCandidate.implementation != address(0), \"There is no candidate\");",
    "Critical-points": "require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");",
    "invariants": " require(_token != address(want()), \"!token\");",
    "critical-invariants": "nonReentrant",
    "ranks": "modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }",
    "vulnerabilities": " modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": " require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": " onlyOwner",
    "ranks": "onlyOwner",
    "vulnerabilities": "onlyOwner"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "onlyOwner",
    "Critical-points": "onlyOwner",
    "invariants": " onlyOwner",
    "critical-invariants": " onlyOwner",
    "ranks": "onlyOwner",
    "vulnerabilities": "onlyOwner"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "onlyOwner",
    "Critical-points": "onlyOwner",
    "invariants": "onlyOwner",
    "critical-invariants": "onlyOwner",
    "ranks": "onlyOwner",
    "vulnerabilities": " require(isPoolActive,'Contract is not running yet');"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "onlyBank",
    "Critical-points": " onlyBank",
    "invariants": "require(isPoolActive,'Contract is not running yet');",
    "critical-invariants": "require(_depositId >= 0, \"Value is not specified\");",
    "ranks": "require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");",
    "vulnerabilities": "require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "require(_depositId >= 0, \"Value is not specified\");",
    "Critical-points": "require(pending > 0 ,\"No rewards to claim.\");",
    "invariants": "onlyRunnerScript",
    "critical-invariants": " require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");",
    "ranks": "require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");",
    "vulnerabilities": "require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";",
    "transaction-context": "require(isPoolActive,'Contract is not running yet');",
    "Critical-points": "require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');",
    "invariants": "require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');",
    "critical-invariants": " require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');",
    "ranks": "modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }",
    "vulnerabilities": "nonReentrant"
  },
  {
    "code": "1 // SPDX-License-Identifier: BSD-3-Clause\n2 pragma solidity ^0.8.10;\n\n3 import \"./ComptrollerInterface.sol\";\n4 import \"./CTokenInterfaces.sol\";\n5 import \"./ErrorReporter.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./InterestRateModel.sol\";\n8 import \"./ExponentialNoError.sol\";",
    "transaction-context": "nonReentrant",
    "Critical-points": "nonReentrant ",
    "invariants": "nonReentrant",
    "critical-invariants": "assert(totalAssets != 0);",
    "ranks": "require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");",
    "vulnerabilities": "assert(usdcAmount <= Old(usdcAmount)*k));"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );",
    "Critical-points": "require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");",
    "invariants": "require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");",
    "critical-invariants": "require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");",
    "ranks": " require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");",
    "vulnerabilities": " require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");"
  },
  {
    "code": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;",
    "transaction-context": "assert(_merkleRoot != 0);",
    "Critical-points": "assert(_msgHash != 0);",
    "invariants": "assert(_root != 0);",
    "critical-invariants": "require(amount > 0);\n",
    "ranks": "assert(lastRoundAssets > 0);",
    "vulnerabilities": "require(depositQueue.size()==1, \"Cannot process multiple deposits\");"
  }
]