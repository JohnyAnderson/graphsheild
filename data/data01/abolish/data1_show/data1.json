[
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ExternalFunctionCall {\n\n3     function foo(uint x) public returns (uint ret) {\n4         ret = x + 2;\n5     }\n\n6     function testExternalFunctionCall(uint x) public {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (y == x + 2);",
    "critical-invariants": "7+ assert (y == x + 2);",
    "ranks": "7+ assert (y == x + 2);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 20+",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 24+\n32+\n37+",
    "invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "critical-invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "ranks": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 20+",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 24+\n32+\n38+",
    "invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "critical-invariants": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "ranks": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0;\n2 import \"./Libraries/VeriSolContracts.sol\";\n\n\n3 contract LoopFor {\n\n4     int x;\n5     int y;\n",
    "transaction-context": "The transaction context is loop\narithmetics",
    "Critical-points": "Critical program points are 6+\n6+\n19+",
    "invariants": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0); ",
    "critical-invariants": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0);",
    "ranks": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "pragma solidity >=0.4.24 <0.6.0;\n\n//simple library with no internal state\n\nlibrary Lib {\n    function add(uint _a, uint _b) public view returns (uint r) {\n        address x = address(this);       \n        r = _a + _b;\n    }",
    "transaction-context": "The transaction context is cross-function\narithmetics",
    "Critical-points": "Critical program points are 5+\n14+",
    "invariants": "5+ assert(x == msg.sender);\n14+ assert (z == 3);",
    "critical-invariants": "14+ assert (z == 3);",
    "ranks": "14+ assert (z == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n2 import \"./../../Libraries/VeriSolContracts.sol\";\n3 //import \"./VeriSolContracts.sol\";\n4 //import \"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\";\n\n5 contract LoopFor {\n\n6     // test Loop invariant with for loop\n7     constructor(uint n) public {",
    "transaction-context": "The transaction context is loop\narithmetics",
    "Critical-points": "Critical program points are 10+ \n12+ \n19+  \n22+  \n29+ \n32+",
    "invariants": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "critical-invariants": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "ranks": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n\n5 /**\n6  * A highly simplified Token to express basic specifications",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 17+ \n47+ \n66+ ",
    "invariants": "17+ require(msg.sender != address(0));\n47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); \n66+ require(_balances[sender] >= amount);",
    "critical-invariants": "47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "ranks": "47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); ",
    "vulnerabilities": "incorrect visibility/ownership\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 //SPDX-License-Identifier: MIT\n2 pragma solidity 0.7.5;\n\n3 contract contrived{\n4  function withdraw(uint256 amount) override public nonReentrant updateReward(msg.sender) {  \n5     _totalSupply = _totalSupply - amount;\n6     _balances[msg.sender] = _balances[msg.sender].sub(amount);\n7     stakingToken.safeTransfer(msg.sender, amount);\n",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 4+",
    "invariants": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "critical-invariants": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "ranks": "4+   require(amount > 0, \"Cannot withdraw 0\");",
    "vulnerabilities": "integer over/underflow"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error",
    "transaction-context": "The transaction context is ERC\ntokenSale",
    "Critical-points": "Critical program points are 11+  \n20+ \n24+ \n51+   \n51+ \n145+ \n152+  \n168+ \n174+ ",
    "invariants": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);\n",
    "critical-invariants": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);",
    "ranks": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);",
    "vulnerabilities": "integer over/underflow\natomicity violation\nincorrect visibility/ownership"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "The transaction context is asset swapping\n",
    "Critical-points": "Critical program points are 17+ \n21+  \n35+ \n37+",
    "invariants": "17+ require(id < nextPositionID, \"bad position id\");\n17+ require(positions[id].goblin == goblin, \"bad position goblin\");\n17+ require(positions[id].owner == msg.sender, \"not position owner\");\n21+  require(config.isGoblin(goblin), \"not a goblin\");\n21+  require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n35+ require(debt >= config.minDebtSize(), \"too small debt size\");\n37+  require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n",
    "critical-invariants": "17+ require(id < nextPositionID, \"bad position id\");",
    "ranks": "17+ require(id < nextPositionID, \"bad position id\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+\n44+",
    "invariants": "13+  require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "critical-invariants": "44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "ranks": "44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "vulnerabilities": "reentrancy\nbusiness logic flaw"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 124+ \n137+ \n150+  \n171+ \n201+\n233+ \n284+ \n286+\n338+ \n341+\n544+ \n559+  \n576+\n655+ \n678+  \n715+ \n733+\n757+ \n797+ ",
    "invariants": "124+  require(c >= a, \"SafeMath: addition overflow\");\n137+  return sub(a, b, \"SafeMath: subtraction overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n576+  require(account != address(0), \"ERC20: burn from the zero address\");\n595+  require(owner != address(0), \"ERC20: approve from the zero address\");\n595+  require(spender != address(0), \"ERC20: approve to the zero address\");\n655+ require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n678+   require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n715+ require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n733+ require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n757+ require(localCounter == _guardCounter);\n797+ assert(token != address(this)); \n797+ assert(token != user); \n\n",
    "critical-invariants": "124+  require(c >= a, \"SafeMath: addition overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n186+ return div(a, b, \"SafeMath: division by zero\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n797+ assert(token != address(this)); \n797+ assert(token != user); ",
    "ranks": "124+  require(c >= a, \"SafeMath: addition overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n186+ return div(a, b, \"SafeMath: division by zero\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n797+ assert(token != address(this)); \n797+ assert(token != user); ",
    "vulnerabilities": "integer over/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 13+\n23+\n42+",
    "invariants": "13+ require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "critical-invariants": "23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "ranks": "23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       ",
    "vulnerabilities": "reentrancy \ninteger over/underflow"
  },
  {
    "code": "1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\n\n2 // File contracts/v0.4/token/linkERC20Basic.sol\n\n3 pragma solidity ^0.4.11;\n\n\n4 /**\n5  * @title ERC20Basic",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 88+  \n97+\n101+  ",
    "invariants": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);\n",
    "critical-invariants": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);",
    "ranks": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);",
    "vulnerabilities": "arithmetic flaw\nreentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "The transaction context is cross-function\nmoney market",
    "Critical-points": "Critical program points are 18+  \n33+ \n44+  \n45+  \n61+  \n63+",
    "invariants": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n",
    "critical-invariants": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");",
    "ranks": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 32+  \n89+ ",
    "invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n89+  require(canTransfer, \"E046\");\n",
    "critical-invariants": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "ranks": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n4 import { LibAsset } from \"../Libraries/LibAsset.sol\";\n5 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n6 import { LibSwap } from \"../Libraries/LibSwap.sol\";\n7 import { ICBridge } from \"../Interfaces/ICBridge.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 58+ \n92+  \n101+\n125+  \n191+  ",
    "invariants": "58+ require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n92+  require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n101+ require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n125+  require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n191+  assert(!invokeSwap);",
    "critical-invariants": "191+  assert(!invokeSwap);",
    "ranks": "191+  assert(!invokeSwap);",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 26+",
    "invariants": "26+   assert(_committedRoot != 0); ",
    "critical-invariants": "26+   assert(_committedRoot != 0); ",
    "ranks": "26+   assert(_committedRoot != 0); ",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 29+  \n30+  \n48+  \n51+  \n54+ \n55+ \n83+ \n106+  \n108+\n112+ \n117+  \n118+ \n121+ \n139+ \n143+ \n145+",
    "invariants": "29+  require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n30+  require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\n30+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");\n48+  require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");\n51+  require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");\n54+ require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n55+ require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\n55+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");\n83+ require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\");\n106+  require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n108+  require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n112+  require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n117+  require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n117+ require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n118+  require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n121+  require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n139+ assert(_method != “f1121318093”); \n143+ require(success == true, \"EthCrossChain call business contract failed\");\n145+  require(res == true, \"EthCrossChain call business contract return is not true\");",
    "critical-invariants": "139+ assert(_method != “f1121318093”); \n",
    "ranks": "139+ assert(_method != “f1121318093”); \n",
    "vulnerabilities": "incorrect visibility/ownership\nID uniqueness violation\nbusiness logic flaw\ninconsistent state update"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 43+    \n83+  ",
    "invariants": "43+    require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "critical-invariants": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "ranks": "43+   require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "vulnerabilities": "ID uniqueness violation\ninconsistent state update"
  },
  {
    "code": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are nan",
    "invariants": "43+  require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+  require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {x++;}",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (x == a + 1);",
    "critical-invariants": "7+ assert (x == a + 1);",
    "ranks": "7+ assert (x == a + 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // Possible bug:\n3 // In this test, ctor D is NOT called twice -\n4 // Only ctor C is called\n5 // compare with ConstructorChaining2_fail.sol\n\n6 contract D {\n7         uint a;",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 14+",
    "invariants": "14+ assert (a == x + 2);",
    "critical-invariants": "14+ assert (a == x + 2);",
    "ranks": "14+ assert (a == x + 2);",
    "vulnerabilities": "arithmetic flaw"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+  assert (a == 1);",
    "critical-invariants": "7+  assert (a == 1);",
    "ranks": "7+  assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract ArrayNestedFixedSize {\n\n2     // NOTE: the number of columns comes first in the declaration!\n3     uint[3][2] a;\n4     bool[2][2] aa;\n\n5     constructor() {\n6       _;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 20+ \n",
    "invariants": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "critical-invariants": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "ranks": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayFixedSize {\n\n3     uint[2] a;\n\n4     constructor() public {}\n\n5     function test() public {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "critical-invariants": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "ranks": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+",
    "invariants": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);\n9+ assert (sa.length == 2);",
    "critical-invariants": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);",
    "ranks": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;",
    "transaction-context": "The transaction context is loop",
    "Critical-points": "Critical program points are 7+  \n15+",
    "invariants": "7+  assert (a[0] == 0);\n7+ assert (a[1] == 1);\n15+ assert (b[j] == j);\n",
    "critical-invariants": "7+  assert (a[0] == 0);\n7+ assert (a[1] == 1);\n15+ assert (b[j] == j);",
    "ranks": "7+  assert (a[0] == 0);\n7+ assert (a[1] == 1);\n15+ assert (b[j] == j);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 8+ \n10+  \n11+ \n",
    "invariants": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);\n",
    "critical-invariants": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);",
    "ranks": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 8+",
    "invariants": "8+  assert (x == a + 1);",
    "critical-invariants": "8+  assert (x == a + 1);",
    "ranks": "8+  assert (x == a + 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+ ",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+   ",
    "invariants": "7+   assert (a == 1);",
    "critical-invariants": "7+   assert (a == 1);",
    "ranks": "7+   assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 13+",
    "invariants": "13+ assert (x == a + 2);",
    "critical-invariants": "13+ assert (x == a + 2);",
    "ranks": "13+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Consts {\n\n4     constructor () public {\n5         uint a;\n6         address b;\n7         address c;",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+",
    "invariants": "10+ assert(b != c);",
    "critical-invariants": "10+ assert(b != c);",
    "ranks": "10+ assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+\n11+",
    "invariants": "8+  assert (a == 1 || a == 2);\n11+ assert (a == 1 || a == 2);",
    "critical-invariants": "11+ assert (a == 1 || a == 2);",
    "ranks": "11+ assert (a == 1 || a == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;",
    "transaction-context": "The transaction context is loop\n",
    "Critical-points": "Critical program points are 9+",
    "invariants": "9+   assert (sum == 1);",
    "critical-invariants": "9+   assert (sum == 1);",
    "ranks": "9+   assert (sum == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Arithmetics {\n\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\n4         c = _a + _b;\n      \n5     }\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 4+ \n7+ \n10+ \n13+ ",
    "invariants": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "critical-invariants": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "ranks": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);",
    "vulnerabilities": "arithmetic flaw \ninteger overflow/underflow\n"
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0; contract Crowdsale {\n2     uint raised;\n3     uint goal;\n4     uint deadline;\n\n5     bool finished; // Instrumented.\n6     bool canceled; // Instrumented.\n\n7     constructor(uint _goal) public {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 16+ \n19+ \n22+ ",
    "invariants": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "critical-invariants": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "ranks": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); ",
    "vulnerabilities": "atomicity violation \n"
  },
  {
    "code": "1 contract JAY is ERC20, Ownable {\n2     using SafeMath for uint256;\n3     AggregatorV3Interface internal priceFeed;\n\n4     address private dev;\n5     uint256 public constant MIN = 1000;\n6     bool private start = false;\n7     bool private lockDev = false;\n",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 24+  \n46+       \n47+   \n100+       \n102+  \n104+ \n140+  \n143+   \n144+ \n148+    \n150+ ",
    "invariants": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");\n140+   require(value > MIN, \"Dude tf\");\n143+   require(success, \"ETH Transfer failed.\");\n144+   require(success2, \"ETH Transfer failed.\");\n148+   require(msg.value > MIN, \"must trade over min\");\n148+   require(start, \"Not started!\");\n150+ require(success, \"ETH Transfer failed.\");",
    "critical-invariants": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");",
    "ranks": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");",
    "vulnerabilities": "atomicity violation \narithmetic flaw\nintefer overflow/underflow\ninconsistent state update\nbusiness logic flaw"
  },
  {
    "code": "1 pragma solidity >=0.6.0 <0.8.0;\n\n2 import \"./openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n3 import \"./openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n4 import \"./openzeppelin/contracts/token/ERC20/IERC20.sol\";\n5 import \"./openzeppelin/contracts/math/SafeMath.sol\";\n6 import \"./openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n7 import \"./openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n8 // import \"hardhat/consolse.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 19+ \n76+",
    "invariants": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "critical-invariants": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "ranks": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); ",
    "vulnerabilities": "incorrect visibility/ownership\narithmetic flaw"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./ComptrollerInterface.sol\";\n3 import \"./CTokenInterfaces.sol\";\n4 import \"./ErrorReporter.sol\";\n5 import \"./Exponential.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./EIP20NonStandardInterface.sol\";\n8 import \"./InterestRateModel.sol\";",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 16+ \n17+   \n20+  \n24+ \n104+\n107+  \n133+\n195+ \n774+  \n828+  ",
    "invariants": "16+   require(msg.sender == admin, \"only admin may initialize the market\");\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n17+   require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n20+  require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n24+  require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n104+ require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n107+   require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n133+ require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n774+  require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n828+  require(_notEntered, \"re-entered\");",
    "critical-invariants": "16+   require(msg.sender == admin, \"only admin may initialize the market\");\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n17+   require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n774+  require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");",
    "ranks": "16+   require(msg.sender == admin, \"only admin may initialize the market\");\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n17+   require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n774+  require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");",
    "vulnerabilities": "reentrancy\ninconsistent state update \nID uniqueness violation\narithmetic flaw\nincorrect visibility/ownership "
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n3 import \"./ERC3156FlashLenderInterface.sol\";\n4 import \"./ERC3156FlashBorrowerInterface.sol\";\n\n5 /**\n6  * @title Cream's CCollateralCapErc20 Contract\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 44+   \n190+  \n194+ \n206+ \n217+ \n491+ \n552+  \n584+  \n586+  ",
    "invariants": "44+   require(err == 0, \"mint failed\");\n190+  require(\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\n                keccak256(\"ERC3156FlashBorrowerInterface.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n206+ require(msg.sender == address(comptroller), \"comptroller only\");\n217+ require(msg.sender == address(comptroller), \"comptroller only\");\n491+ require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");\n586+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n",
    "critical-invariants": "44+   require(err == 0, \"mint failed\");\n190+  require(\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\n                keccak256(\"ERC3156FlashBorrowerInterface.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n491+ require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");\n586+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");",
    "ranks": "44+   require(err == 0, \"mint failed\");\n190+  require(\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\n                keccak256(\"ERC3156FlashBorrowerInterface.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n491+ require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");\n586+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");",
    "vulnerabilities": "cross bridge\ninconsistent state update \nID uniqueness violation\narithmetic flaw"
  },
  {
    "code": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n\n3 /**\n4  * @title Compound's CErc20 Contract\n5  * @notice CTokens which wrap an EIP-20 underlying\n6  * @author Compound\n7  */",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 42+  \n50+ \n59+  \n67+ \n76+\n85+ \n100+\n154+\n192+\n209+\n210+ \n253+  \n260+   \n315+ \n336+  \n343+  \n352+  \n390+  \n402+  ",
    "invariants": "42+  require(err == 0, \"mint failed\");\n50+  require(redeemInternal(redeemTokens, false) == 0, \"redeem failed\");\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n67+  require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n76+  require(err == 0, \"repay failed\");\n85+  require(err == 0, \"repay behalf failed\");\n100+ require(err == 0, \"liquidate borrow failed\");\n154+ require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n192+  require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \"comptroller rejection\");\n210+ require(src != dst, \"bad input\");\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n260+   require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n336+  require(comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens) == 0, \"comptroller rejection\");\n343+  require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n352+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n390+  require(\n            comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\n            \"comptroller rejection\"\n        );\n402+   require(borrower != liquidator, \"invalid account pair\");",
    "critical-invariants": "42+  require(err == 0, \"mint failed\");\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n67+  require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n76+  require(err == 0, \"repay failed\");\n192+  require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \"comptroller rejection\");\n210+ require(src != dst, \"bad input\");\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n260+   require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n\n343+  require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n352+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n390+  require(  comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\"comptroller rejection\");\n402+   require(borrower != liquidator, \"invalid account pair\");",
    "ranks": "42+  require(err == 0, \"mint failed\");\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n67+  require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n76+  require(err == 0, \"repay failed\");\n192+  require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \"comptroller rejection\");\n210+ require(src != dst, \"bad input\");\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n260+   require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n\n343+  require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n352+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n390+  require(  comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\"comptroller rejection\");\n402+   require(borrower != liquidator, \"invalid account pair\");",
    "vulnerabilities": "cross bridge\ninconsistent state update \nID uniqueness violation\narithmetic flaw"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       (a,  b) = (1, 3);\n  ",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n9+ \n\n",
    "invariants": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);\n",
    "critical-invariants": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);",
    "ranks": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-05-09\n3 */\n\n4 pragma solidity ^0.4.21;\n\n\n5 /**\n6  * @title SafeMath",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 17+  \n32+ \n39+ \n84+ \n85+ ",
    "invariants": "17+  assert(c / a == b);\n32+ assert(b <= a);\n39+  assert(c >= a);\n84+  require(_to != address(0));\n85+ require(_value <= balances[msg.sender]);",
    "critical-invariants": "17+  assert(c / a == b);\n32+ assert(b <= a);\n39+  assert(c >= a);\n84+  require(_to != address(0));\n85+ require(_value <= balances[msg.sender]);",
    "ranks": "17+  assert(c / a == b);\n32+ assert(b <= a);\n39+  assert(c >= a);\n84+  require(_to != address(0));\n85+ require(_value <= balances[msg.sender]);",
    "vulnerabilities": "arithmetic flaw \ninteger overflow/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "1 pragma solidity ^0.4.16;\n \n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n \n3 contract TokenERC20 {\n4     string public name;\n5     string public symbol;\n6     uint8 public decimals = 18;  // 18 \n7     uint256 public totalSupply;",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 51+ \n58+  \n59+ ",
    "invariants": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "critical-invariants": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "ranks": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract SafeMath {\n\n2     function safeAdd(uint a, uint b) public pure returns (uint c) {\n3         c = a + b;\n4         require(c >= a);\n5     }\n\n6     function safeSub(uint a, uint b) public pure returns (uint c) {\n7         require(b <= a);",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 4+ \n7+ \n12+ \n15+ ",
    "invariants": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "critical-invariants": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "ranks": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // array variable copy breaks\n\n2 contract ArrayLength {\n3     uint[12] a;\n\n4     constructor (uint[12] memory d) public\n5     {\n6         require (d[1] == 5);\n7         a = d;       ",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 6+ \n8+  ",
    "invariants": "6+ require (d[1] == 5);\n8+  assert (d[1] == 5);",
    "critical-invariants": "8+  assert (d[1] == 5);",
    "ranks": "8+  assert (d[1] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n22+  \n23+  \n24+\n25+ \n26+  \n27+ ",
    "invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);\n",
    "critical-invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "ranks": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ ",
    "invariants": "7+ assert (b[1] == 22);",
    "critical-invariants": "7+ assert (b[1] == 22);",
    "ranks": "7+ assert (b[1] == 22);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.5.2;\n\n2 // Tests that function with inline assembly generates non-det result\n3 contract AssemblyTest\n4 {\n5         bool b;\n6         int x;\n7     constructor () public {\n8   }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 12+ ",
    "invariants": "12+ assert(false);",
    "critical-invariants": "12+ assert(false);",
    "ranks": "12+ assert(false);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+ \n13+ ",
    "invariants": "9+ assert (a == 1 || a == 2);\n13+ assert (a == 1 || a == 2);",
    "critical-invariants": "13+ assert (a == 1 || a == 2);",
    "ranks": "13+ assert (a == 1 || a == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+ ",
    "invariants": "10+ assert(b != c);",
    "critical-invariants": "10+ assert(b != c);",
    "ranks": "10+ assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+ ",
    "invariants": "8+ assert (a == 1);",
    "critical-invariants": "8+ assert (a == 1);",
    "ranks": "8+ assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 15+",
    "invariants": "15+ assert (x == a + 2);",
    "critical-invariants": "15+ assert (x == a + 2);",
    "ranks": "15+ assert (x == a + 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // Shows that constructor chaining still has a bug\n2 // D constructor is called twice - see trace in corral.txt:\n3 // ctor D {x = 1}\n4 // ctor D {x = 1}\n5 // ctor B\n6 // ctor C\n\n7 contract D {\n8         uint x;",
    "transaction-context": "The transaction context is arithmetics",
    "Critical-points": "Critical program points are 16+ ",
    "invariants": "16+ assert (x != 1); ",
    "critical-invariants": "16+ assert (x != 1); ",
    "ranks": "16+ assert (x != 1); ",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 9+   \n10+      \n13+    \n14+     \n16+     \n17+      ",
    "invariants": "9+       assert (a == 1);\n10+       assert (b == 3);\n13+       assert (a == 4);\n14+       assert (b == 40);\n16+       assert (a == 5);\n17+       assert (b == 55);\n",
    "critical-invariants": "9+       assert (a == 1);\n10+       assert (b == 3);\n13+       assert (a == 4);\n14+       assert (b == 40);\n16+       assert (a == 5);\n17+       assert (b == 55);",
    "ranks": "9+       assert (a == 1);\n10+       assert (b == 3);\n13+       assert (a == 4);\n14+       assert (b == 40);\n16+       assert (a == 5);\n17+       assert (b == 55);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;",
    "transaction-context": "The transaction context is loop\ncross function",
    "Critical-points": "Critical program points are 8+ \n9+\n18+ \n",
    "invariants": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);\n",
    "critical-invariants": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);",
    "ranks": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 5+ \n10+ \n11+ \n12+  ",
    "invariants": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "critical-invariants": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "ranks": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayFixedSize {\n\n3     uint[2] a;\n\n4     constructor() public {}\n\n5     function test() public {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+ \n9+ ",
    "invariants": "8+ assert(a[0] == 1);\n9+ assert(a[1] == 2);",
    "critical-invariants": "8+ assert(a[0] == 1);\n9+ assert(a[1] == 2);",
    "ranks": "8+ assert(a[0] == 1);\n9+ assert(a[1] == 2);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1  contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ ",
    "invariants": "7+ assert (b[1] == 22);",
    "critical-invariants": "7+ assert (b[1] == 22);",
    "ranks": "7+ assert (b[1] == 22);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+ \n8+ \n22+ \n23+ \n24+\n25+ \n26+ \n27+ ",
    "invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "critical-invariants": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "ranks": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 7+",
    "invariants": "7+ assert (b[1] == 22);",
    "critical-invariants": "7+ assert (b[1] == 22);",
    "ranks": "7+ assert (b[1] == 22);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+  ",
    "invariants": "10+  assert(b != c);",
    "critical-invariants": "10+  assert(b != c);",
    "ranks": "10+  assert(b != c);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 8+ ",
    "invariants": "8+ assert (a == 1);",
    "critical-invariants": "8+ assert (a == 1);",
    "ranks": "8+ assert (a == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 33+ \n34+ \n92+  ",
    "invariants": "33+ require(amount > 0, \"Invalid amount\");\n34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n92+  require(canTransfer, \"E046\");\n",
    "critical-invariants": "34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");",
    "ranks": "34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 19+         \n35+        \n36+       \n37+       \n49+         \n51+        \n68+        \n69+       \n70+        ",
    "invariants": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "critical-invariants": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "ranks": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");",
    "vulnerabilities": "incorrect visibility/ownership\nreentrancy"
  },
  {
    "code": "1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\n\n2 // File contracts/v0.4/token/linkERC20Basic.sol\n\n3 pragma solidity ^0.4.11;\n\n\n4 /**\n5  * @title ERC20Basic",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are 89+    \n99+    \n104+    ",
    "invariants": "89+    assert(a == 0 || c / a == b);\n99+     assert(b <= a);\n104+    assert(c >= a);",
    "critical-invariants": "89+    assert(a == 0 || c / a == b);\n99+     assert(b <= a);\n104+    assert(c >= a);",
    "ranks": "89+    assert(a == 0 || c / a == b);\n99+     assert(b <= a);\n104+    assert(c >= a);",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 contract ModifierEntrancy {\n\n3   mapping (address => uint) public tokenBalance;\n4   string constant name = \"Nu Token\";\n5   Bank bank;\n  \n6   constructor() public{",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 15+ \n20+  ",
    "invariants": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());\n20+  require(tokenBalance[msg.sender] == 0);\n\n",
    "critical-invariants": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "ranks": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {",
    "transaction-context": "The transaction context is tokenSale",
    "Critical-points": "Critical program points are 14+\n25+\n45+",
    "invariants": "14+  require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n25+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n45+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "critical-invariants": "25+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n45+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "ranks": "25+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n45+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 18+       \n19+ \n20+     \n24+       \n25+        \n31+       \n40+         \n43+    ",
    "invariants": "18+         require(id < nextPositionID, \"bad position id\");\n19+         require(positions[id].goblin == goblin, \"bad position goblin\");\n20+         require(positions[id].owner == msg.sender, \"not position owner\");\n24+         require(config.isGoblin(goblin), \"not a goblin\");\n25+        require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n31+        require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");\n40+         require(debt >= config.minDebtSize(), \"too small debt size\");\n43+         require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");",
    "critical-invariants": "18+         require(id < nextPositionID, \"bad position id\");\n",
    "ranks": "18+         require(id < nextPositionID, \"bad position id\");\n",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n\n3    function get_a()  public returns (uint) {\n4        return 2;\n5    }\n6 }\n",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 33+",
    "invariants": "33+  assert (y == 2*x + 4); ",
    "critical-invariants": "33+  assert (y == 2*x + 4);",
    "ranks": "33+  assert (y == 2*x + 4);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopNestedWhile {\n\n3     uint[2][2] a;\n\n4     function testNestedWhileLoop() public {\n5         uint i = 0;\n6         while (i < 2) {",
    "transaction-context": "The transaction context is loop",
    "Critical-points": "Critical program points are 14+      \n15+       \n16+      \n17+       ",
    "invariants": "14+        assert (a[0][0] == 0);\n15+        assert (a[0][1] == 1);\n16+         assert (a[1][0] == 2);\n17+         assert (a[1][1] == 3);",
    "critical-invariants": "14+        assert (a[0][0] == 0);\n15+        assert (a[0][1] == 1);\n16+         assert (a[1][0] == 2);\n17+         assert (a[1][1] == 3);",
    "ranks": "14+        assert (a[0][0] == 0);\n15+        assert (a[0][1] == 1);\n16+         assert (a[1][0] == 2);\n17+         assert (a[1][1] == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract MappingNested {\n\n3     mapping (uint => mapping (uint => uint)) m;\n4     mapping (uint => uint[]) n;\n5     uint[] p;\n  \n",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 10+         \n11+      \n12+        \n15+        \n16+\n17+         ",
    "invariants": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);\n12+         assert (n[0].length == 0);\n15+         assert (n[0].length == 2);\n16+         assert (n[1].length == 0); \n17+         assert (p.length == 0); ",
    "critical-invariants": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);",
    "ranks": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 //simple library with no internal state\n\n3 library Lib {\n4     function add(uint _a, uint _b) public view returns (uint r) {\n5         address x = address(this);\n6         assert(x == msg.sender);\n7         r = _a + _b;",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 6+\n16+",
    "invariants": "6+ assert(x == msg.sender);\n16+ assert (z == 3);",
    "critical-invariants": "16+ assert (z == 3);",
    "ranks": "16+ assert (z == 3);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 25+  \n34+  \n40+ \n41+    \n42+",
    "invariants": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "critical-invariants": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "ranks": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); ",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 21+  \n22+  ",
    "invariants": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "critical-invariants": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "ranks": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\"; //import \"../../math/SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n5 contract ERC20 is IERC20 {\n6     using SafeMath for uint256;\n",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 11+ \n22+  \n23+  \n24+  \n25+  \n49+  \n50+  \n62+  \n81+ \n82+ \n91+",
    "invariants": "11+ require(msg.sender != address(0));\n22+  _transfer(msg.sender, recipient, amount);\n23+  assert (_balances[msg.sender] + _balances[recipient]) == _balances[msg.sender] + _balances[recipient];\n24+  assert (msg.sender == recipient ||  _balances[msg.sender] == _balances[msg.sender] - amount);\n25+  assert (_balances[recipient] >= _balances[recipient]);\n49+  require(sender != address(0), \"ERC20: transfer from the zero address\");\n50+  require(recipient != address(0), \"ERC20: transfer to the zero address\");\n62+  require(account != address(0), \"ERC20: burn from the zero address\");\n81+ require(owner != address(0), \"ERC20: approve from the zero address\");\n82+ require(spender != address(0), \"ERC20: approve to the zero address\");\n91+ assert(_totalSupply == VeriSol.SumMapping(_balances);",
    "critical-invariants": "91+ assert(_totalSupply == VeriSol.SumMapping(_balances);",
    "ranks": "91+ assert(_totalSupply == VeriSol.SumMapping(_balances);",
    "vulnerabilities": "arithmetic flaw"
  },
  {
    "code": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 12+         \n63+        \n101+                                    \n102+                 \n103+      \n104+                          \n105+      \n140+   \n141+ \n142+   \n143+     \n144+       \n145+         \n157+         \n158+           \n159+       \n277+       \n278+      \n332+     \n342+     \n347+     ",
    "invariants": "12+         require(msg.sender == owner);\n63+         require(!paused);\n101+         require(_to != 0x0);                             \n102+         require(balanceOf[_from] >= _value);                \n103+         require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+         require(!frozenAccount[_from]);                     \n105+         require(!frozenAccount[_to]);   \n140+         require(investor != 0x0);  \n141+         require(validPurchase()); \n142+         require(maxEtherInvestment >= msg.value); \n143+        require(balanceOf[investor] <= maxTokens); \n144+         require(amountRaised <= fundingGoal); \n145+         require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159+       require(pylonSelled + tokens <= totalTokensToSend);\n277+       require(pylonSelled + tokens <= bonusCap); \n278+      require(balanceOf[investor] + tokens <= maxTokens); \n332+    assert(a == 0 || c / a == b);\n342+     assert(b <= a);\n347+     assert(c >= a);",
    "critical-invariants": "63+         require(!paused);\n101+       require(_to != 0x0);                             \n102+       require(balanceOf[_from] >= _value);                \n103+       require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+       require(!frozenAccount[_from]);                     \n105+       require(!frozenAccount[_to]);   \n140+       require(investor != 0x0);  \n141+       require(validPurchase()); \n142+       require(maxEtherInvestment >= msg.value); \n143+       require(balanceOf[investor] <= maxTokens); \n144+       require(amountRaised <= fundingGoal); \n145+       require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n277       require(pylonSelled + tokens <= bonusCap); \n278       require(balanceOf[investor] + tokens <= maxTokens); ",
    "ranks": "63+         require(!paused);\n101+       require(_to != 0x0);                             \n102+       require(balanceOf[_from] >= _value);                \n103+       require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+       require(!frozenAccount[_from]);                     \n105+       require(!frozenAccount[_to]);   \n140+       require(investor != 0x0);  \n141+       require(validPurchase()); \n142+       require(maxEtherInvestment >= msg.value); \n143+       require(balanceOf[investor] <= maxTokens); \n144+       require(amountRaised <= fundingGoal); \n145+       require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n277       require(pylonSelled + tokens <= bonusCap); \n278       require(balanceOf[investor] + tokens <= maxTokens); ",
    "vulnerabilities": "incorrect visibility/ownership\ninteger overflow/underflow \narithmetic flaw \n"
  },
  {
    "code": "\n1 pragma solidity ^0.4.2;\n2 contract owned {\n3     address public owner;\n\n4     function owned() {\n5         owner = msg.sender;\n6     }\n",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 7+\n125+ \n131+",
    "invariants": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount );",
    "critical-invariants": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount ) ",
    "ranks": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount ) ",
    "vulnerabilities": "integer overflow/underflow\nincorrect visibility/ownership"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n\n2 contract Token {\n3     uint256 public totalSupply;\n4     function balanceOf(address _owner) constant returns (uint256 balance);\n5     function transfer(address _to, uint256 _value) returns (bool success);\n6     function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n7     function approve(address _spender, uint256 _value) returns (bool success);\n8     function allowance(address _owner, address _spender) constant returns (uint256 remaining);",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 12+ \n22+   \n62+ \n69+",
    "invariants": "12+ assert(!disabled);\n22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n62+ assert(msg.sender == owner);\n69+ assert(msg.sender == owner);",
    "critical-invariants": "22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n69+ assert(msg.sender == owner);",
    "ranks": "22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n69+ assert(msg.sender == owner);",
    "vulnerabilities": "incorrect invisibility/ownership\natomicity violation\ninteger overflow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract SafeMath {\n\n3     function safeAdd(uint a, uint b) public pure returns (uint c) {\n4         c = a + b;\n\n5     }",
    "transaction-context": "The transaction context is ERC \nfunds transfer",
    "Critical-points": "Critical program points are 4+ \n6+ \n10+\n12+\n71+",
    "invariants": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "critical-invariants": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "ranks": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); ",
    "vulnerabilities": "arithmetic flaw\ninteger overflow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n\n2 contract ERC20Interface {\n3     function totalSupply() public view returns (uint);\n4     function balanceOf(address tokenOwner) public view returns (uint balance);\n5     function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n6     function transfer(address to, uint tokens) public returns (bool success);\n7     function approve(address spender, uint tokens) public returns (bool success);",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 15+ \n17+ \n21+ \n",
    "invariants": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);\n",
    "critical-invariants": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);",
    "ranks": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);",
    "vulnerabilities": "healthy"
  },
  {
    "code": "1 pragma solidity ^0.4.4;\n\n2 contract Token {\n\n3     function totalSupply() constant returns (uint256 supply) {}\n4     function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n5     function transfer(address _to, uint256 _value) returns (bool success) {}\n",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 13+ ",
    "invariants": "13+ assert(balances[msg.sender] >= _value);\n13+ assert( _value > 0); \n",
    "critical-invariants": "13+ assert(balances[msg.sender] >= _value);\n13+ assert( _value > 0); ",
    "ranks": "13+ assert(balances[msg.sender] >= _value);\n13+ assert( _value > 0); ",
    "vulnerabilities": "integer overflow/underflow\narithmetic flaw"
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 21+ \n40+ \n42+ \n44+ \n48+ \n57+ \n59+ \n64+\n87+\n120+\n123+ \n125+ \n136+  \n165+ ",
    "invariants": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);\n",
    "critical-invariants": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);",
    "ranks": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);",
    "vulnerabilities": "incorrect invisibility/ownership\nariithmetic flaw"
  },
  {
    "code": "nan\nWhat's the transaction context of the contract?\n",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are nan",
    "invariants": "nan",
    "critical-invariants": "nan",
    "ranks": "nan",
    "vulnerabilities": "nan"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n6 import \"./interfaces/IStakingBank.sol\";\n7 import \"./BaseChain.sol\";\n",
    "transaction-context": "The transaction context is cross bridge\nfunds transfer",
    "Critical-points": "Critical program points are 74+ \n76+ \n94+",
    "invariants": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp + padding < block.timestamp, \"do not spam\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "critical-invariants": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "ranks": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");",
    "vulnerabilities": "integer over/underflow\nincorrect visibility/ownership\narithmetic flaw"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; ",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 13+ \n20+  \n29+ ",
    "invariants": "13+ require(winningId == 0, \"already drawn\");\n13+ require(!drawingPhase, \"drawing\");\n20+  require(drawingPhase, \"not drawing\");\n29+  require(winningId == 0, \"already drawn\");\n29+ require(!drawingPhase, \"drawing\");",
    "critical-invariants": "13+ require(winningId == 0, \"already drawn\");\n13+ require(!drawingPhase, \"drawing\");\n20+  require(drawingPhase, \"not drawing\");\n29+  require(winningId == 0, \"already drawn\");\n29+ require(!drawingPhase, \"drawing\");",
    "ranks": "13+ require(winningId == 0, \"already drawn\");\n13+ require(!drawingPhase, \"drawing\");\n20+  require(drawingPhase, \"not drawing\");\n29+  require(winningId == 0, \"already drawn\");\n29+ require(!drawingPhase, \"drawing\");",
    "vulnerabilities": "atomicity violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; ",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 19+  ",
    "invariants": "19+   require(!drawingPhase, \"drawing\");",
    "critical-invariants": "19+   require(!drawingPhase, \"drawing\");",
    "ranks": "19+   require(!drawingPhase, \"drawing\");",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24<0.6.0;\n2 \n3 contract SimpleDAO {\n4     mapping (address => uint) public credit;\n5     constructor() public {\n6     }\n7     function donate(address to, uint amount) payable public {\n8         credit[to] += amount;\n9     }",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 22+ ",
    "invariants": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "critical-invariants": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "ranks": "22+ assert(bal == oldBal || bal == (oldBal - amount));",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 ragma solidity ^0.5.0;\n2 \n3 import \"./IERC20.sol\";\n4 import \"./SafeMath.sol\";\n5 import \"./Libraries/VeriSolContracts.sol\"; //change \n6 \n7 \n8 contract ERC20 is IERC20 {\n9 ",
    "transaction-context": "The transaction context is funds transfer\nERC",
    "Critical-points": "Critical program points are 31+ ",
    "invariants": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "critical-invariants": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "ranks": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));",
    "vulnerabilities": "incorrect ownership/visibility"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 \n3 contract AssertFalse {\n4 \n5     function test1() public {\n6               _;\n7 \n8     }\n9 ",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 6+ \n",
    "invariants": "6+ assert (!false);\n",
    "critical-invariants": "6+ assert (!false);",
    "ranks": "6+ assert (!false);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract overflow{\n5     function transferProxy (address from, address to, uint\n6     value, uint fee) {  \n7         if (balance[from] < fee + value) revert();\n8 \n9         if (balance[to] + value < balance[to] ||",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 6+",
    "invariants": "6+  assert(fee + value != 0);\n",
    "critical-invariants": "6+  assert(fee + value != 0);",
    "ranks": "6+  assert(fee + value != 0);",
    "vulnerabilities": "integer overflow/underflow"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract testSuicide{\n5         function initMultiowned(address[] _owners,\n6                             uint _required){\n7         if (m_numOwners > 0) throw;\n8         m_numOwners = _owners.length + 1;\n9         m_owners[1] = uint(msg.sender);",
    "transaction-context": "The transaction context is simple",
    "Critical-points": "Critical program points are 15+",
    "invariants": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "critical-invariants": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "ranks": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);",
    "vulnerabilities": "suicidal contracts"
  },
  {
    "code": "1 / SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract ether{\n5         function payout(address[] recipients,\n6                         uint256[] amounts) {\n7         require(recipients.length==amounts.length);\n8         for (uint i = 0; i < recipients.length; i++) {\n9         recipients[i].send(amounts[i]);",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 6+\n",
    "invariants": "6+  assert(address(this)==msg.sender);\n",
    "critical-invariants": "6+  assert(address(this)==msg.sender);\n",
    "ranks": "6+  assert(address(this)==msg.sender);\n",
    "vulnerabilities": "ether leakage"
  },
  {
    "code": "1   // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n4 \n5 \n6 contract Chain  {\n7   IStakingBank public immutable stakingBank;\n8 \n9   event LogMint(address indexed minter, uint256 blockId, uint256 staked, uint256 power);",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 30+",
    "invariants": "30+ assert(msg.sender == _contractRegistry);\n30+ assert(msg.sender == _contractRegistry);",
    "critical-invariants": "30+ assert(msg.sender == _contractRegistry);",
    "ranks": "30+ assert(msg.sender == _contractRegistry);",
    "vulnerabilities": "incorrect visibility/ownership"
  },
  {
    "code": "1 //SPDX-License-Identifier: GPL-3.0\n2 pragma solidity 0.8.4;\n3 \n4 import \"../libraries/MathLib.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n7 import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n8 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n9 import \"../interfaces/IExchangeFactory.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 147+\n194+\n",
    "invariants": "147+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "critical-invariants": "194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "ranks": "194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.5.0;\n\n3 interface IERC20 {\n4     event Approval(address indexed owner, address indexed spender, uint value);\n5     event Transfer(address indexed from, address indexed to, uint value);\n\n6     function name() external view returns (string memory);\n7     function symbol() external view returns (string memory);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 63+\n73+\n",
    "invariants": "63+ assert(Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair))) == USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)));\n73+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack!\");\n",
    "critical-invariants": "73+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack!\");",
    "ranks": "73+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack!\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n3 \n4  contract Swap {\n5          IERC20 public WEI;\n6          IERC20 public USD;\n7          IUniswapV2Pair public pair; \n8          mapping(address => uint) public debt;\n9          mapping(address => uint) public collateral;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 13+\n23+\n",
    "invariants": "13+ assert(Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair))) == USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)));\n23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n",
    "critical-invariants": "23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n",
    "ranks": "23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity 0.8.4;\n3 import \"./IOracle.sol\";\n4 \n5 \n6 interface IAggregator {\n7     function latestAnswer() external view returns (int256 answer);\n8 }\n9 ",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 24+ \n26+ \n\n\n",
    "invariants": "24+ assert(Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) == price);\n26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n",
    "critical-invariants": "26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n",
    "ranks": "26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity 0.8.4;\n3 import \"./IOracle.sol\";\n4 \n5 \n6 interface IAggregator {\n7     function latestAnswer() external view returns (int256 answer);\n8 }\n9 ",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 24+ \n26+ \n\n\n",
    "invariants": "24+ assert(Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) == price);\n26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n",
    "critical-invariants": "26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");",
    "ranks": "26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 \n3 pragma solidity 0.6.12;\n4 \n5 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"../LPToken.sol\";\n8 import \"../interfaces/ISwap.sol\";\n9 import \"../MathUtils.sol\";",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 110+ \n186+\n",
    "invariants": "110+ assert(Old(CalculateSwapUnderlyingInfo.dy) == dy);\n186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));\n",
    "critical-invariants": "186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));",
    "ranks": "186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "//hundred finance hack\n1 pragma solidity ^0.4.11;\n2 \n3 \n4 import \"./token/ERC677.sol\";\n5 import \"./token/ERC677Receiver.sol\";\n6 \n7 \n8 contract ERC677Token is ERC677 {",
    "transaction-context": "The transaction context is ERC677",
    "Critical-points": "Critical program points are 44+ \n50+ \n\n",
    "invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "critical-invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "ranks": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "vulnerabilities": "reentrancy\natomicity violation"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 \n4 import \"./token/ERC677.sol\";\n5 import \"./token/ERC677Receiver.sol\";\n6 \n7 \n8 contract ERC677Token is ERC677 {\n9 ",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 44+ \n50+ \n\n",
    "invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "critical-invariants": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "ranks": "44+ assert(locked==true);\n50+ assert(locked==true);\n",
    "vulnerabilities": "atomicity violation "
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 \n4 contract Ctoken{\n5     function transfer(address _to, uint256 _value) public returns (bool) {\n6         require(superTransfer(_to, _value));\n7         callAfterTransfer(msg.sender, _to, _value);\n8         return true;\n9     }",
    "transaction-context": "The transaction context is tokenSale\nfunds transfer",
    "Critical-points": "Critical program points are 5+ \n11+\n",
    "invariants": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "critical-invariants": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "ranks": "5+ assert(locked==true);\n11+ assert(locked==true);\n",
    "vulnerabilities": "reentrancy"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 \n3 pragma solidity ^0.8.0;\n4 \n5 contract WUSDMaster{\n6 \n7         function stake(uint256 amount) external nonReentrant {\n8         require(amount <= maxStakeAmount, 'amount too high');\n9         usdt.safeTransferFrom(msg.sender, address(this), amount);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 8+ \n14+ \n",
    "invariants": "8+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n14+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "8+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n14+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k, \"watch out for flashloan attacks!\");\n",
    "ranks": "14+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k, \"watch out for flashloan attacks!\");\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.0;\n3 \n4 contract WUSDMaster is Ownable, Withdrawable, ReentrancyGuard {\n5     using SafeERC20 for IERC20;\n6     \n7     IWUSD public immutable wusd;\n8     IERC20 public usdt;\n9     IERC20 public wex;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 53+ \n59+ \n",
    "invariants": "53+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");\n",
    "critical-invariants": "59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");",
    "ranks": "59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.12;\n3 pragma experimental ABIEncoderV2;\n4 \n5 \n6 \n7 contract PancakeSwap is IStrategy, RewardsDistributionRecipient, ReentrancyGuard, Pausable {\n8     using SafeMath for uint256;\n9     using SafeBEP20 for IBEP20;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 47+\n181+ \n",
    "invariants": "47+ assert(Old(stakingToken.balanceOf(msg.sender)) == stakingToken.balanceOf(msg.sender));\n181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");",
    "ranks": "181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4  contract Lottery {\n5 \n6          mapping (address => mapping(uint64 => uint))\n7          public tickets;\n8          uint64 winningId; \n9          bool drawingPhase; ",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 17+ \n35+ \n",
    "invariants": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "critical-invariants": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "ranks": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n",
    "vulnerabilities": "atomicity violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4 contract testlock {\n5             \n6          function test_lock(\n7                  uint lock,\n8                  uint newLock,\n9                  uint amount",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 12+ \n",
    "invariants": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "critical-invariants": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "ranks": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw"
  },
  {
    "code": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 42+\n151+ \n",
    "invariants": "42+ assert(Old(reserve0) == reserve0);\n42+ assert(Old(reserve1) == reserve1);\n152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "critical-invariants": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "ranks": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 42+\n152+ \n",
    "invariants": "42+ assert(Old(reserve0) == reserve0);\n42+ assert(Old(reserve1) == reserve1);\n152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "critical-invariants": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "ranks": "152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;",
    "transaction-context": "The transaction context is loop",
    "Critical-points": "Critical program points are 9+ ",
    "invariants": "9+ assert (sum == 1);",
    "critical-invariants": "9+ assert (sum == 1);",
    "ranks": "9+ assert (sum == 1);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {",
    "transaction-context": "The transaction context is cross-function",
    "Critical-points": "Critical program points are 20+ ",
    "invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()!=42);",
    "critical-invariants": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()!=42);",
    "ranks": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()!=42);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.24;\n\n\n2 library Math {\n    \n3     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4         if (a == 0) {\n5             return 0;\n6         }",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 8+\n15+\n20+",
    "invariants": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "critical-invariants": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "ranks": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.21;\n\n2 library SafeMath {\n\n\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     if (a == 0) {\n5       return 0;\n6     }",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 8+    \n15+    \n20+    \n44+     \n45+    ",
    "invariants": "8+     assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n44+    require(_to != address(0));\n45+     require(_value <= balances[msg.sender]);",
    "critical-invariants": "8+    assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n",
    "ranks": "8+    assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.4.25;\n\n2 library SafeMath {\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     uint256 c = a * b;\n5     return c;\n6   }\n\n7   function div(uint256 a, uint256 b) internal pure returns (uint256) {",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 4+ \n7+ \n11+  \n15+ \n19+  \n27+ \n47+ \n48+ \n72+ \n73+\n74+\n82+",
    "invariants": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n19+  assert(uint112(a) == a);\n27+ assert(uint128(a) == a);\n47+ require(_to != address(0));\n48+ require(_value <= balances[msg.sender]);\n72+ require(_to != address(0));\n73+ require(_value <= balances[_from]);\n74+ require(_value <= allowed[_from][msg.sender]);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "critical-invariants": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "ranks": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));",
    "vulnerabilities": "arithmetic flaw\ninteger over/underflow"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process",
    "transaction-context": "The transaction context is cross bridge",
    "Critical-points": "Critical program points are 26+ ",
    "invariants": "26+ assert(_committedRoot !=0); ",
    "critical-invariants": "26+ assert(_committedRoot !=0); ",
    "ranks": "26+ assert(_committedRoot !=0); ",
    "vulnerabilities": "cross bridge\nID Uniqueness violation"
  },
  {
    "code": "1 contract Vote {\n2    struct Proposal {\n3       uint160 sTime; address newOwner;\n4  }\n5   IERC20 votingToken;\n6   IERC20 LockedToken;\n7   address owner;\n8   Proposal proposal;\n",
    "transaction-context": "The transaction context is voting\nbidding proposal",
    "Critical-points": "Critical program points are 10+\n11+  \n14+ \n17+ \n20+ \n21+  \n23+ \n24+ \n",
    "invariants": "10+ require(proposal.sTime == 0, \"on-going proposal\");\n11+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n14+ require(proposal.sTime + 2 days > block.timestamp,\n \"voting has ended\");\n17+ assert(Old(votingToken.balanceOf(address(this))) ==votingToken.balanceOf(address(this)));\n20+ require(proposal.sTime != 0, \"no proposal\");\n21+  require(proposal.sTime + 2 days < block.timestamp,\n \"voting has not ended\");\n23+ require(votingToken.balanceOf(address(this))*2 >\nvotingToken.totalSupply(), \"vote failed\");\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n\n",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n\n",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1  contract Lottery {\n2  // user address -> lottery id -> count\n3  mapping (address => mapping(uint64 => uint))\n4  public tickets;\n5  uint64 winningId; // the winning id\n6  bool drawingPhase; // whether the owner is drawing\n\n7  // invoked every day to reset a round\n8  function reset() external onlyOwner {",
    "transaction-context": "The transaction context is lottery",
    "Critical-points": "Critical program points are 13+  \n14+ \n23+  \n24+ \n25+  \n34+  \n",
    "invariants": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "critical-invariants": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "ranks": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n",
    "vulnerabilities": "atomicity violation\nbusiness logic flaw"
  },
  {
    "code": "1 // SPDX-License-Identifier: AGPL-3.0-or-later\n\n2 pragma solidity 0.8.9;\n\n3 import \"./BaseVault.sol\";\n4 ct STETHVault is BaseVault {\n5     using SafeERC20 for IERC20Metadata;\n6     using AuxMath for uint256;\n7     using AuxMath for AuxMath.Fractional;",
    "transaction-context": "The transaction context is nan",
    "Critical-points": "Critical program points are 72+ \n115+ ",
    "invariants": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "critical-invariants": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "ranks": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);",
    "vulnerabilities": "vault\nasset swapping"
  },
  {
    "code": "1 abstract contract BaseVault is IVault, ERC20Permit, Capped {\n\n2      function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n3          if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n4          uint256 _totalAssets = totalAssets();\n5          for (uint256 i = startIndex; i < endIndex; i++) {\n6              uint256 currentAssets = _totalAssets + processedDeposits;\n7              DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);",
    "transaction-context": "The transaction context is vault \nasset swapping",
    "Critical-points": "Critical program points are 10+",
    "invariants": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "critical-invariants": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "ranks": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");",
    "vulnerabilities": "insufficient gas"
  },
  {
    "code": "1/ / SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract overflow{\n5         function pay(address[] recipients,\n6                         uint256[] amounts) {\n7         require(recipients.length==amounts.length);\n8         for (uint i = 0; i < recipients.length; i++) {\n9         recipients[i].send(amounts[i]);",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 7+\n8+ ",
    "invariants": "7+ require(recipients.length==amounts.length);\n8+ assert(amounts[i] >= 0); ",
    "critical-invariants": "8+ assert(amounts[i] >= 0); ",
    "ranks": "8+ assert(amounts[i] >= 0); ",
    "vulnerabilities": "integer overflow/underflow\ninsufficient gas"
  },
  {
    "code": "1 / / SPDX-License-Identifier: MIT\n2   pragma solidity >=0.4.24 <0.6.0;\n3 contract AccountingError{\n\n4 function swap(uint amount1Out, address to) external {\n5      token1.transfer(to, amount1Out);\n6      IUniswapV2Callee(to).uniswapV2Call();\n\n7      uint balance0 = token0.balanceOf(address(this));",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 10+  \n",
    "invariants": "10+  assert( balance0Adj*balance1 >= reserve0* reserve1* 10000);\n",
    "critical-invariants": "10+  assert( balance0Adj*balance1 >= reserve0* reserve1* 10000);",
    "ranks": "10+  assert( balance0Adj*balance1 >= reserve0* reserve1* 10000);",
    "vulnerabilities": "arithmetic flaw\n"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3   contract Swap {\n4           IERC20 public WEI;\n5           IERC20 public USD;\n6           IUniswapV2Pair public pair; \n7           mapping(address => uint) public debt;\n8           mapping(address => uint) public collateral;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 8+ \n16+\n",
    "invariants": "8+ assert(Old(getPrice())==getPrice());\n16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "critical-invariants": "16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "ranks": "16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n",
    "vulnerabilities": "price manipulation\ninconsistent state update"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3 contract etherleakge{\n4    function payout(address[] recipients,\n5                 uint256[] amounts) {\n6       require(recipients.length==amounts.length);\n7       for (uint i = 0; i < recipients.length; i++) {\n",
    "transaction-context": "The transaction context is payment ",
    "Critical-points": "Critical program points are 6+ ",
    "invariants": "6+ assert(msg.sender != 0);",
    "critical-invariants": "assert(msg.sender != 0);",
    "ranks": "assert(msg.sender != 0);",
    "vulnerabilities": "ether leakage"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "//votingToken is important for tracking \n1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;",
    "transaction-context": "The transaction context is voting \nbidding proposal",
    "Critical-points": "Critical program points are  13+ \n17+ \n24+ \n",
    "invariants": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n",
    "critical-invariants": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "ranks": "24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));",
    "vulnerabilities": "privilege escalation\ninteger overlow/underflow"
  },
  {
    "code": "1  // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../ERC1967/ERC1967Proxy.sol\";\n\n5 interface ITransparentUpgradeableProxy {\n6     event Upgraded(address indexed implementation);",
    "transaction-context": "The transaction context is proxy\nprotocol",
    "Critical-points": "Critical program points are 80+ \n92+ \n99+ \n108+ \n111+",
    "invariants": "80+ assert(Old(abi.encode(admin)) == abi.encode(admin)); \n92+ assert(Old(abi.encode(implementation)) == abi.encode(implementation));\n99+ assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));\n108+ assert(Old(newImplementation) == abi.decode(msg.data[4:], (address)));\n111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); \n",
    "critical-invariants": "111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); ",
    "ranks": "111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); ",
    "vulnerabilities": "incorrect visibility/ownership\ninconsistent state update\natomicity violation"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../../utils/math/SafeCast.sol\";\n5 import \"../extensions/IGovernorTimelock.sol\";\n6 import \"../Governor.sol\";\n7 import \"./IGovernorCompatibilityBravo.sol\";",
    "transaction-context": "The transaction context is protocol\nvoting ",
    "Critical-points": "Critical program points are 63+\n111+ \n131+ ",
    "invariants": "63+ assert(signatures.length ==calldatas.length);\n111+ assert(signatures.length ==calldatas.length);\n131+ assert(signatures.length ==calldatas.length);",
    "critical-invariants": "63+ assert(signatures.length ==calldatas.length);",
    "ranks": "63+ assert(signatures.length ==calldatas.length);",
    "vulnerabilities": "insufficient gas"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../../utils/math/SafeCast.sol\";\n5 import \"../extensions/IGovernorTimelock.sol\";\n6 import \"../Governor.sol\";\n7 import \"./IGovernorCompatibilityBravo.sol\";",
    "transaction-context": "The transaction context is protocol\nvoting ",
    "Critical-points": "Critical program points are 36+ ",
    "invariants": "36+ assert(signatures.length ==calldatas.length);",
    "critical-invariants": "assert(signatures.length ==calldatas.length);",
    "ranks": "assert(signatures.length ==calldatas.length);",
    "vulnerabilities": "insufficient gas"
  },
  {
    "code": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";",
    "transaction-context": "The transaction context is ERC",
    "Critical-points": "Critical program points are 42+ \n47+ \n66+ \n67+ \n87+ \n112+ \n141+ \n141+  \n177+ \n177+ \n210+ ",
    "invariants": "42+ require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n47+ require(owner != address(0), \"ERC721: invalid token ID\");\n66+ require(to != owner, \"ERC721: approval to current owner\");\n67+ require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n112+ require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n141+ require(to != address(0), \"ERC721: mint to the zero address\");\n141+  require(!_exists(tokenId), \"ERC721: token already minted\");\n177+  require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n177+ require(to != address(0), \"ERC721: transfer to the zero address\");\n210+ require(_exists(tokenId), \"ERC721: invalid token ID\");\n",
    "critical-invariants": "87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n",
    "ranks": "87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 11+",
    "invariants": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); ",
    "critical-invariants": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "ranks": "11+ assert(price <= 1.2 * Old(pirce)); ",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }",
    "transaction-context": "The transaction context is money market",
    "Critical-points": "Critical program points are 15+  \n19+ \n23+ \n32+  \n34+\n57+ \n58+  \n64+  \n65+ \n74+  \n75+ \n83+  \n94+ \n109+ \n115+ \n121+\n126+ \n168+  \n181+ \n196+ \n212 \n213+\n221 \n222+  \n291 \n296 \n302 \n312 \n318 \n360 \n379 \n409 \n428+  \n454 \n473 \n503 \n520  \n521+ \n523+   ",
    "invariants": "15+  require((z = x + y) >= x, 'ds-math-add-overflow');\n19+  require((z = x - y) <= x, 'ds-math-sub-underflow');\n23+  require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n212 onlyMPC\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n221 onlyMPC\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "critical-invariants": "168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "ranks": "168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');",
    "vulnerabilities": "price manipulation"
  },
  {
    "code": "1 contract PausableToken is StandardToken, Pausable {\n2 \n3   function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n4     return super.transfer(_to, _value);\n5   }\n6 \n7   function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n8     return super.transferFrom(_from, _to, _value);\n9   }",
    "transaction-context": "The transaction context is funds transfer",
    "Critical-points": "Critical program points are 18 \n19 \n19+ ",
    "invariants": "18 require(cnt > 0 && cnt <= 20);\n19 require(_value > 0 && balances[msg.sender] >= amount);\n19+ assert(amount >0);",
    "critical-invariants": "19+ assert(amount >0);",
    "ranks": "19+ assert(amount >0);",
    "vulnerabilities": "integer overflow"
  },
  {
    "code": "1 library SafeMath {\n2   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n3     uint256 c = a * b;\n4     assert(a == 0 || c / a == b);\n5     return c;\n6   }\n7 \n8   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n9     // assert(b > 0); // Solidity automatically throws when dividing by 0",
    "transaction-context": "The transaction context is safemath library",
    "Critical-points": "Critical program points are 4 \n16 \n22 ",
    "invariants": "4 assert(a == 0 || c / a == b);\n16 assert(b <= a);\n22 assert(c >= a);",
    "critical-invariants": "4 assert(a == 0 || c / a == b);\n16 assert(b <= a);\n22 assert(c >= a);",
    "ranks": "4 assert(a == 0 || c / a == b);\n16 assert(b <= a);\n22 assert(c >= a);",
    "vulnerabilities": "healthy "
  },
  {
    "code": "1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;",
    "transaction-context": "The transaction context is asset swapping",
    "Critical-points": "Critical program points are 22  \n27  \n55 \n69 \n109 \n111 \n118 \n119 \n133 ",
    "invariants": "22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n55 require(signatories.length == increments.length, 'two array lenth not equal');\n69 require(signatories.length == decrements.length, 'two array lenth not equal');\n109 require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n111 require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "critical-invariants": "118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "ranks": "118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');",
    "vulnerabilities": "privilege escalation\ncross bridge"
  }
]